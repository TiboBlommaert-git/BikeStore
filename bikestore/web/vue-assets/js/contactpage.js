(function () {
  const x = document.createElement('link').relList;
  if (x && x.supports && x.supports('modulepreload')) return;
  for (const D of document.querySelectorAll('link[rel="modulepreload"]')) A(D);
  new MutationObserver((D) => {
    for (const F of D) if (F.type === 'childList') for (const W of F.addedNodes) W.tagName === 'LINK' && W.rel === 'modulepreload' && A(W);
  }).observe(document, { childList: !0, subtree: !0 });
  function M(D) {
    const F = {};
    return D.integrity && (F.integrity = D.integrity), D.referrerPolicy && (F.referrerPolicy = D.referrerPolicy), D.crossOrigin === 'use-credentials' ? (F.credentials = 'include') : D.crossOrigin === 'anonymous' ? (F.credentials = 'omit') : (F.credentials = 'same-origin'), F;
  }
  function A(D) {
    if (D.ep) return;
    D.ep = !0;
    const F = M(D);
    fetch(D.href, F);
  }
})();
/**
 * @vue/shared v3.4.19
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/ function m_(m, x) {
  const M = new Set(m.split(','));
  return x ? (A) => M.has(A.toLowerCase()) : (A) => M.has(A);
}
const ki = {},
  ja = [],
  pn = () => {},
  RD = () => !1,
  Yh = (m) => m.charCodeAt(0) === 111 && m.charCodeAt(1) === 110 && (m.charCodeAt(2) > 122 || m.charCodeAt(2) < 97),
  __ = (m) => m.startsWith('onUpdate:'),
  gr = Object.assign,
  g_ = (m, x) => {
    const M = m.indexOf(x);
    M > -1 && m.splice(M, 1);
  },
  LD = Object.prototype.hasOwnProperty,
  si = (m, x) => LD.call(m, x),
  Pe = Array.isArray,
  Ga = (m) => gc(m) === '[object Map]',
  Kh = (m) => gc(m) === '[object Set]',
  Lw = (m) => gc(m) === '[object Date]',
  Ge = (m) => typeof m == 'function',
  lr = (m) => typeof m == 'string',
  os = (m) => typeof m == 'symbol',
  Ui = (m) => m !== null && typeof m == 'object',
  mT = (m) => (Ui(m) || Ge(m)) && Ge(m.then) && Ge(m.catch),
  _T = Object.prototype.toString,
  gc = (m) => _T.call(m),
  kD = (m) => gc(m).slice(8, -1),
  gT = (m) => gc(m) === '[object Object]',
  y_ = (m) => lr(m) && m !== 'NaN' && m[0] !== '-' && '' + parseInt(m, 10) === m,
  cc = m_(',key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted'),
  Jh = (m) => {
    const x = Object.create(null);
    return (M) => x[M] || (x[M] = m(M));
  },
  OD = /-(\w)/g,
  Ha = Jh((m) => m.replace(OD, (x, M) => (M ? M.toUpperCase() : ''))),
  BD = /\B([A-Z])/g,
  Ya = Jh((m) => m.replace(BD, '-$1').toLowerCase()),
  yT = Jh((m) => m.charAt(0).toUpperCase() + m.slice(1)),
  Wm = Jh((m) => (m ? `on${yT(m)}` : '')),
  ss = (m, x) => !Object.is(m, x),
  Fh = (m, x) => {
    for (let M = 0; M < m.length; M++) m[M](x);
  },
  qh = (m, x, M) => {
    Object.defineProperty(m, x, { configurable: !0, enumerable: !1, value: M });
  },
  i_ = (m) => {
    const x = parseFloat(m);
    return isNaN(x) ? m : x;
  };
let kw;
const xT = () => kw || (kw = typeof globalThis < 'u' ? globalThis : typeof self < 'u' ? self : typeof window < 'u' ? window : typeof global < 'u' ? global : {});
function x_(m) {
  if (Pe(m)) {
    const x = {};
    for (let M = 0; M < m.length; M++) {
      const A = m[M],
        D = lr(A) ? VD(A) : x_(A);
      if (D) for (const F in D) x[F] = D[F];
    }
    return x;
  } else if (lr(m) || Ui(m)) return m;
}
const FD = /;(?![^(]*\))/g,
  ND = /:([^]+)/,
  UD = /\/\*[^]*?\*\//g;
function VD(m) {
  const x = {};
  return (
    m
      .replace(UD, '')
      .split(FD)
      .forEach((M) => {
        if (M) {
          const A = M.split(ND);
          A.length > 1 && (x[A[0].trim()] = A[1].trim());
        }
      }),
    x
  );
}
function v_(m) {
  let x = '';
  if (lr(m)) x = m;
  else if (Pe(m))
    for (let M = 0; M < m.length; M++) {
      const A = v_(m[M]);
      A && (x += A + ' ');
    }
  else if (Ui(m)) for (const M in m) m[M] && (x += M + ' ');
  return x.trim();
}
const jD = 'itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly',
  GD = m_(jD);
function vT(m) {
  return !!m || m === '';
}
function qD(m, x) {
  if (m.length !== x.length) return !1;
  let M = !0;
  for (let A = 0; M && A < m.length; A++) M = Qh(m[A], x[A]);
  return M;
}
function Qh(m, x) {
  if (m === x) return !0;
  let M = Lw(m),
    A = Lw(x);
  if (M || A) return M && A ? m.getTime() === x.getTime() : !1;
  if (((M = os(m)), (A = os(x)), M || A)) return m === x;
  if (((M = Pe(m)), (A = Pe(x)), M || A)) return M && A ? qD(m, x) : !1;
  if (((M = Ui(m)), (A = Ui(x)), M || A)) {
    if (!M || !A) return !1;
    const D = Object.keys(m).length,
      F = Object.keys(x).length;
    if (D !== F) return !1;
    for (const W in m) {
      const rt = m.hasOwnProperty(W),
        $ = x.hasOwnProperty(W);
      if ((rt && !$) || (!rt && $) || !Qh(m[W], x[W])) return !1;
    }
  }
  return String(m) === String(x);
}
function bT(m, x) {
  return m.findIndex((M) => Qh(M, x));
}
const Va = (m) => (lr(m) ? m : m == null ? '' : Pe(m) || (Ui(m) && (m.toString === _T || !Ge(m.toString))) ? JSON.stringify(m, wT, 2) : String(m)),
  wT = (m, x) => (x && x.__v_isRef ? wT(m, x.value) : Ga(x) ? { [`Map(${x.size})`]: [...x.entries()].reduce((M, [A, D], F) => ((M[Xm(A, F) + ' =>'] = D), M), {}) } : Kh(x) ? { [`Set(${x.size})`]: [...x.values()].map((M) => Xm(M)) } : os(x) ? Xm(x) : Ui(x) && !Pe(x) && !gT(x) ? String(x) : x),
  Xm = (m, x = '') => {
    var M;
    return os(m) ? `Symbol(${(M = m.description) != null ? M : x})` : m;
  };
/**
 * @vue/reactivity v3.4.19
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/ let Sn;
class ZD {
  constructor(x = !1) {
    (this.detached = x), (this._active = !0), (this.effects = []), (this.cleanups = []), (this.parent = Sn), !x && Sn && (this.index = (Sn.scopes || (Sn.scopes = [])).push(this) - 1);
  }
  get active() {
    return this._active;
  }
  run(x) {
    if (this._active) {
      const M = Sn;
      try {
        return (Sn = this), x();
      } finally {
        Sn = M;
      }
    }
  }
  on() {
    Sn = this;
  }
  off() {
    Sn = this.parent;
  }
  stop(x) {
    if (this._active) {
      let M, A;
      for (M = 0, A = this.effects.length; M < A; M++) this.effects[M].stop();
      for (M = 0, A = this.cleanups.length; M < A; M++) this.cleanups[M]();
      if (this.scopes) for (M = 0, A = this.scopes.length; M < A; M++) this.scopes[M].stop(!0);
      if (!this.detached && this.parent && !x) {
        const D = this.parent.scopes.pop();
        D && D !== this && ((this.parent.scopes[this.index] = D), (D.index = this.index));
      }
      (this.parent = void 0), (this._active = !1);
    }
  }
}
function $D(m, x = Sn) {
  x && x.active && x.effects.push(m);
}
function HD() {
  return Sn;
}
let Vs;
class b_ {
  constructor(x, M, A, D) {
    (this.fn = x), (this.trigger = M), (this.scheduler = A), (this.active = !0), (this.deps = []), (this._dirtyLevel = 4), (this._trackId = 0), (this._runnings = 0), (this._shouldSchedule = !1), (this._depsLength = 0), $D(this, D);
  }
  get dirty() {
    if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {
      (this._dirtyLevel = 1), qs();
      for (let x = 0; x < this._depsLength; x++) {
        const M = this.deps[x];
        if (M.computed && (WD(M.computed), this._dirtyLevel >= 4)) break;
      }
      this._dirtyLevel === 1 && (this._dirtyLevel = 0), Zs();
    }
    return this._dirtyLevel >= 4;
  }
  set dirty(x) {
    this._dirtyLevel = x ? 4 : 0;
  }
  run() {
    if (((this._dirtyLevel = 0), !this.active)) return this.fn();
    let x = rs,
      M = Vs;
    try {
      return (rs = !0), (Vs = this), this._runnings++, Ow(this), this.fn();
    } finally {
      Bw(this), this._runnings--, (Vs = M), (rs = x);
    }
  }
  stop() {
    var x;
    this.active && (Ow(this), Bw(this), (x = this.onStop) == null || x.call(this), (this.active = !1));
  }
}
function WD(m) {
  return m.value;
}
function Ow(m) {
  m._trackId++, (m._depsLength = 0);
}
function Bw(m) {
  if (m.deps.length > m._depsLength) {
    for (let x = m._depsLength; x < m.deps.length; x++) TT(m.deps[x], m);
    m.deps.length = m._depsLength;
  }
}
function TT(m, x) {
  const M = m.get(x);
  M !== void 0 && x._trackId !== M && (m.delete(x), m.size === 0 && m.cleanup());
}
let rs = !0,
  r_ = 0;
const ET = [];
function qs() {
  ET.push(rs), (rs = !1);
}
function Zs() {
  const m = ET.pop();
  rs = m === void 0 ? !0 : m;
}
function w_() {
  r_++;
}
function T_() {
  for (r_--; !r_ && n_.length; ) n_.shift()();
}
function MT(m, x, M) {
  if (x.get(m) !== m._trackId) {
    x.set(m, m._trackId);
    const A = m.deps[m._depsLength];
    A !== x ? (A && TT(A, m), (m.deps[m._depsLength++] = x)) : m._depsLength++;
  }
}
const n_ = [];
function ST(m, x, M) {
  w_();
  for (const A of m.keys()) {
    let D;
    A._dirtyLevel < x && (D ?? (D = m.get(A) === A._trackId)) && (A._shouldSchedule || (A._shouldSchedule = A._dirtyLevel === 0), (A._dirtyLevel = x)), A._shouldSchedule && (D ?? (D = m.get(A) === A._trackId)) && (A.trigger(), (!A._runnings || A.allowRecurse) && A._dirtyLevel !== 2 && ((A._shouldSchedule = !1), A.scheduler && n_.push(A.scheduler)));
  }
  T_();
}
const AT = (m, x) => {
    const M = new Map();
    return (M.cleanup = m), (M.computed = x), M;
  },
  o_ = new WeakMap(),
  js = Symbol(''),
  s_ = Symbol('');
function Gr(m, x, M) {
  if (rs && Vs) {
    let A = o_.get(m);
    A || o_.set(m, (A = new Map()));
    let D = A.get(M);
    D || A.set(M, (D = AT(() => A.delete(M)))), MT(Vs, D);
  }
}
function yo(m, x, M, A, D, F) {
  const W = o_.get(m);
  if (!W) return;
  let rt = [];
  if (x === 'clear') rt = [...W.values()];
  else if (M === 'length' && Pe(m)) {
    const $ = Number(A);
    W.forEach((U, Et) => {
      (Et === 'length' || (!os(Et) && Et >= $)) && rt.push(U);
    });
  } else
    switch ((M !== void 0 && rt.push(W.get(M)), x)) {
      case 'add':
        Pe(m) ? y_(M) && rt.push(W.get('length')) : (rt.push(W.get(js)), Ga(m) && rt.push(W.get(s_)));
        break;
      case 'delete':
        Pe(m) || (rt.push(W.get(js)), Ga(m) && rt.push(W.get(s_)));
        break;
      case 'set':
        Ga(m) && rt.push(W.get(js));
        break;
    }
  w_();
  for (const $ of rt) $ && ST($, 4);
  T_();
}
const XD = m_('__proto__,__v_isRef,__isVue'),
  IT = new Set(
    Object.getOwnPropertyNames(Symbol)
      .filter((m) => m !== 'arguments' && m !== 'caller')
      .map((m) => Symbol[m])
      .filter(os)
  ),
  Fw = YD();
function YD() {
  const m = {};
  return (
    ['includes', 'indexOf', 'lastIndexOf'].forEach((x) => {
      m[x] = function (...M) {
        const A = fi(this);
        for (let F = 0, W = this.length; F < W; F++) Gr(A, 'get', F + '');
        const D = A[x](...M);
        return D === -1 || D === !1 ? A[x](...M.map(fi)) : D;
      };
    }),
    ['push', 'pop', 'shift', 'unshift', 'splice'].forEach((x) => {
      m[x] = function (...M) {
        qs(), w_();
        const A = fi(this)[x].apply(this, M);
        return T_(), Zs(), A;
      };
    }),
    m
  );
}
function KD(m) {
  const x = fi(this);
  return Gr(x, 'has', m), x.hasOwnProperty(m);
}
class CT {
  constructor(x = !1, M = !1) {
    (this._isReadonly = x), (this._shallow = M);
  }
  get(x, M, A) {
    const D = this._isReadonly,
      F = this._shallow;
    if (M === '__v_isReactive') return !D;
    if (M === '__v_isReadonly') return D;
    if (M === '__v_isShallow') return F;
    if (M === '__v_raw') return A === (D ? (F ? uR : RT) : F ? DT : zT).get(x) || Object.getPrototypeOf(x) === Object.getPrototypeOf(A) ? x : void 0;
    const W = Pe(x);
    if (!D) {
      if (W && si(Fw, M)) return Reflect.get(Fw, M, A);
      if (M === 'hasOwnProperty') return KD;
    }
    const rt = Reflect.get(x, M, A);
    return (os(M) ? IT.has(M) : XD(M)) || (D || Gr(x, 'get', M), F) ? rt : qr(rt) ? (W && y_(M) ? rt : rt.value) : Ui(rt) ? (D ? LT(rt) : S_(rt)) : rt;
  }
}
class PT extends CT {
  constructor(x = !1) {
    super(!1, x);
  }
  set(x, M, A, D) {
    let F = x[M];
    if (!this._shallow) {
      const $ = Wa(F);
      if ((!Zh(A) && !Wa(A) && ((F = fi(F)), (A = fi(A))), !Pe(x) && qr(F) && !qr(A))) return $ ? !1 : ((F.value = A), !0);
    }
    const W = Pe(x) && y_(M) ? Number(M) < x.length : si(x, M),
      rt = Reflect.set(x, M, A, D);
    return x === fi(D) && (W ? ss(A, F) && yo(x, 'set', M, A) : yo(x, 'add', M, A)), rt;
  }
  deleteProperty(x, M) {
    const A = si(x, M);
    x[M];
    const D = Reflect.deleteProperty(x, M);
    return D && A && yo(x, 'delete', M, void 0), D;
  }
  has(x, M) {
    const A = Reflect.has(x, M);
    return (!os(M) || !IT.has(M)) && Gr(x, 'has', M), A;
  }
  ownKeys(x) {
    return Gr(x, 'iterate', Pe(x) ? 'length' : js), Reflect.ownKeys(x);
  }
}
class JD extends CT {
  constructor(x = !1) {
    super(!0, x);
  }
  set(x, M) {
    return !0;
  }
  deleteProperty(x, M) {
    return !0;
  }
}
const QD = new PT(),
  tR = new JD(),
  eR = new PT(!0),
  E_ = (m) => m,
  td = (m) => Reflect.getPrototypeOf(m);
function Dh(m, x, M = !1, A = !1) {
  m = m.__v_raw;
  const D = fi(m),
    F = fi(x);
  M || (ss(x, F) && Gr(D, 'get', x), Gr(D, 'get', F));
  const { has: W } = td(D),
    rt = A ? E_ : M ? I_ : fc;
  if (W.call(D, x)) return rt(m.get(x));
  if (W.call(D, F)) return rt(m.get(F));
  m !== D && m.get(x);
}
function Rh(m, x = !1) {
  const M = this.__v_raw,
    A = fi(M),
    D = fi(m);
  return x || (ss(m, D) && Gr(A, 'has', m), Gr(A, 'has', D)), m === D ? M.has(m) : M.has(m) || M.has(D);
}
function Lh(m, x = !1) {
  return (m = m.__v_raw), !x && Gr(fi(m), 'iterate', js), Reflect.get(m, 'size', m);
}
function Nw(m) {
  m = fi(m);
  const x = fi(this);
  return td(x).has.call(x, m) || (x.add(m), yo(x, 'add', m, m)), this;
}
function Uw(m, x) {
  x = fi(x);
  const M = fi(this),
    { has: A, get: D } = td(M);
  let F = A.call(M, m);
  F || ((m = fi(m)), (F = A.call(M, m)));
  const W = D.call(M, m);
  return M.set(m, x), F ? ss(x, W) && yo(M, 'set', m, x) : yo(M, 'add', m, x), this;
}
function Vw(m) {
  const x = fi(this),
    { has: M, get: A } = td(x);
  let D = M.call(x, m);
  D || ((m = fi(m)), (D = M.call(x, m))), A && A.call(x, m);
  const F = x.delete(m);
  return D && yo(x, 'delete', m, void 0), F;
}
function jw() {
  const m = fi(this),
    x = m.size !== 0,
    M = m.clear();
  return x && yo(m, 'clear', void 0, void 0), M;
}
function kh(m, x) {
  return function (A, D) {
    const F = this,
      W = F.__v_raw,
      rt = fi(W),
      $ = x ? E_ : m ? I_ : fc;
    return !m && Gr(rt, 'iterate', js), W.forEach((U, Et) => A.call(D, $(U), $(Et), F));
  };
}
function Oh(m, x, M) {
  return function (...A) {
    const D = this.__v_raw,
      F = fi(D),
      W = Ga(F),
      rt = m === 'entries' || (m === Symbol.iterator && W),
      $ = m === 'keys' && W,
      U = D[m](...A),
      Et = M ? E_ : x ? I_ : fc;
    return (
      !x && Gr(F, 'iterate', $ ? s_ : js),
      {
        next() {
          const { value: Zt, done: Mt } = U.next();
          return Mt ? { value: Zt, done: Mt } : { value: rt ? [Et(Zt[0]), Et(Zt[1])] : Et(Zt), done: Mt };
        },
        [Symbol.iterator]() {
          return this;
        },
      }
    );
  };
}
function Qo(m) {
  return function (...x) {
    return m === 'delete' ? !1 : m === 'clear' ? void 0 : this;
  };
}
function iR() {
  const m = {
      get(F) {
        return Dh(this, F);
      },
      get size() {
        return Lh(this);
      },
      has: Rh,
      add: Nw,
      set: Uw,
      delete: Vw,
      clear: jw,
      forEach: kh(!1, !1),
    },
    x = {
      get(F) {
        return Dh(this, F, !1, !0);
      },
      get size() {
        return Lh(this);
      },
      has: Rh,
      add: Nw,
      set: Uw,
      delete: Vw,
      clear: jw,
      forEach: kh(!1, !0),
    },
    M = {
      get(F) {
        return Dh(this, F, !0);
      },
      get size() {
        return Lh(this, !0);
      },
      has(F) {
        return Rh.call(this, F, !0);
      },
      add: Qo('add'),
      set: Qo('set'),
      delete: Qo('delete'),
      clear: Qo('clear'),
      forEach: kh(!0, !1),
    },
    A = {
      get(F) {
        return Dh(this, F, !0, !0);
      },
      get size() {
        return Lh(this, !0);
      },
      has(F) {
        return Rh.call(this, F, !0);
      },
      add: Qo('add'),
      set: Qo('set'),
      delete: Qo('delete'),
      clear: Qo('clear'),
      forEach: kh(!0, !0),
    };
  return (
    ['keys', 'values', 'entries', Symbol.iterator].forEach((F) => {
      (m[F] = Oh(F, !1, !1)), (M[F] = Oh(F, !0, !1)), (x[F] = Oh(F, !1, !0)), (A[F] = Oh(F, !0, !0));
    }),
    [m, M, x, A]
  );
}
const [rR, nR, oR, sR] = iR();
function M_(m, x) {
  const M = x ? (m ? sR : oR) : m ? nR : rR;
  return (A, D, F) => (D === '__v_isReactive' ? !m : D === '__v_isReadonly' ? m : D === '__v_raw' ? A : Reflect.get(si(M, D) && D in A ? M : A, D, F));
}
const aR = { get: M_(!1, !1) },
  lR = { get: M_(!1, !0) },
  cR = { get: M_(!0, !1) },
  zT = new WeakMap(),
  DT = new WeakMap(),
  RT = new WeakMap(),
  uR = new WeakMap();
function hR(m) {
  switch (m) {
    case 'Object':
    case 'Array':
      return 1;
    case 'Map':
    case 'Set':
    case 'WeakMap':
    case 'WeakSet':
      return 2;
    default:
      return 0;
  }
}
function dR(m) {
  return m.__v_skip || !Object.isExtensible(m) ? 0 : hR(kD(m));
}
function S_(m) {
  return Wa(m) ? m : A_(m, !1, QD, aR, zT);
}
function fR(m) {
  return A_(m, !1, eR, lR, DT);
}
function LT(m) {
  return A_(m, !0, tR, cR, RT);
}
function A_(m, x, M, A, D) {
  if (!Ui(m) || (m.__v_raw && !(x && m.__v_isReactive))) return m;
  const F = D.get(m);
  if (F) return F;
  const W = dR(m);
  if (W === 0) return m;
  const rt = new Proxy(m, W === 2 ? A : M);
  return D.set(m, rt), rt;
}
function qa(m) {
  return Wa(m) ? qa(m.__v_raw) : !!(m && m.__v_isReactive);
}
function Wa(m) {
  return !!(m && m.__v_isReadonly);
}
function Zh(m) {
  return !!(m && m.__v_isShallow);
}
function kT(m) {
  return qa(m) || Wa(m);
}
function fi(m) {
  const x = m && m.__v_raw;
  return x ? fi(x) : m;
}
function OT(m) {
  return Object.isExtensible(m) && qh(m, '__v_skip', !0), m;
}
const fc = (m) => (Ui(m) ? S_(m) : m),
  I_ = (m) => (Ui(m) ? LT(m) : m);
class BT {
  constructor(x, M, A, D) {
    (this._setter = M),
      (this.dep = void 0),
      (this.__v_isRef = !0),
      (this.__v_isReadonly = !1),
      (this.effect = new b_(
        () => x(this._value),
        () => Nh(this, this.effect._dirtyLevel === 2 ? 2 : 3)
      )),
      (this.effect.computed = this),
      (this.effect.active = this._cacheable = !D),
      (this.__v_isReadonly = A);
  }
  get value() {
    const x = fi(this);
    return (!x._cacheable || x.effect.dirty) && ss(x._value, (x._value = x.effect.run())) && Nh(x, 4), FT(x), x.effect._dirtyLevel >= 2 && Nh(x, 2), x._value;
  }
  set value(x) {
    this._setter(x);
  }
  get _dirty() {
    return this.effect.dirty;
  }
  set _dirty(x) {
    this.effect.dirty = x;
  }
}
function pR(m, x, M = !1) {
  let A, D;
  const F = Ge(m);
  return F ? ((A = m), (D = pn)) : ((A = m.get), (D = m.set)), new BT(A, D, F || !D, M);
}
function FT(m) {
  var x;
  rs && Vs && ((m = fi(m)), MT(Vs, (x = m.dep) != null ? x : (m.dep = AT(() => (m.dep = void 0), m instanceof BT ? m : void 0))));
}
function Nh(m, x = 4, M) {
  m = fi(m);
  const A = m.dep;
  A && ST(A, x);
}
function qr(m) {
  return !!(m && m.__v_isRef === !0);
}
function Vr(m) {
  return mR(m, !1);
}
function mR(m, x) {
  return qr(m) ? m : new _R(m, x);
}
class _R {
  constructor(x, M) {
    (this.__v_isShallow = M), (this.dep = void 0), (this.__v_isRef = !0), (this._rawValue = M ? x : fi(x)), (this._value = M ? x : fc(x));
  }
  get value() {
    return FT(this), this._value;
  }
  set value(x) {
    const M = this.__v_isShallow || Zh(x) || Wa(x);
    (x = M ? x : fi(x)), ss(x, this._rawValue) && ((this._rawValue = x), (this._value = M ? x : fc(x)), Nh(this, 4));
  }
}
function gR(m) {
  return qr(m) ? m.value : m;
}
const yR = {
  get: (m, x, M) => gR(Reflect.get(m, x, M)),
  set: (m, x, M, A) => {
    const D = m[x];
    return qr(D) && !qr(M) ? ((D.value = M), !0) : Reflect.set(m, x, M, A);
  },
};
function NT(m) {
  return qa(m) ? m : new Proxy(m, yR);
}
/**
 * @vue/runtime-core v3.4.19
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/ function ns(m, x, M, A) {
  try {
    return A ? m(...A) : m();
  } catch (D) {
    ed(D, x, M);
  }
}
function Cn(m, x, M, A) {
  if (Ge(m)) {
    const F = ns(m, x, M, A);
    return (
      F &&
        mT(F) &&
        F.catch((W) => {
          ed(W, x, M);
        }),
      F
    );
  }
  const D = [];
  for (let F = 0; F < m.length; F++) D.push(Cn(m[F], x, M, A));
  return D;
}
function ed(m, x, M, A = !0) {
  const D = x ? x.vnode : null;
  if (x) {
    let F = x.parent;
    const W = x.proxy,
      rt = `https://vuejs.org/error-reference/#runtime-${M}`;
    for (; F; ) {
      const U = F.ec;
      if (U) {
        for (let Et = 0; Et < U.length; Et++) if (U[Et](m, W, rt) === !1) return;
      }
      F = F.parent;
    }
    const $ = x.appContext.config.errorHandler;
    if ($) {
      ns($, null, 10, [m, W, rt]);
      return;
    }
  }
  xR(m, M, D, A);
}
function xR(m, x, M, A = !0) {
  console.error(m);
}
let pc = !1,
  a_ = !1;
const _r = [];
let Xn = 0;
const Za = [];
let ts = null,
  Fs = 0;
const UT = Promise.resolve();
let C_ = null;
function vR(m) {
  const x = C_ || UT;
  return m ? x.then(this ? m.bind(this) : m) : x;
}
function bR(m) {
  let x = Xn + 1,
    M = _r.length;
  for (; x < M; ) {
    const A = (x + M) >>> 1,
      D = _r[A],
      F = mc(D);
    F < m || (F === m && D.pre) ? (x = A + 1) : (M = A);
  }
  return x;
}
function P_(m) {
  (!_r.length || !_r.includes(m, pc && m.allowRecurse ? Xn + 1 : Xn)) && (m.id == null ? _r.push(m) : _r.splice(bR(m.id), 0, m), VT());
}
function VT() {
  !pc && !a_ && ((a_ = !0), (C_ = UT.then(GT)));
}
function wR(m) {
  const x = _r.indexOf(m);
  x > Xn && _r.splice(x, 1);
}
function TR(m) {
  Pe(m) ? Za.push(...m) : (!ts || !ts.includes(m, m.allowRecurse ? Fs + 1 : Fs)) && Za.push(m), VT();
}
function Gw(m, x, M = pc ? Xn + 1 : 0) {
  for (; M < _r.length; M++) {
    const A = _r[M];
    if (A && A.pre) {
      if (m && A.id !== m.uid) continue;
      _r.splice(M, 1), M--, A();
    }
  }
}
function jT(m) {
  if (Za.length) {
    const x = [...new Set(Za)].sort((M, A) => mc(M) - mc(A));
    if (((Za.length = 0), ts)) {
      ts.push(...x);
      return;
    }
    for (ts = x, Fs = 0; Fs < ts.length; Fs++) ts[Fs]();
    (ts = null), (Fs = 0);
  }
}
const mc = (m) => (m.id == null ? 1 / 0 : m.id),
  ER = (m, x) => {
    const M = mc(m) - mc(x);
    if (M === 0) {
      if (m.pre && !x.pre) return -1;
      if (x.pre && !m.pre) return 1;
    }
    return M;
  };
function GT(m) {
  (a_ = !1), (pc = !0), _r.sort(ER);
  try {
    for (Xn = 0; Xn < _r.length; Xn++) {
      const x = _r[Xn];
      x && x.active !== !1 && ns(x, null, 14);
    }
  } finally {
    (Xn = 0), (_r.length = 0), jT(), (pc = !1), (C_ = null), (_r.length || Za.length) && GT();
  }
}
function MR(m, x, ...M) {
  if (m.isUnmounted) return;
  const A = m.vnode.props || ki;
  let D = M;
  const F = x.startsWith('update:'),
    W = F && x.slice(7);
  if (W && W in A) {
    const Et = `${W === 'modelValue' ? 'model' : W}Modifiers`,
      { number: Zt, trim: Mt } = A[Et] || ki;
    Mt && (D = M.map((_e) => (lr(_e) ? _e.trim() : _e))), Zt && (D = M.map(i_));
  }
  let rt,
    $ = A[(rt = Wm(x))] || A[(rt = Wm(Ha(x)))];
  !$ && F && ($ = A[(rt = Wm(Ya(x)))]), $ && Cn($, m, 6, D);
  const U = A[rt + 'Once'];
  if (U) {
    if (!m.emitted) m.emitted = {};
    else if (m.emitted[rt]) return;
    (m.emitted[rt] = !0), Cn(U, m, 6, D);
  }
}
function qT(m, x, M = !1) {
  const A = x.emitsCache,
    D = A.get(m);
  if (D !== void 0) return D;
  const F = m.emits;
  let W = {},
    rt = !1;
  if (!Ge(m)) {
    const $ = (U) => {
      const Et = qT(U, x, !0);
      Et && ((rt = !0), gr(W, Et));
    };
    !M && x.mixins.length && x.mixins.forEach($), m.extends && $(m.extends), m.mixins && m.mixins.forEach($);
  }
  return !F && !rt ? (Ui(m) && A.set(m, null), null) : (Pe(F) ? F.forEach(($) => (W[$] = null)) : gr(W, F), Ui(m) && A.set(m, W), W);
}
function id(m, x) {
  return !m || !Yh(x) ? !1 : ((x = x.slice(2).replace(/Once$/, '')), si(m, x[0].toLowerCase() + x.slice(1)) || si(m, Ya(x)) || si(m, x));
}
let Jr = null,
  ZT = null;
function $h(m) {
  const x = Jr;
  return (Jr = m), (ZT = (m && m.type.__scopeId) || null), x;
}
function SR(m, x = Jr, M) {
  if (!x || m._n) return m;
  const A = (...D) => {
    A._d && Qw(-1);
    const F = $h(x);
    let W;
    try {
      W = m(...D);
    } finally {
      $h(F), A._d && Qw(1);
    }
    return W;
  };
  return (A._n = !0), (A._c = !0), (A._d = !0), A;
}
function Ym(m) {
  const {
    type: x,
    vnode: M,
    proxy: A,
    withProxy: D,
    props: F,
    propsOptions: [W],
    slots: rt,
    attrs: $,
    emit: U,
    render: Et,
    renderCache: Zt,
    data: Mt,
    setupState: _e,
    ctx: ei,
    inheritAttrs: Oe,
  } = m;
  let Si, pi;
  const cr = $h(m);
  try {
    if (M.shapeFlag & 4) {
      const ze = D || A,
        ui = ze;
      (Si = Wn(Et.call(ui, ze, Zt, F, _e, Mt, ei))), (pi = $);
    } else {
      const ze = x;
      (Si = Wn(ze.length > 1 ? ze(F, { attrs: $, slots: rt, emit: U }) : ze(F, null))), (pi = x.props ? $ : AR($));
    }
  } catch (ze) {
    (dc.length = 0), ed(ze, m, 1), (Si = mn(Gs));
  }
  let Ue = Si;
  if (pi && Oe !== !1) {
    const ze = Object.keys(pi),
      { shapeFlag: ui } = Ue;
    ze.length && ui & 7 && (W && ze.some(__) && (pi = IR(pi, W)), (Ue = Xa(Ue, pi)));
  }
  return M.dirs && ((Ue = Xa(Ue)), (Ue.dirs = Ue.dirs ? Ue.dirs.concat(M.dirs) : M.dirs)), M.transition && (Ue.transition = M.transition), (Si = Ue), $h(cr), Si;
}
const AR = (m) => {
    let x;
    for (const M in m) (M === 'class' || M === 'style' || Yh(M)) && ((x || (x = {}))[M] = m[M]);
    return x;
  },
  IR = (m, x) => {
    const M = {};
    for (const A in m) (!__(A) || !(A.slice(9) in x)) && (M[A] = m[A]);
    return M;
  };
function CR(m, x, M) {
  const { props: A, children: D, component: F } = m,
    { props: W, children: rt, patchFlag: $ } = x,
    U = F.emitsOptions;
  if (x.dirs || x.transition) return !0;
  if (M && $ >= 0) {
    if ($ & 1024) return !0;
    if ($ & 16) return A ? qw(A, W, U) : !!W;
    if ($ & 8) {
      const Et = x.dynamicProps;
      for (let Zt = 0; Zt < Et.length; Zt++) {
        const Mt = Et[Zt];
        if (W[Mt] !== A[Mt] && !id(U, Mt)) return !0;
      }
    }
  } else return (D || rt) && (!rt || !rt.$stable) ? !0 : A === W ? !1 : A ? (W ? qw(A, W, U) : !0) : !!W;
  return !1;
}
function qw(m, x, M) {
  const A = Object.keys(x);
  if (A.length !== Object.keys(m).length) return !0;
  for (let D = 0; D < A.length; D++) {
    const F = A[D];
    if (x[F] !== m[F] && !id(M, F)) return !0;
  }
  return !1;
}
function PR({ vnode: m, parent: x }, M) {
  for (; x; ) {
    const A = x.subTree;
    if ((A.suspense && A.suspense.activeBranch === m && (A.el = m.el), A === m)) ((m = x.vnode).el = M), (x = x.parent);
    else break;
  }
}
const zR = Symbol.for('v-ndc'),
  DR = (m) => m.__isSuspense;
function RR(m, x) {
  x && x.pendingBranch ? (Pe(m) ? x.effects.push(...m) : x.effects.push(m)) : TR(m);
}
const LR = Symbol.for('v-scx'),
  kR = () => Vh(LR),
  Bh = {};
function Km(m, x, M) {
  return $T(m, x, M);
}
function $T(m, x, { immediate: M, deep: A, flush: D, once: F, onTrack: W, onTrigger: rt } = ki) {
  if (x && F) {
    const qe = x;
    x = (...Mr) => {
      qe(...Mr), ui();
    };
  }
  const $ = Er,
    U = (qe) => (A === !0 ? qe : Us(qe, A === !1 ? 1 : void 0));
  let Et,
    Zt = !1,
    Mt = !1;
  if (
    (qr(m)
      ? ((Et = () => m.value), (Zt = Zh(m)))
      : qa(m)
      ? ((Et = () => U(m)), (Zt = !0))
      : Pe(m)
      ? ((Mt = !0),
        (Zt = m.some((qe) => qa(qe) || Zh(qe))),
        (Et = () =>
          m.map((qe) => {
            if (qr(qe)) return qe.value;
            if (qa(qe)) return U(qe);
            if (Ge(qe)) return ns(qe, $, 2);
          })))
      : Ge(m)
      ? x
        ? (Et = () => ns(m, $, 2))
        : (Et = () => (_e && _e(), Cn(m, $, 3, [ei])))
      : (Et = pn),
    x && A)
  ) {
    const qe = Et;
    Et = () => Us(qe());
  }
  let _e,
    ei = (qe) => {
      _e = Ue.onStop = () => {
        ns(qe, $, 4), (_e = Ue.onStop = void 0);
      };
    },
    Oe;
  if (sd)
    if (((ei = pn), x ? M && Cn(x, $, 3, [Et(), Mt ? [] : void 0, ei]) : Et(), D === 'sync')) {
      const qe = kR();
      Oe = qe.__watcherHandles || (qe.__watcherHandles = []);
    } else return pn;
  let Si = Mt ? new Array(m.length).fill(Bh) : Bh;
  const pi = () => {
    if (!(!Ue.active || !Ue.dirty))
      if (x) {
        const qe = Ue.run();
        (A || Zt || (Mt ? qe.some((Mr, ur) => ss(Mr, Si[ur])) : ss(qe, Si))) && (_e && _e(), Cn(x, $, 3, [qe, Si === Bh ? void 0 : Mt && Si[0] === Bh ? [] : Si, ei]), (Si = qe));
      } else Ue.run();
  };
  pi.allowRecurse = !!x;
  let cr;
  D === 'sync' ? (cr = pi) : D === 'post' ? (cr = () => jr(pi, $ && $.suspense)) : ((pi.pre = !0), $ && (pi.id = $.uid), (cr = () => P_(pi)));
  const Ue = new b_(Et, pn, cr),
    ze = HD(),
    ui = () => {
      Ue.stop(), ze && g_(ze.effects, Ue);
    };
  return x ? (M ? pi() : (Si = Ue.run())) : D === 'post' ? jr(Ue.run.bind(Ue), $ && $.suspense) : Ue.run(), Oe && Oe.push(ui), ui;
}
function OR(m, x, M) {
  const A = this.proxy,
    D = lr(m) ? (m.includes('.') ? HT(A, m) : () => A[m]) : m.bind(A, A);
  let F;
  Ge(x) ? (F = x) : ((F = x.handler), (M = x));
  const W = yc(this),
    rt = $T(D, F.bind(A), M);
  return W(), rt;
}
function HT(m, x) {
  const M = x.split('.');
  return () => {
    let A = m;
    for (let D = 0; D < M.length && A; D++) A = A[M[D]];
    return A;
  };
}
function Us(m, x, M = 0, A) {
  if (!Ui(m) || m.__v_skip) return m;
  if (x && x > 0) {
    if (M >= x) return m;
    M++;
  }
  if (((A = A || new Set()), A.has(m))) return m;
  if ((A.add(m), qr(m))) Us(m.value, x, M, A);
  else if (Pe(m)) for (let D = 0; D < m.length; D++) Us(m[D], x, M, A);
  else if (Kh(m) || Ga(m))
    m.forEach((D) => {
      Us(D, x, M, A);
    });
  else if (gT(m)) for (const D in m) Us(m[D], x, M, A);
  return m;
}
function Ls(m, x) {
  if (Jr === null) return m;
  const M = ad(Jr) || Jr.proxy,
    A = m.dirs || (m.dirs = []);
  for (let D = 0; D < x.length; D++) {
    let [F, W, rt, $ = ki] = x[D];
    F && (Ge(F) && (F = { mounted: F, updated: F }), F.deep && Us(W), A.push({ dir: F, instance: M, value: W, oldValue: void 0, arg: rt, modifiers: $ }));
  }
  return m;
}
function ks(m, x, M, A) {
  const D = m.dirs,
    F = x && x.dirs;
  for (let W = 0; W < D.length; W++) {
    const rt = D[W];
    F && (rt.oldValue = F[W].value);
    let $ = rt.dir[A];
    $ && (qs(), Cn($, M, 8, [m.el, rt, m, x]), Zs());
  }
}
const Uh = (m) => !!m.type.__asyncLoader,
  WT = (m) => m.type.__isKeepAlive;
function BR(m, x) {
  XT(m, 'a', x);
}
function FR(m, x) {
  XT(m, 'da', x);
}
function XT(m, x, M = Er) {
  const A =
    m.__wdc ||
    (m.__wdc = () => {
      let D = M;
      for (; D; ) {
        if (D.isDeactivated) return;
        D = D.parent;
      }
      return m();
    });
  if ((rd(x, A, M), M)) {
    let D = M.parent;
    for (; D && D.parent; ) WT(D.parent.vnode) && NR(A, x, M, D), (D = D.parent);
  }
}
function NR(m, x, M, A) {
  const D = rd(x, m, A, !0);
  KT(() => {
    g_(A[x], D);
  }, M);
}
function rd(m, x, M = Er, A = !1) {
  if (M) {
    const D = M[m] || (M[m] = []),
      F =
        x.__weh ||
        (x.__weh = (...W) => {
          if (M.isUnmounted) return;
          qs();
          const rt = yc(M),
            $ = Cn(x, M, m, W);
          return rt(), Zs(), $;
        });
    return A ? D.unshift(F) : D.push(F), F;
  }
}
const xo =
    (m) =>
    (x, M = Er) =>
      (!sd || m === 'sp') && rd(m, (...A) => x(...A), M),
  UR = xo('bm'),
  YT = xo('m'),
  VR = xo('bu'),
  jR = xo('u'),
  GR = xo('bum'),
  KT = xo('um'),
  qR = xo('sp'),
  ZR = xo('rtg'),
  $R = xo('rtc');
function HR(m, x = Er) {
  rd('ec', m, x);
}
const l_ = (m) => (m ? (uE(m) ? ad(m) || m.proxy : l_(m.parent)) : null),
  uc = gr(Object.create(null), {
    $: (m) => m,
    $el: (m) => m.vnode.el,
    $data: (m) => m.data,
    $props: (m) => m.props,
    $attrs: (m) => m.attrs,
    $slots: (m) => m.slots,
    $refs: (m) => m.refs,
    $parent: (m) => l_(m.parent),
    $root: (m) => l_(m.root),
    $emit: (m) => m.emit,
    $options: (m) => z_(m),
    $forceUpdate: (m) =>
      m.f ||
      (m.f = () => {
        (m.effect.dirty = !0), P_(m.update);
      }),
    $nextTick: (m) => m.n || (m.n = vR.bind(m.proxy)),
    $watch: (m) => OR.bind(m),
  }),
  Jm = (m, x) => m !== ki && !m.__isScriptSetup && si(m, x),
  WR = {
    get({ _: m }, x) {
      const { ctx: M, setupState: A, data: D, props: F, accessCache: W, type: rt, appContext: $ } = m;
      let U;
      if (x[0] !== '$') {
        const _e = W[x];
        if (_e !== void 0)
          switch (_e) {
            case 1:
              return A[x];
            case 2:
              return D[x];
            case 4:
              return M[x];
            case 3:
              return F[x];
          }
        else {
          if (Jm(A, x)) return (W[x] = 1), A[x];
          if (D !== ki && si(D, x)) return (W[x] = 2), D[x];
          if ((U = m.propsOptions[0]) && si(U, x)) return (W[x] = 3), F[x];
          if (M !== ki && si(M, x)) return (W[x] = 4), M[x];
          c_ && (W[x] = 0);
        }
      }
      const Et = uc[x];
      let Zt, Mt;
      if (Et) return x === '$attrs' && Gr(m, 'get', x), Et(m);
      if ((Zt = rt.__cssModules) && (Zt = Zt[x])) return Zt;
      if (M !== ki && si(M, x)) return (W[x] = 4), M[x];
      if (((Mt = $.config.globalProperties), si(Mt, x))) return Mt[x];
    },
    set({ _: m }, x, M) {
      const { data: A, setupState: D, ctx: F } = m;
      return Jm(D, x) ? ((D[x] = M), !0) : A !== ki && si(A, x) ? ((A[x] = M), !0) : si(m.props, x) || (x[0] === '$' && x.slice(1) in m) ? !1 : ((F[x] = M), !0);
    },
    has({ _: { data: m, setupState: x, accessCache: M, ctx: A, appContext: D, propsOptions: F } }, W) {
      let rt;
      return !!M[W] || (m !== ki && si(m, W)) || Jm(x, W) || ((rt = F[0]) && si(rt, W)) || si(A, W) || si(uc, W) || si(D.config.globalProperties, W);
    },
    defineProperty(m, x, M) {
      return M.get != null ? (m._.accessCache[x] = 0) : si(M, 'value') && this.set(m, x, M.value, null), Reflect.defineProperty(m, x, M);
    },
  };
function Zw(m) {
  return Pe(m) ? m.reduce((x, M) => ((x[M] = null), x), {}) : m;
}
let c_ = !0;
function XR(m) {
  const x = z_(m),
    M = m.proxy,
    A = m.ctx;
  (c_ = !1), x.beforeCreate && $w(x.beforeCreate, m, 'bc');
  const { data: D, computed: F, methods: W, watch: rt, provide: $, inject: U, created: Et, beforeMount: Zt, mounted: Mt, beforeUpdate: _e, updated: ei, activated: Oe, deactivated: Si, beforeDestroy: pi, beforeUnmount: cr, destroyed: Ue, unmounted: ze, render: ui, renderTracked: qe, renderTriggered: Mr, errorCaptured: ur, serverPrefetch: Sr, expose: H, inheritAttrs: we, components: vo, directives: Qr, filters: ne } = x;
  if ((U && YR(U, A, null), W))
    for (const mi in W) {
      const _i = W[mi];
      Ge(_i) && (A[mi] = _i.bind(M));
    }
  if (D) {
    const mi = D.call(M, M);
    Ui(mi) && (m.data = S_(mi));
  }
  if (((c_ = !0), F))
    for (const mi in F) {
      const _i = F[mi],
        yr = Ge(_i) ? _i.bind(M, M) : Ge(_i.get) ? _i.get.bind(M, M) : pn,
        tn = !Ge(_i) && Ge(_i.set) ? _i.set.bind(M) : pn,
        tr = IL({ get: yr, set: tn });
      Object.defineProperty(A, mi, { enumerable: !0, configurable: !0, get: () => tr.value, set: (Bt) => (tr.value = Bt) });
    }
  if (rt) for (const mi in rt) JT(rt[mi], A, M, mi);
  if ($) {
    const mi = Ge($) ? $.call(M) : $;
    Reflect.ownKeys(mi).forEach((_i) => {
      iL(_i, mi[_i]);
    });
  }
  Et && $w(Et, m, 'c');
  function nr(mi, _i) {
    Pe(_i) ? _i.forEach((yr) => mi(yr.bind(M))) : _i && mi(_i.bind(M));
  }
  if ((nr(UR, Zt), nr(YT, Mt), nr(VR, _e), nr(jR, ei), nr(BR, Oe), nr(FR, Si), nr(HR, ur), nr($R, qe), nr(ZR, Mr), nr(GR, cr), nr(KT, ze), nr(qR, Sr), Pe(H)))
    if (H.length) {
      const mi = m.exposed || (m.exposed = {});
      H.forEach((_i) => {
        Object.defineProperty(mi, _i, { get: () => M[_i], set: (yr) => (M[_i] = yr) });
      });
    } else m.exposed || (m.exposed = {});
  ui && m.render === pn && (m.render = ui), we != null && (m.inheritAttrs = we), vo && (m.components = vo), Qr && (m.directives = Qr);
}
function YR(m, x, M = pn) {
  Pe(m) && (m = u_(m));
  for (const A in m) {
    const D = m[A];
    let F;
    Ui(D) ? ('default' in D ? (F = Vh(D.from || A, D.default, !0)) : (F = Vh(D.from || A))) : (F = Vh(D)), qr(F) ? Object.defineProperty(x, A, { enumerable: !0, configurable: !0, get: () => F.value, set: (W) => (F.value = W) }) : (x[A] = F);
  }
}
function $w(m, x, M) {
  Cn(Pe(m) ? m.map((A) => A.bind(x.proxy)) : m.bind(x.proxy), x, M);
}
function JT(m, x, M, A) {
  const D = A.includes('.') ? HT(M, A) : () => M[A];
  if (lr(m)) {
    const F = x[m];
    Ge(F) && Km(D, F);
  } else if (Ge(m)) Km(D, m.bind(M));
  else if (Ui(m))
    if (Pe(m)) m.forEach((F) => JT(F, x, M, A));
    else {
      const F = Ge(m.handler) ? m.handler.bind(M) : x[m.handler];
      Ge(F) && Km(D, F, m);
    }
}
function z_(m) {
  const x = m.type,
    { mixins: M, extends: A } = x,
    {
      mixins: D,
      optionsCache: F,
      config: { optionMergeStrategies: W },
    } = m.appContext,
    rt = F.get(x);
  let $;
  return rt ? ($ = rt) : !D.length && !M && !A ? ($ = x) : (($ = {}), D.length && D.forEach((U) => Hh($, U, W, !0)), Hh($, x, W)), Ui(x) && F.set(x, $), $;
}
function Hh(m, x, M, A = !1) {
  const { mixins: D, extends: F } = x;
  F && Hh(m, F, M, !0), D && D.forEach((W) => Hh(m, W, M, !0));
  for (const W in x)
    if (!(A && W === 'expose')) {
      const rt = KR[W] || (M && M[W]);
      m[W] = rt ? rt(m[W], x[W]) : x[W];
    }
  return m;
}
const KR = { data: Hw, props: Ww, emits: Ww, methods: lc, computed: lc, beforeCreate: Tr, created: Tr, beforeMount: Tr, mounted: Tr, beforeUpdate: Tr, updated: Tr, beforeDestroy: Tr, beforeUnmount: Tr, destroyed: Tr, unmounted: Tr, activated: Tr, deactivated: Tr, errorCaptured: Tr, serverPrefetch: Tr, components: lc, directives: lc, watch: QR, provide: Hw, inject: JR };
function Hw(m, x) {
  return x
    ? m
      ? function () {
          return gr(Ge(m) ? m.call(this, this) : m, Ge(x) ? x.call(this, this) : x);
        }
      : x
    : m;
}
function JR(m, x) {
  return lc(u_(m), u_(x));
}
function u_(m) {
  if (Pe(m)) {
    const x = {};
    for (let M = 0; M < m.length; M++) x[m[M]] = m[M];
    return x;
  }
  return m;
}
function Tr(m, x) {
  return m ? [...new Set([].concat(m, x))] : x;
}
function lc(m, x) {
  return m ? gr(Object.create(null), m, x) : x;
}
function Ww(m, x) {
  return m ? (Pe(m) && Pe(x) ? [...new Set([...m, ...x])] : gr(Object.create(null), Zw(m), Zw(x ?? {}))) : x;
}
function QR(m, x) {
  if (!m) return x;
  if (!x) return m;
  const M = gr(Object.create(null), m);
  for (const A in x) M[A] = Tr(m[A], x[A]);
  return M;
}
function QT() {
  return { app: null, config: { isNativeTag: RD, performance: !1, globalProperties: {}, optionMergeStrategies: {}, errorHandler: void 0, warnHandler: void 0, compilerOptions: {} }, mixins: [], components: {}, directives: {}, provides: Object.create(null), optionsCache: new WeakMap(), propsCache: new WeakMap(), emitsCache: new WeakMap() };
}
let tL = 0;
function eL(m, x) {
  return function (A, D = null) {
    Ge(A) || (A = gr({}, A)), D != null && !Ui(D) && (D = null);
    const F = QT(),
      W = new WeakSet();
    let rt = !1;
    const $ = (F.app = {
      _uid: tL++,
      _component: A,
      _props: D,
      _container: null,
      _context: F,
      _instance: null,
      version: CL,
      get config() {
        return F.config;
      },
      set config(U) {},
      use(U, ...Et) {
        return W.has(U) || (U && Ge(U.install) ? (W.add(U), U.install($, ...Et)) : Ge(U) && (W.add(U), U($, ...Et))), $;
      },
      mixin(U) {
        return F.mixins.includes(U) || F.mixins.push(U), $;
      },
      component(U, Et) {
        return Et ? ((F.components[U] = Et), $) : F.components[U];
      },
      directive(U, Et) {
        return Et ? ((F.directives[U] = Et), $) : F.directives[U];
      },
      mount(U, Et, Zt) {
        if (!rt) {
          const Mt = mn(A, D);
          return (Mt.appContext = F), Zt === !0 ? (Zt = 'svg') : Zt === !1 && (Zt = void 0), Et && x ? x(Mt, U) : m(Mt, U, Zt), (rt = !0), ($._container = U), (U.__vue_app__ = $), ad(Mt.component) || Mt.component.proxy;
        }
      },
      unmount() {
        rt && (m(null, $._container), delete $._container.__vue_app__);
      },
      provide(U, Et) {
        return (F.provides[U] = Et), $;
      },
      runWithContext(U) {
        const Et = hc;
        hc = $;
        try {
          return U();
        } finally {
          hc = Et;
        }
      },
    });
    return $;
  };
}
let hc = null;
function iL(m, x) {
  if (Er) {
    let M = Er.provides;
    const A = Er.parent && Er.parent.provides;
    A === M && (M = Er.provides = Object.create(A)), (M[m] = x);
  }
}
function Vh(m, x, M = !1) {
  const A = Er || Jr;
  if (A || hc) {
    const D = A ? (A.parent == null ? A.vnode.appContext && A.vnode.appContext.provides : A.parent.provides) : hc._context.provides;
    if (D && m in D) return D[m];
    if (arguments.length > 1) return M && Ge(x) ? x.call(A && A.proxy) : x;
  }
}
function rL(m, x, M, A = !1) {
  const D = {},
    F = {};
  qh(F, od, 1), (m.propsDefaults = Object.create(null)), tE(m, x, D, F);
  for (const W in m.propsOptions[0]) W in D || (D[W] = void 0);
  M ? (m.props = A ? D : fR(D)) : m.type.props ? (m.props = D) : (m.props = F), (m.attrs = F);
}
function nL(m, x, M, A) {
  const {
      props: D,
      attrs: F,
      vnode: { patchFlag: W },
    } = m,
    rt = fi(D),
    [$] = m.propsOptions;
  let U = !1;
  if ((A || W > 0) && !(W & 16)) {
    if (W & 8) {
      const Et = m.vnode.dynamicProps;
      for (let Zt = 0; Zt < Et.length; Zt++) {
        let Mt = Et[Zt];
        if (id(m.emitsOptions, Mt)) continue;
        const _e = x[Mt];
        if ($)
          if (si(F, Mt)) _e !== F[Mt] && ((F[Mt] = _e), (U = !0));
          else {
            const ei = Ha(Mt);
            D[ei] = h_($, rt, ei, _e, m, !1);
          }
        else _e !== F[Mt] && ((F[Mt] = _e), (U = !0));
      }
    }
  } else {
    tE(m, x, D, F) && (U = !0);
    let Et;
    for (const Zt in rt) (!x || (!si(x, Zt) && ((Et = Ya(Zt)) === Zt || !si(x, Et)))) && ($ ? M && (M[Zt] !== void 0 || M[Et] !== void 0) && (D[Zt] = h_($, rt, Zt, void 0, m, !0)) : delete D[Zt]);
    if (F !== rt) for (const Zt in F) (!x || !si(x, Zt)) && (delete F[Zt], (U = !0));
  }
  U && yo(m, 'set', '$attrs');
}
function tE(m, x, M, A) {
  const [D, F] = m.propsOptions;
  let W = !1,
    rt;
  if (x)
    for (let $ in x) {
      if (cc($)) continue;
      const U = x[$];
      let Et;
      D && si(D, (Et = Ha($))) ? (!F || !F.includes(Et) ? (M[Et] = U) : ((rt || (rt = {}))[Et] = U)) : id(m.emitsOptions, $) || ((!($ in A) || U !== A[$]) && ((A[$] = U), (W = !0)));
    }
  if (F) {
    const $ = fi(M),
      U = rt || ki;
    for (let Et = 0; Et < F.length; Et++) {
      const Zt = F[Et];
      M[Zt] = h_(D, $, Zt, U[Zt], m, !si(U, Zt));
    }
  }
  return W;
}
function h_(m, x, M, A, D, F) {
  const W = m[M];
  if (W != null) {
    const rt = si(W, 'default');
    if (rt && A === void 0) {
      const $ = W.default;
      if (W.type !== Function && !W.skipFactory && Ge($)) {
        const { propsDefaults: U } = D;
        if (M in U) A = U[M];
        else {
          const Et = yc(D);
          (A = U[M] = $.call(null, x)), Et();
        }
      } else A = $;
    }
    W[0] && (F && !rt ? (A = !1) : W[1] && (A === '' || A === Ya(M)) && (A = !0));
  }
  return A;
}
function eE(m, x, M = !1) {
  const A = x.propsCache,
    D = A.get(m);
  if (D) return D;
  const F = m.props,
    W = {},
    rt = [];
  let $ = !1;
  if (!Ge(m)) {
    const Et = (Zt) => {
      $ = !0;
      const [Mt, _e] = eE(Zt, x, !0);
      gr(W, Mt), _e && rt.push(..._e);
    };
    !M && x.mixins.length && x.mixins.forEach(Et), m.extends && Et(m.extends), m.mixins && m.mixins.forEach(Et);
  }
  if (!F && !$) return Ui(m) && A.set(m, ja), ja;
  if (Pe(F))
    for (let Et = 0; Et < F.length; Et++) {
      const Zt = Ha(F[Et]);
      Xw(Zt) && (W[Zt] = ki);
    }
  else if (F)
    for (const Et in F) {
      const Zt = Ha(Et);
      if (Xw(Zt)) {
        const Mt = F[Et],
          _e = (W[Zt] = Pe(Mt) || Ge(Mt) ? { type: Mt } : gr({}, Mt));
        if (_e) {
          const ei = Jw(Boolean, _e.type),
            Oe = Jw(String, _e.type);
          (_e[0] = ei > -1), (_e[1] = Oe < 0 || ei < Oe), (ei > -1 || si(_e, 'default')) && rt.push(Zt);
        }
      }
    }
  const U = [W, rt];
  return Ui(m) && A.set(m, U), U;
}
function Xw(m) {
  return m[0] !== '$' && !cc(m);
}
function Yw(m) {
  return m === null ? 'null' : typeof m == 'function' ? m.name || '' : (typeof m == 'object' && m.constructor && m.constructor.name) || '';
}
function Kw(m, x) {
  return Yw(m) === Yw(x);
}
function Jw(m, x) {
  return Pe(x) ? x.findIndex((M) => Kw(M, m)) : Ge(x) && Kw(x, m) ? 0 : -1;
}
const iE = (m) => m[0] === '_' || m === '$stable',
  D_ = (m) => (Pe(m) ? m.map(Wn) : [Wn(m)]),
  oL = (m, x, M) => {
    if (x._n) return x;
    const A = SR((...D) => D_(x(...D)), M);
    return (A._c = !1), A;
  },
  rE = (m, x, M) => {
    const A = m._ctx;
    for (const D in m) {
      if (iE(D)) continue;
      const F = m[D];
      if (Ge(F)) x[D] = oL(D, F, A);
      else if (F != null) {
        const W = D_(F);
        x[D] = () => W;
      }
    }
  },
  nE = (m, x) => {
    const M = D_(x);
    m.slots.default = () => M;
  },
  sL = (m, x) => {
    if (m.vnode.shapeFlag & 32) {
      const M = x._;
      M ? ((m.slots = fi(x)), qh(x, '_', M)) : rE(x, (m.slots = {}));
    } else (m.slots = {}), x && nE(m, x);
    qh(m.slots, od, 1);
  },
  aL = (m, x, M) => {
    const { vnode: A, slots: D } = m;
    let F = !0,
      W = ki;
    if (A.shapeFlag & 32) {
      const rt = x._;
      rt ? (M && rt === 1 ? (F = !1) : (gr(D, x), !M && rt === 1 && delete D._)) : ((F = !x.$stable), rE(x, D)), (W = x);
    } else x && (nE(m, x), (W = { default: 1 }));
    if (F) for (const rt in D) !iE(rt) && W[rt] == null && delete D[rt];
  };
function d_(m, x, M, A, D = !1) {
  if (Pe(m)) {
    m.forEach((Mt, _e) => d_(Mt, x && (Pe(x) ? x[_e] : x), M, A, D));
    return;
  }
  if (Uh(A) && !D) return;
  const F = A.shapeFlag & 4 ? ad(A.component) || A.component.proxy : A.el,
    W = D ? null : F,
    { i: rt, r: $ } = m,
    U = x && x.r,
    Et = rt.refs === ki ? (rt.refs = {}) : rt.refs,
    Zt = rt.setupState;
  if ((U != null && U !== $ && (lr(U) ? ((Et[U] = null), si(Zt, U) && (Zt[U] = null)) : qr(U) && (U.value = null)), Ge($))) ns($, rt, 12, [W, Et]);
  else {
    const Mt = lr($),
      _e = qr($);
    if (Mt || _e) {
      const ei = () => {
        if (m.f) {
          const Oe = Mt ? (si(Zt, $) ? Zt[$] : Et[$]) : $.value;
          D ? Pe(Oe) && g_(Oe, F) : Pe(Oe) ? Oe.includes(F) || Oe.push(F) : Mt ? ((Et[$] = [F]), si(Zt, $) && (Zt[$] = Et[$])) : (($.value = [F]), m.k && (Et[m.k] = $.value));
        } else Mt ? ((Et[$] = W), si(Zt, $) && (Zt[$] = W)) : _e && (($.value = W), m.k && (Et[m.k] = W));
      };
      W ? ((ei.id = -1), jr(ei, M)) : ei();
    }
  }
}
const jr = RR;
function lL(m) {
  return cL(m);
}
function cL(m, x) {
  const M = xT();
  M.__VUE__ = !0;
  const { insert: A, remove: D, patchProp: F, createElement: W, createText: rt, createComment: $, setText: U, setElementText: Et, parentNode: Zt, nextSibling: Mt, setScopeId: _e = pn, insertStaticContent: ei } = m,
    Oe = (Y, ot, xt, zt = null, tt = null, P = null, L = void 0, B = null, et = !!ot.dynamicChildren) => {
      if (Y === ot) return;
      Y && !oc(Y, ot) && ((zt = Ft(Y)), Bt(Y, tt, P, !0), (Y = null)), ot.patchFlag === -2 && ((et = !1), (ot.dynamicChildren = null));
      const { type: K, ref: ft, shapeFlag: gt } = ot;
      switch (K) {
        case nd:
          Si(Y, ot, xt, zt);
          break;
        case Gs:
          pi(Y, ot, xt, zt);
          break;
        case jh:
          Y == null && cr(ot, xt, zt, L);
          break;
        case Hn:
          vo(Y, ot, xt, zt, tt, P, L, B, et);
          break;
        default:
          gt & 1 ? ui(Y, ot, xt, zt, tt, P, L, B, et) : gt & 6 ? Qr(Y, ot, xt, zt, tt, P, L, B, et) : (gt & 64 || gt & 128) && K.process(Y, ot, xt, zt, tt, P, L, B, et, $r);
      }
      ft != null && tt && d_(ft, Y && Y.ref, P, ot || Y, !ot);
    },
    Si = (Y, ot, xt, zt) => {
      if (Y == null) A((ot.el = rt(ot.children)), xt, zt);
      else {
        const tt = (ot.el = Y.el);
        ot.children !== Y.children && U(tt, ot.children);
      }
    },
    pi = (Y, ot, xt, zt) => {
      Y == null ? A((ot.el = $(ot.children || '')), xt, zt) : (ot.el = Y.el);
    },
    cr = (Y, ot, xt, zt) => {
      [Y.el, Y.anchor] = ei(Y.children, ot, xt, zt, Y.el, Y.anchor);
    },
    Ue = ({ el: Y, anchor: ot }, xt, zt) => {
      let tt;
      for (; Y && Y !== ot; ) (tt = Mt(Y)), A(Y, xt, zt), (Y = tt);
      A(ot, xt, zt);
    },
    ze = ({ el: Y, anchor: ot }) => {
      let xt;
      for (; Y && Y !== ot; ) (xt = Mt(Y)), D(Y), (Y = xt);
      D(ot);
    },
    ui = (Y, ot, xt, zt, tt, P, L, B, et) => {
      ot.type === 'svg' ? (L = 'svg') : ot.type === 'math' && (L = 'mathml'), Y == null ? qe(ot, xt, zt, tt, P, L, B, et) : Sr(Y, ot, tt, P, L, B, et);
    },
    qe = (Y, ot, xt, zt, tt, P, L, B) => {
      let et, K;
      const { props: ft, shapeFlag: gt, transition: ct, dirs: Tt } = Y;
      if (((et = Y.el = W(Y.type, P, ft && ft.is, ft)), gt & 8 ? Et(et, Y.children) : gt & 16 && ur(Y.children, et, null, zt, tt, Qm(Y, P), L, B), Tt && ks(Y, null, zt, 'created'), Mr(et, Y, Y.scopeId, L, zt), ft)) {
        for (const jt in ft) jt !== 'value' && !cc(jt) && F(et, jt, null, ft[jt], P, Y.children, zt, tt, hr);
        'value' in ft && F(et, 'value', null, ft.value, P), (K = ft.onVnodeBeforeMount) && Zn(K, zt, Y);
      }
      Tt && ks(Y, null, zt, 'beforeMount');
      const Lt = uL(tt, ct);
      Lt && ct.beforeEnter(et),
        A(et, ot, xt),
        ((K = ft && ft.onVnodeMounted) || Lt || Tt) &&
          jr(() => {
            K && Zn(K, zt, Y), Lt && ct.enter(et), Tt && ks(Y, null, zt, 'mounted');
          }, tt);
    },
    Mr = (Y, ot, xt, zt, tt) => {
      if ((xt && _e(Y, xt), zt)) for (let P = 0; P < zt.length; P++) _e(Y, zt[P]);
      if (tt) {
        let P = tt.subTree;
        if (ot === P) {
          const L = tt.vnode;
          Mr(Y, L, L.scopeId, L.slotScopeIds, tt.parent);
        }
      }
    },
    ur = (Y, ot, xt, zt, tt, P, L, B, et = 0) => {
      for (let K = et; K < Y.length; K++) {
        const ft = (Y[K] = B ? es(Y[K]) : Wn(Y[K]));
        Oe(null, ft, ot, xt, zt, tt, P, L, B);
      }
    },
    Sr = (Y, ot, xt, zt, tt, P, L) => {
      const B = (ot.el = Y.el);
      let { patchFlag: et, dynamicChildren: K, dirs: ft } = ot;
      et |= Y.patchFlag & 16;
      const gt = Y.props || ki,
        ct = ot.props || ki;
      let Tt;
      if ((xt && Os(xt, !1), (Tt = ct.onVnodeBeforeUpdate) && Zn(Tt, xt, ot, Y), ft && ks(ot, Y, xt, 'beforeUpdate'), xt && Os(xt, !0), K ? H(Y.dynamicChildren, K, B, xt, zt, Qm(ot, tt), P) : L || _i(Y, ot, B, null, xt, zt, Qm(ot, tt), P, !1), et > 0)) {
        if (et & 16) we(B, ot, gt, ct, xt, zt, tt);
        else if ((et & 2 && gt.class !== ct.class && F(B, 'class', null, ct.class, tt), et & 4 && F(B, 'style', gt.style, ct.style, tt), et & 8)) {
          const Lt = ot.dynamicProps;
          for (let jt = 0; jt < Lt.length; jt++) {
            const le = Lt[jt],
              Ie = gt[le],
              ai = ct[le];
            (ai !== Ie || le === 'value') && F(B, le, Ie, ai, tt, Y.children, xt, zt, hr);
          }
        }
        et & 1 && Y.children !== ot.children && Et(B, ot.children);
      } else !L && K == null && we(B, ot, gt, ct, xt, zt, tt);
      ((Tt = ct.onVnodeUpdated) || ft) &&
        jr(() => {
          Tt && Zn(Tt, xt, ot, Y), ft && ks(ot, Y, xt, 'updated');
        }, zt);
    },
    H = (Y, ot, xt, zt, tt, P, L) => {
      for (let B = 0; B < ot.length; B++) {
        const et = Y[B],
          K = ot[B],
          ft = et.el && (et.type === Hn || !oc(et, K) || et.shapeFlag & 70) ? Zt(et.el) : xt;
        Oe(et, K, ft, null, zt, tt, P, L, !0);
      }
    },
    we = (Y, ot, xt, zt, tt, P, L) => {
      if (xt !== zt) {
        if (xt !== ki) for (const B in xt) !cc(B) && !(B in zt) && F(Y, B, xt[B], null, L, ot.children, tt, P, hr);
        for (const B in zt) {
          if (cc(B)) continue;
          const et = zt[B],
            K = xt[B];
          et !== K && B !== 'value' && F(Y, B, K, et, L, ot.children, tt, P, hr);
        }
        'value' in zt && F(Y, 'value', xt.value, zt.value, L);
      }
    },
    vo = (Y, ot, xt, zt, tt, P, L, B, et) => {
      const K = (ot.el = Y ? Y.el : rt('')),
        ft = (ot.anchor = Y ? Y.anchor : rt(''));
      let { patchFlag: gt, dynamicChildren: ct, slotScopeIds: Tt } = ot;
      Tt && (B = B ? B.concat(Tt) : Tt), Y == null ? (A(K, xt, zt), A(ft, xt, zt), ur(ot.children || [], xt, ft, tt, P, L, B, et)) : gt > 0 && gt & 64 && ct && Y.dynamicChildren ? (H(Y.dynamicChildren, ct, xt, tt, P, L, B), (ot.key != null || (tt && ot === tt.subTree)) && oE(Y, ot, !0)) : _i(Y, ot, xt, ft, tt, P, L, B, et);
    },
    Qr = (Y, ot, xt, zt, tt, P, L, B, et) => {
      (ot.slotScopeIds = B), Y == null ? (ot.shapeFlag & 512 ? tt.ctx.activate(ot, xt, zt, L, et) : ne(ot, xt, zt, tt, P, L, et)) : Vi(Y, ot, et);
    },
    ne = (Y, ot, xt, zt, tt, P, L) => {
      const B = (Y.component = wL(Y, zt, tt));
      if ((WT(Y) && (B.ctx.renderer = $r), TL(B), B.asyncDep)) {
        if ((tt && tt.registerDep(B, nr), !Y.el)) {
          const et = (B.subTree = mn(Gs));
          pi(null, et, ot, xt);
        }
      } else nr(B, Y, ot, xt, tt, P, L);
    },
    Vi = (Y, ot, xt) => {
      const zt = (ot.component = Y.component);
      if (CR(Y, ot, xt))
        if (zt.asyncDep && !zt.asyncResolved) {
          mi(zt, ot, xt);
          return;
        } else (zt.next = ot), wR(zt.update), (zt.effect.dirty = !0), zt.update();
      else (ot.el = Y.el), (zt.vnode = ot);
    },
    nr = (Y, ot, xt, zt, tt, P, L) => {
      const B = () => {
          if (Y.isMounted) {
            let { next: ft, bu: gt, u: ct, parent: Tt, vnode: Lt } = Y;
            {
              const ii = sE(Y);
              if (ii) {
                ft && ((ft.el = Lt.el), mi(Y, ft, L)),
                  ii.asyncDep.then(() => {
                    Y.isUnmounted || B();
                  });
                return;
              }
            }
            let jt = ft,
              le;
            Os(Y, !1), ft ? ((ft.el = Lt.el), mi(Y, ft, L)) : (ft = Lt), gt && Fh(gt), (le = ft.props && ft.props.onVnodeBeforeUpdate) && Zn(le, Tt, ft, Lt), Os(Y, !0);
            const Ie = Ym(Y),
              ai = Y.subTree;
            (Y.subTree = Ie), Oe(ai, Ie, Zt(ai.el), Ft(ai), Y, tt, P), (ft.el = Ie.el), jt === null && PR(Y, Ie.el), ct && jr(ct, tt), (le = ft.props && ft.props.onVnodeUpdated) && jr(() => Zn(le, Tt, ft, Lt), tt);
          } else {
            let ft;
            const { el: gt, props: ct } = ot,
              { bm: Tt, m: Lt, parent: jt } = Y,
              le = Uh(ot);
            if ((Os(Y, !1), Tt && Fh(Tt), !le && (ft = ct && ct.onVnodeBeforeMount) && Zn(ft, jt, ot), Os(Y, !0), gt && wo)) {
              const Ie = () => {
                (Y.subTree = Ym(Y)), wo(gt, Y.subTree, Y, tt, null);
              };
              le ? ot.type.__asyncLoader().then(() => !Y.isUnmounted && Ie()) : Ie();
            } else {
              const Ie = (Y.subTree = Ym(Y));
              Oe(null, Ie, xt, zt, Y, tt, P), (ot.el = Ie.el);
            }
            if ((Lt && jr(Lt, tt), !le && (ft = ct && ct.onVnodeMounted))) {
              const Ie = ot;
              jr(() => Zn(ft, jt, Ie), tt);
            }
            (ot.shapeFlag & 256 || (jt && Uh(jt.vnode) && jt.vnode.shapeFlag & 256)) && Y.a && jr(Y.a, tt), (Y.isMounted = !0), (ot = xt = zt = null);
          }
        },
        et = (Y.effect = new b_(B, pn, () => P_(K), Y.scope)),
        K = (Y.update = () => {
          et.dirty && et.run();
        });
      (K.id = Y.uid), Os(Y, !0), K();
    },
    mi = (Y, ot, xt) => {
      ot.component = Y;
      const zt = Y.vnode.props;
      (Y.vnode = ot), (Y.next = null), nL(Y, ot.props, zt, xt), aL(Y, ot.children, xt), qs(), Gw(Y), Zs();
    },
    _i = (Y, ot, xt, zt, tt, P, L, B, et = !1) => {
      const K = Y && Y.children,
        ft = Y ? Y.shapeFlag : 0,
        gt = ot.children,
        { patchFlag: ct, shapeFlag: Tt } = ot;
      if (ct > 0) {
        if (ct & 128) {
          tn(K, gt, xt, zt, tt, P, L, B, et);
          return;
        } else if (ct & 256) {
          yr(K, gt, xt, zt, tt, P, L, B, et);
          return;
        }
      }
      Tt & 8 ? (ft & 16 && hr(K, tt, P), gt !== K && Et(xt, gt)) : ft & 16 ? (Tt & 16 ? tn(K, gt, xt, zt, tt, P, L, B, et) : hr(K, tt, P, !0)) : (ft & 8 && Et(xt, ''), Tt & 16 && ur(gt, xt, zt, tt, P, L, B, et));
    },
    yr = (Y, ot, xt, zt, tt, P, L, B, et) => {
      (Y = Y || ja), (ot = ot || ja);
      const K = Y.length,
        ft = ot.length,
        gt = Math.min(K, ft);
      let ct;
      for (ct = 0; ct < gt; ct++) {
        const Tt = (ot[ct] = et ? es(ot[ct]) : Wn(ot[ct]));
        Oe(Y[ct], Tt, xt, null, tt, P, L, B, et);
      }
      K > ft ? hr(Y, tt, P, !0, !1, gt) : ur(ot, xt, zt, tt, P, L, B, et, gt);
    },
    tn = (Y, ot, xt, zt, tt, P, L, B, et) => {
      let K = 0;
      const ft = ot.length;
      let gt = Y.length - 1,
        ct = ft - 1;
      for (; K <= gt && K <= ct; ) {
        const Tt = Y[K],
          Lt = (ot[K] = et ? es(ot[K]) : Wn(ot[K]));
        if (oc(Tt, Lt)) Oe(Tt, Lt, xt, null, tt, P, L, B, et);
        else break;
        K++;
      }
      for (; K <= gt && K <= ct; ) {
        const Tt = Y[gt],
          Lt = (ot[ct] = et ? es(ot[ct]) : Wn(ot[ct]));
        if (oc(Tt, Lt)) Oe(Tt, Lt, xt, null, tt, P, L, B, et);
        else break;
        gt--, ct--;
      }
      if (K > gt) {
        if (K <= ct) {
          const Tt = ct + 1,
            Lt = Tt < ft ? ot[Tt].el : zt;
          for (; K <= ct; ) Oe(null, (ot[K] = et ? es(ot[K]) : Wn(ot[K])), xt, Lt, tt, P, L, B, et), K++;
        }
      } else if (K > ct) for (; K <= gt; ) Bt(Y[K], tt, P, !0), K++;
      else {
        const Tt = K,
          Lt = K,
          jt = new Map();
        for (K = Lt; K <= ct; K++) {
          const wi = (ot[K] = et ? es(ot[K]) : Wn(ot[K]));
          wi.key != null && jt.set(wi.key, K);
        }
        let le,
          Ie = 0;
        const ai = ct - Lt + 1;
        let ii = !1,
          bi = 0;
        const Ye = new Array(ai);
        for (K = 0; K < ai; K++) Ye[K] = 0;
        for (K = Tt; K <= gt; K++) {
          const wi = Y[K];
          if (Ie >= ai) {
            Bt(wi, tt, P, !0);
            continue;
          }
          let zi;
          if (wi.key != null) zi = jt.get(wi.key);
          else
            for (le = Lt; le <= ct; le++)
              if (Ye[le - Lt] === 0 && oc(wi, ot[le])) {
                zi = le;
                break;
              }
          zi === void 0 ? Bt(wi, tt, P, !0) : ((Ye[zi - Lt] = K + 1), zi >= bi ? (bi = zi) : (ii = !0), Oe(wi, ot[zi], xt, null, tt, P, L, B, et), Ie++);
        }
        const er = ii ? hL(Ye) : ja;
        for (le = er.length - 1, K = ai - 1; K >= 0; K--) {
          const wi = Lt + K,
            zi = ot[wi],
            Ar = wi + 1 < ft ? ot[wi + 1].el : zt;
          Ye[K] === 0 ? Oe(null, zi, xt, Ar, tt, P, L, B, et) : ii && (le < 0 || K !== er[le] ? tr(zi, xt, Ar, 2) : le--);
        }
      }
    },
    tr = (Y, ot, xt, zt, tt = null) => {
      const { el: P, type: L, transition: B, children: et, shapeFlag: K } = Y;
      if (K & 6) {
        tr(Y.component.subTree, ot, xt, zt);
        return;
      }
      if (K & 128) {
        Y.suspense.move(ot, xt, zt);
        return;
      }
      if (K & 64) {
        L.move(Y, ot, xt, $r);
        return;
      }
      if (L === Hn) {
        A(P, ot, xt);
        for (let gt = 0; gt < et.length; gt++) tr(et[gt], ot, xt, zt);
        A(Y.anchor, ot, xt);
        return;
      }
      if (L === jh) {
        Ue(Y, ot, xt);
        return;
      }
      if (zt !== 2 && K & 1 && B)
        if (zt === 0) B.beforeEnter(P), A(P, ot, xt), jr(() => B.enter(P), tt);
        else {
          const { leave: gt, delayLeave: ct, afterLeave: Tt } = B,
            Lt = () => A(P, ot, xt),
            jt = () => {
              gt(P, () => {
                Lt(), Tt && Tt();
              });
            };
          ct ? ct(P, Lt, jt) : jt();
        }
      else A(P, ot, xt);
    },
    Bt = (Y, ot, xt, zt = !1, tt = !1) => {
      const { type: P, props: L, ref: B, children: et, dynamicChildren: K, shapeFlag: ft, patchFlag: gt, dirs: ct } = Y;
      if ((B != null && d_(B, null, xt, Y, !0), ft & 256)) {
        ot.ctx.deactivate(Y);
        return;
      }
      const Tt = ft & 1 && ct,
        Lt = !Uh(Y);
      let jt;
      if ((Lt && (jt = L && L.onVnodeBeforeUnmount) && Zn(jt, ot, Y), ft & 6)) Yn(Y.component, xt, zt);
      else {
        if (ft & 128) {
          Y.suspense.unmount(xt, zt);
          return;
        }
        Tt && ks(Y, null, ot, 'beforeUnmount'), ft & 64 ? Y.type.remove(Y, ot, xt, tt, $r, zt) : K && (P !== Hn || (gt > 0 && gt & 64)) ? hr(K, ot, xt, !1, !0) : ((P === Hn && gt & 384) || (!tt && ft & 16)) && hr(et, ot, xt), zt && Zr(Y);
      }
      ((Lt && (jt = L && L.onVnodeUnmounted)) || Tt) &&
        jr(() => {
          jt && Zn(jt, ot, Y), Tt && ks(Y, null, ot, 'unmounted');
        }, xt);
    },
    Zr = (Y) => {
      const { type: ot, el: xt, anchor: zt, transition: tt } = Y;
      if (ot === Hn) {
        en(xt, zt);
        return;
      }
      if (ot === jh) {
        ze(Y);
        return;
      }
      const P = () => {
        D(xt), tt && !tt.persisted && tt.afterLeave && tt.afterLeave();
      };
      if (Y.shapeFlag & 1 && tt && !tt.persisted) {
        const { leave: L, delayLeave: B } = tt,
          et = () => L(xt, P);
        B ? B(Y.el, P, et) : et();
      } else P();
    },
    en = (Y, ot) => {
      let xt;
      for (; Y !== ot; ) (xt = Mt(Y)), D(Y), (Y = xt);
      D(ot);
    },
    Yn = (Y, ot, xt) => {
      const { bum: zt, scope: tt, update: P, subTree: L, um: B } = Y;
      zt && Fh(zt),
        tt.stop(),
        P && ((P.active = !1), Bt(L, Y, ot, xt)),
        B && jr(B, ot),
        jr(() => {
          Y.isUnmounted = !0;
        }, ot),
        ot && ot.pendingBranch && !ot.isUnmounted && Y.asyncDep && !Y.asyncResolved && Y.suspenseId === ot.pendingId && (ot.deps--, ot.deps === 0 && ot.resolve());
    },
    hr = (Y, ot, xt, zt = !1, tt = !1, P = 0) => {
      for (let L = P; L < Y.length; L++) Bt(Y[L], ot, xt, zt, tt);
    },
    Ft = (Y) => (Y.shapeFlag & 6 ? Ft(Y.component.subTree) : Y.shapeFlag & 128 ? Y.suspense.next() : Mt(Y.anchor || Y.el));
  let ar = !1;
  const $s = (Y, ot, xt) => {
      Y == null ? ot._vnode && Bt(ot._vnode, null, null, !0) : Oe(ot._vnode || null, Y, ot, null, null, null, xt), ar || ((ar = !0), Gw(), jT(), (ar = !1)), (ot._vnode = Y);
    },
    $r = { p: Oe, um: Bt, m: tr, r: Zr, mt: ne, mc: ur, pc: _i, pbc: H, n: Ft, o: m };
  let bo, wo;
  return x && ([bo, wo] = x($r)), { render: $s, hydrate: bo, createApp: eL($s, bo) };
}
function Qm({ type: m, props: x }, M) {
  return (M === 'svg' && m === 'foreignObject') || (M === 'mathml' && m === 'annotation-xml' && x && x.encoding && x.encoding.includes('html')) ? void 0 : M;
}
function Os({ effect: m, update: x }, M) {
  m.allowRecurse = x.allowRecurse = M;
}
function uL(m, x) {
  return (!m || (m && !m.pendingBranch)) && x && !x.persisted;
}
function oE(m, x, M = !1) {
  const A = m.children,
    D = x.children;
  if (Pe(A) && Pe(D))
    for (let F = 0; F < A.length; F++) {
      const W = A[F];
      let rt = D[F];
      rt.shapeFlag & 1 && !rt.dynamicChildren && ((rt.patchFlag <= 0 || rt.patchFlag === 32) && ((rt = D[F] = es(D[F])), (rt.el = W.el)), M || oE(W, rt)), rt.type === nd && (rt.el = W.el);
    }
}
function hL(m) {
  const x = m.slice(),
    M = [0];
  let A, D, F, W, rt;
  const $ = m.length;
  for (A = 0; A < $; A++) {
    const U = m[A];
    if (U !== 0) {
      if (((D = M[M.length - 1]), m[D] < U)) {
        (x[A] = D), M.push(A);
        continue;
      }
      for (F = 0, W = M.length - 1; F < W; ) (rt = (F + W) >> 1), m[M[rt]] < U ? (F = rt + 1) : (W = rt);
      U < m[M[F]] && (F > 0 && (x[A] = M[F - 1]), (M[F] = A));
    }
  }
  for (F = M.length, W = M[F - 1]; F-- > 0; ) (M[F] = W), (W = x[W]);
  return M;
}
function sE(m) {
  const x = m.subTree.component;
  if (x) return x.asyncDep && !x.asyncResolved ? x : sE(x);
}
const dL = (m) => m.__isTeleport,
  Hn = Symbol.for('v-fgt'),
  nd = Symbol.for('v-txt'),
  Gs = Symbol.for('v-cmt'),
  jh = Symbol.for('v-stc'),
  dc = [];
let In = null;
function An(m = !1) {
  dc.push((In = m ? null : []));
}
function fL() {
  dc.pop(), (In = dc[dc.length - 1] || null);
}
let _c = 1;
function Qw(m) {
  _c += m;
}
function aE(m) {
  return (m.dynamicChildren = _c > 0 ? In || ja : null), fL(), _c > 0 && In && In.push(m), m;
}
function $n(m, x, M, A, D, F) {
  return aE($i(m, x, M, A, D, F, !0));
}
function pL(m, x, M, A, D) {
  return aE(mn(m, x, M, A, D, !0));
}
function mL(m) {
  return m ? m.__v_isVNode === !0 : !1;
}
function oc(m, x) {
  return m.type === x.type && m.key === x.key;
}
const od = '__vInternal',
  lE = ({ key: m }) => m ?? null,
  Gh = ({ ref: m, ref_key: x, ref_for: M }) => (typeof m == 'number' && (m = '' + m), m != null ? (lr(m) || qr(m) || Ge(m) ? { i: Jr, r: m, k: x, f: !!M } : m) : null);
function $i(m, x = null, M = null, A = 0, D = null, F = m === Hn ? 0 : 1, W = !1, rt = !1) {
  const $ = { __v_isVNode: !0, __v_skip: !0, type: m, props: x, key: x && lE(x), ref: x && Gh(x), scopeId: ZT, slotScopeIds: null, children: M, component: null, suspense: null, ssContent: null, ssFallback: null, dirs: null, transition: null, el: null, anchor: null, target: null, targetAnchor: null, staticCount: 0, shapeFlag: F, patchFlag: A, dynamicProps: D, dynamicChildren: null, appContext: null, ctx: Jr };
  return rt ? (R_($, M), F & 128 && m.normalize($)) : M && ($.shapeFlag |= lr(M) ? 8 : 16), _c > 0 && !W && In && ($.patchFlag > 0 || F & 6) && $.patchFlag !== 32 && In.push($), $;
}
const mn = _L;
function _L(m, x = null, M = null, A = 0, D = null, F = !1) {
  if (((!m || m === zR) && (m = Gs), mL(m))) {
    const rt = Xa(m, x, !0);
    return M && R_(rt, M), _c > 0 && !F && In && (rt.shapeFlag & 6 ? (In[In.indexOf(m)] = rt) : In.push(rt)), (rt.patchFlag |= -2), rt;
  }
  if ((AL(m) && (m = m.__vccOpts), x)) {
    x = gL(x);
    let { class: rt, style: $ } = x;
    rt && !lr(rt) && (x.class = v_(rt)), Ui($) && (kT($) && !Pe($) && ($ = gr({}, $)), (x.style = x_($)));
  }
  const W = lr(m) ? 1 : DR(m) ? 128 : dL(m) ? 64 : Ui(m) ? 4 : Ge(m) ? 2 : 0;
  return $i(m, x, M, A, D, W, F, !0);
}
function gL(m) {
  return m ? (kT(m) || od in m ? gr({}, m) : m) : null;
}
function Xa(m, x, M = !1) {
  const { props: A, ref: D, patchFlag: F, children: W } = m,
    rt = x ? xL(A || {}, x) : A;
  return { __v_isVNode: !0, __v_skip: !0, type: m.type, props: rt, key: rt && lE(rt), ref: x && x.ref ? (M && D ? (Pe(D) ? D.concat(Gh(x)) : [D, Gh(x)]) : Gh(x)) : D, scopeId: m.scopeId, slotScopeIds: m.slotScopeIds, children: W, target: m.target, targetAnchor: m.targetAnchor, staticCount: m.staticCount, shapeFlag: m.shapeFlag, patchFlag: x && m.type !== Hn ? (F === -1 ? 16 : F | 16) : F, dynamicProps: m.dynamicProps, dynamicChildren: m.dynamicChildren, appContext: m.appContext, dirs: m.dirs, transition: m.transition, component: m.component, suspense: m.suspense, ssContent: m.ssContent && Xa(m.ssContent), ssFallback: m.ssFallback && Xa(m.ssFallback), el: m.el, anchor: m.anchor, ctx: m.ctx, ce: m.ce };
}
function yL(m = ' ', x = 0) {
  return mn(nd, null, m, x);
}
function cE(m, x) {
  const M = mn(jh, null, m);
  return (M.staticCount = x), M;
}
function Bs(m = '', x = !1) {
  return x ? (An(), pL(Gs, null, m)) : mn(Gs, null, m);
}
function Wn(m) {
  return m == null || typeof m == 'boolean' ? mn(Gs) : Pe(m) ? mn(Hn, null, m.slice()) : typeof m == 'object' ? es(m) : mn(nd, null, String(m));
}
function es(m) {
  return (m.el === null && m.patchFlag !== -1) || m.memo ? m : Xa(m);
}
function R_(m, x) {
  let M = 0;
  const { shapeFlag: A } = m;
  if (x == null) x = null;
  else if (Pe(x)) M = 16;
  else if (typeof x == 'object')
    if (A & 65) {
      const D = x.default;
      D && (D._c && (D._d = !1), R_(m, D()), D._c && (D._d = !0));
      return;
    } else {
      M = 32;
      const D = x._;
      !D && !(od in x) ? (x._ctx = Jr) : D === 3 && Jr && (Jr.slots._ === 1 ? (x._ = 1) : ((x._ = 2), (m.patchFlag |= 1024)));
    }
  else Ge(x) ? ((x = { default: x, _ctx: Jr }), (M = 32)) : ((x = String(x)), A & 64 ? ((M = 16), (x = [yL(x)])) : (M = 8));
  (m.children = x), (m.shapeFlag |= M);
}
function xL(...m) {
  const x = {};
  for (let M = 0; M < m.length; M++) {
    const A = m[M];
    for (const D in A)
      if (D === 'class') x.class !== A.class && (x.class = v_([x.class, A.class]));
      else if (D === 'style') x.style = x_([x.style, A.style]);
      else if (Yh(D)) {
        const F = x[D],
          W = A[D];
        W && F !== W && !(Pe(F) && F.includes(W)) && (x[D] = F ? [].concat(F, W) : W);
      } else D !== '' && (x[D] = A[D]);
  }
  return x;
}
function Zn(m, x, M, A = null) {
  Cn(m, x, 7, [M, A]);
}
const vL = QT();
let bL = 0;
function wL(m, x, M) {
  const A = m.type,
    D = (x ? x.appContext : m.appContext) || vL,
    F = { uid: bL++, vnode: m, type: A, parent: x, appContext: D, root: null, next: null, subTree: null, effect: null, update: null, scope: new ZD(!0), render: null, proxy: null, exposed: null, exposeProxy: null, withProxy: null, provides: x ? x.provides : Object.create(D.provides), accessCache: null, renderCache: [], components: null, directives: null, propsOptions: eE(A, D), emitsOptions: qT(A, D), emit: null, emitted: null, propsDefaults: ki, inheritAttrs: A.inheritAttrs, ctx: ki, data: ki, props: ki, attrs: ki, slots: ki, refs: ki, setupState: ki, setupContext: null, attrsProxy: null, slotsProxy: null, suspense: M, suspenseId: M ? M.pendingId : 0, asyncDep: null, asyncResolved: !1, isMounted: !1, isUnmounted: !1, isDeactivated: !1, bc: null, c: null, bm: null, m: null, bu: null, u: null, um: null, bum: null, da: null, a: null, rtg: null, rtc: null, ec: null, sp: null };
  return (F.ctx = { _: F }), (F.root = x ? x.root : F), (F.emit = MR.bind(null, F)), m.ce && m.ce(F), F;
}
let Er = null,
  Wh,
  f_;
{
  const m = xT(),
    x = (M, A) => {
      let D;
      return (
        (D = m[M]) || (D = m[M] = []),
        D.push(A),
        (F) => {
          D.length > 1 ? D.forEach((W) => W(F)) : D[0](F);
        }
      );
    };
  (Wh = x('__VUE_INSTANCE_SETTERS__', (M) => (Er = M))), (f_ = x('__VUE_SSR_SETTERS__', (M) => (sd = M)));
}
const yc = (m) => {
    const x = Er;
    return (
      Wh(m),
      m.scope.on(),
      () => {
        m.scope.off(), Wh(x);
      }
    );
  },
  tT = () => {
    Er && Er.scope.off(), Wh(null);
  };
function uE(m) {
  return m.vnode.shapeFlag & 4;
}
let sd = !1;
function TL(m, x = !1) {
  x && f_(x);
  const { props: M, children: A } = m.vnode,
    D = uE(m);
  rL(m, M, D, x), sL(m, A);
  const F = D ? EL(m, x) : void 0;
  return x && f_(!1), F;
}
function EL(m, x) {
  const M = m.type;
  (m.accessCache = Object.create(null)), (m.proxy = OT(new Proxy(m.ctx, WR)));
  const { setup: A } = M;
  if (A) {
    const D = (m.setupContext = A.length > 1 ? SL(m) : null),
      F = yc(m);
    qs();
    const W = ns(A, m, 0, [m.props, D]);
    if ((Zs(), F(), mT(W))) {
      if ((W.then(tT, tT), x))
        return W.then((rt) => {
          eT(m, rt, x);
        }).catch((rt) => {
          ed(rt, m, 0);
        });
      m.asyncDep = W;
    } else eT(m, W, x);
  } else hE(m, x);
}
function eT(m, x, M) {
  Ge(x) ? (m.type.__ssrInlineRender ? (m.ssrRender = x) : (m.render = x)) : Ui(x) && (m.setupState = NT(x)), hE(m, M);
}
let iT;
function hE(m, x, M) {
  const A = m.type;
  if (!m.render) {
    if (!x && iT && !A.render) {
      const D = A.template || z_(m).template;
      if (D) {
        const { isCustomElement: F, compilerOptions: W } = m.appContext.config,
          { delimiters: rt, compilerOptions: $ } = A,
          U = gr(gr({ isCustomElement: F, delimiters: rt }, W), $);
        A.render = iT(D, U);
      }
    }
    m.render = A.render || pn;
  }
  {
    const D = yc(m);
    qs();
    try {
      XR(m);
    } finally {
      Zs(), D();
    }
  }
}
function ML(m) {
  return (
    m.attrsProxy ||
    (m.attrsProxy = new Proxy(m.attrs, {
      get(x, M) {
        return Gr(m, 'get', '$attrs'), x[M];
      },
    }))
  );
}
function SL(m) {
  const x = (M) => {
    m.exposed = M || {};
  };
  return {
    get attrs() {
      return ML(m);
    },
    slots: m.slots,
    emit: m.emit,
    expose: x,
  };
}
function ad(m) {
  if (m.exposed)
    return (
      m.exposeProxy ||
      (m.exposeProxy = new Proxy(NT(OT(m.exposed)), {
        get(x, M) {
          if (M in x) return x[M];
          if (M in uc) return uc[M](m);
        },
        has(x, M) {
          return M in x || M in uc;
        },
      }))
    );
}
function AL(m) {
  return Ge(m) && '__vccOpts' in m;
}
const IL = (m, x) => pR(m, x, sd),
  CL = '3.4.19';
/**
 * @vue/runtime-dom v3.4.19
 * (c) 2018-present Yuxi (Evan) You and Vue contributors
 * @license MIT
 **/ const PL = 'http://www.w3.org/2000/svg',
  zL = 'http://www.w3.org/1998/Math/MathML',
  is = typeof document < 'u' ? document : null,
  rT = is && is.createElement('template'),
  DL = {
    insert: (m, x, M) => {
      x.insertBefore(m, M || null);
    },
    remove: (m) => {
      const x = m.parentNode;
      x && x.removeChild(m);
    },
    createElement: (m, x, M, A) => {
      const D = x === 'svg' ? is.createElementNS(PL, m) : x === 'mathml' ? is.createElementNS(zL, m) : is.createElement(m, M ? { is: M } : void 0);
      return m === 'select' && A && A.multiple != null && D.setAttribute('multiple', A.multiple), D;
    },
    createText: (m) => is.createTextNode(m),
    createComment: (m) => is.createComment(m),
    setText: (m, x) => {
      m.nodeValue = x;
    },
    setElementText: (m, x) => {
      m.textContent = x;
    },
    parentNode: (m) => m.parentNode,
    nextSibling: (m) => m.nextSibling,
    querySelector: (m) => is.querySelector(m),
    setScopeId(m, x) {
      m.setAttribute(x, '');
    },
    insertStaticContent(m, x, M, A, D, F) {
      const W = M ? M.previousSibling : x.lastChild;
      if (D && (D === F || D.nextSibling)) for (; x.insertBefore(D.cloneNode(!0), M), !(D === F || !(D = D.nextSibling)); );
      else {
        rT.innerHTML = A === 'svg' ? `<svg>${m}</svg>` : A === 'mathml' ? `<math>${m}</math>` : m;
        const rt = rT.content;
        if (A === 'svg' || A === 'mathml') {
          const $ = rt.firstChild;
          for (; $.firstChild; ) rt.appendChild($.firstChild);
          rt.removeChild($);
        }
        x.insertBefore(rt, M);
      }
      return [W ? W.nextSibling : x.firstChild, M ? M.previousSibling : x.lastChild];
    },
  },
  RL = Symbol('_vtc');
function LL(m, x, M) {
  const A = m[RL];
  A && (x = (x ? [x, ...A] : [...A]).join(' ')), x == null ? m.removeAttribute('class') : M ? m.setAttribute('class', x) : (m.className = x);
}
const nT = Symbol('_vod'),
  kL = Symbol(''),
  OL = /(^|;)\s*display\s*:/;
function BL(m, x, M) {
  const A = m.style,
    D = lr(M),
    F = A.display;
  let W = !1;
  if (M && !D) {
    if (x && !lr(x)) for (const rt in x) M[rt] == null && p_(A, rt, '');
    for (const rt in M) rt === 'display' && (W = !0), p_(A, rt, M[rt]);
  } else if (D) {
    if (x !== M) {
      const rt = A[kL];
      rt && (M += ';' + rt), (A.cssText = M), (W = OL.test(M));
    }
  } else x && m.removeAttribute('style');
  nT in m && ((m[nT] = W ? A.display : ''), (A.display = F));
}
const oT = /\s*!important$/;
function p_(m, x, M) {
  if (Pe(M)) M.forEach((A) => p_(m, x, A));
  else if ((M == null && (M = ''), x.startsWith('--'))) m.setProperty(x, M);
  else {
    const A = FL(m, x);
    oT.test(M) ? m.setProperty(Ya(A), M.replace(oT, ''), 'important') : (m[A] = M);
  }
}
const sT = ['Webkit', 'Moz', 'ms'],
  t_ = {};
function FL(m, x) {
  const M = t_[x];
  if (M) return M;
  let A = Ha(x);
  if (A !== 'filter' && A in m) return (t_[x] = A);
  A = yT(A);
  for (let D = 0; D < sT.length; D++) {
    const F = sT[D] + A;
    if (F in m) return (t_[x] = F);
  }
  return x;
}
const aT = 'http://www.w3.org/1999/xlink';
function NL(m, x, M, A, D) {
  if (A && x.startsWith('xlink:')) M == null ? m.removeAttributeNS(aT, x.slice(6, x.length)) : m.setAttributeNS(aT, x, M);
  else {
    const F = GD(x);
    M == null || (F && !vT(M)) ? m.removeAttribute(x) : m.setAttribute(x, F ? '' : M);
  }
}
function UL(m, x, M, A, D, F, W) {
  if (x === 'innerHTML' || x === 'textContent') {
    A && W(A, D, F), (m[x] = M ?? '');
    return;
  }
  const rt = m.tagName;
  if (x === 'value' && rt !== 'PROGRESS' && !rt.includes('-')) {
    m._value = M;
    const U = rt === 'OPTION' ? m.getAttribute('value') : m.value,
      Et = M ?? '';
    U !== Et && (m.value = Et), M == null && m.removeAttribute(x);
    return;
  }
  let $ = !1;
  if (M === '' || M == null) {
    const U = typeof m[x];
    U === 'boolean' ? (M = vT(M)) : M == null && U === 'string' ? ((M = ''), ($ = !0)) : U === 'number' && ((M = 0), ($ = !0));
  }
  try {
    m[x] = M;
  } catch {}
  $ && m.removeAttribute(x);
}
function Ns(m, x, M, A) {
  m.addEventListener(x, M, A);
}
function VL(m, x, M, A) {
  m.removeEventListener(x, M, A);
}
const lT = Symbol('_vei');
function jL(m, x, M, A, D = null) {
  const F = m[lT] || (m[lT] = {}),
    W = F[x];
  if (A && W) W.value = A;
  else {
    const [rt, $] = GL(x);
    if (A) {
      const U = (F[x] = $L(A, D));
      Ns(m, rt, U, $);
    } else W && (VL(m, rt, W, $), (F[x] = void 0));
  }
}
const cT = /(?:Once|Passive|Capture)$/;
function GL(m) {
  let x;
  if (cT.test(m)) {
    x = {};
    let A;
    for (; (A = m.match(cT)); ) (m = m.slice(0, m.length - A[0].length)), (x[A[0].toLowerCase()] = !0);
  }
  return [m[2] === ':' ? m.slice(3) : Ya(m.slice(2)), x];
}
let e_ = 0;
const qL = Promise.resolve(),
  ZL = () => e_ || (qL.then(() => (e_ = 0)), (e_ = Date.now()));
function $L(m, x) {
  const M = (A) => {
    if (!A._vts) A._vts = Date.now();
    else if (A._vts <= M.attached) return;
    Cn(HL(A, M.value), x, 5, [A]);
  };
  return (M.value = m), (M.attached = ZL()), M;
}
function HL(m, x) {
  if (Pe(x)) {
    const M = m.stopImmediatePropagation;
    return (
      (m.stopImmediatePropagation = () => {
        M.call(m), (m._stopped = !0);
      }),
      x.map((A) => (D) => !D._stopped && A && A(D))
    );
  } else return x;
}
const uT = (m) => m.charCodeAt(0) === 111 && m.charCodeAt(1) === 110 && m.charCodeAt(2) > 96 && m.charCodeAt(2) < 123,
  WL = (m, x, M, A, D, F, W, rt, $) => {
    const U = D === 'svg';
    x === 'class' ? LL(m, A, U) : x === 'style' ? BL(m, M, A) : Yh(x) ? __(x) || jL(m, x, M, A, W) : (x[0] === '.' ? ((x = x.slice(1)), !0) : x[0] === '^' ? ((x = x.slice(1)), !1) : XL(m, x, A, U)) ? UL(m, x, A, F, W, rt, $) : (x === 'true-value' ? (m._trueValue = A) : x === 'false-value' && (m._falseValue = A), NL(m, x, A, U));
  };
function XL(m, x, M, A) {
  if (A) return !!(x === 'innerHTML' || x === 'textContent' || (x in m && uT(x) && Ge(M)));
  if (x === 'spellcheck' || x === 'draggable' || x === 'translate' || x === 'form' || (x === 'list' && m.tagName === 'INPUT') || (x === 'type' && m.tagName === 'TEXTAREA')) return !1;
  if (x === 'width' || x === 'height') {
    const D = m.tagName;
    if (D === 'IMG' || D === 'VIDEO' || D === 'CANVAS' || D === 'SOURCE') return !1;
  }
  return uT(x) && lr(M) ? !1 : x in m;
}
const Xh = (m) => {
  const x = m.props['onUpdate:modelValue'] || !1;
  return Pe(x) ? (M) => Fh(x, M) : x;
};
function YL(m) {
  m.target.composing = !0;
}
function hT(m) {
  const x = m.target;
  x.composing && ((x.composing = !1), x.dispatchEvent(new Event('input')));
}
const $a = Symbol('_assign'),
  sc = {
    created(m, { modifiers: { lazy: x, trim: M, number: A } }, D) {
      m[$a] = Xh(D);
      const F = A || (D.props && D.props.type === 'number');
      Ns(m, x ? 'change' : 'input', (W) => {
        if (W.target.composing) return;
        let rt = m.value;
        M && (rt = rt.trim()), F && (rt = i_(rt)), m[$a](rt);
      }),
        M &&
          Ns(m, 'change', () => {
            m.value = m.value.trim();
          }),
        x || (Ns(m, 'compositionstart', YL), Ns(m, 'compositionend', hT), Ns(m, 'change', hT));
    },
    mounted(m, { value: x }) {
      m.value = x ?? '';
    },
    beforeUpdate(m, { value: x, modifiers: { lazy: M, trim: A, number: D } }, F) {
      if (((m[$a] = Xh(F)), m.composing)) return;
      const W = D || m.type === 'number' ? i_(m.value) : m.value,
        rt = x ?? '';
      W !== rt && ((document.activeElement === m && m.type !== 'range' && (M || (A && m.value.trim() === rt))) || (m.value = rt));
    },
  },
  dT = {
    deep: !0,
    created(m, x, M) {
      (m[$a] = Xh(M)),
        Ns(m, 'change', () => {
          const A = m._modelValue,
            D = KL(m),
            F = m.checked,
            W = m[$a];
          if (Pe(A)) {
            const rt = bT(A, D),
              $ = rt !== -1;
            if (F && !$) W(A.concat(D));
            else if (!F && $) {
              const U = [...A];
              U.splice(rt, 1), W(U);
            }
          } else if (Kh(A)) {
            const rt = new Set(A);
            F ? rt.add(D) : rt.delete(D), W(rt);
          } else W(dE(m, F));
        });
    },
    mounted: fT,
    beforeUpdate(m, x, M) {
      (m[$a] = Xh(M)), fT(m, x, M);
    },
  };
function fT(m, { value: x, oldValue: M }, A) {
  (m._modelValue = x), Pe(x) ? (m.checked = bT(x, A.props.value) > -1) : Kh(x) ? (m.checked = x.has(A.props.value)) : x !== M && (m.checked = Qh(x, dE(m, !0)));
}
function KL(m) {
  return '_value' in m ? m._value : m.value;
}
function dE(m, x) {
  const M = x ? '_trueValue' : '_falseValue';
  return M in m ? m[M] : x;
}
const JL = ['ctrl', 'shift', 'alt', 'meta'],
  QL = { stop: (m) => m.stopPropagation(), prevent: (m) => m.preventDefault(), self: (m) => m.target !== m.currentTarget, ctrl: (m) => !m.ctrlKey, shift: (m) => !m.shiftKey, alt: (m) => !m.altKey, meta: (m) => !m.metaKey, left: (m) => 'button' in m && m.button !== 0, middle: (m) => 'button' in m && m.button !== 1, right: (m) => 'button' in m && m.button !== 2, exact: (m, x) => JL.some((M) => m[`${M}Key`] && !x.includes(M)) },
  t3 = (m, x) => {
    const M = m._withMods || (m._withMods = {}),
      A = x.join('.');
    return (
      M[A] ||
      (M[A] = (D, ...F) => {
        for (let W = 0; W < x.length; W++) {
          const rt = QL[x[W]];
          if (rt && rt(D, x)) return;
        }
        return m(D, ...F);
      })
    );
  },
  e3 = gr({ patchProp: WL }, DL);
let pT;
function i3() {
  return pT || (pT = lL(e3));
}
const r3 = (...m) => {
  const x = i3().createApp(...m),
    { mount: M } = x;
  return (
    (x.mount = (A) => {
      const D = o3(A);
      if (!D) return;
      const F = x._component;
      !Ge(F) && !F.render && !F.template && (F.template = D.innerHTML), (D.innerHTML = '');
      const W = M(D, !1, n3(D));
      return D instanceof Element && (D.removeAttribute('v-cloak'), D.setAttribute('data-v-app', '')), W;
    }),
    x
  );
};
function n3(m) {
  if (m instanceof SVGElement) return 'svg';
  if (typeof MathMLElement == 'function' && m instanceof MathMLElement) return 'mathml';
}
function o3(m) {
  return lr(m) ? document.querySelector(m) : m;
}
const s3 = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACEAAAAvCAYAAABt7qMfAAAAAXNSR0IArs4c6QAAAARzQklUCAgICHwIZIgAAANjSURBVFhHzVhtTttAEN0JIRISsR2J5G/DCRpOQDhB6QmAEzScoHCCpidoOAHlBElPAD0B6V+CFH8gITUf01kHWxvHXs86CaolfqDszL6deTPzdkEwP8SxEwSzYxTzUxTQFIgOALSkOSIOBcAQBNJfaVCt7twB1FymawF5C19fx82/k8lXIeA8b636Owox2AFxXa3WB3l2mSDkyf1g8s108+SGEky5hJf7+42HLDCpIIJg1J7NxS2AcPJOwfkdUbglgAvLOviZtn4FhO8/n6PAHxznxmtQXNt2/SpptwRiqwDedgYRRqSnAolBvLw8taYz6G8qBbooEZDPampiEK4/6tM/beMQFzCQJW1bu0dRGYcg3iMNK1gVfoQgXO/pkRpPs8ChCpvIinHsek06AMmF2Rzui3gjR39CJyA+FLGPuAFe8NylvvvFyAmFslIp9/b2akNpFzY2f9qhxtQhQDbfF97YVuMciJADyskx1zDJbNXurcIGXCBE0AfHbhwB8eE+GkS5QDKajWpnSnLbqgN4/oiiyPsqu+XDKAU6C9cbudxoGIGQJCQ2syrIJMUhCEI95LBbNhjK3yEnZuYgDIhpVcs1jlihg4057T+KLnje6IqkDYkWxrd5Yt5ROk6B2ExyDW8ZEKgfCLe8gydZAsV4CKK4pNHehYWCmo45IBaNKRQoHZqCN4nSPJsjdjlpiOyiagtnB5WpVDyfuEAiMJTGhWRD0TLZfGGCvx2rEQrl/2eKSjQmDcYkYllr1cYXixrPf+pRYM42sQHDR1gV0boYxOJ+MX1kOFh7SQnEiXofWRK67xENGlS/HKveVk+yBELeN+Yo+msfVeMgTQqs3DuKlCsXdFoU4hJVnWyTG0kurBBTBbINbmRFITUSi244djx/Kke8gV7UJ0UniDJv5UbTNY8UAN/t6kEna5n2fYIreHQYaOB5tlVu6nSIFsQmSjbtApwEnftSs07J6siY2azSwroOSbnqPDcSEpiJ+ooPwpCC2j6RFhGTtKiCJa9wMvvEOmmR1UA6tK17KDMmpmrASsubeOVEwDgdkYGupXOrYa1IxC09mNBNHj6qzjhNqVDHzDJKe1jJmpCctLBKNM3R0hOAQTmm+SoMQjqT/JCP7Um5xjm9UcfUD6dx+OzMuSTr/PwDdiu2P4jIatgAAAAASUVORK5CYII=',
  a3 = $i('div', { id: 'top' }, null, -1),
  l3 = { class: 'lg:h-824 flex lg:flex-row flex-col bg-nav-text-green lg:bg-white z-0 mb-20' },
  c3 = cE('<div class="w-full lg:w-2/5 bg-primary-white"><div class="flex justify-start items-center lg:h-full"><div class="w-full flex flex-col text-left text-primary-white px-6 lg:px-10 my-10 lg:my-auto"><div class="text-nav-text-green font-black text-5xl lg:text-6xl xl:text-7xl font-inter mb-8"><p>Contacteer ons nu</p></div><div class="font-inter"><p class="mb-8 text-black">Ontdek jouw droomfiets met een gratis testrit bij ons! Of je nu door de stad wilt cruisen of de paden wilt verkennen, wij hebben de perfecte fiets voor jou. Ervaar het plezier van het rijden op een fiets die bij jou past. Boek nu jouw testrit en begin aan jouw fietsavontuur!</p></div></div></div></div>', 1),
  u3 = { class: 'w-full flex lg:w-3/5 bg-nav-text-green justify-center items-center py-20 lg:py-0' },
  h3 = { key: 0, class: 'text-red-900 text-sm' },
  d3 = { key: 1, class: 'text-red-900 text-sm' },
  f3 = { key: 0, class: 'text-red-900 text-sm' },
  p3 = { key: 1, class: 'text-red-900 text-sm' },
  m3 = { key: 0, class: 'text-red-900 text-sm' },
  _3 = { class: 'flex items-center mt-4 sm:col-span-2' },
  g3 = $i('label', { for: 'agree1' }, 'Ik ontvang graag de nieuwsbrief', -1),
  y3 = { class: 'flex items-center mt-4 sm:col-span-2' },
  x3 = $i('label', { for: 'agree2' }, 'Ik ga akkoord met het privacy statement', -1),
  v3 = { key: 1, class: 'text-red-900 text-sm' },
  b3 = { key: 2, class: 'mt-4 text-primary-white underline' },
  w3 = $i('a', { href: '#top', class: 'fixed right-4 bottom-4 text-white bg-fixed-nav-green p-2 rounded-full px-4 shadow-lg z-50' }, ' Terug naar boven ', -1),
  T3 = {
    __name: 'AppHeroContact',
    setup(m, { expose: x }) {
      const M = Vr(''),
        A = Vr(''),
        D = Vr(''),
        F = Vr(''),
        W = Vr(''),
        rt = Vr(!1),
        $ = Vr(!1),
        U = Vr(''),
        Et = Vr(''),
        Zt = Vr(''),
        Mt = Vr(''),
        _e = Vr(''),
        ei = Vr(''),
        Oe = Vr(!1);
      x({ formSuccess: Oe });
      const Si = () => {
          let Ue = !0;
          M.value ? (U.value = '') : ((U.value = 'Email is required'), (Ue = !1)),
            A.value ? (Et.value = '') : ((Et.value = 'Name is required'), (Ue = !1)),
            D.value ? (Zt.value = '') : ((Zt.value = 'Phone number is required'), (Ue = !1)),
            F.value ? (Mt.value = '') : ((Mt.value = 'Subject is required'), (Ue = !1)),
            W.value ? (_e.value = '') : ((_e.value = 'Message is required'), (Ue = !1)),
            $.value || ((ei.value = 'You must agree to the privacy statement'), (Ue = !1)),
            Ue &&
              ((Oe.value = !0),
              console.log('Form successfully submitted!'),
              console.log(Oe.value),
              setTimeout(() => {
                pi(), cr();
              }, 200));
        },
        pi = () => {
          (A.value = ''), (M.value = ''), (D.value = ''), (F.value = ''), (W.value = ''), (rt.value = !1), ($.value = !1);
        },
        cr = () => {
          (U.value = ''), (Et.value = ''), (Zt.value = ''), (Mt.value = ''), (_e.value = ''), (ei.value = '');
        };
      return (Ue, ze) => (
        An(),
        $n(
          Hn,
          null,
          [
            a3,
            $i('div', l3, [
              c3,
              $i('div', u3, [
                $i(
                  'form',
                  { class: 'grid grid-cols-1 sm:grid-cols-2 gap-4 text-primary-white w-85p sm:w-90p lg:w-4/5', onSubmit: t3(Si, ['prevent']) },
                  [
                    $i('div', null, [Ls($i('input', { 'onUpdate:modelValue': ze[0] || (ze[0] = (ui) => (M.value = ui)), class: 'bg-transparent border-2 border-white rounded-1 pb-1 pl-2 footer-form w-full h-10', placeholder: 'Emailadres' }, null, 512), [[sc, M.value]]), U.value ? (An(), $n('div', h3, Va(U.value), 1)) : Bs('', !0), Ls($i('input', { 'onUpdate:modelValue': ze[1] || (ze[1] = (ui) => (A.value = ui)), class: 'bg-transparent border-2 border-white rounded-1 pb-1 pl-2 footer-form w-full h-10 mt-4', placeholder: 'Name' }, null, 512), [[sc, A.value]]), Et.value ? (An(), $n('div', d3, Va(Et.value), 1)) : Bs('', !0)]),
                    $i('div', null, [Ls($i('input', { 'onUpdate:modelValue': ze[2] || (ze[2] = (ui) => (D.value = ui)), class: 'bg-transparent border-2 border-white rounded-1 pb-1 pl-2 footer-form w-full h-10', placeholder: 'Telefoon' }, null, 512), [[sc, D.value]]), Zt.value ? (An(), $n('div', f3, Va(Zt.value), 1)) : Bs('', !0), Ls($i('input', { 'onUpdate:modelValue': ze[3] || (ze[3] = (ui) => (F.value = ui)), class: 'bg-transparent border-2 border-white rounded-1 pb-1 pl-2 footer-form w-full h-10 mt-4', placeholder: 'Onderwerp' }, null, 512), [[sc, F.value]]), Mt.value ? (An(), $n('div', p3, Va(Mt.value), 1)) : Bs('', !0)]),
                    Ls($i('textarea', { 'onUpdate:modelValue': ze[4] || (ze[4] = (ui) => (W.value = ui)), class: 'bg-transparent border-2 border-white rounded-1 pb-1 pl-2 footer-form w-full h-8 mt-2 sm:col-span-2', placeholder: 'Bericht' }, null, 512), [[sc, W.value]]),
                    _e.value ? (An(), $n('div', m3, Va(_e.value), 1)) : Bs('', !0),
                    $i('div', _3, [Ls($i('input', { 'onUpdate:modelValue': ze[5] || (ze[5] = (ui) => (rt.value = ui)), type: 'checkbox', id: 'agree1', name: 'agree1', class: 'bg-transparent border-2 border-white rounded-1 pb-1 footer-form w-6 h-6 mr-2' }, null, 512), [[dT, rt.value]]), g3]),
                    $i('div', y3, [Ls($i('input', { 'onUpdate:modelValue': ze[6] || (ze[6] = (ui) => ($.value = ui)), type: 'checkbox', id: 'agree2', name: 'agree2', class: 'bg-transparent border-2 border-white rounded-1 pb-1 footer-form w-6 h-6 mr-2' }, null, 512), [[dT, $.value]]), x3]),
                    ei.value ? (An(), $n('div', v3, Va(ei.value), 1)) : Bs('', !0),
                    $i('div', { class: 'text-left xl:text-right lg:col-span-2 lg:mt-2 mt-4' }, [$i('button', { onClick: Si, class: 'bg-nav-text-green text-primary-white font-regular py-2 px-4 rounded-1px font-sofia border-2 border-white transition-colors duration-400 delay-50 hover:bg-primary-white hover:text-nav-text-green' }, 'Verzenden')]),
                    Oe.value ? (An(), $n('div', b3, 'Je vraag is succesvol verstuurd!')) : Bs('', !0),
                  ],
                  32
                ),
              ]),
            ]),
            w3,
          ],
          64
        )
      );
    },
  };
var E3 = typeof globalThis < 'u' ? globalThis : typeof window < 'u' ? window : typeof global < 'u' ? global : typeof self < 'u' ? self : {};
function M3(m) {
  return m && m.__esModule && Object.prototype.hasOwnProperty.call(m, 'default') ? m.default : m;
}
var fE = { exports: {} };
(function (m, x) {
  var M = {};
  (function (A, D) {
    m.exports = D();
  })(E3, function () {
    var A, D, F;
    function W($, U) {
      if (!A) A = U;
      else if (!D) D = U;
      else {
        var Et = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" + A + ')(sharedChunk); (' + D + ')(sharedChunk); self.onerror = null;',
          Zt = {};
        A(Zt), (F = U(Zt)), typeof window < 'u' && window && window.URL && window.URL.createObjectURL && (F.workerUrl = window.URL.createObjectURL(new Blob([Et], { type: 'text/javascript' })));
      }
    }
    W(['exports'], function ($) {
      var U = typeof self < 'u' ? self : {},
        Et = '3.1.2';
      let Zt;
      const Mt = {
          API_URL: 'https://api.mapbox.com',
          get API_URL_REGEX() {
            if (Zt == null) {
              const e = /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
              try {
                Zt = M.API_URL_REGEX != null ? new RegExp(M.API_URL_REGEX) : e;
              } catch {
                Zt = e;
              }
            }
            return Zt;
          },
          get API_TILEJSON_REGEX() {
            return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i;
          },
          get API_SPRITE_REGEX() {
            return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i;
          },
          get API_FONTS_REGEX() {
            return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i;
          },
          get API_STYLE_REGEX() {
            return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i;
          },
          get API_CDN_URL_REGEX() {
            return /^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i;
          },
          get EVENTS_URL() {
            if (!Mt.API_URL) return null;
            try {
              const e = new URL(Mt.API_URL);
              return e.hostname === 'api.mapbox.cn' ? 'https://events.mapbox.cn/events/v2' : e.hostname === 'api.mapbox.com' ? 'https://events.mapbox.com/events/v2' : null;
            } catch {
              return null;
            }
          },
          SESSION_PATH: '/map-sessions/v1',
          FEEDBACK_URL: 'https://apps.mapbox.com/feedback',
          TILE_URL_VERSION: 'v4',
          RASTER_URL_PREFIX: 'raster/v1',
          REQUIRE_ACCESS_TOKEN: !0,
          ACCESS_TOKEN: null,
          DEFAULT_STYLE: 'mapbox://styles/mapbox/standard',
          MAX_PARALLEL_IMAGE_REQUESTS: 16,
          DRACO_URL: 'https://api.mapbox.com/mapbox-gl-js/draco_decoder_gltf_v1.5.6.wasm',
          GLYPHS_URL: 'mapbox://fonts/mapbox/{fontstack}/{range}.pbf',
        },
        _e = {
          supported: !1,
          testSupport: function (e) {
            !Si && Oe && (pi ? cr(e) : (ei = e));
          },
        };
      let ei,
        Oe,
        Si = !1,
        pi = !1;
      function cr(e) {
        const t = e.createTexture();
        e.bindTexture(e.TEXTURE_2D, t);
        try {
          if ((e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, Oe), e.isContextLost())) return;
          _e.supported = !0;
        } catch {}
        e.deleteTexture(t), (Si = !0);
      }
      U.document &&
        ((Oe = U.document.createElement('img')),
        (Oe.onload = function () {
          ei && cr(ei), (ei = null), (pi = !0);
        }),
        (Oe.onerror = function () {
          (Si = !0), (ei = null);
        }),
        (Oe.src = 'data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA='));
      const Ue = '01';
      function ze(e) {
        return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, 'default') ? e.default : e;
      }
      var ui = qe;
      function qe(e, t, i, r) {
        (this.cx = 3 * e), (this.bx = 3 * (i - e) - this.cx), (this.ax = 1 - this.cx - this.bx), (this.cy = 3 * t), (this.by = 3 * (r - t) - this.cy), (this.ay = 1 - this.cy - this.by), (this.p1x = e), (this.p1y = t), (this.p2x = i), (this.p2y = r);
      }
      qe.prototype = {
        sampleCurveX: function (e) {
          return ((this.ax * e + this.bx) * e + this.cx) * e;
        },
        sampleCurveY: function (e) {
          return ((this.ay * e + this.by) * e + this.cy) * e;
        },
        sampleCurveDerivativeX: function (e) {
          return (3 * this.ax * e + 2 * this.bx) * e + this.cx;
        },
        solveCurveX: function (e, t) {
          if ((t === void 0 && (t = 1e-6), e < 0)) return 0;
          if (e > 1) return 1;
          for (var i = e, r = 0; r < 8; r++) {
            var n = this.sampleCurveX(i) - e;
            if (Math.abs(n) < t) return i;
            var o = this.sampleCurveDerivativeX(i);
            if (Math.abs(o) < 1e-6) break;
            i -= n / o;
          }
          var s = 0,
            a = 1;
          for (i = e, r = 0; r < 20 && ((n = this.sampleCurveX(i)), !(Math.abs(n - e) < t)); r++) e > n ? (s = i) : (a = i), (i = 0.5 * (a - s) + s);
          return i;
        },
        solve: function (e, t) {
          return this.sampleCurveY(this.solveCurveX(e, t));
        },
      };
      var Mr = ze(ui),
        ur = Sr;
      function Sr(e, t) {
        (this.x = e), (this.y = t);
      }
      (Sr.prototype = {
        clone: function () {
          return new Sr(this.x, this.y);
        },
        add: function (e) {
          return this.clone()._add(e);
        },
        sub: function (e) {
          return this.clone()._sub(e);
        },
        multByPoint: function (e) {
          return this.clone()._multByPoint(e);
        },
        divByPoint: function (e) {
          return this.clone()._divByPoint(e);
        },
        mult: function (e) {
          return this.clone()._mult(e);
        },
        div: function (e) {
          return this.clone()._div(e);
        },
        rotate: function (e) {
          return this.clone()._rotate(e);
        },
        rotateAround: function (e, t) {
          return this.clone()._rotateAround(e, t);
        },
        matMult: function (e) {
          return this.clone()._matMult(e);
        },
        unit: function () {
          return this.clone()._unit();
        },
        perp: function () {
          return this.clone()._perp();
        },
        round: function () {
          return this.clone()._round();
        },
        mag: function () {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        },
        equals: function (e) {
          return this.x === e.x && this.y === e.y;
        },
        dist: function (e) {
          return Math.sqrt(this.distSqr(e));
        },
        distSqr: function (e) {
          var t = e.x - this.x,
            i = e.y - this.y;
          return t * t + i * i;
        },
        angle: function () {
          return Math.atan2(this.y, this.x);
        },
        angleTo: function (e) {
          return Math.atan2(this.y - e.y, this.x - e.x);
        },
        angleWith: function (e) {
          return this.angleWithSep(e.x, e.y);
        },
        angleWithSep: function (e, t) {
          return Math.atan2(this.x * t - this.y * e, this.x * e + this.y * t);
        },
        _matMult: function (e) {
          var t = e[2] * this.x + e[3] * this.y;
          return (this.x = e[0] * this.x + e[1] * this.y), (this.y = t), this;
        },
        _add: function (e) {
          return (this.x += e.x), (this.y += e.y), this;
        },
        _sub: function (e) {
          return (this.x -= e.x), (this.y -= e.y), this;
        },
        _mult: function (e) {
          return (this.x *= e), (this.y *= e), this;
        },
        _div: function (e) {
          return (this.x /= e), (this.y /= e), this;
        },
        _multByPoint: function (e) {
          return (this.x *= e.x), (this.y *= e.y), this;
        },
        _divByPoint: function (e) {
          return (this.x /= e.x), (this.y /= e.y), this;
        },
        _unit: function () {
          return this._div(this.mag()), this;
        },
        _perp: function () {
          var e = this.y;
          return (this.y = this.x), (this.x = -e), this;
        },
        _rotate: function (e) {
          var t = Math.cos(e),
            i = Math.sin(e),
            r = i * this.x + t * this.y;
          return (this.x = t * this.x - i * this.y), (this.y = r), this;
        },
        _rotateAround: function (e, t) {
          var i = Math.cos(e),
            r = Math.sin(e),
            n = t.y + r * (this.x - t.x) + i * (this.y - t.y);
          return (this.x = t.x + i * (this.x - t.x) - r * (this.y - t.y)), (this.y = n), this;
        },
        _round: function () {
          return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
        },
      }),
        (Sr.convert = function (e) {
          return e instanceof Sr ? e : Array.isArray(e) ? new Sr(e[0], e[1]) : e;
        });
      var H = ze(ur);
      function we(e, t) {
        if (Array.isArray(e)) {
          if (!Array.isArray(t) || e.length !== t.length) return !1;
          for (let i = 0; i < e.length; i++) if (!we(e[i], t[i])) return !1;
          return !0;
        }
        if (typeof e == 'object' && e !== null && t !== null) {
          if (typeof t != 'object' || Object.keys(e).length !== Object.keys(t).length) return !1;
          for (const i in e) if (!we(e[i], t[i])) return !1;
          return !0;
        }
        return e === t;
      }
      const vo = Math.PI / 180,
        Qr = 180 / Math.PI;
      function ne(e) {
        return e * vo;
      }
      function Vi(e) {
        return e * Qr;
      }
      const nr = [
        [0, 0],
        [1, 0],
        [1, 1],
        [0, 1],
      ];
      function mi(e) {
        if (e <= 0) return 0;
        if (e >= 1) return 1;
        const t = e * e,
          i = t * e;
        return 4 * (e < 0.5 ? i : 3 * (e - t) + i - 0.75);
      }
      function _i(e) {
        let t = 1 / 0,
          i = 1 / 0,
          r = -1 / 0,
          n = -1 / 0;
        for (const o of e) (t = Math.min(t, o.x)), (i = Math.min(i, o.y)), (r = Math.max(r, o.x)), (n = Math.max(n, o.y));
        return { min: new H(t, i), max: new H(r, n) };
      }
      function yr(e, t, i = 0, r = !0) {
        const n = new H(i, i),
          o = e.sub(n),
          s = t.add(n),
          a = [o, new H(s.x, o.y), s, new H(o.x, s.y)];
        return r && a.push(o.clone()), a;
      }
      function tn(e, t, i, r) {
        const n = new Mr(e, t, i, r);
        return function (o) {
          return n.solve(o);
        };
      }
      const tr = tn(0.25, 0.1, 0.25, 1);
      function Bt(e, t, i) {
        return Math.min(i, Math.max(t, e));
      }
      function Zr(e, t, i) {
        return (i = Bt((i - e) / (t - e), 0, 1)) * i * (3 - 2 * i);
      }
      function en(e, t, i) {
        const r = i - t,
          n = ((((e - t) % r) + r) % r) + t;
        return n === t ? i : n;
      }
      function Yn(e, t, i) {
        if (!e.length) return i(null, []);
        let r = e.length;
        const n = new Array(e.length);
        let o = null;
        e.forEach((s, a) => {
          t(s, (l, c) => {
            l && (o = l), (n[a] = c), --r == 0 && i(o, n);
          });
        });
      }
      function hr(e) {
        const t = [];
        for (const i in e) t.push(e[i]);
        return t;
      }
      function Ft(e, ...t) {
        for (const i of t) for (const r in i) e[r] = i[r];
        return e;
      }
      function ar(e, t) {
        const i = {};
        for (let r = 0; r < t.length; r++) {
          const n = t[r];
          n in e && (i[n] = e[n]);
        }
        return i;
      }
      let $s = 1;
      function $r() {
        return $s++;
      }
      function bo() {
        return (function e(t) {
          return t ? (t ^ (Math.random() * (16 >> (t / 4)))).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, e);
        })();
      }
      function wo(e) {
        return e <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(e) / Math.LN2));
      }
      function Y(e) {
        return !!e && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(e);
      }
      function ot(e, t) {
        e.forEach((i) => {
          t[i] && (t[i] = t[i].bind(t));
        });
      }
      function xt(e, t) {
        return e.indexOf(t, e.length - t.length) !== -1;
      }
      function zt(e, t, i) {
        const r = {};
        for (const n in e) r[n] = t.call(i || this, e[n], n, e);
        return r;
      }
      function tt(e, t, i) {
        const r = {};
        for (const n in e) t.call(i || this, e[n], n, e) && (r[n] = e[n]);
        return r;
      }
      function P(e) {
        return Array.isArray(e) ? e.map(P) : typeof e == 'object' && e ? zt(e, P) : e;
      }
      const L = {};
      function B(e) {
        L[e] || (typeof console < 'u' && console.warn(e), (L[e] = !0));
      }
      function et(e, t, i) {
        return (i.y - e.y) * (t.x - e.x) > (t.y - e.y) * (i.x - e.x);
      }
      function K(e) {
        let t = 0;
        for (let i, r, n = 0, o = e.length, s = o - 1; n < o; s = n++) (i = e[n]), (r = e[s]), (t += (r.x - i.x) * (i.y + r.y));
        return t;
      }
      function ft([e, t, i]) {
        const r = ne(t + 90),
          n = ne(i);
        return { x: e * Math.cos(r) * Math.sin(n), y: e * Math.sin(r) * Math.sin(n), z: e * Math.cos(n), azimuthal: t, polar: i };
      }
      function gt(e, t, i) {
        const r = Math.sqrt(e * e + t * t + i * i),
          n = r > 0 ? Math.acos(i / r) * Qr : 0;
        let o = e !== 0 || t !== 0 ? Math.atan2(-t, -e) * Qr + 90 : 0;
        return o < 0 && (o += 360), [r, o, n];
      }
      function ct() {
        return typeof WorkerGlobalScope < 'u' && typeof self < 'u' && self instanceof WorkerGlobalScope;
      }
      function Tt(e) {
        const t = {};
        if (
          (e.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (i, r, n, o) => {
            const s = n || o;
            return (t[r] = !s || s.toLowerCase()), '';
          }),
          t['max-age'])
        ) {
          const i = parseInt(t['max-age'], 10);
          isNaN(i) ? delete t['max-age'] : (t['max-age'] = i);
        }
        return t;
      }
      let Lt = null;
      function jt() {
        return !!U.document.fullscreenElement || !!U.document.webkitFullscreenElement;
      }
      function le(e) {
        try {
          const t = U[e];
          return t.setItem('_mapbox_test_', 1), t.removeItem('_mapbox_test_'), !0;
        } catch {
          return !1;
        }
      }
      function Ie(e, t) {
        return [e[4 * t], e[4 * t + 1], e[4 * t + 2], e[4 * t + 3]];
      }
      function ai(e, t, i) {
        (e[4 * t + 0] = i[0]), (e[4 * t + 1] = i[1]), (e[4 * t + 2] = i[2]), (e[4 * t + 3] = i[3]);
      }
      function ii(e, t) {
        return [Math.pow(e[0], 2.2) * t, Math.pow(e[1], 2.2) * t, Math.pow(e[2], 2.2) * t];
      }
      function bi(e) {
        return [Math.pow(e[0], 1 / 2.2), Math.pow(e[1], 1 / 2.2), Math.pow(e[2], 1 / 2.2)];
      }
      const Ye = 'mapbox-tiles';
      let er = 500,
        wi = 50,
        zi,
        Ar;
      function Hs() {
        try {
          return U.caches;
        } catch {}
      }
      function Ir() {
        Hs() && !zi && (zi = U.caches.open(Ye));
      }
      function Kn(e) {
        const t = e.indexOf('?');
        if (t < 0) return e;
        const i = (function (n) {
            const o = n.indexOf('?');
            return o > 0 ? n.slice(o + 1).split('&') : [];
          })(e),
          r = i.filter((n) => {
            const o = n.split('=');
            return o[0] === 'language' || o[0] === 'worldview';
          });
        return r.length ? `${e.slice(0, t)}?${r.join('&')}` : e.slice(0, t);
      }
      let To = 1 / 0;
      function Ws(e) {
        To++, To > wi && (e.getActor().send('enforceCacheSizeLimit', er), (To = 0));
      }
      const dt = { Unknown: 'Unknown', Style: 'Style', Source: 'Source', Tile: 'Tile', Glyphs: 'Glyphs', SpriteImage: 'SpriteImage', SpriteJSON: 'SpriteJSON', Image: 'Image', Model: 'Model' };
      typeof Object.freeze == 'function' && Object.freeze(dt);
      class mt extends Error {
        constructor(t, i, r) {
          i === 401 && Ei(r) && (t += ': you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes'), super(t), (this.status = i), (this.url = r);
        }
        toString() {
          return `${this.name}: ${this.message} (${this.status}): ${this.url}`;
        }
      }
      const bt = ct() ? () => self.worker && self.worker.referrer : () => (U.location.protocol === 'blob:' ? U.parent : U).location.href,
        St = function (e, t) {
          if (!(/^file:/.test((i = e.url)) || (/^file:/.test(bt()) && !/^\w+:/.test(i)))) {
            if (U.fetch && U.Request && U.AbortController && U.Request.prototype.hasOwnProperty('signal'))
              return (function (r, n) {
                const o = new U.AbortController(),
                  s = new U.Request(r.url, { method: r.method || 'GET', body: r.body, credentials: r.credentials, headers: r.headers, referrer: bt(), referrerPolicy: r.referrerPolicy, signal: o.signal });
                let a = !1,
                  l = !1;
                const c = (u = s.url).indexOf('sku=') > 0 && Ei(u);
                var u;
                r.type === 'json' && s.headers.set('Accept', 'application/json');
                const h = (f, p, _) => {
                    if (l) return;
                    if ((f && f.message !== 'SecurityError' && B(f.toString()), p && _)) return d(p);
                    const g = Date.now();
                    U.fetch(s)
                      .then((y) => {
                        if (y.ok) {
                          const v = c ? y.clone() : null;
                          return d(y, v, g);
                        }
                        return n(new mt(y.statusText, y.status, r.url));
                      })
                      .catch((y) => {
                        y.name !== 'AbortError' && n(new Error(`${y.message} ${r.url}`));
                      });
                  },
                  d = (f, p, _) => {
                    (r.type === 'arrayBuffer' ? f.arrayBuffer() : r.type === 'json' ? f.json() : f.text())
                      .then((g) => {
                        l ||
                          (p &&
                            _ &&
                            (function (y, v, w) {
                              if ((Ir(), !zi)) return;
                              const T = { status: v.status, statusText: v.statusText, headers: new U.Headers() };
                              v.headers.forEach((S, I) => T.headers.set(I, S));
                              const b = Tt(v.headers.get('Cache-Control') || '');
                              if (b['no-store']) return;
                              b['max-age'] && T.headers.set('Expires', new Date(w + 1e3 * b['max-age']).toUTCString());
                              const E = T.headers.get('Expires');
                              E &&
                                (new Date(E).getTime() - w < 42e4 ||
                                  (function (S, I) {
                                    if (Ar === void 0)
                                      try {
                                        new Response(new ReadableStream()), (Ar = !0);
                                      } catch {
                                        Ar = !1;
                                      }
                                    Ar ? I(S.body) : S.blob().then(I);
                                  })(v, (S) => {
                                    const I = new U.Response(S, T);
                                    Ir(), zi && zi.then((C) => C.put(Kn(y.url), I)).catch((C) => B(C.message));
                                  }));
                            })(s, p, _),
                          (a = !0),
                          n(null, g, f.headers.get('Cache-Control'), f.headers.get('Expires')));
                      })
                      .catch((g) => {
                        l || n(new Error(g.message));
                      });
                  };
                return (
                  c
                    ? (function (f, p) {
                        if ((Ir(), !zi)) return p(null);
                        const _ = Kn(f.url);
                        zi.then((g) => {
                          g.match(_)
                            .then((y) => {
                              const v = (function (w) {
                                if (!w) return !1;
                                const T = new Date(w.headers.get('Expires') || 0),
                                  b = Tt(w.headers.get('Cache-Control') || '');
                                return T > Date.now() && !b['no-cache'];
                              })(y);
                              g.delete(_), v && g.put(_, y.clone()), p(null, y, v);
                            })
                            .catch(p);
                        }).catch(p);
                      })(s, h)
                    : h(null, null),
                  {
                    cancel: () => {
                      (l = !0), a || o.abort();
                    },
                  }
                );
              })(e, t);
            if (ct() && self.worker && self.worker.actor) return self.worker.actor.send('getResource', e, t, void 0, !0);
          }
          var i;
          return (function (r, n) {
            const o = new U.XMLHttpRequest();
            o.open(r.method || 'GET', r.url, !0), r.type === 'arrayBuffer' && (o.responseType = 'arraybuffer');
            for (const s in r.headers) o.setRequestHeader(s, r.headers[s]);
            return (
              r.type === 'json' && ((o.responseType = 'text'), o.setRequestHeader('Accept', 'application/json')),
              (o.withCredentials = r.credentials === 'include'),
              (o.onerror = () => {
                n(new Error(o.statusText));
              }),
              (o.onload = () => {
                if (((o.status >= 200 && o.status < 300) || o.status === 0) && o.response !== null) {
                  let s = o.response;
                  if (r.type === 'json')
                    try {
                      s = JSON.parse(o.response);
                    } catch (a) {
                      return n(a);
                    }
                  n(null, s, o.getResponseHeader('Cache-Control'), o.getResponseHeader('Expires'));
                } else n(new mt(o.statusText, o.status, r.url));
              }),
              o.send(r.body),
              { cancel: () => o.abort() }
            );
          })(e, t);
        },
        At = function (e, t) {
          return St(Ft(e, { type: 'json' }), t);
        },
        Dt = function (e, t) {
          return St(Ft(e, { type: 'arrayBuffer' }), t);
        };
      function kt(e) {
        const t = U.document.createElement('a');
        return (t.href = e), t.protocol === U.document.location.protocol && t.host === U.document.location.host;
      }
      const It = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=';
      let qt, Rt;
      (qt = []), (Rt = 0);
      const de = function (e, t) {
          if ((_e.supported && (e.headers || (e.headers = {}), (e.headers.accept = 'image/webp,*/*')), Rt >= Mt.MAX_PARALLEL_IMAGE_REQUESTS)) {
            const o = {
              requestParameters: e,
              callback: t,
              cancelled: !1,
              cancel() {
                this.cancelled = !0;
              },
            };
            return qt.push(o), o;
          }
          Rt++;
          let i = !1;
          const r = () => {
              if (!i)
                for (i = !0, Rt--; qt.length && Rt < Mt.MAX_PARALLEL_IMAGE_REQUESTS; ) {
                  const o = qt.shift(),
                    { requestParameters: s, callback: a, cancelled: l } = o;
                  l || (o.cancel = de(s, a).cancel);
                }
            },
            n = Dt(e, (o, s, a, l) => {
              r(),
                o
                  ? t(o)
                  : s &&
                    (U.createImageBitmap
                      ? (function (c, u) {
                          const h = new U.Blob([new Uint8Array(c)], { type: 'image/png' });
                          U.createImageBitmap(h)
                            .then((d) => {
                              u(null, d);
                            })
                            .catch((d) => {
                              u(new Error(`Could not load image because of ${d.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
                            });
                        })(s, (c, u) => t(c, u, a, l))
                      : (function (c, u) {
                          const h = new U.Image(),
                            d = U.URL;
                          (h.onload = () => {
                            u(null, h),
                              d.revokeObjectURL(h.src),
                              (h.onload = null),
                              U.requestAnimationFrame(() => {
                                h.src = It;
                              });
                          }),
                            (h.onerror = () => u(new Error('Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.')));
                          const f = new U.Blob([new Uint8Array(c)], { type: 'image/png' });
                          h.src = c.byteLength ? d.createObjectURL(f) : It;
                        })(s, (c, u) => t(c, u, a, l)));
            });
          return {
            cancel: () => {
              n.cancel(), r();
            },
          };
        },
        Ke = 'NO_ACCESS_TOKEN';
      class Yt {
        constructor(t, i, r) {
          (this._transformRequestFn = t), (this._customAccessToken = i), (this._silenceAuthErrors = !!r), this._createSkuToken();
        }
        _createSkuToken() {
          const t = (function () {
            let i = '';
            for (let r = 0; r < 10; r++) i += '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'[Math.floor(62 * Math.random())];
            return { token: ['1', Ue, i].join(''), tokenExpiresAt: Date.now() + 432e5 };
          })();
          (this._skuToken = t.token), (this._skuTokenExpiresAt = t.tokenExpiresAt);
        }
        _isSkuTokenExpired() {
          return Date.now() > this._skuTokenExpiresAt;
        }
        transformRequest(t, i) {
          return (this._transformRequestFn && this._transformRequestFn(t, i)) || { url: t };
        }
        normalizeStyleURL(t, i) {
          if (!Ze(t)) return t;
          const r = Wi(t);
          return r.params.push(`sdk=js-${Et}`), (r.path = `/styles/v1${r.path}`), this._makeAPIURL(r, this._customAccessToken || i);
        }
        normalizeGlyphsURL(t, i) {
          if (!Ze(t)) return t;
          const r = Wi(t);
          return (r.path = `/fonts/v1${r.path}`), this._makeAPIURL(r, this._customAccessToken || i);
        }
        normalizeModelURL(t, i) {
          if (!Ze(t)) return t;
          const r = Wi(t);
          return (r.path = `/models/v1${r.path}`), this._makeAPIURL(r, this._customAccessToken || i);
        }
        normalizeSourceURL(t, i, r, n) {
          if (!Ze(t)) return t;
          const o = Wi(t);
          return (o.path = `/v4/${o.authority}.json`), o.params.push('secure'), r && o.params.push(`language=${r}`), n && o.params.push(`worldview=${n}`), this._makeAPIURL(o, this._customAccessToken || i);
        }
        normalizeSpriteURL(t, i, r, n) {
          const o = Wi(t);
          return Ze(t) ? ((o.path = `/styles/v1${o.path}/sprite${i}${r}`), this._makeAPIURL(o, this._customAccessToken || n)) : ((o.path += `${i}${r}`), xr(o));
        }
        normalizeTileURL(t, i, r) {
          if ((this._isSkuTokenExpired() && this._createSkuToken(), t && !Ze(t))) return t;
          const n = Wi(t);
          (n.path = n.path.replace(/(\.(png|jpg)\d*)(?=$)/, `${i || (r && n.authority !== 'raster' && r === 512) ? '@2x' : ''}${_e.supported ? '.webp' : '$1'}`)), n.authority === 'raster' ? (n.path = `/${Mt.RASTER_URL_PREFIX}${n.path}`) : ((n.path = n.path.replace(/^.+\/v4\//, '/')), (n.path = `/${Mt.TILE_URL_VERSION}${n.path}`));
          const o =
            this._customAccessToken ||
            (function (s) {
              for (const a of s) {
                const l = a.match(/^access_token=(.*)$/);
                if (l) return l[1];
              }
              return null;
            })(n.params) ||
            Mt.ACCESS_TOKEN;
          return Mt.REQUIRE_ACCESS_TOKEN && o && this._skuToken && n.params.push(`sku=${this._skuToken}`), this._makeAPIURL(n, o);
        }
        canonicalizeTileURL(t, i) {
          const r = Wi(t);
          if (!r.path.match(/^(\/v4\/|\/raster\/v1\/)/) || !r.path.match(/\.[\w]+$/)) return t;
          let n = 'mapbox://';
          r.path.match(/^\/raster\/v1\//) ? (n += `raster/${r.path.replace(`/${Mt.RASTER_URL_PREFIX}/`, '')}`) : (n += `tiles/${r.path.replace(`/${Mt.TILE_URL_VERSION}/`, '')}`);
          let o = r.params;
          return i && (o = o.filter((s) => !s.match(/^access_token=/))), o.length && (n += `?${o.join('&')}`), n;
        }
        canonicalizeTileset(t, i) {
          const r = !!i && Ze(i),
            n = [];
          for (const o of t.tiles || []) Ei(o) ? n.push(this.canonicalizeTileURL(o, r)) : n.push(o);
          return n;
        }
        _makeAPIURL(t, i) {
          const r = 'See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes',
            n = Wi(Mt.API_URL);
          if (((t.protocol = n.protocol), (t.authority = n.authority), t.protocol === 'http')) {
            const o = t.params.indexOf('secure');
            o >= 0 && t.params.splice(o, 1);
          }
          if ((n.path !== '/' && (t.path = `${n.path}${t.path}`), !Mt.REQUIRE_ACCESS_TOKEN)) return xr(t);
          if (((i = i || Mt.ACCESS_TOKEN), !this._silenceAuthErrors)) {
            if (!i) throw new Error(`An API access token is required to use Mapbox GL. ${r}`);
            if (i[0] === 's') throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${r}`);
          }
          return (t.params = t.params.filter((o) => o.indexOf('access_token') === -1)), t.params.push(`access_token=${i || ''}`), xr(t);
        }
      }
      function Ze(e) {
        return e.indexOf('mapbox:') === 0;
      }
      function Ei(e) {
        return Mt.API_URL_REGEX.test(e);
      }
      function Di(e) {
        return Mt.API_CDN_URL_REGEX.test(e);
      }
      function ji(e) {
        return Mt.API_STYLE_REGEX.test(e) && !dr(e);
      }
      function dr(e) {
        return Mt.API_SPRITE_REGEX.test(e);
      }
      const rn = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
      function Wi(e) {
        const t = e.match(rn);
        if (!t) throw new Error('Unable to parse URL object');
        return { protocol: t[1], authority: t[2], path: t[3] || '/', params: t[4] ? t[4].split('&') : [] };
      }
      function xr(e) {
        const t = e.params.length ? `?${e.params.join('&')}` : '';
        return `${e.protocol}://${e.authority}${e.path}${t}`;
      }
      const fr = 'mapbox.eventData';
      function Xs(e) {
        if (!e) return null;
        const t = e.split('.');
        if (!t || t.length !== 3) return null;
        try {
          return JSON.parse(
            decodeURIComponent(
              U.atob(t[1])
                .split('')
                .map((i) => '%' + ('00' + i.charCodeAt(0).toString(16)).slice(-2))
                .join('')
            )
          );
        } catch {
          return null;
        }
      }
      class Eo {
        constructor(t) {
          (this.type = t), (this.anonId = null), (this.eventData = {}), (this.queue = []), (this.pendingRequest = null);
        }
        getStorageKey(t) {
          const i = Xs(Mt.ACCESS_TOKEN);
          let r = '';
          return (r = i && i.u ? U.btoa(encodeURIComponent(i.u).replace(/%([0-9A-F]{2})/g, (n, o) => String.fromCharCode(+('0x' + o)))) : Mt.ACCESS_TOKEN || ''), t ? `${fr}.${t}:${r}` : `${fr}:${r}`;
        }
        fetchEventData() {
          const t = le('localStorage'),
            i = this.getStorageKey(),
            r = this.getStorageKey('uuid');
          if (t)
            try {
              const n = U.localStorage.getItem(i);
              n && (this.eventData = JSON.parse(n));
              const o = U.localStorage.getItem(r);
              o && (this.anonId = o);
            } catch {
              B('Unable to read from LocalStorage');
            }
        }
        saveEventData() {
          const t = le('localStorage'),
            i = this.getStorageKey(),
            r = this.getStorageKey('uuid');
          if (t)
            try {
              U.localStorage.setItem(r, this.anonId), Object.keys(this.eventData).length >= 1 && U.localStorage.setItem(i, JSON.stringify(this.eventData));
            } catch {
              B('Unable to write to LocalStorage');
            }
        }
        processRequests(t) {}
        postEvent(t, i, r, n) {
          if (!Mt.EVENTS_URL) return;
          const o = Wi(Mt.EVENTS_URL);
          o.params.push(`access_token=${n || Mt.ACCESS_TOKEN || ''}`);
          const s = { event: this.type, created: new Date(t).toISOString() },
            a = i ? Ft(s, i) : s,
            l = { url: xr(o), headers: { 'Content-Type': 'text/plain' }, body: JSON.stringify([a]) };
          this.pendingRequest = (function (c, u) {
            return St(Ft(c, { method: 'POST' }), u);
          })(l, (c) => {
            (this.pendingRequest = null), r(c), this.saveEventData(), this.processRequests(n);
          });
        }
        queueRequest(t, i) {
          this.queue.push(t), this.processRequests(i);
        }
      }
      const Ys = new (class extends Eo {
          constructor(e) {
            super('appUserTurnstile'), (this._customAccessToken = e);
          }
          postTurnstileEvent(e, t) {
            Mt.EVENTS_URL && Mt.ACCESS_TOKEN && Array.isArray(e) && e.some((i) => Ze(i) || Ei(i)) && this.queueRequest(Date.now(), t);
          }
          processRequests(e) {
            if (this.pendingRequest || this.queue.length === 0) return;
            (this.anonId && this.eventData.lastSuccess && this.eventData.tokenU) || this.fetchEventData();
            const t = Xs(Mt.ACCESS_TOKEN),
              i = t ? t.u : Mt.ACCESS_TOKEN;
            let r = i !== this.eventData.tokenU;
            Y(this.anonId) || ((this.anonId = bo()), (r = !0));
            const n = this.queue.shift();
            if (this.eventData.lastSuccess) {
              const o = new Date(this.eventData.lastSuccess),
                s = new Date(n),
                a = (n - this.eventData.lastSuccess) / 864e5;
              r = r || a >= 1 || a < -1 || o.getDate() !== s.getDate();
            } else r = !0;
            r
              ? this.postEvent(
                  n,
                  { sdkIdentifier: 'mapbox-gl-js', sdkVersion: Et, skuId: Ue, 'enabled.telemetry': !1, userId: this.anonId },
                  (o) => {
                    o || ((this.eventData.lastSuccess = n), (this.eventData.tokenU = i));
                  },
                  e
                )
              : this.processRequests();
          }
        })(),
        ld = Ys.postTurnstileEvent.bind(Ys),
        L_ = new (class extends Eo {
          constructor() {
            super('map.load'), (this.success = {}), (this.skuToken = '');
          }
          postMapLoadEvent(e, t, i, r) {
            (this.skuToken = t), (this.errorCb = r), Mt.EVENTS_URL && (i || Mt.ACCESS_TOKEN ? this.queueRequest({ id: e, timestamp: Date.now() }, i) : this.errorCb(new Error(Ke)));
          }
          processRequests(e) {
            if (this.pendingRequest || this.queue.length === 0) return;
            const { id: t, timestamp: i } = this.queue.shift();
            (t && this.success[t]) ||
              (this.anonId || this.fetchEventData(),
              Y(this.anonId) || (this.anonId = bo()),
              this.postEvent(
                i,
                { sdkIdentifier: 'mapbox-gl-js', sdkVersion: Et, skuId: Ue, skuToken: this.skuToken, userId: this.anonId },
                (r) => {
                  r ? this.errorCb(r) : t && (this.success[t] = !0);
                },
                e
              ));
          }
        })(),
        mE = L_.postMapLoadEvent.bind(L_),
        k_ = new (class extends Eo {
          constructor() {
            super('gljs.performance');
          }
          postPerformanceEvent(e, t) {
            Mt.EVENTS_URL && (e || Mt.ACCESS_TOKEN) && this.queueRequest({ timestamp: Date.now(), performanceData: t }, e);
          }
          processRequests(e) {
            if (this.pendingRequest || this.queue.length === 0) return;
            const { timestamp: t, performanceData: i } = this.queue.shift(),
              r = (function (n) {
                const o = U.performance.getEntriesByType('resource'),
                  s = U.performance.getEntriesByType('mark'),
                  a = (function (d) {
                    const f = {};
                    if (d) {
                      for (const p in d)
                        if (p !== 'other')
                          for (const _ of d[p]) {
                            const g = `${p}ResolveRangeMin`,
                              y = `${p}ResolveRangeMax`,
                              v = `${p}RequestCount`,
                              w = `${p}RequestCachedCount`;
                            (f[g] = Math.min(f[g] || 1 / 0, _.startTime)), (f[y] = Math.max(f[y] || -1 / 0, _.responseEnd));
                            const T = (b) => {
                              f[b] === void 0 && (f[b] = 0), ++f[b];
                            };
                            _.transferSize !== void 0 && _.transferSize === 0 && T(w), T(v);
                          }
                    }
                    return f;
                  })(
                    (function (d, f) {
                      const p = {};
                      if (d)
                        for (const _ of d) {
                          const g = f(_);
                          p[g] === void 0 && (p[g] = []), p[g].push(_);
                        }
                      return p;
                    })(o, yE)
                  ),
                  l = U.devicePixelRatio,
                  c = U.navigator.connection || U.navigator.mozConnection || U.navigator.webkitConnection,
                  u = { counters: [], metadata: [], attributes: [] },
                  h = (d, f, p) => {
                    p != null && d.push({ name: f, value: p.toString() });
                  };
                for (const d in a) h(u.counters, d, a[d]);
                if ((n.interactionRange[0] !== 1 / 0 && n.interactionRange[1] !== -1 / 0 && (h(u.counters, 'interactionRangeMin', n.interactionRange[0]), h(u.counters, 'interactionRangeMax', n.interactionRange[1])), s))
                  for (const d of Object.keys(vc)) {
                    const f = vc[d],
                      p = s.find((_) => _.name === f);
                    p && h(u.counters, f, p.startTime);
                  }
                return (
                  h(u.counters, 'visibilityHidden', n.visibilityHidden),
                  h(
                    u.attributes,
                    'style',
                    (function (d) {
                      if (d)
                        for (const f of d) {
                          const p = f.name.split('?')[0];
                          if (ji(p)) {
                            const _ = p.split('/').slice(-2);
                            if (_.length === 2) return `mapbox://styles/${_[0]}/${_[1]}`;
                          }
                        }
                    })(o)
                  ),
                  h(u.attributes, 'terrainEnabled', n.terrainEnabled ? 'true' : 'false'),
                  h(u.attributes, 'fogEnabled', n.fogEnabled ? 'true' : 'false'),
                  h(u.attributes, 'projection', n.projection),
                  h(u.attributes, 'zoom', n.zoom),
                  h(u.metadata, 'devicePixelRatio', l),
                  h(u.metadata, 'connectionEffectiveType', c ? c.effectiveType : void 0),
                  h(u.metadata, 'navigatorUserAgent', U.navigator.userAgent),
                  h(u.metadata, 'screenWidth', U.screen.width),
                  h(u.metadata, 'screenHeight', U.screen.height),
                  h(u.metadata, 'windowWidth', U.innerWidth),
                  h(u.metadata, 'windowHeight', U.innerHeight),
                  h(u.metadata, 'mapWidth', n.width / l),
                  h(u.metadata, 'mapHeight', n.height / l),
                  h(u.metadata, 'webglRenderer', n.renderer),
                  h(u.metadata, 'webglVendor', n.vendor),
                  h(u.metadata, 'sdkVersion', Et),
                  h(u.metadata, 'sdkIdentifier', 'mapbox-gl-js'),
                  u
                );
              })(i);
            for (const n of r.metadata);
            for (const n of r.counters);
            for (const n of r.attributes);
            this.postEvent(t, r, () => {}, e);
          }
        })(),
        _E = k_.postPerformanceEvent.bind(k_),
        O_ = new (class extends Eo {
          constructor() {
            super('map.auth'), (this.success = {}), (this.skuToken = '');
          }
          getSession(e, t, i, r) {
            if (!Mt.API_URL || !Mt.SESSION_PATH) return;
            const n = Wi(Mt.API_URL + Mt.SESSION_PATH);
            n.params.push(`sku=${t || ''}`), n.params.push(`access_token=${r || Mt.ACCESS_TOKEN || ''}`);
            const o = { url: xr(n), headers: { 'Content-Type': 'text/plain' } };
            this.pendingRequest = (function (s, a) {
              return St(Ft(s, { method: 'GET' }), a);
            })(o, (s) => {
              (this.pendingRequest = null), i(s), this.saveEventData(), this.processRequests(r);
            });
          }
          getSessionAPI(e, t, i, r) {
            (this.skuToken = t), (this.errorCb = r), Mt.SESSION_PATH && Mt.API_URL && (i || Mt.ACCESS_TOKEN ? this.queueRequest({ id: e, timestamp: Date.now() }, i) : this.errorCb(new Error(Ke)));
          }
          processRequests(e) {
            if (this.pendingRequest || this.queue.length === 0) return;
            const { id: t, timestamp: i } = this.queue.shift();
            (t && this.success[t]) ||
              this.getSession(
                i,
                this.skuToken,
                (r) => {
                  r ? this.errorCb(r) : t && (this.success[t] = !0);
                },
                e
              );
          }
        })(),
        gE = O_.getSessionAPI.bind(O_),
        xc = new Set();
      function B_(e, t) {
        t ? xc.add(e) : xc.delete(e);
      }
      const vc = { create: 'create', load: 'load', fullLoad: 'fullLoad' },
        F_ = {
          mark(e) {
            U.performance.mark(e);
          },
          measure(e, t, i) {
            U.performance.measure(e, t, i);
          },
        };
      function yE(e) {
        const t = e.name.split('?')[0];
        return Di(t) && t.includes('mapbox-gl.js')
          ? 'javascript'
          : Di(t) && t.includes('mapbox-gl.css')
          ? 'css'
          : (function (i) {
              return Mt.API_FONTS_REGEX.test(i);
            })(t)
          ? 'fontRange'
          : dr(t)
          ? 'sprite'
          : ji(t)
          ? 'style'
          : (function (i) {
              return Mt.API_TILEJSON_REGEX.test(i);
            })(t)
          ? 'tilejson'
          : 'other';
      }
      const xE = U.performance;
      function N_(e) {
        const t = e ? e.url.toString() : void 0;
        return xE.getEntriesByName(t);
      }
      var U_ = cd;
      function cd(e) {
        return !(function (t) {
          return typeof window > 'u' || typeof document > 'u'
            ? 'not a browser'
            : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray
            ? Function.prototype && Function.prototype.bind
              ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions
                ? 'JSON' in window && 'parse' in JSON && 'stringify' in JSON
                  ? (function () {
                      if (!('Worker' in window && 'Blob' in window && 'URL' in window)) return !1;
                      var r,
                        n,
                        o = new Blob([''], { type: 'text/javascript' }),
                        s = URL.createObjectURL(o);
                      try {
                        (n = new Worker(s)), (r = !0);
                      } catch {
                        r = !1;
                      }
                      return n && n.terminate(), URL.revokeObjectURL(s), r;
                    })()
                    ? 'Uint8ClampedArray' in window
                      ? ArrayBuffer.isView
                        ? (function () {
                            var r = document.createElement('canvas');
                            r.width = r.height = 1;
                            var n = r.getContext('2d');
                            if (!n) return !1;
                            var o = n.getImageData(0, 0, 1, 1);
                            return o && o.width === r.width;
                          })()
                          ? (ud[(i = t && t.failIfMajorPerformanceCaveat)] === void 0 &&
                              (ud[i] = (function (r) {
                                var n,
                                  o = (function (s) {
                                    var a = document.createElement('canvas'),
                                      l = Object.create(cd.webGLContextAttributes);
                                    return (l.failIfMajorPerformanceCaveat = s), a.getContext('webgl', l) || a.getContext('experimental-webgl', l);
                                  })(r);
                                if (!o) return !1;
                                try {
                                  n = o.createShader(o.VERTEX_SHADER);
                                } catch {
                                  return !1;
                                }
                                return !(!n || o.isContextLost()) && (o.shaderSource(n, 'void main() {}'), o.compileShader(n), o.getShaderParameter(n, o.COMPILE_STATUS) === !0);
                              })(i)),
                            ud[i] ? (document.documentMode ? 'insufficient ECMAScript 6 support' : void 0) : 'insufficient WebGL support')
                          : 'insufficient Canvas/getImageData support'
                        : 'insufficient ArrayBuffer support'
                      : 'insufficient Uint8ClampedArray support'
                    : 'insufficient worker support'
                  : 'insufficient JSON support'
                : 'insufficient Object support'
              : 'insufficient Function support'
            : 'insufficent Array support';
          var i;
        })(e);
      }
      var ud = {};
      let hd, bc, dd, wc, as;
      function V_() {
        return hd == null && (hd = U.OffscreenCanvas && new U.OffscreenCanvas(1, 1).getContext('2d') && typeof U.createImageBitmap == 'function'), hd;
      }
      cd.webGLContextAttributes = { antialias: !1, alpha: !0, stencil: !0, depth: !0 };
      const oe = {
        now: () => (wc !== void 0 ? wc : U.performance.now()),
        setNow(e) {
          wc = e;
        },
        restoreNow() {
          wc = void 0;
        },
        frame(e) {
          const t = U.requestAnimationFrame(e);
          return { cancel: () => U.cancelAnimationFrame(t) };
        },
        getImageData(e, t = 0) {
          const { width: i, height: r } = e;
          as || (as = U.document.createElement('canvas'));
          const n = as.getContext('2d', { willReadFrequently: !0 });
          if (!n) throw new Error('failed to create canvas 2d context');
          return (i > as.width || r > as.height) && ((as.width = i), (as.height = r)), n.clearRect(-t, -t, i + 2 * t, r + 2 * t), n.drawImage(e, 0, 0, i, r), n.getImageData(-t, -t, i + 2 * t, r + 2 * t);
        },
        resolveURL: (e) => (bc || (bc = U.document.createElement('a')), (bc.href = e), bc.href),
        get devicePixelRatio() {
          return U.devicePixelRatio;
        },
        get prefersReducedMotion() {
          return !!U.matchMedia && (dd == null && (dd = U.matchMedia('(prefers-reduced-motion: reduce)')), dd.matches);
        },
        hasCanvasFingerprintNoise() {
          if (!V_()) return !1;
          const e = new U.OffscreenCanvas(85, 1),
            t = e.getContext('2d', { willReadFrequently: !0 });
          let i = 0;
          for (let n = 0; n < e.width; ++n) (t.fillStyle = `rgba(${i++},${i++},${i++}, 255)`), t.fillRect(n, 0, 1, 1);
          const r = t.getImageData(0, 0, e.width, e.height);
          i = 0;
          for (let n = 0; n < r.data.length; ++n) if (n % 4 != 3 && i++ !== r.data[n]) return !0;
          return !1;
        },
      };
      function ri(e, t, i) {
        const r = U.document.createElement(e);
        return t !== void 0 && (r.className = t), i && i.appendChild(r), r;
      }
      function Jn(e, t, i) {
        const r = U.document.createElementNS('http://www.w3.org/2000/svg', e);
        for (const n of Object.keys(t)) r.setAttributeNS(null, n, t[n]);
        return i && i.appendChild(r), r;
      }
      const ls = U.document && U.document.documentElement.style,
        Ka = ls && ls.userSelect !== void 0 ? 'userSelect' : 'WebkitUserSelect';
      let j_;
      function G_() {
        ls && Ka && ((j_ = ls[Ka]), (ls[Ka] = 'none'));
      }
      function q_() {
        ls && Ka && (ls[Ka] = j_);
      }
      function fd(e) {
        e.preventDefault(), e.stopPropagation(), U.removeEventListener('click', fd, !0);
      }
      function pd() {
        U.addEventListener('click', fd, !0),
          U.setTimeout(() => {
            U.removeEventListener('click', fd, !0);
          }, 0);
      }
      function Ja(e, t) {
        const i = e.getBoundingClientRect();
        return $_(e, i, t);
      }
      function Tc(e, t) {
        const i = e.getBoundingClientRect(),
          r = [];
        for (let n = 0; n < t.length; n++) r.push($_(e, i, t[n]));
        return r;
      }
      function Z_(e) {
        return U.InstallTrigger !== void 0 && e.button === 2 && e.ctrlKey && U.navigator.platform.toUpperCase().indexOf('MAC') >= 0 ? 0 : e.button;
      }
      function $_(e, t, i) {
        const r = e.offsetWidth === t.width ? 1 : e.offsetWidth / t.width;
        return new H((i.clientX - t.left) * r, (i.clientY - t.top) * r);
      }
      function H_(e, t, i) {
        (i[e] && i[e].indexOf(t) !== -1) || ((i[e] = i[e] || []), i[e].push(t));
      }
      function md(e, t, i) {
        if (i && i[e]) {
          const r = i[e].indexOf(t);
          r !== -1 && i[e].splice(r, 1);
        }
      }
      class wt {
        constructor(t, i = {}) {
          Ft(this, i), (this.type = t);
        }
      }
      class re extends wt {
        constructor(t, i = {}) {
          super('error', Ft({ error: t }, i));
        }
      }
      class Oi {
        on(t, i) {
          return (this._listeners = this._listeners || {}), H_(t, i, this._listeners), this;
        }
        off(t, i) {
          return md(t, i, this._listeners), md(t, i, this._oneTimeListeners), this;
        }
        once(t, i) {
          return i ? ((this._oneTimeListeners = this._oneTimeListeners || {}), H_(t, i, this._oneTimeListeners), this) : new Promise((r) => this.once(t, r));
        }
        fire(t, i) {
          typeof t == 'string' && (t = new wt(t, i || {}));
          const r = t.type;
          if (this.listens(r)) {
            t.target = this;
            const n = this._listeners && this._listeners[r] ? this._listeners[r].slice() : [];
            for (const a of n) a.call(this, t);
            const o = this._oneTimeListeners && this._oneTimeListeners[r] ? this._oneTimeListeners[r].slice() : [];
            for (const a of o) md(r, a, this._oneTimeListeners), a.call(this, t);
            const s = this._eventedParent;
            s && (Ft(t, typeof this._eventedParentData == 'function' ? this._eventedParentData() : this._eventedParentData), s.fire(t));
          } else t instanceof re && console.error(t.error);
          return this;
        }
        listens(t) {
          return !!((this._listeners && this._listeners[t] && this._listeners[t].length > 0) || (this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0) || (this._eventedParent && this._eventedParent.listens(t)));
        }
        setEventedParent(t, i) {
          return (this._eventedParent = t), (this._eventedParentData = i), this;
        }
      }
      var Q = JSON.parse(
        '{"$version":8,"$root":{"version":{"required":true,"type":"enum","values":[8]},"fragment":{"type":"boolean"},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360},"pitch":{"type":"number","default":0},"light":{"type":"light"},"lights":{"required":false,"type":"array","value":"light-3d"},"terrain":{"type":"terrain","optional":true},"fog":{"type":"fog"},"camera":{"type":"camera"},"imports":{"type":"array","value":"import"},"schema":{"type":"schema"},"sources":{"required":true,"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string","default":"mapbox://fonts/mapbox/{fontstack}/{range}.pbf"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"required":true,"type":"array","value":"layer"},"models":{"type":"models"}},"model":{"type":"string","required":true},"import":{"id":{"type":"string","required":true},"url":{"type":"string","required":true},"config":{"type":"config"},"data":{"type":"$root"}},"config":{"*":{"type":"*"}},"schema":{"*":{"type":"option"}},"option":{"default":{"type":"*","required":true},"type":{"type":"enum","values":{"string":1,"number":1,"boolean":1,"color":1}},"array":{"type":"boolean"},"minValue":{"type":"number"},"maxValue":{"type":"number"},"stepValue":{"type":"number"},"values":{"type":"array","value":"*"},"metadata":{"type":"*"}},"models":{"*":{"type":"model"}},"light-3d":{"id":{"type":"string","required":true},"properties":{"type":"properties"},"type":{"type":"enum","values":{"ambient":{},"directional":{},"flat":{}}}},"properties":["properties_light_directional","properties_light_ambient","properties_light_flat"],"properties_light_directional":{"direction":{"type":"array","default":[210,30],"minimum":[0,0],"maximum":[360,90],"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"cast-shadows":{"type":"boolean","default":false,"expression":{},"property-type":"data-constant"},"shadow-intensity":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_ambient":{"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_flat":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"property-type":"data-constant","expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_raster_array","source_geojson","source_video","source_image","source_model"],"source_vector":{"type":{"required":true,"type":"enum","values":{"vector":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"required":true,"type":"enum","values":{"raster":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"required":true,"type":"enum","values":{"raster-dem":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":1,"mapbox":1},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_array":{"type":{"required":true,"type":"enum","values":{"raster-array":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"rasterLayers":{"type":"*"},"*":{"type":"*"}},"source_geojson":{"type":{"required":true,"type":"enum","values":{"geojson":1}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"}},"source_video":{"type":{"required":true,"type":"enum","values":{"video":1}},"urls":{"required":true,"type":"array","value":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"required":true,"type":"enum","values":{"image":1}},"url":{"required":false,"type":"string"},"coordinates":{"required":true,"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_model":{"type":{"required":true,"type":"enum","values":{"model":1,"batched-model":1}},"maxzoom":{"type":"number","default":18},"minzoom":{"type":"number","default":0},"tiles":{"type":"array","value":"string"}},"layer":{"id":{"type":"string","required":true},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"raster":{},"hillshade":{},"model":{},"background":{},"sky":{},"slot":{}},"required":true},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"slot":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_symbol","layout_raster","layout_hillshade","layout_background","layout_sky","layout_model"],"layout_background":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_model":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"model-id":{"type":"string","default":"","property-type":"data-driven","expression":{"parameters":["zoom","feature"]}}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"},"fill-extrusion-edge-radius":{"type":"number","private":true,"default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"constant"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":1,"round":1,"square":1},"default":"butt","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":1,"round":1,"miter":1},"default":"miter","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-round-limit":{"type":"number","default":1.05,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":1,"line":1,"line-center":1},"default":"point","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-spacing":{"type":"number","default":250,"minimum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":1,"viewport-y":1,"source":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"symbol-z-elevate":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-size":{"type":"number","default":1,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit":{"type":"enum","values":{"none":1,"width":1,"height":1,"both":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-keep-upright":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-width":{"type":"number","default":10,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":1,"left":1,"center":1,"right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","default":0,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":1,"vertical":1},"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-rotate":{"type":"number","default":0,"period":360,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-keep-upright":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-transform":{"type":"enum","values":{"none":1,"uppercase":1,"lowercase":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","length":2,"default":[0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"text-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{},"property-type":"constant"}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":1,"!=":1,">":1,">=":1,"<":1,"<=":1,"in":1,"!in":1,"all":1,"any":1,"none":1,"has":1,"!has":1}},"geometry_type":{"type":"enum","values":{"Point":1,"LineString":1,"Polygon":1}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":1,"exponential":1,"interval":1,"categorical":1},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":1,"lab":1,"hcl":1},"default":"rgb"},"default":{"type":"*","required":false}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"high-color":{"type":"color","property-type":"data-constant","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"space-color":{"type":"color","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"horizon-blend":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"star-intensity":{"type":"number","property-type":"data-constant","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vertical-range":{"type":"array","default":[0,0],"minimum":0,"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}}},"camera":{"camera-projection":{"type":"enum","values":{"perspective":1,"orthographic":1},"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"default":"perspective","property-type":"data-constant"}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"property-type":"data-constant","expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","property-type":"data-constant","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","property-type":"data-constant","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":1,"equalEarth":1,"equirectangular":1,"lambertConformalConic":1,"mercator":1,"naturalEarth":1,"winkelTripel":1,"globe":1},"default":"mercator","required":true},"center":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-180,-90],"maximum":[180,90]},"parallels":{"type":"array","length":2,"value":"number","property-type":"data-constant","minimum":[-90,-90],"maximum":[90,90]}},"terrain":{"source":{"type":"string","required":true},"exaggeration":{"type":"number","property-type":"data-constant","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_symbol","paint_raster","paint_hillshade","paint_background","paint_sky","paint_model"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"fill-extrusion-ambient-occlusion-intensity":{"property-type":"data-constant","type":"number","private":true,"default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"property-type":"data-constant","type":"number","private":true,"default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-wall-radius":{"property-type":"data-constant","type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-radius":{"property-type":"data-constant","type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-attenuation":{"property-type":"data-constant","type":"number","default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-flood-light-color":{"property-type":"data-constant","type":"color","default":"#ffffff","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-intensity":{"property-type":"data-constant","type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-wall-radius":{"property-type":"data-driven","type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-radius":{"property-type":"data-driven","type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-attenuation":{"property-type":"data-constant","type":"number","default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-vertical-scale":{"property-type":"data-constant","type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-rounded-roof":{"property-type":"data-constant","type":"boolean","default":true,"expression":{"parameters":["zoom"]}},"fill-extrusion-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"},"fill-extrusion-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"line-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-gradient":{"type":"color","expression":{"interpolated":true,"parameters":["line-progress"]},"property-type":"color-ramp"},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"property-type":"constant"},"line-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"line-border-width":{"type":"number","private":true,"default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-border-color":{"type":"color","private":true,"default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"circle-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-scale":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"expression":{"interpolated":true,"parameters":["heatmap-density"]},"property-type":"color-ramp"},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-driven"},"text-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"icon-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-image-cross-fade":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"transition":true},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","transition":true,"overridable":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"text-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"icon-color-saturation":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{},"property-type":"data-constant"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-color":{"type":"color","expression":{"interpolated":true,"parameters":["raster-value"]},"property-type":"color-ramp"},"raster-color-mix":{"type":"array","default":[0.2126,0.7152,0.0722,0],"length":4,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-color-range":{"type":"array","default":[0,1],"length":2,"value":"number","property-type":"data-constant","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-resampling":{"type":"enum","values":{"linear":1,"nearest":1},"default":"linear","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"raster-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"raster-array-band":{"type":"string","required":false,"property-type":"data-constant"},"raster-elevation":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-illumination-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"hillshade-shadow-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-accent-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"},"hillshade-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_background":{"background-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"background-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"property-type":"data-constant"}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":1,"atmosphere":1},"default":"atmosphere","expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-atmosphere-sun-intensity":{"type":"number","default":10,"minimum":0,"maximum":100,"property-type":"data-constant"},"sky-gradient-center":{"type":"array","value":"number","default":[0,0],"length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient-radius":{"type":"number","default":90,"minimum":0,"maximum":180,"expression":{"parameters":["zoom"]},"property-type":"data-constant"},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"expression":{"interpolated":true,"parameters":["sky-radial-progress"]},"property-type":"color-ramp"},"sky-atmosphere-halo-color":{"type":"color","default":"white","property-type":"data-constant"},"sky-atmosphere-color":{"type":"color","default":"white","property-type":"data-constant"},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"}},"paint_model":{"model-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant"},"model-rotation":{"type":"array","value":"number","length":3,"default":[0,0,0],"period":360,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-scale":{"type":"array","value":"number","length":3,"default":[1,1,1],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-translation":{"type":"array","value":"number","length":3,"default":[0,0,0],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-color":{"type":"color","default":"#ffffff","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light","zoom"]},"transition":true},"model-color-mix-intensity":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-type":{"type":"enum","values":{"common-3d":1,"location-indicator":1},"default":"common-3d","property-type":"data-constant"},"model-cast-shadows":{"type":"boolean","default":true,"expression":{},"property-type":"data-constant"},"model-receive-shadows":{"type":"boolean","default":true,"expression":{},"property-type":"data-constant"},"model-ambient-occlusion-intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"property-type":"data-constant","transition":true},"model-emissive-strength":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":5,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-roughness":{"type":"number","default":1,"minimum":0,"maximum":1,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state"]},"transition":true},"model-height-based-emissive-strength-multiplier":{"type":"array","default":[1,1,1,1,0],"length":5,"value":"number","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{},"property-type":"data-constant"}},"transition":{"duration":{"type":"number","default":300,"minimum":0},"delay":{"type":"number","default":0,"minimum":0}},"property-type":{"data-driven":{"type":"property-type"},"color-ramp":{"type":"property-type"},"data-constant":{"type":"property-type"},"constant":{"type":"property-type"}},"promoteId":{"*":{"type":"string"}}}'
      );
      class Vt {
        constructor(t, i, r, n) {
          (this.message = (t ? `${t}: ` : '') + r), n && (this.identifier = n), i != null && i.__line__ && (this.line = i.__line__);
        }
      }
      class cs extends Vt {}
      function Qn(e, ...t) {
        for (const i of t) for (const r in i) e[r] = i[r];
        return e;
      }
      function Gi(e) {
        return e instanceof Number || e instanceof String || e instanceof Boolean ? e.valueOf() : e;
      }
      function to(e) {
        if (Array.isArray(e)) return e.map(to);
        if (e instanceof Object && !(e instanceof Number || e instanceof String || e instanceof Boolean)) {
          const t = {};
          for (const i in e) t[i] = to(e[i]);
          return t;
        }
        return Gi(e);
      }
      class vE extends Error {
        constructor(t, i) {
          super(i), (this.message = i), (this.key = t);
        }
      }
      var Pn = vE;
      class _d {
        constructor(t, i = []) {
          (this.parent = t), (this.bindings = {});
          for (const [r, n] of i) this.bindings[r] = n;
        }
        concat(t) {
          return new _d(this, t);
        }
        get(t) {
          if (this.bindings[t]) return this.bindings[t];
          if (this.parent) return this.parent.get(t);
          throw new Error(`${t} not found in scope.`);
        }
        has(t) {
          return !!this.bindings[t] || (!!this.parent && this.parent.has(t));
        }
      }
      var bE = _d;
      const Ks = { kind: 'null' },
        Nt = { kind: 'number' },
        Re = { kind: 'string' },
        Fe = { kind: 'boolean' },
        nn = { kind: 'color' },
        Js = { kind: 'object' },
        ke = { kind: 'value' },
        Ec = { kind: 'collator' },
        Qa = { kind: 'formatted' },
        tl = { kind: 'resolvedImage' };
      function Cr(e, t) {
        return { kind: 'array', itemType: e, N: t };
      }
      function Bi(e) {
        if (e.kind === 'array') {
          const t = Bi(e.itemType);
          return typeof e.N == 'number' ? `array<${t}, ${e.N}>` : e.itemType.kind === 'value' ? 'array' : `array<${t}>`;
        }
        return e.kind;
      }
      const wE = [Ks, Nt, Re, Fe, nn, Qa, Js, Cr(ke), tl];
      function el(e, t) {
        if (t.kind === 'error') return null;
        if (e.kind === 'array') {
          if (t.kind === 'array' && ((t.N === 0 && t.itemType.kind === 'value') || !el(e.itemType, t.itemType)) && (typeof e.N != 'number' || e.N === t.N)) return null;
        } else {
          if (e.kind === t.kind) return null;
          if (e.kind === 'value') {
            for (const i of wE) if (!el(i, t)) return null;
          }
        }
        return `Expected ${Bi(e)} but found ${Bi(t)} instead.`;
      }
      function gd(e, t) {
        return t.some((i) => i.kind === e.kind);
      }
      function il(e, t) {
        return t.some((i) => (i === 'null' ? e === null : i === 'array' ? Array.isArray(e) : i === 'object' ? e && !Array.isArray(e) && typeof e == 'object' : i === typeof e));
      }
      var yd,
        W_ = {
          transparent: [0, 0, 0, 0],
          aliceblue: [240, 248, 255, 1],
          antiquewhite: [250, 235, 215, 1],
          aqua: [0, 255, 255, 1],
          aquamarine: [127, 255, 212, 1],
          azure: [240, 255, 255, 1],
          beige: [245, 245, 220, 1],
          bisque: [255, 228, 196, 1],
          black: [0, 0, 0, 1],
          blanchedalmond: [255, 235, 205, 1],
          blue: [0, 0, 255, 1],
          blueviolet: [138, 43, 226, 1],
          brown: [165, 42, 42, 1],
          burlywood: [222, 184, 135, 1],
          cadetblue: [95, 158, 160, 1],
          chartreuse: [127, 255, 0, 1],
          chocolate: [210, 105, 30, 1],
          coral: [255, 127, 80, 1],
          cornflowerblue: [100, 149, 237, 1],
          cornsilk: [255, 248, 220, 1],
          crimson: [220, 20, 60, 1],
          cyan: [0, 255, 255, 1],
          darkblue: [0, 0, 139, 1],
          darkcyan: [0, 139, 139, 1],
          darkgoldenrod: [184, 134, 11, 1],
          darkgray: [169, 169, 169, 1],
          darkgreen: [0, 100, 0, 1],
          darkgrey: [169, 169, 169, 1],
          darkkhaki: [189, 183, 107, 1],
          darkmagenta: [139, 0, 139, 1],
          darkolivegreen: [85, 107, 47, 1],
          darkorange: [255, 140, 0, 1],
          darkorchid: [153, 50, 204, 1],
          darkred: [139, 0, 0, 1],
          darksalmon: [233, 150, 122, 1],
          darkseagreen: [143, 188, 143, 1],
          darkslateblue: [72, 61, 139, 1],
          darkslategray: [47, 79, 79, 1],
          darkslategrey: [47, 79, 79, 1],
          darkturquoise: [0, 206, 209, 1],
          darkviolet: [148, 0, 211, 1],
          deeppink: [255, 20, 147, 1],
          deepskyblue: [0, 191, 255, 1],
          dimgray: [105, 105, 105, 1],
          dimgrey: [105, 105, 105, 1],
          dodgerblue: [30, 144, 255, 1],
          firebrick: [178, 34, 34, 1],
          floralwhite: [255, 250, 240, 1],
          forestgreen: [34, 139, 34, 1],
          fuchsia: [255, 0, 255, 1],
          gainsboro: [220, 220, 220, 1],
          ghostwhite: [248, 248, 255, 1],
          gold: [255, 215, 0, 1],
          goldenrod: [218, 165, 32, 1],
          gray: [128, 128, 128, 1],
          green: [0, 128, 0, 1],
          greenyellow: [173, 255, 47, 1],
          grey: [128, 128, 128, 1],
          honeydew: [240, 255, 240, 1],
          hotpink: [255, 105, 180, 1],
          indianred: [205, 92, 92, 1],
          indigo: [75, 0, 130, 1],
          ivory: [255, 255, 240, 1],
          khaki: [240, 230, 140, 1],
          lavender: [230, 230, 250, 1],
          lavenderblush: [255, 240, 245, 1],
          lawngreen: [124, 252, 0, 1],
          lemonchiffon: [255, 250, 205, 1],
          lightblue: [173, 216, 230, 1],
          lightcoral: [240, 128, 128, 1],
          lightcyan: [224, 255, 255, 1],
          lightgoldenrodyellow: [250, 250, 210, 1],
          lightgray: [211, 211, 211, 1],
          lightgreen: [144, 238, 144, 1],
          lightgrey: [211, 211, 211, 1],
          lightpink: [255, 182, 193, 1],
          lightsalmon: [255, 160, 122, 1],
          lightseagreen: [32, 178, 170, 1],
          lightskyblue: [135, 206, 250, 1],
          lightslategray: [119, 136, 153, 1],
          lightslategrey: [119, 136, 153, 1],
          lightsteelblue: [176, 196, 222, 1],
          lightyellow: [255, 255, 224, 1],
          lime: [0, 255, 0, 1],
          limegreen: [50, 205, 50, 1],
          linen: [250, 240, 230, 1],
          magenta: [255, 0, 255, 1],
          maroon: [128, 0, 0, 1],
          mediumaquamarine: [102, 205, 170, 1],
          mediumblue: [0, 0, 205, 1],
          mediumorchid: [186, 85, 211, 1],
          mediumpurple: [147, 112, 219, 1],
          mediumseagreen: [60, 179, 113, 1],
          mediumslateblue: [123, 104, 238, 1],
          mediumspringgreen: [0, 250, 154, 1],
          mediumturquoise: [72, 209, 204, 1],
          mediumvioletred: [199, 21, 133, 1],
          midnightblue: [25, 25, 112, 1],
          mintcream: [245, 255, 250, 1],
          mistyrose: [255, 228, 225, 1],
          moccasin: [255, 228, 181, 1],
          navajowhite: [255, 222, 173, 1],
          navy: [0, 0, 128, 1],
          oldlace: [253, 245, 230, 1],
          olive: [128, 128, 0, 1],
          olivedrab: [107, 142, 35, 1],
          orange: [255, 165, 0, 1],
          orangered: [255, 69, 0, 1],
          orchid: [218, 112, 214, 1],
          palegoldenrod: [238, 232, 170, 1],
          palegreen: [152, 251, 152, 1],
          paleturquoise: [175, 238, 238, 1],
          palevioletred: [219, 112, 147, 1],
          papayawhip: [255, 239, 213, 1],
          peachpuff: [255, 218, 185, 1],
          peru: [205, 133, 63, 1],
          pink: [255, 192, 203, 1],
          plum: [221, 160, 221, 1],
          powderblue: [176, 224, 230, 1],
          purple: [128, 0, 128, 1],
          rebeccapurple: [102, 51, 153, 1],
          red: [255, 0, 0, 1],
          rosybrown: [188, 143, 143, 1],
          royalblue: [65, 105, 225, 1],
          saddlebrown: [139, 69, 19, 1],
          salmon: [250, 128, 114, 1],
          sandybrown: [244, 164, 96, 1],
          seagreen: [46, 139, 87, 1],
          seashell: [255, 245, 238, 1],
          sienna: [160, 82, 45, 1],
          silver: [192, 192, 192, 1],
          skyblue: [135, 206, 235, 1],
          slateblue: [106, 90, 205, 1],
          slategray: [112, 128, 144, 1],
          slategrey: [112, 128, 144, 1],
          snow: [255, 250, 250, 1],
          springgreen: [0, 255, 127, 1],
          steelblue: [70, 130, 180, 1],
          tan: [210, 180, 140, 1],
          teal: [0, 128, 128, 1],
          thistle: [216, 191, 216, 1],
          tomato: [255, 99, 71, 1],
          turquoise: [64, 224, 208, 1],
          violet: [238, 130, 238, 1],
          wheat: [245, 222, 179, 1],
          white: [255, 255, 255, 1],
          whitesmoke: [245, 245, 245, 1],
          yellow: [255, 255, 0, 1],
          yellowgreen: [154, 205, 50, 1],
        };
      function Mc(e) {
        return (e = Math.round(e)) < 0 ? 0 : e > 255 ? 255 : e;
      }
      function xd(e) {
        return Mc(e[e.length - 1] === '%' ? (parseFloat(e) / 100) * 255 : parseInt(e));
      }
      function Sc(e) {
        return (t = e[e.length - 1] === '%' ? parseFloat(e) / 100 : parseFloat(e)) < 0 ? 0 : t > 1 ? 1 : t;
        var t;
      }
      function vd(e, t, i) {
        return i < 0 ? (i += 1) : i > 1 && (i -= 1), 6 * i < 1 ? e + (t - e) * i * 6 : 2 * i < 1 ? t : 3 * i < 2 ? e + (t - e) * (2 / 3 - i) * 6 : e;
      }
      try {
        yd = {}.parseCSSColor = function (e) {
          var t,
            i = e.replace(/ /g, '').toLowerCase();
          if (i in W_) return W_[i].slice();
          if (i[0] === '#') return i.length === 4 ? ((t = parseInt(i.substr(1), 16)) >= 0 && t <= 4095 ? [((3840 & t) >> 4) | ((3840 & t) >> 8), (240 & t) | ((240 & t) >> 4), (15 & t) | ((15 & t) << 4), 1] : null) : i.length === 7 && (t = parseInt(i.substr(1), 16)) >= 0 && t <= 16777215 ? [(16711680 & t) >> 16, (65280 & t) >> 8, 255 & t, 1] : null;
          var r = i.indexOf('('),
            n = i.indexOf(')');
          if (r !== -1 && n + 1 === i.length) {
            var o = i.substr(0, r),
              s = i.substr(r + 1, n - (r + 1)).split(','),
              a = 1;
            switch (o) {
              case 'rgba':
                if (s.length !== 4) return null;
                a = Sc(s.pop());
              case 'rgb':
                return s.length !== 3 ? null : [xd(s[0]), xd(s[1]), xd(s[2]), a];
              case 'hsla':
                if (s.length !== 4) return null;
                a = Sc(s.pop());
              case 'hsl':
                if (s.length !== 3) return null;
                var l = (((parseFloat(s[0]) % 360) + 360) % 360) / 360,
                  c = Sc(s[1]),
                  u = Sc(s[2]),
                  h = u <= 0.5 ? u * (c + 1) : u + c - u * c,
                  d = 2 * u - h;
                return [Mc(255 * vd(d, h, l + 1 / 3)), Mc(255 * vd(d, h, l)), Mc(255 * vd(d, h, l - 1 / 3)), a];
              default:
                return null;
            }
          }
          return null;
        };
      } catch {}
      class Pr {
        constructor(t, i, r, n = 1) {
          (this.r = t), (this.g = i), (this.b = r), (this.a = n);
        }
        static parse(t) {
          if (!t) return;
          if (t instanceof Pr) return t;
          if (typeof t != 'string') return;
          const i = yd(t);
          return i ? new Pr((i[0] / 255) * i[3], (i[1] / 255) * i[3], (i[2] / 255) * i[3], i[3]) : void 0;
        }
        toString() {
          const [t, i, r, n] = this.toArray();
          return `rgba(${Math.round(t)},${Math.round(i)},${Math.round(r)},${n})`;
        }
        toArray() {
          const { r: t, g: i, b: r, a: n } = this;
          return n === 0 ? [0, 0, 0, 0] : [(255 * t) / n, (255 * i) / n, (255 * r) / n, n];
        }
        toArray01() {
          const { r: t, g: i, b: r, a: n } = this;
          return n === 0 ? [0, 0, 0, 0] : [t / n, i / n, r / n, n];
        }
        toArray01Scaled(t) {
          const { r: i, g: r, b: n, a: o } = this;
          return o === 0 ? [0, 0, 0] : [(i / o) * t, (r / o) * t, (n / o) * t];
        }
        toArray01PremultipliedAlpha() {
          const { r: t, g: i, b: r, a: n } = this;
          return [t, i, r, n];
        }
        toArray01Linear() {
          const { r: t, g: i, b: r, a: n } = this;
          return n === 0 ? [0, 0, 0, 0] : [Math.pow(t / n, 2.2), Math.pow(i / n, 2.2), Math.pow(r / n, 2.2), n];
        }
      }
      (Pr.black = new Pr(0, 0, 0, 1)), (Pr.white = new Pr(1, 1, 1, 1)), (Pr.transparent = new Pr(0, 0, 0, 0)), (Pr.red = new Pr(1, 0, 0, 1)), (Pr.blue = new Pr(0, 0, 1, 1));
      var pe = Pr;
      class bd {
        constructor(t, i, r) {
          (this.sensitivity = t ? (i ? 'variant' : 'case') : i ? 'accent' : 'base'), (this.locale = r), (this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: 'search' }));
        }
        compare(t, i) {
          return this.collator.compare(t, i);
        }
        resolvedLocale() {
          return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
        }
      }
      class wd {
        constructor(t, i, r, n, o) {
          (this.text = t.normalize ? t.normalize() : t), (this.image = i), (this.scale = r), (this.fontStack = n), (this.textColor = o);
        }
      }
      class zr {
        constructor(t) {
          this.sections = t;
        }
        static fromString(t) {
          return new zr([new wd(t, null, null, null, null)]);
        }
        isEmpty() {
          return this.sections.length === 0 || !this.sections.some((t) => t.text.length !== 0 || (t.image && t.image.namePrimary.length !== 0));
        }
        static factory(t) {
          return t instanceof zr ? t : zr.fromString(t);
        }
        toString() {
          return this.sections.length === 0 ? '' : this.sections.map((t) => t.text).join('');
        }
        serialize() {
          const t = ['format'];
          for (const i of this.sections) {
            if (i.image) {
              t.push(['image', i.image.namePrimary]);
              continue;
            }
            t.push(i.text);
            const r = {};
            i.fontStack && (r['text-font'] = ['literal', i.fontStack.split(',')]), i.scale && (r['font-scale'] = i.scale), i.textColor && (r['text-color'] = ['rgba'].concat(i.textColor.toArray())), t.push(r);
          }
          return t;
        }
      }
      class on {
        constructor(t) {
          (this.namePrimary = t.namePrimary), t.nameSecondary && (this.nameSecondary = t.nameSecondary), (this.available = t.available);
        }
        toString() {
          return this.nameSecondary ? `[${this.namePrimary},${this.nameSecondary}]` : this.namePrimary;
        }
        static fromString(t, i) {
          return t ? new on({ namePrimary: t, nameSecondary: i, available: !1 }) : null;
        }
        serialize() {
          return this.nameSecondary ? ['image', this.namePrimary, this.nameSecondary] : ['image', this.namePrimary];
        }
      }
      function X_(e, t, i, r) {
        return typeof e == 'number' && e >= 0 && e <= 255 && typeof t == 'number' && t >= 0 && t <= 255 && typeof i == 'number' && i >= 0 && i <= 255 ? (r === void 0 || (typeof r == 'number' && r >= 0 && r <= 1) ? null : `Invalid rgba value [${[e, t, i, r].join(', ')}]: 'a' must be between 0 and 1.`) : `Invalid rgba value [${(typeof r == 'number' ? [e, t, i, r] : [e, t, i]).join(', ')}]: 'r', 'g', and 'b' must be between 0 and 255.`;
      }
      function Qs(e) {
        if (e === null || typeof e == 'string' || typeof e == 'boolean' || typeof e == 'number' || e instanceof pe || e instanceof bd || e instanceof zr || e instanceof on) return !0;
        if (Array.isArray(e)) {
          for (const t of e) if (!Qs(t)) return !1;
          return !0;
        }
        if (typeof e == 'object') {
          for (const t in e) if (!Qs(e[t])) return !1;
          return !0;
        }
        return !1;
      }
      function Xi(e) {
        if (e === null) return Ks;
        if (typeof e == 'string') return Re;
        if (typeof e == 'boolean') return Fe;
        if (typeof e == 'number') return Nt;
        if (e instanceof pe) return nn;
        if (e instanceof bd) return Ec;
        if (e instanceof zr) return Qa;
        if (e instanceof on) return tl;
        if (Array.isArray(e)) {
          const t = e.length;
          let i;
          for (const r of e) {
            const n = Xi(r);
            if (i) {
              if (i === n) continue;
              i = ke;
              break;
            }
            i = n;
          }
          return Cr(i || ke, t);
        }
        return Js;
      }
      function rl(e) {
        const t = typeof e;
        return e === null ? '' : t === 'string' || t === 'number' || t === 'boolean' ? String(e) : e instanceof pe || e instanceof zr || e instanceof on ? e.toString() : JSON.stringify(e);
      }
      class Td {
        constructor(t, i) {
          (this.type = t), (this.value = i);
        }
        static parse(t, i) {
          if (t.length !== 2) return i.error(`'literal' expression requires exactly one argument, but found ${t.length - 1} instead.`);
          if (!Qs(t[1])) return i.error('invalid value');
          const r = t[1];
          let n = Xi(r);
          const o = i.expectedType;
          return n.kind !== 'array' || n.N !== 0 || !o || o.kind !== 'array' || (typeof o.N == 'number' && o.N !== 0) || (n = o), new Td(n, r);
        }
        evaluate() {
          return this.value;
        }
        eachChild() {}
        outputDefined() {
          return !0;
        }
        serialize() {
          return this.type.kind === 'array' || this.type.kind === 'object' ? ['literal', this.value] : this.value instanceof pe ? ['rgba'].concat(this.value.toArray()) : this.value instanceof zr ? this.value.serialize() : this.value;
        }
      }
      var nl = Td,
        ir = class {
          constructor(e) {
            (this.name = 'ExpressionEvaluationError'), (this.message = e);
          }
          toJSON() {
            return this.message;
          }
        };
      const Ed = { string: Re, number: Nt, boolean: Fe, object: Js };
      class Md {
        constructor(t, i) {
          (this.type = t), (this.args = i);
        }
        static parse(t, i) {
          if (t.length < 2) return i.error('Expected at least one argument.');
          let r,
            n = 1;
          const o = t[0];
          if (o === 'array') {
            let a, l;
            if (t.length > 2) {
              const c = t[1];
              if (typeof c != 'string' || !(c in Ed) || c === 'object') return i.error('The item type argument of "array" must be one of string, number, boolean', 1);
              (a = Ed[c]), n++;
            } else a = ke;
            if (t.length > 3) {
              if (t[2] !== null && (typeof t[2] != 'number' || t[2] < 0 || t[2] !== Math.floor(t[2]))) return i.error('The length argument to "array" must be a positive integer literal', 2);
              (l = t[2]), n++;
            }
            r = Cr(a, l);
          } else r = Ed[o];
          const s = [];
          for (; n < t.length; n++) {
            const a = i.parse(t[n], n, ke);
            if (!a) return null;
            s.push(a);
          }
          return new Md(r, s);
        }
        evaluate(t) {
          for (let i = 0; i < this.args.length; i++) {
            const r = this.args[i].evaluate(t);
            if (!el(this.type, Xi(r))) return r;
            if (i === this.args.length - 1) throw new ir(`Expected value to be of type ${Bi(this.type)}, but found ${Bi(Xi(r))} instead.`);
          }
          return null;
        }
        eachChild(t) {
          this.args.forEach(t);
        }
        outputDefined() {
          return this.args.every((t) => t.outputDefined());
        }
        serialize() {
          const t = this.type,
            i = [t.kind];
          if (t.kind === 'array') {
            const r = t.itemType;
            if (r.kind === 'string' || r.kind === 'number' || r.kind === 'boolean') {
              i.push(r.kind);
              const n = t.N;
              (typeof n == 'number' || this.args.length > 1) && i.push(n);
            }
          }
          return i.concat(this.args.map((r) => r.serialize()));
        }
      }
      var eo = Md;
      class ol {
        constructor(t) {
          (this.type = Qa), (this.sections = t);
        }
        static parse(t, i) {
          if (t.length < 2) return i.error('Expected at least one argument.');
          const r = t[1];
          if (!Array.isArray(r) && typeof r == 'object') return i.error('First argument must be an image or text section.');
          const n = [];
          let o = !1;
          for (let s = 1; s <= t.length - 1; ++s) {
            const a = t[s];
            if (o && typeof a == 'object' && !Array.isArray(a)) {
              o = !1;
              let l = null;
              if (a['font-scale'] && ((l = i.parse(a['font-scale'], 1, Nt)), !l)) return null;
              let c = null;
              if (a['text-font'] && ((c = i.parse(a['text-font'], 1, Cr(Re))), !c)) return null;
              let u = null;
              if (a['text-color'] && ((u = i.parse(a['text-color'], 1, nn)), !u)) return null;
              const h = n[n.length - 1];
              (h.scale = l), (h.font = c), (h.textColor = u);
            } else {
              const l = i.parse(t[s], 1, ke);
              if (!l) return null;
              const c = l.type.kind;
              if (c !== 'string' && c !== 'value' && c !== 'null' && c !== 'resolvedImage') return i.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
              (o = !0), n.push({ content: l, scale: null, font: null, textColor: null });
            }
          }
          return new ol(n);
        }
        evaluate(t) {
          return new zr(
            this.sections.map((i) => {
              const r = i.content.evaluate(t);
              return Xi(r) === tl ? new wd('', r, null, null, null) : new wd(rl(r), null, i.scale ? i.scale.evaluate(t) : null, i.font ? i.font.evaluate(t).join(',') : null, i.textColor ? i.textColor.evaluate(t) : null);
            })
          );
        }
        eachChild(t) {
          for (const i of this.sections) t(i.content), i.scale && t(i.scale), i.font && t(i.font), i.textColor && t(i.textColor);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          const t = ['format'];
          for (const i of this.sections) {
            t.push(i.content.serialize());
            const r = {};
            i.scale && (r['font-scale'] = i.scale.serialize()), i.font && (r['text-font'] = i.font.serialize()), i.textColor && (r['text-color'] = i.textColor.serialize()), t.push(r);
          }
          return t;
        }
      }
      class sl {
        constructor(t, i) {
          (this.type = tl), (this.inputPrimary = t), (this.inputSecondary = i);
        }
        static parse(t, i) {
          if (t.length < 2) return i.error('Expected two or more arguments.');
          const r = i.parse(t[1], 1, Re);
          if (!r) return i.error('No image name provided.');
          if (t.length === 2) return new sl(r);
          const n = i.parse(t[2], 1, Re);
          return n ? new sl(r, n) : i.error('Secondary image variant is not a string.');
        }
        evaluate(t) {
          const i = on.fromString(this.inputPrimary.evaluate(t), this.inputSecondary ? this.inputSecondary.evaluate(t) : void 0);
          return i && t.availableImages && ((i.available = t.availableImages.indexOf(i.namePrimary) > -1), i.nameSecondary && i.available && t.availableImages && (i.available = t.availableImages.indexOf(i.nameSecondary) > -1)), i;
        }
        eachChild(t) {
          t(this.inputPrimary), this.inputSecondary && t(this.inputSecondary);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          return this.inputSecondary ? ['image', this.inputPrimary.serialize(), this.inputSecondary.serialize()] : ['image', this.inputPrimary.serialize()];
        }
      }
      function $e(e) {
        return e instanceof Number ? 'number' : e instanceof String ? 'string' : e instanceof Boolean ? 'boolean' : Array.isArray(e) ? 'array' : e === null ? 'null' : typeof e;
      }
      const TE = { 'to-boolean': Fe, 'to-color': nn, 'to-number': Nt, 'to-string': Re };
      class Sd {
        constructor(t, i) {
          (this.type = t), (this.args = i);
        }
        static parse(t, i) {
          if (t.length < 2) return i.error('Expected at least one argument.');
          const r = t[0],
            n = [];
          let o = Ks;
          if (r === 'to-array') {
            if (!Array.isArray(t[1])) return null;
            const s = t[1].length;
            if (i.expectedType) {
              if (i.expectedType.kind !== 'array') return i.error(`Expected ${i.expectedType.kind} but found array.`);
              o = Cr(i.expectedType.itemType, s);
            } else {
              if (!(s > 0 && Qs(t[1][0]))) return null;
              o = Cr(Xi(t[1][0]), s);
            }
            for (let a = 0; a < s; a++) {
              const l = t[1][a];
              let c;
              if ($e(l) === 'array') c = i.parse(l, void 0, o.itemType);
              else {
                const u = $e(l);
                if (u !== o.itemType.kind) return i.error(`Expected ${o.itemType.kind} but found ${u}.`);
                c = i.registry.literal.parse(['literal', l === void 0 ? null : l], i);
              }
              if (!c) return null;
              n.push(c);
            }
          } else {
            if ((r === 'to-boolean' || r === 'to-string') && t.length !== 2) return i.error('Expected one argument.');
            o = TE[r];
            for (let s = 1; s < t.length; s++) {
              const a = i.parse(t[s], s, ke);
              if (!a) return null;
              n.push(a);
            }
          }
          return new Sd(o, n);
        }
        evaluate(t) {
          if (this.type.kind === 'boolean') return !!this.args[0].evaluate(t);
          if (this.type.kind === 'color') {
            let i, r;
            for (const n of this.args) {
              if (((i = n.evaluate(t)), (r = null), i instanceof pe)) return i;
              if (typeof i == 'string') {
                const o = t.parseColor(i);
                if (o) return o;
              } else if (Array.isArray(i) && ((r = i.length < 3 || i.length > 4 ? `Invalid rbga value ${JSON.stringify(i)}: expected an array containing either three or four numeric values.` : X_(i[0], i[1], i[2], i[3])), !r)) return new pe(i[0] / 255, i[1] / 255, i[2] / 255, i[3]);
            }
            throw new ir(r || `Could not parse color from value '${typeof i == 'string' ? i : String(JSON.stringify(i))}'`);
          }
          if (this.type.kind === 'number') {
            let i = null;
            for (const r of this.args) {
              if (((i = r.evaluate(t)), i === null)) return 0;
              const n = Number(i);
              if (!isNaN(n)) return n;
            }
            throw new ir(`Could not convert ${JSON.stringify(i)} to number.`);
          }
          return this.type.kind === 'formatted' ? zr.fromString(rl(this.args[0].evaluate(t))) : this.type.kind === 'resolvedImage' ? on.fromString(rl(this.args[0].evaluate(t))) : this.type.kind === 'array' ? this.args.map((i) => i.evaluate(t)) : rl(this.args[0].evaluate(t));
        }
        eachChild(t) {
          this.args.forEach(t);
        }
        outputDefined() {
          return this.args.every((t) => t.outputDefined());
        }
        serialize() {
          if (this.type.kind === 'formatted') return new ol([{ content: this.args[0], scale: null, font: null, textColor: null }]).serialize();
          if (this.type.kind === 'resolvedImage') return new sl(this.args[0]).serialize();
          const t = this.type.kind === 'array' ? [] : [`to-${this.type.kind}`];
          return (
            this.eachChild((i) => {
              t.push(i.serialize());
            }),
            t
          );
        }
      }
      var us = Sd;
      const EE = ['Unknown', 'Point', 'LineString', 'Polygon'];
      var Y_ = class {
        constructor(e) {
          (this.globals = null), (this.feature = null), (this.featureState = null), (this.formattedSection = null), (this._parseColorCache = {}), (this.availableImages = null), (this.canonical = null), (this.featureTileCoord = null), (this.featureDistanceData = null), (this.options = e);
        }
        id() {
          return this.feature && this.feature.id !== void 0 ? this.feature.id : null;
        }
        geometryType() {
          return this.feature ? (typeof this.feature.type == 'number' ? EE[this.feature.type] : this.feature.type) : null;
        }
        geometry() {
          return this.feature && 'geometry' in this.feature ? this.feature.geometry : null;
        }
        canonicalID() {
          return this.canonical;
        }
        properties() {
          return (this.feature && this.feature.properties) || {};
        }
        measureLight(e) {
          return this.globals.brightness || 0;
        }
        distanceFromCenter() {
          if (this.featureTileCoord && this.featureDistanceData) {
            const e = this.featureDistanceData.center,
              t = this.featureDistanceData.scale,
              { x: i, y: r } = this.featureTileCoord;
            return this.featureDistanceData.bearing[0] * (i * t - e[0]) + this.featureDistanceData.bearing[1] * (r * t - e[1]);
          }
          return 0;
        }
        parseColor(e) {
          let t = this._parseColorCache[e];
          return t || (t = this._parseColorCache[e] = pe.parse(e)), t;
        }
        getConfig(e) {
          return this.options ? this.options.get(e) : null;
        }
      };
      class hs {
        constructor(t, i, r, n, o) {
          (this.name = t), (this.type = i), (this._evaluate = r), (this.args = n), (this._overloadIndex = o);
        }
        evaluate(t) {
          if (!this._evaluate) {
            const i = hs.definitions[this.name];
            this._evaluate = Array.isArray(i) ? i[2] : i.overloads[this._overloadIndex][1];
          }
          return this._evaluate(t, this.args);
        }
        eachChild(t) {
          this.args.forEach(t);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          return [this.name].concat(this.args.map((t) => t.serialize()));
        }
        static parse(t, i) {
          const r = t[0],
            n = hs.definitions[r];
          if (!n) return i.error(`Unknown expression "${r}". If you wanted a literal array, use ["literal", [...]].`, 0);
          const o = Array.isArray(n) ? n[0] : n.type,
            s = Array.isArray(n) ? [[n[1], n[2]]] : n.overloads,
            a = [];
          let l = null,
            c = -1;
          for (const [u, h] of s) {
            if (Array.isArray(u) && u.length !== t.length - 1) continue;
            a.push(u), c++, (l = new fg(i.registry, i.path, null, i.scope, void 0, i.options));
            const d = [];
            let f = !1;
            for (let p = 1; p < t.length; p++) {
              const _ = t[p],
                g = Array.isArray(u) ? u[p - 1] : u.type,
                y = l.parse(_, 1 + d.length, g);
              if (!y) {
                f = !0;
                break;
              }
              d.push(y);
            }
            if (!f)
              if (Array.isArray(u) && u.length !== d.length) l.error(`Expected ${u.length} arguments, but found ${d.length} instead.`);
              else {
                for (let p = 0; p < d.length; p++) {
                  const _ = Array.isArray(u) ? u[p] : u.type,
                    g = d[p];
                  l.concat(p + 1).checkSubtype(_, g.type);
                }
                if (l.errors.length === 0) return new hs(r, o, h, d, c);
              }
          }
          if (a.length === 1) i.errors.push(...l.errors);
          else {
            const u = (a.length ? a : s.map(([d]) => d)).map(ME).join(' | '),
              h = [];
            for (let d = 1; d < t.length; d++) {
              const f = i.parse(t[d], 1 + h.length);
              if (!f) return null;
              h.push(Bi(f.type));
            }
            i.error(`Expected arguments of type ${u}, but found (${h.join(', ')}) instead.`);
          }
          return null;
        }
        static register(t, i) {
          hs.definitions = i;
          for (const r in i) t[r] = hs;
        }
      }
      function ME(e) {
        return Array.isArray(e) ? `(${e.map(Bi).join(', ')})` : `(${Bi(e.type)}...)`;
      }
      var zn = hs;
      class Ac {
        constructor(t, i, r) {
          (this.type = Ec), (this.locale = r), (this.caseSensitive = t), (this.diacriticSensitive = i);
        }
        static parse(t, i) {
          if (t.length !== 2) return i.error('Expected one argument.');
          const r = t[1];
          if (typeof r != 'object' || Array.isArray(r)) return i.error('Collator options argument must be an object.');
          const n = i.parse(r['case-sensitive'] !== void 0 && r['case-sensitive'], 1, Fe);
          if (!n) return null;
          const o = i.parse(r['diacritic-sensitive'] !== void 0 && r['diacritic-sensitive'], 1, Fe);
          if (!o) return null;
          let s = null;
          return r.locale && ((s = i.parse(r.locale, 1, Re)), !s) ? null : new Ac(n, o, s);
        }
        evaluate(t) {
          return new bd(this.caseSensitive.evaluate(t), this.diacriticSensitive.evaluate(t), this.locale ? this.locale.evaluate(t) : null);
        }
        eachChild(t) {
          t(this.caseSensitive), t(this.diacriticSensitive), this.locale && t(this.locale);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          const t = {};
          return (t['case-sensitive'] = this.caseSensitive.serialize()), (t['diacritic-sensitive'] = this.diacriticSensitive.serialize()), this.locale && (t.locale = this.locale.serialize()), ['collator', t];
        }
      }
      var K_ = { exports: {} };
      K_.exports = (function () {
        function e(r, n, o, s, a) {
          for (; s > o; ) {
            if (s - o > 600) {
              var l = s - o + 1,
                c = n - o + 1,
                u = Math.log(l),
                h = 0.5 * Math.exp((2 * u) / 3),
                d = 0.5 * Math.sqrt((u * h * (l - h)) / l) * (c - l / 2 < 0 ? -1 : 1);
              e(r, n, Math.max(o, Math.floor(n - (c * h) / l + d)), Math.min(s, Math.floor(n + ((l - c) * h) / l + d)), a);
            }
            var f = r[n],
              p = o,
              _ = s;
            for (t(r, o, n), a(r[s], f) > 0 && t(r, o, s); p < _; ) {
              for (t(r, p, _), p++, _--; a(r[p], f) < 0; ) p++;
              for (; a(r[_], f) > 0; ) _--;
            }
            a(r[o], f) === 0 ? t(r, o, _) : t(r, ++_, s), _ <= n && (o = _ + 1), n <= _ && (s = _ - 1);
          }
        }
        function t(r, n, o) {
          var s = r[n];
          (r[n] = r[o]), (r[o] = s);
        }
        function i(r, n) {
          return r < n ? -1 : r > n ? 1 : 0;
        }
        return function (r, n, o, s, a) {
          e(r, n, o || 0, s || r.length - 1, a || i);
        };
      })();
      var SE = ze(K_.exports);
      function AE(e) {
        let t = 0;
        for (let i, r, n = 0, o = e.length, s = o - 1; n < o; s = n++) (i = e[n]), (r = e[s]), (t += (r.x - i.x) * (i.y + r.y));
        return t;
      }
      function al(e, t) {
        (e[0] = Math.min(e[0], t[0])), (e[1] = Math.min(e[1], t[1])), (e[2] = Math.max(e[2], t[0])), (e[3] = Math.max(e[3], t[1]));
      }
      function ll(e, t) {
        return !(e[0] <= t[0] || e[2] >= t[2] || e[1] <= t[1] || e[3] >= t[3]);
      }
      function IE(e, t, i) {
        const r = e[0] - t[0],
          n = e[1] - t[1],
          o = e[0] - i[0],
          s = e[1] - i[1];
        return r * s - o * n == 0 && r * o <= 0 && n * s <= 0;
      }
      function ta(e, t, i = !1) {
        let r = !1;
        for (let a = 0, l = t.length; a < l; a++) {
          const c = t[a];
          for (let u = 0, h = c.length, d = h - 1; u < h; d = u++) {
            const f = c[d],
              p = c[u];
            if (IE(e, f, p)) return i;
            (o = f)[1] > (n = e)[1] != (s = p)[1] > n[1] && n[0] < ((s[0] - o[0]) * (n[1] - o[1])) / (s[1] - o[1]) + o[0] && (r = !r);
          }
        }
        var n, o, s;
        return r;
      }
      function J_(e, t, i, r) {
        const n = r[0] - i[0],
          o = r[1] - i[1],
          s = (e[0] - i[0]) * o - n * (e[1] - i[1]),
          a = (t[0] - i[0]) * o - n * (t[1] - i[1]);
        return (s > 0 && a < 0) || (s < 0 && a > 0);
      }
      function Ic(e, t, i, r) {
        return (n = [r[0] - i[0], r[1] - i[1]])[0] * (o = [t[0] - e[0], t[1] - e[1]])[1] - n[1] * o[0] != 0 && !(!J_(e, t, i, r) || !J_(i, r, e, t));
        var n, o;
      }
      const Mo = 8192;
      function CE(e, t) {
        const i = (180 + e[0]) / 360,
          r = (180 - (180 / Math.PI) * Math.log(Math.tan(Math.PI / 4 + (e[1] * Math.PI) / 360))) / 360,
          n = Math.pow(2, t.z);
        return [Math.round(i * n * Mo), Math.round(r * n * Mo)];
      }
      function PE(e, t) {
        for (let i = 0; i < t.length; i++) if (ta(e, t[i])) return !0;
        return !1;
      }
      function zE(e, t, i) {
        for (const r of i) for (let n = 0, o = r.length, s = o - 1; n < o; s = n++) if (Ic(e, t, r[s], r[n])) return !0;
        return !1;
      }
      function Q_(e, t) {
        for (let i = 0; i < e.length; ++i) if (!ta(e[i], t)) return !1;
        for (let i = 0; i < e.length - 1; ++i) if (zE(e[i], e[i + 1], t)) return !1;
        return !0;
      }
      function DE(e, t) {
        for (let i = 0; i < t.length; i++) if (Q_(e, t[i])) return !0;
        return !1;
      }
      function Ad(e, t, i) {
        const r = [];
        for (let n = 0; n < e.length; n++) {
          const o = [];
          for (let s = 0; s < e[n].length; s++) {
            const a = CE(e[n][s], i);
            al(t, a), o.push(a);
          }
          r.push(o);
        }
        return r;
      }
      function tg(e, t, i) {
        const r = [];
        for (let n = 0; n < e.length; n++) {
          const o = Ad(e[n], t, i);
          r.push(o);
        }
        return r;
      }
      function eg(e, t, i, r) {
        if (e[0] < i[0] || e[0] > i[2]) {
          const n = 0.5 * r;
          let o = e[0] - i[0] > n ? -r : i[0] - e[0] > n ? r : 0;
          o === 0 && (o = e[0] - i[2] > n ? -r : i[2] - e[0] > n ? r : 0), (e[0] += o);
        }
        al(t, e);
      }
      function ig(e, t, i, r) {
        const n = Math.pow(2, r.z) * Mo,
          o = [r.x * Mo, r.y * Mo],
          s = [];
        if (!e) return s;
        for (const a of e)
          for (const l of a) {
            const c = [l.x + o[0], l.y + o[1]];
            eg(c, t, i, n), s.push(c);
          }
        return s;
      }
      function rg(e, t, i, r) {
        const n = Math.pow(2, r.z) * Mo,
          o = [r.x * Mo, r.y * Mo],
          s = [];
        if (!e) return s;
        for (const l of e) {
          const c = [];
          for (const u of l) {
            const h = [u.x + o[0], u.y + o[1]];
            al(t, h), c.push(h);
          }
          s.push(c);
        }
        if (t[2] - t[0] <= n / 2) {
          ((a = t)[0] = a[1] = 1 / 0), (a[2] = a[3] = -1 / 0);
          for (const l of s) for (const c of l) eg(c, t, i, n);
        }
        var a;
        return s;
      }
      class cl {
        constructor(t, i) {
          (this.type = Fe), (this.geojson = t), (this.geometries = i);
        }
        static parse(t, i) {
          if (t.length !== 2) return i.error(`'within' expression requires exactly one argument, but found ${t.length - 1} instead.`);
          if (Qs(t[1])) {
            const r = t[1];
            if (r.type === 'FeatureCollection')
              for (let n = 0; n < r.features.length; ++n) {
                const o = r.features[n].geometry.type;
                if (o === 'Polygon' || o === 'MultiPolygon') return new cl(r, r.features[n].geometry);
              }
            else if (r.type === 'Feature') {
              const n = r.geometry.type;
              if (n === 'Polygon' || n === 'MultiPolygon') return new cl(r, r.geometry);
            } else if (r.type === 'Polygon' || r.type === 'MultiPolygon') return new cl(r, r);
          }
          return i.error("'within' expression requires valid geojson object that contains polygon geometry type.");
        }
        evaluate(t) {
          if (t.geometry() != null && t.canonicalID() != null) {
            if (t.geometryType() === 'Point')
              return (function (i, r) {
                const n = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  o = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  s = i.canonicalID();
                if (!s) return !1;
                if (r.type === 'Polygon') {
                  const a = Ad(r.coordinates, o, s),
                    l = ig(i.geometry(), n, o, s);
                  if (!ll(n, o)) return !1;
                  for (const c of l) if (!ta(c, a)) return !1;
                }
                if (r.type === 'MultiPolygon') {
                  const a = tg(r.coordinates, o, s),
                    l = ig(i.geometry(), n, o, s);
                  if (!ll(n, o)) return !1;
                  for (const c of l) if (!PE(c, a)) return !1;
                }
                return !0;
              })(t, this.geometries);
            if (t.geometryType() === 'LineString')
              return (function (i, r) {
                const n = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  o = [1 / 0, 1 / 0, -1 / 0, -1 / 0],
                  s = i.canonicalID();
                if (!s) return !1;
                if (r.type === 'Polygon') {
                  const a = Ad(r.coordinates, o, s),
                    l = rg(i.geometry(), n, o, s);
                  if (!ll(n, o)) return !1;
                  for (const c of l) if (!Q_(c, a)) return !1;
                }
                if (r.type === 'MultiPolygon') {
                  const a = tg(r.coordinates, o, s),
                    l = rg(i.geometry(), n, o, s);
                  if (!ll(n, o)) return !1;
                  for (const c of l) if (!DE(c, a)) return !1;
                }
                return !0;
              })(t, this.geometries);
          }
          return !1;
        }
        eachChild() {}
        outputDefined() {
          return !0;
        }
        serialize() {
          return ['within', this.geojson];
        }
      }
      var Id = cl,
        ng = { exports: {} };
      ng.exports = (function () {
        var e = { kilometers: 1, miles: 0.621371192237334, nauticalmiles: 0.5399568034557235, meters: 1e3, metres: 1e3, yards: 1093.6132983377079, feet: 3280.839895013123, inches: 39370.078740157485 },
          t = 1 / 298.257223563,
          i = t * (2 - t),
          r = Math.PI / 180,
          n = function (c, u) {
            if (c === void 0) throw new Error('No latitude given.');
            if (u && !e[u]) throw new Error('Unknown unit ' + u + '. Use one of: ' + Object.keys(e).join(', '));
            var h = 6378.137 * r * (u ? e[u] : 1),
              d = Math.cos(c * r),
              f = 1 / (1 - i * (1 - d * d)),
              p = Math.sqrt(f);
            (this.kx = h * p * d), (this.ky = h * p * f * (1 - i));
          },
          o = { units: { configurable: !0 } };
        function s(c, u) {
          return c[0] === u[0] && c[1] === u[1];
        }
        function a(c, u, h) {
          var d = l(u[0] - c[0]);
          return [c[0] + d * h, c[1] + (u[1] - c[1]) * h];
        }
        function l(c) {
          for (; c < -180; ) c += 360;
          for (; c > 180; ) c -= 360;
          return c;
        }
        return (
          (n.fromTile = function (c, u, h) {
            var d = Math.PI * (1 - (2 * (c + 0.5)) / Math.pow(2, u)),
              f = Math.atan(0.5 * (Math.exp(d) - Math.exp(-d))) / r;
            return new n(f, h);
          }),
          (o.units.get = function () {
            return e;
          }),
          (n.prototype.distance = function (c, u) {
            var h = l(c[0] - u[0]) * this.kx,
              d = (c[1] - u[1]) * this.ky;
            return Math.sqrt(h * h + d * d);
          }),
          (n.prototype.bearing = function (c, u) {
            var h = l(u[0] - c[0]) * this.kx;
            return Math.atan2(h, (u[1] - c[1]) * this.ky) / r;
          }),
          (n.prototype.destination = function (c, u, h) {
            var d = h * r;
            return this.offset(c, Math.sin(d) * u, Math.cos(d) * u);
          }),
          (n.prototype.offset = function (c, u, h) {
            return [c[0] + u / this.kx, c[1] + h / this.ky];
          }),
          (n.prototype.lineDistance = function (c) {
            for (var u = 0, h = 0; h < c.length - 1; h++) u += this.distance(c[h], c[h + 1]);
            return u;
          }),
          (n.prototype.area = function (c) {
            for (var u = 0, h = 0; h < c.length; h++) for (var d = c[h], f = 0, p = d.length, _ = p - 1; f < p; _ = f++) u += l(d[f][0] - d[_][0]) * (d[f][1] + d[_][1]) * (h ? -1 : 1);
            return (Math.abs(u) / 2) * this.kx * this.ky;
          }),
          (n.prototype.along = function (c, u) {
            var h = 0;
            if (u <= 0) return c[0];
            for (var d = 0; d < c.length - 1; d++) {
              var f = c[d],
                p = c[d + 1],
                _ = this.distance(f, p);
              if ((h += _) > u) return a(f, p, (u - (h - _)) / _);
            }
            return c[c.length - 1];
          }),
          (n.prototype.pointToSegmentDistance = function (c, u, h) {
            var d = u[0],
              f = u[1],
              p = l(h[0] - d) * this.kx,
              _ = (h[1] - f) * this.ky,
              g = 0;
            return (p === 0 && _ === 0) || ((g = (l(c[0] - d) * this.kx * p + (c[1] - f) * this.ky * _) / (p * p + _ * _)) > 1 ? ((d = h[0]), (f = h[1])) : g > 0 && ((d += (p / this.kx) * g), (f += (_ / this.ky) * g))), (p = l(c[0] - d) * this.kx), (_ = (c[1] - f) * this.ky), Math.sqrt(p * p + _ * _);
          }),
          (n.prototype.pointOnLine = function (c, u) {
            for (var h, d, f, p, _ = 1 / 0, g = 0; g < c.length - 1; g++) {
              var y = c[g][0],
                v = c[g][1],
                w = l(c[g + 1][0] - y) * this.kx,
                T = (c[g + 1][1] - v) * this.ky,
                b = 0;
              (w === 0 && T === 0) || ((b = (l(u[0] - y) * this.kx * w + (u[1] - v) * this.ky * T) / (w * w + T * T)) > 1 ? ((y = c[g + 1][0]), (v = c[g + 1][1])) : b > 0 && ((y += (w / this.kx) * b), (v += (T / this.ky) * b)));
              var E = (w = l(u[0] - y) * this.kx) * w + (T = (u[1] - v) * this.ky) * T;
              E < _ && ((_ = E), (h = y), (d = v), (f = g), (p = b));
            }
            return { point: [h, d], index: f, t: Math.max(0, Math.min(1, p)) };
          }),
          (n.prototype.lineSlice = function (c, u, h) {
            var d = this.pointOnLine(h, c),
              f = this.pointOnLine(h, u);
            if (d.index > f.index || (d.index === f.index && d.t > f.t)) {
              var p = d;
              (d = f), (f = p);
            }
            var _ = [d.point],
              g = d.index + 1,
              y = f.index;
            !s(h[g], _[0]) && g <= y && _.push(h[g]);
            for (var v = g + 1; v <= y; v++) _.push(h[v]);
            return s(h[y], f.point) || _.push(f.point), _;
          }),
          (n.prototype.lineSliceAlong = function (c, u, h) {
            for (var d = 0, f = [], p = 0; p < h.length - 1; p++) {
              var _ = h[p],
                g = h[p + 1],
                y = this.distance(_, g);
              if (((d += y) > c && f.length === 0 && f.push(a(_, g, (c - (d - y)) / y)), d >= u)) return f.push(a(_, g, (u - (d - y)) / y)), f;
              d > c && f.push(g);
            }
            return f;
          }),
          (n.prototype.bufferPoint = function (c, u) {
            var h = u / this.ky,
              d = u / this.kx;
            return [c[0] - d, c[1] - h, c[0] + d, c[1] + h];
          }),
          (n.prototype.bufferBBox = function (c, u) {
            var h = u / this.ky,
              d = u / this.kx;
            return [c[0] - d, c[1] - h, c[2] + d, c[3] + h];
          }),
          (n.prototype.insideBBox = function (c, u) {
            return l(c[0] - u[0]) >= 0 && l(c[0] - u[2]) <= 0 && c[1] >= u[1] && c[1] <= u[3];
          }),
          Object.defineProperties(n, o),
          n
        );
      })();
      var Cd = ze(ng.exports),
        og = { exports: {} };
      og.exports = (function () {
        var e = function (i, r) {
          if ((i === void 0 && (i = []), r === void 0 && (r = t), (this.data = i), (this.length = this.data.length), (this.compare = r), this.length > 0)) for (var n = (this.length >> 1) - 1; n >= 0; n--) this._down(n);
        };
        function t(i, r) {
          return i < r ? -1 : i > r ? 1 : 0;
        }
        return (
          (e.prototype.push = function (i) {
            this.data.push(i), this.length++, this._up(this.length - 1);
          }),
          (e.prototype.pop = function () {
            if (this.length !== 0) {
              var i = this.data[0],
                r = this.data.pop();
              return this.length--, this.length > 0 && ((this.data[0] = r), this._down(0)), i;
            }
          }),
          (e.prototype.peek = function () {
            return this.data[0];
          }),
          (e.prototype._up = function (i) {
            for (var r = this.data, n = this.compare, o = r[i]; i > 0; ) {
              var s = (i - 1) >> 1,
                a = r[s];
              if (n(o, a) >= 0) break;
              (r[i] = a), (i = s);
            }
            r[i] = o;
          }),
          (e.prototype._down = function (i) {
            for (var r = this.data, n = this.compare, o = this.length >> 1, s = r[i]; i < o; ) {
              var a = 1 + (i << 1),
                l = r[a],
                c = a + 1;
              if ((c < this.length && n(r[c], l) < 0 && ((a = c), (l = r[c])), n(l, s) >= 0)) break;
              (r[i] = l), (i = a);
            }
            r[i] = s;
          }),
          e
        );
      })();
      var Pd = ze(og.exports),
        lt = 8192;
      function sg(e, t) {
        return t.dist - e.dist;
      }
      const zd = 100,
        Dd = 50;
      function ag(e) {
        const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        if (t.length !== e.length) return !1;
        for (let i = 0; i < t.length; i++) if (t[i] !== e[i]) return !1;
        return !0;
      }
      function Cc(e) {
        return e[1] - e[0] + 1;
      }
      function io(e, t) {
        const i = e[1] >= e[0] && e[1] < t;
        return i || console.warn('Distance Expression: Index is out of range'), i;
      }
      function Rd(e, t) {
        if (e[0] > e[1]) return [null, null];
        const i = Cc(e);
        if (t) {
          if (i === 2) return [e, null];
          const r = Math.floor(i / 2);
          return [
            [e[0], e[0] + r],
            [e[0] + r, e[1]],
          ];
        }
        {
          if (i === 1) return [e, null];
          const r = Math.floor(i / 2) - 1;
          return [
            [e[0], e[0] + r],
            [e[0] + r + 1, e[1]],
          ];
        }
      }
      function ds(e, t) {
        const i = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        if (!io(t, e.length)) return i;
        for (let r = t[0]; r <= t[1]; ++r) al(i, e[r]);
        return i;
      }
      function Pc(e) {
        const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (let i = 0; i < e.length; ++i) for (let r = 0; r < e[i].length; ++r) al(t, e[i][r]);
        return t;
      }
      function ea(e, t, i) {
        if (ag(e) || ag(t)) return NaN;
        let r = 0,
          n = 0;
        return e[2] < t[0] && (r = t[0] - e[2]), e[0] > t[2] && (r = e[0] - t[2]), e[1] > t[3] && (n = e[1] - t[3]), e[3] < t[1] && (n = t[1] - e[3]), i.distance([0, 0], [r, n]);
      }
      function Ld(e, t) {
        const i = Math.pow(2, t.z);
        return [((n = (e.x / lt + t.x) / i), 360 * n - 180), ((r = (e.y / lt + t.y) / i), (360 / Math.PI) * Math.atan(Math.exp(((180 - 360 * r) * Math.PI) / 180)) - 90)];
        var r, n;
      }
      function RE(e, t) {
        const i = [];
        for (let r = 0; r < e.length; ++r) i.push(Ld(e[r], t));
        return i;
      }
      function lg(e, t, i) {
        const r = i.pointOnLine(t, e).point;
        return i.distance(e, r);
      }
      function cg(e, t, i, r, n) {
        const o = i.slice(r[0], r[1] + 1);
        let s = 1 / 0;
        for (let a = t[0]; a <= t[1]; ++a) if ((s = Math.min(s, lg(e[a], o, n))) === 0) return 0;
        return s;
      }
      function kd(e, t, i, r, n) {
        const o = Math.min(n.pointToSegmentDistance(e, i, r), n.pointToSegmentDistance(t, i, r)),
          s = Math.min(n.pointToSegmentDistance(i, e, t), n.pointToSegmentDistance(r, e, t));
        return Math.min(o, s);
      }
      function LE(e, t, i, r, n) {
        if (!io(t, e.length) || !io(r, i.length)) return NaN;
        let o = 1 / 0;
        for (let s = t[0]; s < t[1]; ++s)
          for (let a = r[0]; a < r[1]; ++a) {
            if (Ic(e[s], e[s + 1], i[a], i[a + 1])) return 0;
            o = Math.min(o, kd(e[s], e[s + 1], i[a], i[a + 1], n));
          }
        return o;
      }
      function kE(e, t, i, r, n) {
        if (!io(t, e.length) || !io(r, i.length)) return NaN;
        let o = 1 / 0;
        for (let s = t[0]; s <= t[1]; ++s) for (let a = r[0]; a <= r[1]; ++a) if ((o = Math.min(o, n.distance(e[s], i[a]))) === 0) return o;
        return o;
      }
      function OE(e, t, i) {
        if (ta(e, t, !0)) return 0;
        let r = 1 / 0;
        for (const n of t) {
          const o = n.length;
          if (o < 2) return console.warn('Distance Expression: Invalid polygon!'), NaN;
          if ((n[0] !== n[o - 1] && (r = Math.min(r, i.pointToSegmentDistance(e, n[o - 1], n[0]))) === 0) || (r = Math.min(r, lg(e, n, i))) === 0) return r;
        }
        return r;
      }
      function BE(e, t, i, r) {
        if (!io(t, e.length)) return NaN;
        for (let o = t[0]; o <= t[1]; ++o) if (ta(e[o], i, !0)) return 0;
        let n = 1 / 0;
        for (let o = t[0]; o < t[1]; ++o)
          for (const s of i)
            for (let a = 0, l = s.length, c = l - 1; a < l; c = a++) {
              if (Ic(e[o], e[o + 1], s[c], s[a])) return 0;
              n = Math.min(n, kd(e[o], e[o + 1], s[c], s[a], r));
            }
        return n;
      }
      function ug(e, t) {
        for (const i of e) for (let r = 0; r <= i.length - 1; ++r) if (ta(i[r], t, !0)) return !0;
        return !1;
      }
      function FE(e, t, i, r = 1 / 0) {
        const n = Pc(e),
          o = Pc(t);
        if (r !== 1 / 0 && ea(n, o, i) >= r) return r;
        if (ll(n, o)) {
          if (ug(e, t)) return 0;
        } else if (ug(t, e)) return 0;
        let s = r;
        for (const a of e)
          for (let l = 0, c = a.length, u = c - 1; l < c; u = l++)
            for (const h of t)
              for (let d = 0, f = h.length, p = f - 1; d < f; p = d++) {
                if (Ic(a[u], a[l], h[p], h[d])) return 0;
                s = Math.min(s, kd(a[u], a[l], h[p], h[d], i));
              }
        return s;
      }
      function zc(e, t, i, r, n, o, s) {
        if (o === null || s === null) return;
        const a = ea(ds(r, o), ds(n, s), i);
        a < t && e.push({ dist: a, range1: o, range2: s });
      }
      function NE(e, t, i, r, n = 1 / 0) {
        let o = Math.min(r.distance(e[0], i[0][0]), n);
        if (o === 0) return o;
        const s = new Pd([{ dist: 0, range1: [0, e.length - 1], range2: [0, 0] }], sg),
          a = t ? Dd : zd,
          l = Pc(i);
        for (; s.length; ) {
          const c = s.pop();
          if (c.dist >= o) continue;
          const u = c.range1;
          if (Cc(u) <= a) {
            if (!io(u, e.length)) return NaN;
            if (t) {
              const h = BE(e, u, i, r);
              if ((o = Math.min(o, h)) === 0) return o;
            } else
              for (let h = u[0]; h <= u[1]; ++h) {
                const d = OE(e[h], i, r);
                if ((o = Math.min(o, d)) === 0) return o;
              }
          } else {
            const h = Rd(u, t);
            if (h[0] !== null) {
              const d = ea(ds(e, h[0]), l, r);
              d < o && s.push({ dist: d, range1: h[0], range2: [0, 0] });
            }
            if (h[1] !== null) {
              const d = ea(ds(e, h[1]), l, r);
              d < o && s.push({ dist: d, range1: h[1], range2: [0, 0] });
            }
          }
        }
        return o;
      }
      function hg(e, t, i, r, n, o = 1 / 0) {
        let s = Math.min(o, n.distance(e[0], i[0]));
        if (s === 0) return s;
        const a = new Pd([{ dist: 0, range1: [0, e.length - 1], range2: [0, i.length - 1] }], sg),
          l = t ? Dd : zd,
          c = r ? Dd : zd;
        for (; a.length; ) {
          const u = a.pop();
          if (u.dist >= s) continue;
          const h = u.range1,
            d = u.range2;
          if (Cc(h) <= l && Cc(d) <= c) {
            if (!io(h, e.length) || !io(d, i.length)) return NaN;
            if ((t && r ? (s = Math.min(s, LE(e, h, i, d, n))) : t || r ? (t && !r ? (s = Math.min(s, cg(i, d, e, h, n))) : !t && r && (s = Math.min(s, cg(e, h, i, d, n)))) : (s = Math.min(s, kE(e, h, i, d, n))), s === 0)) return s;
          } else {
            const f = Rd(h, t),
              p = Rd(d, r);
            zc(a, s, n, e, i, f[0], p[0]), zc(a, s, n, e, i, f[0], p[1]), zc(a, s, n, e, i, f[1], p[0]), zc(a, s, n, e, i, f[1], p[1]);
          }
        }
        return s;
      }
      function Od(e, t, i, r, n = 1 / 0) {
        let o = n;
        const s = ds(e, [0, e.length - 1]);
        for (const a of i) if (!(o !== 1 / 0 && ea(s, ds(a, [0, a.length - 1]), r) >= o) && ((o = Math.min(o, hg(e, t, a, !0, r, o))), o === 0)) return o;
        return o;
      }
      function Dc(e, t, i, r, n = 1 / 0) {
        let o = n;
        const s = ds(e, [0, e.length - 1]);
        for (const a of i) {
          if (o !== 1 / 0 && ea(s, Pc(a), r) >= o) continue;
          const l = NE(e, t, a, r, o);
          if (isNaN(l)) return l;
          if ((o = Math.min(o, l)) === 0) return o;
        }
        return o;
      }
      function Bd(e) {
        return e === 'Point' || e === 'MultiPoint' || e === 'LineString' || e === 'MultiLineString' || e === 'Polygon' || e === 'MultiPolygon';
      }
      class ul {
        constructor(t, i) {
          (this.type = Nt), (this.geojson = t), (this.geometries = i);
        }
        static parse(t, i) {
          if (t.length !== 2) return i.error(`'distance' expression requires either one argument, but found ' ${t.length - 1} instead.`);
          if (Qs(t[1])) {
            const r = t[1];
            if (r.type === 'FeatureCollection') {
              for (let n = 0; n < r.features.length; ++n) if (Bd(r.features[n].geometry.type)) return new ul(r, r.features[n].geometry);
            } else if (r.type === 'Feature') {
              if (Bd(r.geometry.type)) return new ul(r, r.geometry);
            } else if (Bd(r.type)) return new ul(r, r);
          }
          return i.error("'distance' expression needs to be an array with format ['Distance', GeoJSONObj].");
        }
        evaluate(t) {
          const i = t.geometry(),
            r = t.canonicalID();
          if (i != null && r != null) {
            if (t.geometryType() === 'Point')
              return (function (n, o, s) {
                const a = [];
                for (const c of n) for (const u of c) a.push(Ld(u, o));
                const l = new Cd(a[0][1], 'meters');
                return s.type === 'Point' || s.type === 'MultiPoint' || s.type === 'LineString' ? hg(a, !1, s.type === 'Point' ? [s.coordinates] : s.coordinates, s.type === 'LineString', l) : s.type === 'MultiLineString' ? Od(a, !1, s.coordinates, l) : s.type === 'Polygon' || s.type === 'MultiPolygon' ? Dc(a, !1, s.type === 'Polygon' ? [s.coordinates] : s.coordinates, l) : null;
              })(i, r, this.geometries);
            if (t.geometryType() === 'LineString')
              return (function (n, o, s) {
                const a = [];
                for (const c of n) {
                  const u = [];
                  for (const h of c) u.push(Ld(h, o));
                  a.push(u);
                }
                const l = new Cd(a[0][0][1], 'meters');
                if (s.type === 'Point' || s.type === 'MultiPoint' || s.type === 'LineString') return Od(s.type === 'Point' ? [s.coordinates] : s.coordinates, s.type === 'LineString', a, l);
                if (s.type === 'MultiLineString') {
                  let c = 1 / 0;
                  for (let u = 0; u < s.coordinates.length; u++) {
                    const h = Od(s.coordinates[u], !0, a, l, c);
                    if (isNaN(h)) return h;
                    if ((c = Math.min(c, h)) === 0) return c;
                  }
                  return c;
                }
                if (s.type === 'Polygon' || s.type === 'MultiPolygon') {
                  let c = 1 / 0;
                  for (let u = 0; u < a.length; u++) {
                    const h = Dc(a[u], !0, s.type === 'Polygon' ? [s.coordinates] : s.coordinates, l, c);
                    if (isNaN(h)) return h;
                    if ((c = Math.min(c, h)) === 0) return c;
                  }
                  return c;
                }
                return null;
              })(i, r, this.geometries);
            if (t.geometryType() === 'Polygon')
              return (function (n, o, s) {
                const a = [];
                for (const c of (function (u, h) {
                  const d = u.length;
                  if (d <= 1) return [u];
                  const f = [];
                  let p, _;
                  for (let g = 0; g < d; g++) {
                    const y = AE(u[g]);
                    y !== 0 && ((u[g].area = Math.abs(y)), _ === void 0 && (_ = y < 0), _ === y < 0 ? (p && f.push(p), (p = [u[g]])) : p.push(u[g]));
                  }
                  return p && f.push(p), f;
                })(n)) {
                  const u = [];
                  for (let h = 0; h < c.length; ++h) u.push(RE(c[h], o));
                  a.push(u);
                }
                const l = new Cd(a[0][0][0][1], 'meters');
                if (s.type === 'Point' || s.type === 'MultiPoint' || s.type === 'LineString') return Dc(s.type === 'Point' ? [s.coordinates] : s.coordinates, s.type === 'LineString', a, l);
                if (s.type === 'MultiLineString') {
                  let c = 1 / 0;
                  for (let u = 0; u < s.coordinates.length; u++) {
                    const h = Dc(s.coordinates[u], !0, a, l, c);
                    if (isNaN(h)) return h;
                    if ((c = Math.min(c, h)) === 0) return c;
                  }
                  return c;
                }
                return s.type === 'Polygon' || s.type === 'MultiPolygon'
                  ? (function (c, u, h) {
                      let d = 1 / 0;
                      for (const f of c)
                        for (const p of u) {
                          const _ = FE(f, p, h, d);
                          if (isNaN(_)) return _;
                          if ((d = Math.min(d, _)) === 0) return d;
                        }
                      return d;
                    })(s.type === 'Polygon' ? [s.coordinates] : s.coordinates, a, l)
                  : null;
              })(i, r, this.geometries);
            console.warn('Distance Expression: currently only evaluates valid Point/LineString/Polygon geometries.');
          } else console.warn('Distance Expression: requirs valid feature and canonical information.');
          return null;
        }
        eachChild() {}
        outputDefined() {
          return !0;
        }
        serialize() {
          return ['distance', this.geojson];
        }
      }
      var Fd = ul;
      function ia(e) {
        if ((e instanceof zn && ((e.name === 'get' && e.args.length === 1) || e.name === 'feature-state' || (e.name === 'has' && e.args.length === 1) || e.name === 'properties' || e.name === 'geometry-type' || e.name === 'id' || /^filter-/.test(e.name))) || e instanceof Id || e instanceof Fd) return !1;
        let t = !0;
        return (
          e.eachChild((i) => {
            t && !ia(i) && (t = !1);
          }),
          t
        );
      }
      function hl(e) {
        if (e instanceof zn && e.name === 'feature-state') return !1;
        let t = !0;
        return (
          e.eachChild((i) => {
            t && !hl(i) && (t = !1);
          }),
          t
        );
      }
      function Nd(e) {
        if (e instanceof zn && e.name === 'config') return !1;
        let t = !0;
        return (
          e.eachChild((i) => {
            t && !Nd(i) && (t = !1);
          }),
          t
        );
      }
      function ra(e, t) {
        if (e instanceof zn && t.indexOf(e.name) >= 0) return !1;
        let i = !0;
        return (
          e.eachChild((r) => {
            i && !ra(r, t) && (i = !1);
          }),
          i
        );
      }
      class Ud {
        constructor(t, i) {
          (this.type = i.type), (this.name = t), (this.boundExpression = i);
        }
        static parse(t, i) {
          if (t.length !== 2 || typeof t[1] != 'string') return i.error("'var' expression requires exactly one string literal argument.");
          const r = t[1];
          return i.scope.has(r) ? new Ud(r, i.scope.get(r)) : i.error(`Unknown variable "${r}". Make sure "${r}" has been bound in an enclosing "let" expression before using it.`, 1);
        }
        evaluate(t) {
          return this.boundExpression.evaluate(t);
        }
        eachChild() {}
        outputDefined() {
          return !1;
        }
        serialize() {
          return ['var', this.name];
        }
      }
      var dg = Ud;
      class Vd {
        constructor(t, i = [], r, n = new bE(), o = [], s) {
          (this.registry = t), (this.path = i), (this.key = i.map((a) => `[${a}]`).join('')), (this.scope = n), (this.errors = o), (this.expectedType = r), (this.options = s);
        }
        parse(t, i, r, n, o = {}) {
          return i || r ? this.concat(i, r, n)._parse(t, o) : this._parse(t, o);
        }
        _parse(t, i) {
          function r(n, o, s) {
            return s === 'assert' ? new eo(o, [n]) : s === 'coerce' ? new us(o, [n]) : n;
          }
          if (((t !== null && typeof t != 'string' && typeof t != 'boolean' && typeof t != 'number') || (t = ['literal', t]), Array.isArray(t))) {
            if (t.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
            const n = typeof t[0] == 'string' ? this.registry[t[0]] : void 0;
            if (n) {
              let o = n.parse(t, this);
              if (!o) return null;
              if (this.expectedType) {
                const s = this.expectedType,
                  a = o.type;
                if ((s.kind !== 'string' && s.kind !== 'number' && s.kind !== 'boolean' && s.kind !== 'object' && s.kind !== 'array') || a.kind !== 'value')
                  if ((s.kind !== 'color' && s.kind !== 'formatted' && s.kind !== 'resolvedImage') || (a.kind !== 'value' && a.kind !== 'string')) {
                    if (this.checkSubtype(s, a)) return null;
                  } else o = r(o, s, i.typeAnnotation || 'coerce');
                else o = r(o, s, i.typeAnnotation || 'assert');
              }
              if (!(o instanceof nl) && o.type.kind !== 'resolvedImage' && jd(o)) {
                const s = new Y_(this.options);
                try {
                  o = new nl(o.type, o.evaluate(s));
                } catch (a) {
                  return this.error(a.message), null;
                }
              }
              return o;
            }
            return us.parse(['to-array', t], this);
          }
          return this.error(t === void 0 ? "'undefined' value invalid. Use null instead." : typeof t == 'object' ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`);
        }
        concat(t, i, r) {
          const n = typeof t == 'number' ? this.path.concat(t) : this.path,
            o = r ? this.scope.concat(r) : this.scope;
          return new Vd(this.registry, n, i || null, o, this.errors, this.options);
        }
        error(t, ...i) {
          const r = `${this.key}${i.map((n) => `[${n}]`).join('')}`;
          this.errors.push(new Pn(r, t));
        }
        checkSubtype(t, i) {
          const r = el(t, i);
          return r && this.error(r), r;
        }
      }
      var fg = Vd;
      function jd(e) {
        if (e instanceof dg) return jd(e.boundExpression);
        if ((e instanceof zn && e.name === 'error') || (e instanceof zn && e.name === 'config') || e instanceof Ac || e instanceof Id || e instanceof Fd) return !1;
        const t = e instanceof us || e instanceof eo;
        let i = !0;
        return (
          e.eachChild((r) => {
            i = t ? i && jd(r) : i && r instanceof nl;
          }),
          !!i && ia(e) && ra(e, ['zoom', 'heatmap-density', 'line-progress', 'raster-value', 'sky-radial-progress', 'accumulated', 'is-supported-script', 'pitch', 'distance-from-center', 'measure-light'])
        );
      }
      function Rc(e, t) {
        const i = e.length - 1;
        let r,
          n,
          o = 0,
          s = i,
          a = 0;
        for (; o <= s; )
          if (((a = Math.floor((o + s) / 2)), (r = e[a]), (n = e[a + 1]), r <= t)) {
            if (a === i || t < n) return a;
            o = a + 1;
          } else {
            if (!(r > t)) throw new ir('Input is not a number.');
            s = a - 1;
          }
        return 0;
      }
      class Gd {
        constructor(t, i, r) {
          (this.type = t), (this.input = i), (this.labels = []), (this.outputs = []);
          for (const [n, o] of r) this.labels.push(n), this.outputs.push(o);
        }
        static parse(t, i) {
          if (t.length - 1 < 4) return i.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
          if ((t.length - 1) % 2 != 0) return i.error('Expected an even number of arguments.');
          const r = i.parse(t[1], 1, Nt);
          if (!r) return null;
          const n = [];
          let o = null;
          i.expectedType && i.expectedType.kind !== 'value' && (o = i.expectedType);
          for (let s = 1; s < t.length; s += 2) {
            const a = s === 1 ? -1 / 0 : t[s],
              l = t[s + 1],
              c = s,
              u = s + 1;
            if (typeof a != 'number') return i.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', c);
            if (n.length && n[n.length - 1][0] >= a) return i.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', c);
            const h = i.parse(l, u, o);
            if (!h) return null;
            (o = o || h.type), n.push([a, h]);
          }
          return new Gd(o, r, n);
        }
        evaluate(t) {
          const i = this.labels,
            r = this.outputs;
          if (i.length === 1) return r[0].evaluate(t);
          const n = this.input.evaluate(t);
          if (n <= i[0]) return r[0].evaluate(t);
          const o = i.length;
          return n >= i[o - 1] ? r[o - 1].evaluate(t) : r[Rc(i, n)].evaluate(t);
        }
        eachChild(t) {
          t(this.input);
          for (const i of this.outputs) t(i);
        }
        outputDefined() {
          return this.outputs.every((t) => t.outputDefined());
        }
        serialize() {
          const t = ['step', this.input.serialize()];
          for (let i = 0; i < this.labels.length; i++) i > 0 && t.push(this.labels[i]), t.push(this.outputs[i].serialize());
          return t;
        }
      }
      var qd = Gd;
      function ee(e, t, i) {
        return e * (1 - i) + t * i;
      }
      function pg(e, t, i) {
        return e.map((r, n) => ee(r, t[n], i));
      }
      var Lc = Object.freeze({
        __proto__: null,
        array: pg,
        color: function (e, t, i) {
          return new pe(ee(e.r, t.r, i), ee(e.g, t.g, i), ee(e.b, t.b, i), ee(e.a, t.a, i));
        },
        number: ee,
      });
      const mg = 0.95047,
        _g = 1.08883,
        gg = 4 / 29,
        na = 6 / 29,
        yg = 3 * na * na,
        UE = na * na * na,
        VE = Math.PI / 180,
        jE = 180 / Math.PI;
      function Zd(e) {
        return e > UE ? Math.pow(e, 1 / 3) : e / yg + gg;
      }
      function $d(e) {
        return e > na ? e * e * e : yg * (e - gg);
      }
      function Hd(e) {
        return 255 * (e <= 0.0031308 ? 12.92 * e : 1.055 * Math.pow(e, 1 / 2.4) - 0.055);
      }
      function Wd(e) {
        return (e /= 255) <= 0.04045 ? e / 12.92 : Math.pow((e + 0.055) / 1.055, 2.4);
      }
      function xg(e) {
        const t = Wd(e.r),
          i = Wd(e.g),
          r = Wd(e.b),
          n = Zd((0.4124564 * t + 0.3575761 * i + 0.1804375 * r) / mg),
          o = Zd((0.2126729 * t + 0.7151522 * i + 0.072175 * r) / 1);
        return { l: 116 * o - 16, a: 500 * (n - o), b: 200 * (o - Zd((0.0193339 * t + 0.119192 * i + 0.9503041 * r) / _g)), alpha: e.a };
      }
      function vg(e) {
        let t = (e.l + 16) / 116,
          i = isNaN(e.a) ? t : t + e.a / 500,
          r = isNaN(e.b) ? t : t - e.b / 200;
        return (t = 1 * $d(t)), (i = mg * $d(i)), (r = _g * $d(r)), new pe(Hd(3.2404542 * i - 1.5371385 * t - 0.4985314 * r), Hd(-0.969266 * i + 1.8760108 * t + 0.041556 * r), Hd(0.0556434 * i - 0.2040259 * t + 1.0572252 * r), e.alpha);
      }
      function GE(e, t, i) {
        const r = t - e;
        return e + i * (r > 180 || r < -180 ? r - 360 * Math.round(r / 360) : r);
      }
      const dl = {
          forward: xg,
          reverse: vg,
          interpolate: function (e, t, i) {
            return { l: ee(e.l, t.l, i), a: ee(e.a, t.a, i), b: ee(e.b, t.b, i), alpha: ee(e.alpha, t.alpha, i) };
          },
        },
        fl = {
          forward: function (e) {
            const { l: t, a: i, b: r } = xg(e),
              n = Math.atan2(r, i) * jE;
            return { h: n < 0 ? n + 360 : n, c: Math.sqrt(i * i + r * r), l: t, alpha: e.a };
          },
          reverse: function (e) {
            const t = e.h * VE,
              i = e.c;
            return vg({ l: e.l, a: Math.cos(t) * i, b: Math.sin(t) * i, alpha: e.alpha });
          },
          interpolate: function (e, t, i) {
            return { h: GE(e.h, t.h, i), c: ee(e.c, t.c, i), l: ee(e.l, t.l, i), alpha: ee(e.alpha, t.alpha, i) };
          },
        };
      var bg = Object.freeze({ __proto__: null, hcl: fl, lab: dl });
      class kc {
        constructor(t, i, r, n, o) {
          (this.type = t), (this.operator = i), (this.interpolation = r), (this.input = n), (this.labels = []), (this.outputs = []);
          for (const [s, a] of o) this.labels.push(s), this.outputs.push(a);
        }
        static interpolationFactor(t, i, r, n) {
          let o = 0;
          if (t.name === 'exponential') o = Xd(i, t.base, r, n);
          else if (t.name === 'linear') o = Xd(i, 1, r, n);
          else if (t.name === 'cubic-bezier') {
            const s = t.controlPoints;
            o = new Mr(s[0], s[1], s[2], s[3]).solve(Xd(i, 1, r, n));
          }
          return o;
        }
        static parse(t, i) {
          let [r, n, o, ...s] = t;
          if (!Array.isArray(n) || n.length === 0) return i.error('Expected an interpolation type expression.', 1);
          if (n[0] === 'linear') n = { name: 'linear' };
          else if (n[0] === 'exponential') {
            const c = n[1];
            if (typeof c != 'number') return i.error('Exponential interpolation requires a numeric base.', 1, 1);
            n = { name: 'exponential', base: c };
          } else {
            if (n[0] !== 'cubic-bezier') return i.error(`Unknown interpolation type ${String(n[0])}`, 1, 0);
            {
              const c = n.slice(1);
              if (c.length !== 4 || c.some((u) => typeof u != 'number' || u < 0 || u > 1)) return i.error('Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.', 1);
              n = { name: 'cubic-bezier', controlPoints: c };
            }
          }
          if (t.length - 1 < 4) return i.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
          if ((t.length - 1) % 2 != 0) return i.error('Expected an even number of arguments.');
          if (((o = i.parse(o, 2, Nt)), !o)) return null;
          const a = [];
          let l = null;
          r === 'interpolate-hcl' || r === 'interpolate-lab' ? (l = nn) : i.expectedType && i.expectedType.kind !== 'value' && (l = i.expectedType);
          for (let c = 0; c < s.length; c += 2) {
            const u = s[c],
              h = s[c + 1],
              d = c + 3,
              f = c + 4;
            if (typeof u != 'number') return i.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', d);
            if (a.length && a[a.length - 1][0] >= u) return i.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', d);
            const p = i.parse(h, f, l);
            if (!p) return null;
            (l = l || p.type), a.push([u, p]);
          }
          return l.kind === 'number' || l.kind === 'color' || (l.kind === 'array' && l.itemType.kind === 'number' && typeof l.N == 'number') ? new kc(l, r, n, o, a) : i.error(`Type ${Bi(l)} is not interpolatable.`);
        }
        evaluate(t) {
          const i = this.labels,
            r = this.outputs;
          if (i.length === 1) return r[0].evaluate(t);
          const n = this.input.evaluate(t);
          if (n <= i[0]) return r[0].evaluate(t);
          const o = i.length;
          if (n >= i[o - 1]) return r[o - 1].evaluate(t);
          const s = Rc(i, n),
            a = kc.interpolationFactor(this.interpolation, n, i[s], i[s + 1]),
            l = r[s].evaluate(t),
            c = r[s + 1].evaluate(t);
          return this.operator === 'interpolate' ? Lc[this.type.kind.toLowerCase()](l, c, a) : this.operator === 'interpolate-hcl' ? fl.reverse(fl.interpolate(fl.forward(l), fl.forward(c), a)) : dl.reverse(dl.interpolate(dl.forward(l), dl.forward(c), a));
        }
        eachChild(t) {
          t(this.input);
          for (const i of this.outputs) t(i);
        }
        outputDefined() {
          return this.outputs.every((t) => t.outputDefined());
        }
        serialize() {
          let t;
          t = this.interpolation.name === 'linear' ? ['linear'] : this.interpolation.name === 'exponential' ? (this.interpolation.base === 1 ? ['linear'] : ['exponential', this.interpolation.base]) : ['cubic-bezier'].concat(this.interpolation.controlPoints);
          const i = [this.operator, t, this.input.serialize()];
          for (let r = 0; r < this.labels.length; r++) i.push(this.labels[r], this.outputs[r].serialize());
          return i;
        }
      }
      function Xd(e, t, i, r) {
        const n = r - i,
          o = e - i;
        return n === 0 ? 0 : t === 1 ? o / n : (Math.pow(t, o) - 1) / (Math.pow(t, n) - 1);
      }
      var Dn = kc;
      class Yd {
        constructor(t, i) {
          (this.type = t), (this.args = i);
        }
        static parse(t, i) {
          if (t.length < 2) return i.error('Expectected at least one argument.');
          let r = null;
          const n = i.expectedType;
          n && n.kind !== 'value' && (r = n);
          const o = [];
          for (const a of t.slice(1)) {
            const l = i.parse(a, 1 + o.length, r, void 0, { typeAnnotation: 'omit' });
            if (!l) return null;
            (r = r || l.type), o.push(l);
          }
          const s = n && o.some((a) => el(n, a.type));
          return new Yd(s ? ke : r, o);
        }
        evaluate(t) {
          let i,
            r = null,
            n = 0;
          for (const o of this.args) {
            if ((n++, (r = o.evaluate(t)), r && r instanceof on && !r.available && (i || (i = r), (r = null), n === this.args.length))) return i;
            if (r !== null) break;
          }
          return r;
        }
        eachChild(t) {
          this.args.forEach(t);
        }
        outputDefined() {
          return this.args.every((t) => t.outputDefined());
        }
        serialize() {
          const t = ['coalesce'];
          return (
            this.eachChild((i) => {
              t.push(i.serialize());
            }),
            t
          );
        }
      }
      var wg = Yd;
      class Kd {
        constructor(t, i) {
          (this.type = i.type), (this.bindings = [].concat(t)), (this.result = i);
        }
        evaluate(t) {
          return this.result.evaluate(t);
        }
        eachChild(t) {
          for (const i of this.bindings) t(i[1]);
          t(this.result);
        }
        static parse(t, i) {
          if (t.length < 4) return i.error(`Expected at least 3 arguments, but found ${t.length - 1} instead.`);
          const r = [];
          for (let o = 1; o < t.length - 1; o += 2) {
            const s = t[o];
            if (typeof s != 'string') return i.error(`Expected string, but found ${typeof s} instead.`, o);
            if (/[^a-zA-Z0-9_]/.test(s)) return i.error("Variable names must contain only alphanumeric characters or '_'.", o);
            const a = i.parse(t[o + 1], o + 1);
            if (!a) return null;
            r.push([s, a]);
          }
          const n = i.parse(t[t.length - 1], t.length - 1, i.expectedType, r);
          return n ? new Kd(r, n) : null;
        }
        outputDefined() {
          return this.result.outputDefined();
        }
        serialize() {
          const t = ['let'];
          for (const [i, r] of this.bindings) t.push(i, r.serialize());
          return t.push(this.result.serialize()), t;
        }
      }
      var Tg = Kd;
      class Jd {
        constructor(t, i, r) {
          (this.type = t), (this.index = i), (this.input = r);
        }
        static parse(t, i) {
          if (t.length !== 3) return i.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
          const r = i.parse(t[1], 1, Nt),
            n = i.parse(t[2], 2, Cr(i.expectedType || ke));
          return r && n ? new Jd(n.type.itemType, r, n) : null;
        }
        evaluate(t) {
          const i = this.index.evaluate(t),
            r = this.input.evaluate(t);
          if (i < 0) throw new ir(`Array index out of bounds: ${i} < 0.`);
          if (i >= r.length) throw new ir(`Array index out of bounds: ${i} > ${r.length - 1}.`);
          if (i !== Math.floor(i)) throw new ir(`Array index must be an integer, but found ${i} instead.`);
          return r[i];
        }
        eachChild(t) {
          t(this.index), t(this.input);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          return ['at', this.index.serialize(), this.input.serialize()];
        }
      }
      var qE = Jd;
      class Qd {
        constructor(t, i) {
          (this.type = Fe), (this.needle = t), (this.haystack = i);
        }
        static parse(t, i) {
          if (t.length !== 3) return i.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
          const r = i.parse(t[1], 1, ke),
            n = i.parse(t[2], 2, ke);
          return r && n ? (gd(r.type, [Fe, Re, Nt, Ks, ke]) ? new Qd(r, n) : i.error(`Expected first argument to be of type boolean, string, number or null, but found ${Bi(r.type)} instead`)) : null;
        }
        evaluate(t) {
          const i = this.needle.evaluate(t),
            r = this.haystack.evaluate(t);
          if (r == null) return !1;
          if (!il(i, ['boolean', 'string', 'number', 'null'])) throw new ir(`Expected first argument to be of type boolean, string, number or null, but found ${Bi(Xi(i))} instead.`);
          if (!il(r, ['string', 'array'])) throw new ir(`Expected second argument to be of type array or string, but found ${Bi(Xi(r))} instead.`);
          return r.indexOf(i) >= 0;
        }
        eachChild(t) {
          t(this.needle), t(this.haystack);
        }
        outputDefined() {
          return !0;
        }
        serialize() {
          return ['in', this.needle.serialize(), this.haystack.serialize()];
        }
      }
      var ZE = Qd;
      class Oc {
        constructor(t, i, r) {
          (this.type = Nt), (this.needle = t), (this.haystack = i), (this.fromIndex = r);
        }
        static parse(t, i) {
          if (t.length <= 2 || t.length >= 5) return i.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);
          const r = i.parse(t[1], 1, ke),
            n = i.parse(t[2], 2, ke);
          if (!r || !n) return null;
          if (!gd(r.type, [Fe, Re, Nt, Ks, ke])) return i.error(`Expected first argument to be of type boolean, string, number or null, but found ${Bi(r.type)} instead`);
          if (t.length === 4) {
            const o = i.parse(t[3], 3, Nt);
            return o ? new Oc(r, n, o) : null;
          }
          return new Oc(r, n);
        }
        evaluate(t) {
          const i = this.needle.evaluate(t),
            r = this.haystack.evaluate(t);
          if (!il(i, ['boolean', 'string', 'number', 'null'])) throw new ir(`Expected first argument to be of type boolean, string, number or null, but found ${Bi(Xi(i))} instead.`);
          if (!il(r, ['string', 'array'])) throw new ir(`Expected second argument to be of type array or string, but found ${Bi(Xi(r))} instead.`);
          if (this.fromIndex) {
            const n = this.fromIndex.evaluate(t);
            return r.indexOf(i, n);
          }
          return r.indexOf(i);
        }
        eachChild(t) {
          t(this.needle), t(this.haystack), this.fromIndex && t(this.fromIndex);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          if (this.fromIndex != null && this.fromIndex !== void 0) {
            const t = this.fromIndex.serialize();
            return ['index-of', this.needle.serialize(), this.haystack.serialize(), t];
          }
          return ['index-of', this.needle.serialize(), this.haystack.serialize()];
        }
      }
      var $E = Oc;
      class tf {
        constructor(t, i, r, n, o, s) {
          (this.inputType = t), (this.type = i), (this.input = r), (this.cases = n), (this.outputs = o), (this.otherwise = s);
        }
        static parse(t, i) {
          if (t.length < 5) return i.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
          if (t.length % 2 != 1) return i.error('Expected an even number of arguments.');
          let r, n;
          i.expectedType && i.expectedType.kind !== 'value' && (n = i.expectedType);
          const o = {},
            s = [];
          for (let c = 2; c < t.length - 1; c += 2) {
            let u = t[c];
            const h = t[c + 1];
            Array.isArray(u) || (u = [u]);
            const d = i.concat(c);
            if (u.length === 0) return d.error('Expected at least one branch label.');
            for (const p of u) {
              if (typeof p != 'number' && typeof p != 'string') return d.error('Branch labels must be numbers or strings.');
              if (typeof p == 'number' && Math.abs(p) > Number.MAX_SAFE_INTEGER) return d.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
              if (typeof p == 'number' && Math.floor(p) !== p) return d.error('Numeric branch labels must be integer values.');
              if (r) {
                if (d.checkSubtype(r, Xi(p))) return null;
              } else r = Xi(p);
              if (o[String(p)] !== void 0) return d.error('Branch labels must be unique.');
              o[String(p)] = s.length;
            }
            const f = i.parse(h, c, n);
            if (!f) return null;
            (n = n || f.type), s.push(f);
          }
          const a = i.parse(t[1], 1, ke);
          if (!a) return null;
          const l = i.parse(t[t.length - 1], t.length - 1, n);
          return l ? (a.type.kind !== 'value' && i.concat(1).checkSubtype(r, a.type) ? null : new tf(r, n, a, o, s, l)) : null;
        }
        evaluate(t) {
          const i = this.input.evaluate(t);
          return ((Xi(i) === this.inputType && this.outputs[this.cases[i]]) || this.otherwise).evaluate(t);
        }
        eachChild(t) {
          t(this.input), this.outputs.forEach(t), t(this.otherwise);
        }
        outputDefined() {
          return this.outputs.every((t) => t.outputDefined()) && this.otherwise.outputDefined();
        }
        serialize() {
          const t = ['match', this.input.serialize()],
            i = Object.keys(this.cases).sort(),
            r = [],
            n = {};
          for (const s of i) {
            const a = n[this.cases[s]];
            a === void 0 ? ((n[this.cases[s]] = r.length), r.push([this.cases[s], [s]])) : r[a][1].push(s);
          }
          const o = (s) => (this.inputType.kind === 'number' ? Number(s) : s);
          for (const [s, a] of r) t.push(a.length === 1 ? o(a[0]) : a.map(o)), t.push(this.outputs[s].serialize());
          return t.push(this.otherwise.serialize()), t;
        }
      }
      var HE = tf;
      class ef {
        constructor(t, i, r) {
          (this.type = t), (this.branches = i), (this.otherwise = r);
        }
        static parse(t, i) {
          if (t.length < 4) return i.error(`Expected at least 3 arguments, but found only ${t.length - 1}.`);
          if (t.length % 2 != 0) return i.error('Expected an odd number of arguments.');
          let r;
          i.expectedType && i.expectedType.kind !== 'value' && (r = i.expectedType);
          const n = [];
          for (let s = 1; s < t.length - 1; s += 2) {
            const a = i.parse(t[s], s, Fe);
            if (!a) return null;
            const l = i.parse(t[s + 1], s + 1, r);
            if (!l) return null;
            n.push([a, l]), (r = r || l.type);
          }
          const o = i.parse(t[t.length - 1], t.length - 1, r);
          return o ? new ef(r, n, o) : null;
        }
        evaluate(t) {
          for (const [i, r] of this.branches) if (i.evaluate(t)) return r.evaluate(t);
          return this.otherwise.evaluate(t);
        }
        eachChild(t) {
          for (const [i, r] of this.branches) t(i), t(r);
          t(this.otherwise);
        }
        outputDefined() {
          return this.branches.every(([t, i]) => i.outputDefined()) && this.otherwise.outputDefined();
        }
        serialize() {
          const t = ['case'];
          return (
            this.eachChild((i) => {
              t.push(i.serialize());
            }),
            t
          );
        }
      }
      var WE = ef;
      class Bc {
        constructor(t, i, r, n) {
          (this.type = t), (this.input = i), (this.beginIndex = r), (this.endIndex = n);
        }
        static parse(t, i) {
          if (t.length <= 2 || t.length >= 5) return i.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);
          const r = i.parse(t[1], 1, ke),
            n = i.parse(t[2], 2, Nt);
          if (!r || !n) return null;
          if (!gd(r.type, [Cr(ke), Re, ke])) return i.error(`Expected first argument to be of type array or string, but found ${Bi(r.type)} instead`);
          if (t.length === 4) {
            const o = i.parse(t[3], 3, Nt);
            return o ? new Bc(r.type, r, n, o) : null;
          }
          return new Bc(r.type, r, n);
        }
        evaluate(t) {
          const i = this.input.evaluate(t),
            r = this.beginIndex.evaluate(t);
          if (!il(i, ['string', 'array'])) throw new ir(`Expected first argument to be of type array or string, but found ${Bi(Xi(i))} instead.`);
          if (this.endIndex) {
            const n = this.endIndex.evaluate(t);
            return i.slice(r, n);
          }
          return i.slice(r);
        }
        eachChild(t) {
          t(this.input), t(this.beginIndex), this.endIndex && t(this.endIndex);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          if (this.endIndex != null && this.endIndex !== void 0) {
            const t = this.endIndex.serialize();
            return ['slice', this.input.serialize(), this.beginIndex.serialize(), t];
          }
          return ['slice', this.input.serialize(), this.beginIndex.serialize()];
        }
      }
      var XE = Bc;
      function Eg(e, t) {
        return e === '==' || e === '!=' ? t.kind === 'boolean' || t.kind === 'string' || t.kind === 'number' || t.kind === 'null' || t.kind === 'value' : t.kind === 'string' || t.kind === 'number' || t.kind === 'value';
      }
      function Mg(e, t, i, r) {
        return r.compare(t, i) === 0;
      }
      function oa(e, t, i) {
        const r = e !== '==' && e !== '!=';
        return class pE {
          constructor(o, s, a) {
            (this.type = Fe), (this.lhs = o), (this.rhs = s), (this.collator = a), (this.hasUntypedArgument = o.type.kind === 'value' || s.type.kind === 'value');
          }
          static parse(o, s) {
            if (o.length !== 3 && o.length !== 4) return s.error('Expected two or three arguments.');
            const a = o[0];
            let l = s.parse(o[1], 1, ke);
            if (!l) return null;
            if (!Eg(a, l.type)) return s.concat(1).error(`"${a}" comparisons are not supported for type '${Bi(l.type)}'.`);
            let c = s.parse(o[2], 2, ke);
            if (!c) return null;
            if (!Eg(a, c.type)) return s.concat(2).error(`"${a}" comparisons are not supported for type '${Bi(c.type)}'.`);
            if (l.type.kind !== c.type.kind && l.type.kind !== 'value' && c.type.kind !== 'value') return s.error(`Cannot compare types '${Bi(l.type)}' and '${Bi(c.type)}'.`);
            r && (l.type.kind === 'value' && c.type.kind !== 'value' ? (l = new eo(c.type, [l])) : l.type.kind !== 'value' && c.type.kind === 'value' && (c = new eo(l.type, [c])));
            let u = null;
            if (o.length === 4) {
              if (l.type.kind !== 'string' && c.type.kind !== 'string' && l.type.kind !== 'value' && c.type.kind !== 'value') return s.error('Cannot use collator to compare non-string types.');
              if (((u = s.parse(o[3], 3, Ec)), !u)) return null;
            }
            return new pE(l, c, u);
          }
          evaluate(o) {
            const s = this.lhs.evaluate(o),
              a = this.rhs.evaluate(o);
            if (r && this.hasUntypedArgument) {
              const l = Xi(s),
                c = Xi(a);
              if (l.kind !== c.kind || (l.kind !== 'string' && l.kind !== 'number')) throw new ir(`Expected arguments for "${e}" to be (string, string) or (number, number), but found (${l.kind}, ${c.kind}) instead.`);
            }
            if (this.collator && !r && this.hasUntypedArgument) {
              const l = Xi(s),
                c = Xi(a);
              if (l.kind !== 'string' || c.kind !== 'string') return t(o, s, a);
            }
            return this.collator ? i(o, s, a, this.collator.evaluate(o)) : t(o, s, a);
          }
          eachChild(o) {
            o(this.lhs), o(this.rhs), this.collator && o(this.collator);
          }
          outputDefined() {
            return !0;
          }
          serialize() {
            const o = [e];
            return (
              this.eachChild((s) => {
                o.push(s.serialize());
              }),
              o
            );
          }
        };
      }
      const YE = oa(
          '==',
          function (e, t, i) {
            return t === i;
          },
          Mg
        ),
        KE = oa(
          '!=',
          function (e, t, i) {
            return t !== i;
          },
          function (e, t, i, r) {
            return !Mg(0, t, i, r);
          }
        ),
        JE = oa(
          '<',
          function (e, t, i) {
            return t < i;
          },
          function (e, t, i, r) {
            return r.compare(t, i) < 0;
          }
        ),
        QE = oa(
          '>',
          function (e, t, i) {
            return t > i;
          },
          function (e, t, i, r) {
            return r.compare(t, i) > 0;
          }
        ),
        tM = oa(
          '<=',
          function (e, t, i) {
            return t <= i;
          },
          function (e, t, i, r) {
            return r.compare(t, i) <= 0;
          }
        ),
        eM = oa(
          '>=',
          function (e, t, i) {
            return t >= i;
          },
          function (e, t, i, r) {
            return r.compare(t, i) >= 0;
          }
        );
      class rf {
        constructor(t, i, r, n, o, s) {
          (this.type = Re), (this.number = t), (this.locale = i), (this.currency = r), (this.unit = n), (this.minFractionDigits = o), (this.maxFractionDigits = s);
        }
        static parse(t, i) {
          if (t.length !== 3) return i.error('Expected two arguments.');
          const r = i.parse(t[1], 1, Nt);
          if (!r) return null;
          const n = t[2];
          if (typeof n != 'object' || Array.isArray(n)) return i.error('NumberFormat options argument must be an object.');
          let o = null;
          if (n.locale && ((o = i.parse(n.locale, 1, Re)), !o)) return null;
          let s = null;
          if (n.currency && ((s = i.parse(n.currency, 1, Re)), !s)) return null;
          let a = null;
          if (n.unit && ((a = i.parse(n.unit, 1, Re)), !a)) return null;
          let l = null;
          if (n['min-fraction-digits'] && ((l = i.parse(n['min-fraction-digits'], 1, Nt)), !l)) return null;
          let c = null;
          return n['max-fraction-digits'] && ((c = i.parse(n['max-fraction-digits'], 1, Nt)), !c) ? null : new rf(r, o, s, a, l, c);
        }
        evaluate(t) {
          return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [], { style: (this.currency ? 'currency' : this.unit && 'unit') || 'decimal', currency: this.currency ? this.currency.evaluate(t) : void 0, unit: this.unit ? this.unit.evaluate(t) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0 }).format(this.number.evaluate(t));
        }
        eachChild(t) {
          t(this.number), this.locale && t(this.locale), this.currency && t(this.currency), this.unit && t(this.unit), this.minFractionDigits && t(this.minFractionDigits), this.maxFractionDigits && t(this.maxFractionDigits);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          const t = {};
          return this.locale && (t.locale = this.locale.serialize()), this.currency && (t.currency = this.currency.serialize()), this.unit && (t.unit = this.unit.serialize()), this.minFractionDigits && (t['min-fraction-digits'] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t['max-fraction-digits'] = this.maxFractionDigits.serialize()), ['number-format', this.number.serialize(), t];
        }
      }
      class nf {
        constructor(t) {
          (this.type = Nt), (this.input = t);
        }
        static parse(t, i) {
          if (t.length !== 2) return i.error(`Expected 1 argument, but found ${t.length - 1} instead.`);
          const r = i.parse(t[1], 1);
          return r ? (r.type.kind !== 'array' && r.type.kind !== 'string' && r.type.kind !== 'value' ? i.error(`Expected argument of type string or array, but found ${Bi(r.type)} instead.`) : new nf(r)) : null;
        }
        evaluate(t) {
          const i = this.input.evaluate(t);
          if (typeof i == 'string' || Array.isArray(i)) return i.length;
          throw new ir(`Expected value to be of type string or array, but found ${Bi(Xi(i))} instead.`);
        }
        eachChild(t) {
          t(this.input);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          const t = ['length'];
          return (
            this.eachChild((i) => {
              t.push(i.serialize());
            }),
            t
          );
        }
      }
      function of(e) {
        return function () {
          e = (1831565813 + (e |= 0)) | 0;
          let t = Math.imul(e ^ (e >>> 15), 1 | e);
          return (t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t), ((t ^ (t >>> 14)) >>> 0) / 4294967296;
        };
      }
      const Sg = { '==': YE, '!=': KE, '>': QE, '<': JE, '>=': eM, '<=': tM, array: eo, at: qE, boolean: eo, case: WE, coalesce: wg, collator: Ac, format: ol, image: sl, in: ZE, 'index-of': $E, interpolate: Dn, 'interpolate-hcl': Dn, 'interpolate-lab': Dn, length: nf, let: Tg, literal: nl, match: HE, number: eo, 'number-format': rf, object: eo, slice: XE, step: qd, string: eo, 'to-boolean': us, 'to-color': us, 'to-number': us, 'to-string': us, var: dg, within: Id, distance: Fd };
      function Ag(e, [t, i, r, n]) {
        (t = t.evaluate(e)), (i = i.evaluate(e)), (r = r.evaluate(e));
        const o = n ? n.evaluate(e) : 1,
          s = X_(t, i, r, o);
        if (s) throw new ir(s);
        return new pe((t / 255) * o, (i / 255) * o, (r / 255) * o, o);
      }
      function Ig(e, [t, i, r, n]) {
        (t = t.evaluate(e)), (i = i.evaluate(e)), (r = r.evaluate(e));
        const o = n ? n.evaluate(e) : 1,
          s = (function (c, u, h, d) {
            return typeof c == 'number' && c >= 0 && c <= 360 ? (typeof u == 'number' && u >= 0 && u <= 100 && typeof h == 'number' && h >= 0 && h <= 100 ? (d === void 0 || (typeof d == 'number' && d >= 0 && d <= 1) ? null : `Invalid hsla value [${[c, u, h, d].join(', ')}]: 'a' must be between 0 and 1.`) : `Invalid hsla value [${(typeof d == 'number' ? [c, u, h, d] : [c, u, h]).join(', ')}]: 's', and 'l' must be between 0 and 100.`) : `Invalid hsla value [${(typeof d == 'number' ? [c, u, h, d] : [c, u, h]).join(', ')}]: 'h' must be between 0 and 360.`;
          })(t, i, r, o);
        if (s) throw new ir(s);
        const a = `hsla(${t}, ${i}%, ${r}%, ${o})`,
          l = pe.parse(a);
        if (!l) throw new ir(`Failed to parse HSLA color: ${a}`);
        return l;
      }
      function Cg(e, t) {
        return e in t;
      }
      function sf(e, t) {
        const i = t[e];
        return i === void 0 ? null : i;
      }
      function Pg(e, t) {
        switch (e) {
          case 'string':
            return String(t);
          case 'number':
            return +t;
          case 'boolean':
            return !!t;
          case 'color':
            return pe.parse(t);
        }
        return t;
      }
      function zg(e, t, i, r) {
        return r !== void 0 && (e = r * Math.round(e / r)), t !== void 0 && e < t && (e = t), i !== void 0 && e > i && (e = i), e;
      }
      function Dg(e, t, i) {
        i.length && (t += `${i}`);
        const r = e.getConfig(t);
        if (!r) return null;
        const { type: n, value: o, values: s, minValue: a, maxValue: l, stepValue: c } = r,
          u = r.default.evaluate(e);
        let h = o ? o.evaluate(e) : u;
        return n && (h = Pg(n, h)), o !== void 0 && h !== void 0 && s && !s.includes(h) && ((h = u), n && (h = Pg(n, h))), h === void 0 || (a === void 0 && l === void 0 && c === void 0) || (typeof h == 'number' ? (h = zg(h, a, l, c)) : Array.isArray(h) && (h = h.map((d) => (typeof d == 'number' ? zg(d, a, l, c) : d)))), h;
      }
      function fs(e) {
        return { type: e };
      }
      zn.register(Sg, {
        error: [
          { kind: 'error' },
          [Re],
          (e, [t]) => {
            throw new ir(t.evaluate(e));
          },
        ],
        typeof: [Re, [ke], (e, [t]) => Bi(Xi(t.evaluate(e)))],
        'to-rgba': [Cr(Nt, 4), [nn], (e, [t]) => t.evaluate(e).toArray()],
        rgb: [nn, [Nt, Nt, Nt], Ag],
        rgba: [nn, [Nt, Nt, Nt, Nt], Ag],
        hsl: [nn, [Nt, Nt, Nt], Ig],
        hsla: [nn, [Nt, Nt, Nt, Nt], Ig],
        has: {
          type: Fe,
          overloads: [
            [[Re], (e, [t]) => Cg(t.evaluate(e), e.properties())],
            [[Re, Js], (e, [t, i]) => Cg(t.evaluate(e), i.evaluate(e))],
          ],
        },
        get: {
          type: ke,
          overloads: [
            [[Re], (e, [t]) => sf(t.evaluate(e), e.properties())],
            [[Re, Js], (e, [t, i]) => sf(t.evaluate(e), i.evaluate(e))],
          ],
        },
        config: {
          type: ke,
          overloads: [
            [[Re], (e, [t]) => Dg(e, t.evaluate(e), '')],
            [[Re, Re], (e, [t, i]) => Dg(e, t.evaluate(e), i.evaluate(e))],
          ],
        },
        'feature-state': [ke, [Re], (e, [t]) => sf(t.evaluate(e), e.featureState || {})],
        properties: [Js, [], (e) => e.properties()],
        'geometry-type': [Re, [], (e) => e.geometryType()],
        id: [ke, [], (e) => e.id()],
        zoom: [Nt, [], (e) => e.globals.zoom],
        pitch: [Nt, [], (e) => e.globals.pitch || 0],
        'distance-from-center': [Nt, [], (e) => e.distanceFromCenter()],
        'measure-light': [Nt, [Re], (e, [t]) => e.measureLight(t.evaluate(e))],
        'heatmap-density': [Nt, [], (e) => e.globals.heatmapDensity || 0],
        'line-progress': [Nt, [], (e) => e.globals.lineProgress || 0],
        'raster-value': [Nt, [], (e) => e.globals.rasterValue || 0],
        'sky-radial-progress': [Nt, [], (e) => e.globals.skyRadialProgress || 0],
        accumulated: [ke, [], (e) => (e.globals.accumulated === void 0 ? null : e.globals.accumulated)],
        '+': [
          Nt,
          fs(Nt),
          (e, t) => {
            let i = 0;
            for (const r of t) i += r.evaluate(e);
            return i;
          },
        ],
        '*': [
          Nt,
          fs(Nt),
          (e, t) => {
            let i = 1;
            for (const r of t) i *= r.evaluate(e);
            return i;
          },
        ],
        '-': {
          type: Nt,
          overloads: [
            [[Nt, Nt], (e, [t, i]) => t.evaluate(e) - i.evaluate(e)],
            [[Nt], (e, [t]) => -t.evaluate(e)],
          ],
        },
        '/': [Nt, [Nt, Nt], (e, [t, i]) => t.evaluate(e) / i.evaluate(e)],
        '%': [Nt, [Nt, Nt], (e, [t, i]) => t.evaluate(e) % i.evaluate(e)],
        ln2: [Nt, [], () => Math.LN2],
        pi: [Nt, [], () => Math.PI],
        e: [Nt, [], () => Math.E],
        '^': [Nt, [Nt, Nt], (e, [t, i]) => Math.pow(t.evaluate(e), i.evaluate(e))],
        sqrt: [Nt, [Nt], (e, [t]) => Math.sqrt(t.evaluate(e))],
        log10: [Nt, [Nt], (e, [t]) => Math.log(t.evaluate(e)) / Math.LN10],
        ln: [Nt, [Nt], (e, [t]) => Math.log(t.evaluate(e))],
        log2: [Nt, [Nt], (e, [t]) => Math.log(t.evaluate(e)) / Math.LN2],
        sin: [Nt, [Nt], (e, [t]) => Math.sin(t.evaluate(e))],
        cos: [Nt, [Nt], (e, [t]) => Math.cos(t.evaluate(e))],
        tan: [Nt, [Nt], (e, [t]) => Math.tan(t.evaluate(e))],
        asin: [Nt, [Nt], (e, [t]) => Math.asin(t.evaluate(e))],
        acos: [Nt, [Nt], (e, [t]) => Math.acos(t.evaluate(e))],
        atan: [Nt, [Nt], (e, [t]) => Math.atan(t.evaluate(e))],
        min: [Nt, fs(Nt), (e, t) => Math.min(...t.map((i) => i.evaluate(e)))],
        max: [Nt, fs(Nt), (e, t) => Math.max(...t.map((i) => i.evaluate(e)))],
        abs: [Nt, [Nt], (e, [t]) => Math.abs(t.evaluate(e))],
        round: [
          Nt,
          [Nt],
          (e, [t]) => {
            const i = t.evaluate(e);
            return i < 0 ? -Math.round(-i) : Math.round(i);
          },
        ],
        floor: [Nt, [Nt], (e, [t]) => Math.floor(t.evaluate(e))],
        ceil: [Nt, [Nt], (e, [t]) => Math.ceil(t.evaluate(e))],
        'filter-==': [Fe, [Re, ke], (e, [t, i]) => e.properties()[t.value] === i.value],
        'filter-id-==': [Fe, [ke], (e, [t]) => e.id() === t.value],
        'filter-type-==': [Fe, [Re], (e, [t]) => e.geometryType() === t.value],
        'filter-<': [
          Fe,
          [Re, ke],
          (e, [t, i]) => {
            const r = e.properties()[t.value],
              n = i.value;
            return typeof r == typeof n && r < n;
          },
        ],
        'filter-id-<': [
          Fe,
          [ke],
          (e, [t]) => {
            const i = e.id(),
              r = t.value;
            return typeof i == typeof r && i < r;
          },
        ],
        'filter->': [
          Fe,
          [Re, ke],
          (e, [t, i]) => {
            const r = e.properties()[t.value],
              n = i.value;
            return typeof r == typeof n && r > n;
          },
        ],
        'filter-id->': [
          Fe,
          [ke],
          (e, [t]) => {
            const i = e.id(),
              r = t.value;
            return typeof i == typeof r && i > r;
          },
        ],
        'filter-<=': [
          Fe,
          [Re, ke],
          (e, [t, i]) => {
            const r = e.properties()[t.value],
              n = i.value;
            return typeof r == typeof n && r <= n;
          },
        ],
        'filter-id-<=': [
          Fe,
          [ke],
          (e, [t]) => {
            const i = e.id(),
              r = t.value;
            return typeof i == typeof r && i <= r;
          },
        ],
        'filter->=': [
          Fe,
          [Re, ke],
          (e, [t, i]) => {
            const r = e.properties()[t.value],
              n = i.value;
            return typeof r == typeof n && r >= n;
          },
        ],
        'filter-id->=': [
          Fe,
          [ke],
          (e, [t]) => {
            const i = e.id(),
              r = t.value;
            return typeof i == typeof r && i >= r;
          },
        ],
        'filter-has': [Fe, [ke], (e, [t]) => t.value in e.properties()],
        'filter-has-id': [Fe, [], (e) => e.id() !== null && e.id() !== void 0],
        'filter-type-in': [Fe, [Cr(Re)], (e, [t]) => t.value.indexOf(e.geometryType()) >= 0],
        'filter-id-in': [Fe, [Cr(ke)], (e, [t]) => t.value.indexOf(e.id()) >= 0],
        'filter-in-small': [Fe, [Re, Cr(ke)], (e, [t, i]) => i.value.indexOf(e.properties()[t.value]) >= 0],
        'filter-in-large': [
          Fe,
          [Re, Cr(ke)],
          (e, [t, i]) =>
            (function (r, n, o, s) {
              for (; o <= s; ) {
                const a = (o + s) >> 1;
                if (n[a] === r) return !0;
                n[a] > r ? (s = a - 1) : (o = a + 1);
              }
              return !1;
            })(e.properties()[t.value], i.value, 0, i.value.length - 1),
        ],
        all: {
          type: Fe,
          overloads: [
            [[Fe, Fe], (e, [t, i]) => t.evaluate(e) && i.evaluate(e)],
            [
              fs(Fe),
              (e, t) => {
                for (const i of t) if (!i.evaluate(e)) return !1;
                return !0;
              },
            ],
          ],
        },
        any: {
          type: Fe,
          overloads: [
            [[Fe, Fe], (e, [t, i]) => t.evaluate(e) || i.evaluate(e)],
            [
              fs(Fe),
              (e, t) => {
                for (const i of t) if (i.evaluate(e)) return !0;
                return !1;
              },
            ],
          ],
        },
        '!': [Fe, [Fe], (e, [t]) => !t.evaluate(e)],
        'is-supported-script': [
          Fe,
          [Re],
          (e, [t]) => {
            const i = e.globals && e.globals.isSupportedScript;
            return !i || i(t.evaluate(e));
          },
        ],
        upcase: [Re, [Re], (e, [t]) => t.evaluate(e).toUpperCase()],
        downcase: [Re, [Re], (e, [t]) => t.evaluate(e).toLowerCase()],
        concat: [Re, fs(ke), (e, t) => t.map((i) => rl(i.evaluate(e))).join('')],
        'resolved-locale': [Re, [Ec], (e, [t]) => t.evaluate(e).resolvedLocale()],
        random: [
          Nt,
          [Nt, Nt, ke],
          (e, t) => {
            const [i, r, n] = t.map((s) => s.evaluate(e));
            if (i > r || i === r) return i;
            let o;
            if (typeof n == 'string')
              o = (function (s) {
                let a = 0;
                if (s.length === 0) return a;
                for (let l = 0; l < s.length; l++) (a = (a << 5) - a + s.charCodeAt(l)), (a &= a);
                return a;
              })(n);
            else {
              if (typeof n != 'number') throw new ir(`Invalid seed input: ${n}`);
              o = n;
            }
            return i + of(o)() * (r - i);
          },
        ],
      });
      var pl = Sg;
      function Rg(e) {
        return { result: 'success', value: e };
      }
      function ps(e) {
        return { result: 'error', value: e };
      }
      function Lg(e, t) {
        return !!e && !!e.parameters && e.parameters.indexOf(t) > -1;
      }
      function ms(e) {
        return e['property-type'] === 'data-driven';
      }
      function kg(e) {
        return Lg(e.expression, 'measure-light');
      }
      function af(e) {
        return Lg(e.expression, 'zoom');
      }
      function lf(e) {
        return !!e.expression && e.expression.interpolated;
      }
      function Fc(e) {
        return typeof e == 'object' && e !== null && !Array.isArray(e);
      }
      function iM(e) {
        return e;
      }
      function Og(e, t) {
        const i = t.type === 'color',
          r = e.stops && typeof e.stops[0][0] == 'object',
          n = r || !(r || e.property !== void 0),
          o = e.type || (lf(t) ? 'exponential' : 'interval');
        if ((i && ((e = Qn({}, e)).stops && (e.stops = e.stops.map((c) => [c[0], pe.parse(c[1])])), (e.default = pe.parse(e.default ? e.default : t.default))), e.colorSpace && e.colorSpace !== 'rgb' && !bg[e.colorSpace])) throw new Error(`Unknown color space: ${e.colorSpace}`);
        let s, a, l;
        if (o === 'exponential') s = Bg;
        else if (o === 'interval') s = nM;
        else if (o === 'categorical') {
          (s = rM), (a = Object.create(null));
          for (const c of e.stops) a[c[0]] = c[1];
          l = typeof e.stops[0][0];
        } else {
          if (o !== 'identity') throw new Error(`Unknown function type "${o}"`);
          s = oM;
        }
        if (r) {
          const c = {},
            u = [];
          for (let f = 0; f < e.stops.length; f++) {
            const p = e.stops[f],
              _ = p[0].zoom;
            c[_] === void 0 && ((c[_] = { zoom: _, type: e.type, property: e.property, default: e.default, stops: [] }), u.push(_)), c[_].stops.push([p[0].value, p[1]]);
          }
          const h = [];
          for (const f of u) h.push([c[f].zoom, Og(c[f], t)]);
          const d = { name: 'linear' };
          return { kind: 'composite', interpolationType: d, interpolationFactor: Dn.interpolationFactor.bind(void 0, d), zoomStops: h.map((f) => f[0]), evaluate: ({ zoom: f }, p) => Bg({ stops: h, base: e.base }, t, f).evaluate(f, p) };
        }
        if (n) {
          const c = o === 'exponential' ? { name: 'exponential', base: e.base !== void 0 ? e.base : 1 } : null;
          return { kind: 'camera', interpolationType: c, interpolationFactor: Dn.interpolationFactor.bind(void 0, c), zoomStops: e.stops.map((u) => u[0]), evaluate: ({ zoom: u }) => s(e, t, u, a, l) };
        }
        return {
          kind: 'source',
          evaluate(c, u) {
            const h = u && u.properties ? u.properties[e.property] : void 0;
            return h === void 0 ? ml(e.default, t.default) : s(e, t, h, a, l);
          },
        };
      }
      function ml(e, t, i) {
        return e !== void 0 ? e : t !== void 0 ? t : i !== void 0 ? i : void 0;
      }
      function rM(e, t, i, r, n) {
        return ml(typeof i === n ? r[i] : void 0, e.default, t.default);
      }
      function nM(e, t, i) {
        if ($e(i) !== 'number') return ml(e.default, t.default);
        const r = e.stops.length;
        if (r === 1 || i <= e.stops[0][0]) return e.stops[0][1];
        if (i >= e.stops[r - 1][0]) return e.stops[r - 1][1];
        const n = Rc(
          e.stops.map((o) => o[0]),
          i
        );
        return e.stops[n][1];
      }
      function Bg(e, t, i) {
        const r = e.base !== void 0 ? e.base : 1;
        if ($e(i) !== 'number') return ml(e.default, t.default);
        const n = e.stops.length;
        if (n === 1 || i <= e.stops[0][0]) return e.stops[0][1];
        if (i >= e.stops[n - 1][0]) return e.stops[n - 1][1];
        const o = Rc(
            e.stops.map((u) => u[0]),
            i
          ),
          s = (function (u, h, d, f) {
            const p = f - d,
              _ = u - d;
            return p === 0 ? 0 : h === 1 ? _ / p : (Math.pow(h, _) - 1) / (Math.pow(h, p) - 1);
          })(i, r, e.stops[o][0], e.stops[o + 1][0]),
          a = e.stops[o][1],
          l = e.stops[o + 1][1];
        let c = Lc[t.type] || iM;
        if (e.colorSpace && e.colorSpace !== 'rgb') {
          const u = bg[e.colorSpace];
          c = (h, d) => u.reverse(u.interpolate(u.forward(h), u.forward(d), s));
        }
        return typeof a.evaluate == 'function'
          ? {
              evaluate(...u) {
                const h = a.evaluate.apply(void 0, u),
                  d = l.evaluate.apply(void 0, u);
                if (h !== void 0 && d !== void 0) return c(h, d, s);
              },
            }
          : c(a, l, s);
      }
      function oM(e, t, i) {
        return t.type === 'color' ? (i = pe.parse(i)) : t.type === 'formatted' ? (i = zr.fromString(i.toString())) : t.type === 'resolvedImage' ? (i = on.fromString(i.toString())) : $e(i) === t.type || (t.type === 'enum' && t.values[i]) || (i = void 0), ml(i, e.default, t.default);
      }
      class cf {
        constructor(t, i, r) {
          (this.expression = t),
            (this._warningHistory = {}),
            (this._evaluator = new Y_(r)),
            (this._defaultValue = i
              ? (function (n) {
                  return n.type === 'color' && (Fc(n.default) || Array.isArray(n.default)) ? new pe(0, 0, 0, 0) : n.type === 'color' ? pe.parse(n.default) || null : n.default === void 0 ? null : n.default;
                })(i)
              : null),
            (this._enumValues = i && i.type === 'enum' ? i.values : null);
        }
        evaluateWithoutErrorHandling(t, i, r, n, o, s, a, l) {
          return (this._evaluator.globals = t), (this._evaluator.feature = i), (this._evaluator.featureState = r), (this._evaluator.canonical = n || null), (this._evaluator.availableImages = o || null), (this._evaluator.formattedSection = s), (this._evaluator.featureTileCoord = a || null), (this._evaluator.featureDistanceData = l || null), this.expression.evaluate(this._evaluator);
        }
        evaluate(t, i, r, n, o, s, a, l) {
          (this._evaluator.globals = t), (this._evaluator.feature = i || null), (this._evaluator.featureState = r || null), (this._evaluator.canonical = n || null), (this._evaluator.availableImages = o || null), (this._evaluator.formattedSection = s || null), (this._evaluator.featureTileCoord = a || null), (this._evaluator.featureDistanceData = l || null);
          try {
            const c = this.expression.evaluate(this._evaluator);
            if (c == null || (typeof c == 'number' && c != c)) return this._defaultValue;
            if (this._enumValues && !(c in this._enumValues))
              throw new ir(
                `Expected value to be one of ${Object.keys(this._enumValues)
                  .map((u) => JSON.stringify(u))
                  .join(', ')}, but found ${JSON.stringify(c)} instead.`
              );
            return c;
          } catch (c) {
            return this._warningHistory[c.message] || ((this._warningHistory[c.message] = !0), typeof console < 'u' && console.warn(c.message)), this._defaultValue;
          }
        }
      }
      function Nc(e) {
        return Array.isArray(e) && e.length > 0 && typeof e[0] == 'string' && e[0] in pl;
      }
      function So(e, t, i) {
        const r = new fg(
            pl,
            [],
            t
              ? (function (o) {
                  const s = { color: nn, string: Re, number: Nt, enum: Re, boolean: Fe, formatted: Qa, resolvedImage: tl };
                  return o.type === 'array' ? Cr(s[o.value] || ke, o.length) : s[o.type];
                })(t)
              : void 0,
            void 0,
            void 0,
            i
          ),
          n = r.parse(e, void 0, void 0, void 0, t && t.type === 'string' ? { typeAnnotation: 'coerce' } : void 0);
        return n ? Rg(new cf(n, t, i)) : ps(r.errors);
      }
      class uf {
        constructor(t, i, r) {
          (this.kind = t), (this._styleExpression = i), (this.isLightConstant = r), (this.isStateDependent = t !== 'constant' && !hl(i.expression)), (this.isConfigDependent = !Nd(i.expression));
        }
        evaluateWithoutErrorHandling(t, i, r, n, o, s) {
          return this._styleExpression.evaluateWithoutErrorHandling(t, i, r, n, o, s);
        }
        evaluate(t, i, r, n, o, s) {
          return this._styleExpression.evaluate(t, i, r, n, o, s);
        }
      }
      class Ao {
        constructor(t, i, r, n, o) {
          (this.kind = t), (this.zoomStops = r), (this._styleExpression = i), (this.isStateDependent = t !== 'camera' && !hl(i.expression)), (this.isLightConstant = o), (this.isConfigDependent = !Nd(i.expression)), (this.interpolationType = n);
        }
        evaluateWithoutErrorHandling(t, i, r, n, o, s) {
          return this._styleExpression.evaluateWithoutErrorHandling(t, i, r, n, o, s);
        }
        evaluate(t, i, r, n, o, s) {
          return this._styleExpression.evaluate(t, i, r, n, o, s);
        }
        interpolationFactor(t, i, r) {
          return this.interpolationType ? Dn.interpolationFactor(this.interpolationType, t, i, r) : 0;
        }
      }
      function hf(e, t, i) {
        if ((e = So(e, t, i)).result === 'error') return e;
        const r = e.value.expression,
          n = ia(r);
        if (!n && !ms(t)) return ps([new Pn('', 'data expressions not supported')]);
        const o = ra(r, ['zoom', 'pitch', 'distance-from-center']);
        if (!o && !af(t)) return ps([new Pn('', 'zoom expressions not supported')]);
        const s = ra(r, ['measure-light']);
        if (!s && !kg(t)) return ps([new Pn('', 'measure-light expression not supported')]);
        const a = t.expression && t.expression.relaxZoomRestriction,
          l = Vc(r);
        return l || o || a ? (l instanceof Pn ? ps([l]) : l instanceof Dn && !lf(t) ? ps([new Pn('', '"interpolate" expressions cannot be used with this property')]) : Rg(l ? new Ao(n ? 'camera' : 'composite', e.value, l.labels, l instanceof Dn ? l.interpolation : void 0, s) : new uf(n ? 'constant' : 'source', e.value, s))) : ps([new Pn('', '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression, or in the properties of atmosphere.')]);
      }
      class Uc {
        constructor(t, i) {
          (this._parameters = t), (this._specification = i), Qn(this, Og(this._parameters, this._specification));
        }
        static deserialize(t) {
          return new Uc(t._parameters, t._specification);
        }
        static serialize(t) {
          return { _parameters: t._parameters, _specification: t._specification };
        }
      }
      function Vc(e) {
        let t = null;
        if (e instanceof Tg) t = Vc(e.result);
        else if (e instanceof wg) {
          for (const i of e.args) if (((t = Vc(i)), t)) break;
        } else (e instanceof qd || e instanceof Dn) && e.input instanceof zn && e.input.name === 'zoom' && (t = e);
        return (
          t instanceof Pn ||
            e.eachChild((i) => {
              const r = Vc(i);
              r instanceof Pn ? (t = r) : t && r && t !== r && (t = new Pn('', 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
            }),
          t
        );
      }
      function sn(e) {
        const t = e.key,
          i = e.value,
          r = e.valueSpec || {},
          n = e.objectElementValidators || {},
          o = e.style,
          s = e.styleSpec;
        let a = [];
        const l = $e(i);
        if (l !== 'object') return [new Vt(t, i, `object expected, ${l} found`)];
        for (const c in i) {
          const u = c.split('.')[0];
          let h;
          n[u] ? (h = n[u]) : r[u] ? (h = or) : n['*'] ? (h = n['*']) : r['*'] && (h = or), h ? (a = a.concat(h({ key: (t && `${t}.`) + c, value: i[c], valueSpec: r[u] || r['*'], style: o, styleSpec: s, object: i, objectKey: c }, i))) : a.push(new cs(t, i[c], `unknown property "${c}"`));
        }
        for (const c in r) n[c] || (r[c].required && r[c].default === void 0 && i[c] === void 0 && a.push(new Vt(t, i, `missing required property "${c}"`)));
        return a;
      }
      function Fg(e) {
        const t = e.value,
          i = e.valueSpec,
          r = e.style,
          n = e.styleSpec,
          o = e.key,
          s = e.arrayElementValidator || or;
        if ($e(t) !== 'array') return [new Vt(o, t, `array expected, ${$e(t)} found`)];
        if (i.length && t.length !== i.length) return [new Vt(o, t, `array length ${i.length} expected, length ${t.length} found`)];
        if (i['min-length'] && t.length < i['min-length']) return [new Vt(o, t, `array length at least ${i['min-length']} expected, length ${t.length} found`)];
        let a = { type: i.value, values: i.values, minimum: i.minimum, maximum: i.maximum, function: void 0 };
        n.$version < 7 && (a.function = i.function), $e(i.value) === 'object' && (a = i.value);
        let l = [];
        for (let c = 0; c < t.length; c++) l = l.concat(s({ array: t, arrayIndex: c, value: t[c], valueSpec: a, style: r, styleSpec: n, key: `${o}[${c}]` }, !0));
        return l;
      }
      function Ng(e) {
        const t = e.key,
          i = e.value,
          r = e.valueSpec;
        let n = $e(i);
        if ((n === 'number' && i != i && (n = 'NaN'), n !== 'number')) return [new Vt(t, i, `number expected, ${n} found`)];
        if ('minimum' in r) {
          let o = r.minimum;
          if (($e(r.minimum) === 'array' && (o = r.minimum[e.arrayIndex]), i < o)) return [new Vt(t, i, `${i} is less than the minimum value ${o}`)];
        }
        if ('maximum' in r) {
          let o = r.maximum;
          if (($e(r.maximum) === 'array' && (o = r.maximum[e.arrayIndex]), i > o)) return [new Vt(t, i, `${i} is greater than the maximum value ${o}`)];
        }
        return [];
      }
      function Ug(e) {
        const t = e.valueSpec,
          i = Gi(e.value.type);
        let r,
          n,
          o,
          s = {};
        const a = i !== 'categorical' && e.value.property === void 0,
          l = !a,
          c = $e(e.value.stops) === 'array' && $e(e.value.stops[0]) === 'array' && $e(e.value.stops[0][0]) === 'object',
          u = sn({
            key: e.key,
            value: e.value,
            valueSpec: e.styleSpec.function,
            style: e.style,
            styleSpec: e.styleSpec,
            objectElementValidators: {
              stops: function (f) {
                if (i === 'identity') return [new Vt(f.key, f.value, 'identity function may not have a "stops" property')];
                let p = [];
                const _ = f.value;
                return (p = p.concat(Fg({ key: f.key, value: _, valueSpec: f.valueSpec, style: f.style, styleSpec: f.styleSpec, arrayElementValidator: h }))), $e(_) === 'array' && _.length === 0 && p.push(new Vt(f.key, _, 'array must have at least one stop')), p;
              },
              default: function (f) {
                return or({ key: f.key, value: f.value, valueSpec: t, style: f.style, styleSpec: f.styleSpec });
              },
            },
          });
        return i === 'identity' && a && u.push(new Vt(e.key, e.value, 'missing required property "property"')), i === 'identity' || e.value.stops || u.push(new Vt(e.key, e.value, 'missing required property "stops"')), i === 'exponential' && e.valueSpec.expression && !lf(e.valueSpec) && u.push(new Vt(e.key, e.value, 'exponential functions not supported')), e.styleSpec.$version >= 8 && (l && !ms(e.valueSpec) ? u.push(new Vt(e.key, e.value, 'property functions not supported')) : a && !af(e.valueSpec) && u.push(new Vt(e.key, e.value, 'zoom functions not supported'))), (i !== 'categorical' && !c) || e.value.property !== void 0 || u.push(new Vt(e.key, e.value, '"property" property is required')), u;
        function h(f) {
          let p = [];
          const _ = f.value,
            g = f.key;
          if ($e(_) !== 'array') return [new Vt(g, _, `array expected, ${$e(_)} found`)];
          if (_.length !== 2) return [new Vt(g, _, `array length 2 expected, length ${_.length} found`)];
          if (c) {
            if ($e(_[0]) !== 'object') return [new Vt(g, _, `object expected, ${$e(_[0])} found`)];
            if (_[0].zoom === void 0) return [new Vt(g, _, 'object stop key must have zoom')];
            if (_[0].value === void 0) return [new Vt(g, _, 'object stop key must have value')];
            const y = Gi(_[0].zoom);
            if (typeof y != 'number') return [new Vt(g, _[0].zoom, 'stop zoom values must be numbers')];
            if (o && o > y) return [new Vt(g, _[0].zoom, 'stop zoom values must appear in ascending order')];
            y !== o && ((o = y), (n = void 0), (s = {})), (p = p.concat(sn({ key: `${g}[0]`, value: _[0], valueSpec: { zoom: {} }, style: f.style, styleSpec: f.styleSpec, objectElementValidators: { zoom: Ng, value: d } })));
          } else p = p.concat(d({ key: `${g}[0]`, value: _[0], valueSpec: {}, style: f.style, styleSpec: f.styleSpec }, _));
          return Nc(to(_[1])) ? p.concat([new Vt(`${g}[1]`, _[1], 'expressions are not allowed in function stops.')]) : p.concat(or({ key: `${g}[1]`, value: _[1], valueSpec: t, style: f.style, styleSpec: f.styleSpec }));
        }
        function d(f, p) {
          const _ = $e(f.value),
            g = Gi(f.value),
            y = f.value !== null ? f.value : p;
          if (r) {
            if (_ !== r) return [new Vt(f.key, y, `${_} stop domain type must match previous stop domain type ${r}`)];
          } else r = _;
          if (_ !== 'number' && _ !== 'string' && _ !== 'boolean' && typeof g != 'number' && typeof g != 'string' && typeof g != 'boolean') return [new Vt(f.key, y, 'stop domain value must be a number, string, or boolean')];
          if (_ !== 'number' && i !== 'categorical') {
            let v = `number expected, ${_} found`;
            return ms(t) && i === void 0 && (v += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new Vt(f.key, y, v)];
          }
          return i !== 'categorical' || _ !== 'number' || (typeof g == 'number' && isFinite(g) && Math.floor(g) === g) ? (i !== 'categorical' && _ === 'number' && typeof g == 'number' && typeof n == 'number' && n !== void 0 && g < n ? [new Vt(f.key, y, 'stop domain values must appear in ascending order')] : ((n = g), i === 'categorical' && g in s ? [new Vt(f.key, y, 'stop domain values must be unique')] : ((s[g] = !0), []))) : [new Vt(f.key, y, `integer expected, found ${String(g)}`)];
        }
      }
      function _s(e) {
        const t = (e.expressionContext === 'property' ? hf : So)(to(e.value), e.valueSpec);
        if (t.result === 'error') return t.value.map((r) => new Vt(`${e.key}${r.key}`, e.value, r.message));
        const i = t.value.expression || t.value._styleExpression.expression;
        if (e.expressionContext === 'property' && e.propertyKey === 'text-font' && !i.outputDefined()) return [new Vt(e.key, e.value, `Invalid data expression for "${e.propertyKey}". Output values must be contained as literals within the expression.`)];
        if (e.expressionContext === 'property' && e.propertyType === 'layout' && !hl(i)) return [new Vt(e.key, e.value, '"feature-state" data expressions are not supported with layout properties.')];
        if (e.expressionContext === 'filter') return Vg(i, e);
        if (e.expressionContext && e.expressionContext.indexOf('cluster') === 0) {
          if (!ra(i, ['zoom', 'feature-state'])) return [new Vt(e.key, e.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
          if (e.expressionContext === 'cluster-initial' && !ia(i)) return [new Vt(e.key, e.value, 'Feature data expressions are not supported with initial expression part of cluster properties.')];
        }
        return [];
      }
      function Vg(e, t) {
        const i = new Set(['zoom', 'feature-state', 'pitch', 'distance-from-center']);
        if (t.valueSpec && t.valueSpec.expression) for (const n of t.valueSpec.expression.parameters) i.delete(n);
        if (i.size === 0) return [];
        const r = [];
        return e instanceof zn && i.has(e.name)
          ? [new Vt(t.key, t.value, `["${e.name}"] expression is not supported in a filter for a ${t.object.type} layer with id: ${t.object.id}`)]
          : (e.eachChild((n) => {
              r.push(...Vg(n, t));
            }),
            r);
      }
      function jc(e) {
        const t = e.key,
          i = e.value,
          r = e.valueSpec,
          n = [];
        return Array.isArray(r.values) ? r.values.indexOf(Gi(i)) === -1 && n.push(new Vt(t, i, `expected one of [${r.values.join(', ')}], ${JSON.stringify(i)} found`)) : Object.keys(r.values).indexOf(Gi(i)) === -1 && n.push(new Vt(t, i, `expected one of [${Object.keys(r.values).join(', ')}], ${JSON.stringify(i)} found`)), n;
      }
      function df(e) {
        if (e === !0 || e === !1) return !0;
        if (!Array.isArray(e) || e.length === 0) return !1;
        switch (e[0]) {
          case 'has':
            return e.length >= 2 && e[1] !== '$id' && e[1] !== '$type';
          case 'in':
            return e.length >= 3 && (typeof e[1] != 'string' || Array.isArray(e[2]));
          case '!in':
          case '!has':
          case 'none':
            return !1;
          case '==':
          case '!=':
          case '>':
          case '>=':
          case '<':
          case '<=':
            return e.length !== 3 || Array.isArray(e[1]) || Array.isArray(e[2]);
          case 'any':
          case 'all':
            for (const t of e.slice(1)) if (!df(t) && typeof t != 'boolean') return !1;
            return !0;
          default:
            return !0;
        }
      }
      function Gc(e, t = 'fill') {
        if (e == null) return { filter: () => !0, needGeometry: !1, needFeature: !1 };
        df(e) || (e = qc(e));
        const i = e;
        let r = !0;
        try {
          r = (function (c) {
            if (!sa(c)) return c;
            let u = to(c);
            return Gg(u), (u = jg(u)), u;
          })(i);
        } catch {
          console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.
This is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md
and paste the contents of this message in the report.
Thank you!
Filter Expression:
${JSON.stringify(i, null, 2)}
        `);
        }
        const n = Q[`filter_${t}`],
          o = So(r, n);
        let s = null;
        if (o.result === 'error') throw new Error(o.value.map((c) => `${c.key}: ${c.message}`).join(', '));
        s = (c, u, h) => o.value.evaluate(c, u, {}, h);
        let a = null,
          l = null;
        if (r !== i) {
          const c = So(i, n);
          if (c.result === 'error') throw new Error(c.value.map((u) => `${u.key}: ${u.message}`).join(', '));
          (a = (u, h, d, f, p) => c.value.evaluate(u, h, {}, d, void 0, void 0, f, p)), (l = !ia(c.value.expression));
        }
        return { filter: s, dynamicFilter: a || void 0, needGeometry: qg(r), needFeature: !!l };
      }
      function jg(e) {
        if (!Array.isArray(e)) return e;
        const t = (function (i) {
          if (sM.has(i[0])) {
            for (let r = 1; r < i.length; r++) if (sa(i[r])) return !0;
          }
          return i;
        })(e);
        return t === !0 ? t : t.map((i) => jg(i));
      }
      function Gg(e) {
        let t = !1;
        const i = [];
        if (e[0] === 'case') {
          for (let r = 1; r < e.length - 1; r += 2) (t = t || sa(e[r])), i.push(e[r + 1]);
          i.push(e[e.length - 1]);
        } else if (e[0] === 'match') {
          t = t || sa(e[1]);
          for (let r = 2; r < e.length - 1; r += 2) i.push(e[r + 1]);
          i.push(e[e.length - 1]);
        } else if (e[0] === 'step') {
          t = t || sa(e[1]);
          for (let r = 1; r < e.length - 1; r += 2) i.push(e[r + 1]);
        }
        t && ((e.length = 0), e.push('any', ...i));
        for (let r = 1; r < e.length; r++) Gg(e[r]);
      }
      function sa(e) {
        if (!Array.isArray(e)) return !1;
        if ((t = e[0]) === 'pitch' || t === 'distance-from-center') return !0;
        var t;
        for (let i = 1; i < e.length; i++) if (sa(e[i])) return !0;
        return !1;
      }
      const sM = new Set(['in', '==', '!=', '>', '>=', '<', '<=', 'to-boolean']);
      function aM(e, t) {
        return e < t ? -1 : e > t ? 1 : 0;
      }
      function qg(e) {
        if (!Array.isArray(e)) return !1;
        if (e[0] === 'within' || e[0] === 'distance') return !0;
        for (let t = 1; t < e.length; t++) if (qg(e[t])) return !0;
        return !1;
      }
      function qc(e) {
        if (!e) return !0;
        const t = e[0];
        return e.length <= 1 ? t !== 'any' : t === '==' ? ff(e[1], e[2], '==') : t === '!=' ? Zc(ff(e[1], e[2], '==')) : t === '<' || t === '>' || t === '<=' || t === '>=' ? ff(e[1], e[2], t) : t === 'any' ? ((i = e.slice(1)), ['any'].concat(i.map(qc))) : t === 'all' ? ['all'].concat(e.slice(1).map(qc)) : t === 'none' ? ['all'].concat(e.slice(1).map(qc).map(Zc)) : t === 'in' ? Zg(e[1], e.slice(2)) : t === '!in' ? Zc(Zg(e[1], e.slice(2))) : t === 'has' ? $g(e[1]) : t !== '!has' || Zc($g(e[1]));
        var i;
      }
      function ff(e, t, i) {
        switch (e) {
          case '$type':
            return [`filter-type-${i}`, t];
          case '$id':
            return [`filter-id-${i}`, t];
          default:
            return [`filter-${i}`, e, t];
        }
      }
      function Zg(e, t) {
        if (t.length === 0) return !1;
        switch (e) {
          case '$type':
            return ['filter-type-in', ['literal', t]];
          case '$id':
            return ['filter-id-in', ['literal', t]];
          default:
            return t.length > 200 && !t.some((i) => typeof i != typeof t[0]) ? ['filter-in-large', e, ['literal', t.sort(aM)]] : ['filter-in-small', e, ['literal', t]];
        }
      }
      function $g(e) {
        switch (e) {
          case '$type':
            return !0;
          case '$id':
            return ['filter-has-id'];
          default:
            return ['filter-has', e];
        }
      }
      function Zc(e) {
        return ['!', e];
      }
      function pf(e) {
        return df(to(e.value)) ? _s(Qn({}, e, { expressionContext: 'filter', valueSpec: e.styleSpec[`filter_${e.layerType || 'fill'}`] })) : Hg(e);
      }
      function Hg(e) {
        const t = e.value,
          i = e.key;
        if ($e(t) !== 'array') return [new Vt(i, t, `array expected, ${$e(t)} found`)];
        const r = e.styleSpec;
        let n,
          o = [];
        if (t.length < 1) return [new Vt(i, t, 'filter array must have at least 1 element')];
        switch (((o = o.concat(jc({ key: `${i}[0]`, value: t[0], valueSpec: r.filter_operator, style: e.style, styleSpec: e.styleSpec }))), Gi(t[0]))) {
          case '<':
          case '<=':
          case '>':
          case '>=':
            t.length >= 2 && Gi(t[1]) === '$type' && o.push(new Vt(i, t, `"$type" cannot be use with operator "${t[0]}"`));
          case '==':
          case '!=':
            t.length !== 3 && o.push(new Vt(i, t, `filter array for operator "${t[0]}" must have 3 elements`));
          case 'in':
          case '!in':
            t.length >= 2 && ((n = $e(t[1])), n !== 'string' && o.push(new Vt(`${i}[1]`, t[1], `string expected, ${n} found`)));
            for (let s = 2; s < t.length; s++) (n = $e(t[s])), Gi(t[1]) === '$type' ? (o = o.concat(jc({ key: `${i}[${s}]`, value: t[s], valueSpec: r.geometry_type, style: e.style, styleSpec: e.styleSpec }))) : n !== 'string' && n !== 'number' && n !== 'boolean' && o.push(new Vt(`${i}[${s}]`, t[s], `string, number, or boolean expected, ${n} found`));
            break;
          case 'any':
          case 'all':
          case 'none':
            for (let s = 1; s < t.length; s++) o = o.concat(Hg({ key: `${i}[${s}]`, value: t[s], style: e.style, styleSpec: e.styleSpec }));
            break;
          case 'has':
          case '!has':
            (n = $e(t[1])), t.length !== 2 ? o.push(new Vt(i, t, `filter array for "${t[0]}" operator must have 2 elements`)) : n !== 'string' && o.push(new Vt(`${i}[1]`, t[1], `string expected, ${n} found`));
        }
        return o;
      }
      function Wg(e, t) {
        const i = e.key,
          r = e.style,
          n = e.layer,
          o = e.styleSpec,
          s = e.value,
          a = e.objectKey,
          l = o[`${t}_${e.layerType}`];
        if (!l) return [];
        const c = a.match(/^(.*)-transition$/);
        if (t === 'paint' && c && l[c[1]] && l[c[1]].transition) return or({ key: i, value: s, valueSpec: o.transition, style: r, styleSpec: o });
        const u = e.valueSpec || l[a];
        if (!u) return [new cs(i, s, `unknown property "${a}"`)];
        let h;
        if ($e(s) === 'string' && ms(u) && !u.tokens && (h = /^{([^}]+)}$/.exec(s))) {
          const f = `\`{ "type": "identity", "property": ${h ? JSON.stringify(h[1]) : '"_"'} }\``;
          return [
            new Vt(
              i,
              s,
              `"${a}" does not support interpolation syntax
Use an identity property function instead: ${f}.`
            ),
          ];
        }
        const d = [];
        if (e.layerType === 'symbol') a !== 'text-field' || !r || r.glyphs || r.imports || d.push(new Vt(i, s, 'use of "text-field" requires a style "glyphs" property')), a === 'text-font' && Fc(to(s)) && Gi(s.type) === 'identity' && d.push(new Vt(i, s, '"text-font" does not support identity functions'));
        else if (e.layerType === 'model' && t === 'paint' && n && n.layout && n.layout.hasOwnProperty('model-id') && ms(u) && (kg(u) || af(u))) {
          const f = hf(to(s), u),
            p = f.value.expression || f.value._styleExpression.expression;
          p && !ra(p, ['measure-light']) && ((a === 'model-emissive-strength' && ia(p) && hl(p)) || d.push(new Vt(i, s, `${a} does not support measure-light expressions when the model layer source is vector tile or GeoJSON.`)));
        }
        return d.concat(or({ key: e.key, value: s, valueSpec: u, style: r, styleSpec: o, expressionContext: 'property', propertyType: t, propertyKey: a }));
      }
      function Xg(e) {
        return Wg(e, 'paint');
      }
      function Yg(e) {
        return Wg(e, 'layout');
      }
      function Kg(e) {
        let t = [];
        const i = e.value,
          r = e.key,
          n = e.style,
          o = e.styleSpec;
        i.type || i.ref || t.push(new Vt(r, i, 'either "type" or "ref" is required'));
        let s = Gi(i.type);
        const a = Gi(i.ref);
        if (i.id) {
          const l = Gi(i.id);
          for (let c = 0; c < e.arrayIndex; c++) {
            const u = n.layers[c];
            Gi(u.id) === l && t.push(new Vt(r, i.id, `duplicate layer id "${i.id}", previously used at line ${u.id.__line__}`));
          }
        }
        if ('ref' in i) {
          let l;
          ['type', 'source', 'source-layer', 'filter', 'layout'].forEach((c) => {
            c in i && t.push(new Vt(r, i[c], `"${c}" is prohibited for ref layers`));
          }),
            n.layers.forEach((c) => {
              Gi(c.id) === a && (l = c);
            }),
            l ? (l.ref ? t.push(new Vt(r, i.ref, 'ref cannot reference another ref layer')) : (s = Gi(l.type))) : typeof a == 'string' && t.push(new Vt(r, i.ref, `ref layer "${a}" not found`));
        } else if (s !== 'background' && s !== 'sky' && s !== 'slot')
          if (i.source) {
            const l = n.sources && n.sources[i.source],
              c = l && Gi(l.type);
            l ? (c === 'vector' && s === 'raster' ? t.push(new Vt(r, i.source, `layer "${i.id}" requires a raster source`)) : c === 'raster' && s !== 'raster' ? t.push(new Vt(r, i.source, `layer "${i.id}" requires a vector source`)) : c !== 'vector' || i['source-layer'] ? (c === 'raster-dem' && s !== 'hillshade' ? t.push(new Vt(r, i.source, "raster-dem source can only be used with layer type 'hillshade'.")) : s !== 'line' || !i.paint || (!i.paint['line-gradient'] && !i.paint['line-trim-offset']) || (c === 'geojson' && l.lineMetrics) || t.push(new Vt(r, i, `layer "${i.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`))) : t.push(new Vt(r, i, `layer "${i.id}" must specify a "source-layer"`))) : t.push(new Vt(r, i.source, `source "${i.source}" not found`));
          } else t.push(new Vt(r, i, 'missing required property "source"'));
        return (t = t.concat(sn({ key: r, value: i, valueSpec: o.layer, style: e.style, styleSpec: e.styleSpec, objectElementValidators: { '*': () => [], type: () => or({ key: `${r}.type`, value: i.type, valueSpec: o.layer.type, style: e.style, styleSpec: e.styleSpec, object: i, objectKey: 'type' }), filter: (l) => pf(Qn({ layerType: s }, l)), layout: (l) => sn({ layer: i, key: l.key, value: l.value, valueSpec: {}, style: l.style, styleSpec: l.styleSpec, objectElementValidators: { '*': (c) => Yg(Qn({ layerType: s }, c)) } }), paint: (l) => sn({ layer: i, key: l.key, value: l.value, valueSpec: {}, style: l.style, styleSpec: l.styleSpec, objectElementValidators: { '*': (c) => Xg(Qn({ layerType: s, layer: i }, c)) } }) } }))), t;
      }
      function aa(e) {
        const t = e.value,
          i = e.key,
          r = $e(t);
        return r !== 'string' ? [new Vt(i, t, `string expected, ${r} found`)] : [];
      }
      const Jg = {
        promoteId: function ({ key: e, value: t }) {
          if ($e(t) === 'string') return aa({ key: e, value: t });
          {
            const i = [];
            for (const r in t) i.push(...aa({ key: `${e}.${r}`, value: t[r] }));
            return i;
          }
        },
      };
      function Qg(e) {
        const t = e.value,
          i = e.key,
          r = e.styleSpec,
          n = e.style;
        if (!t.type) return [new Vt(i, t, '"type" is required')];
        const o = Gi(t.type);
        let s = [];
        switch ((['vector', 'raster', 'raster-dem'].includes(o) && (t.url || t.tiles || s.push(new Vt(i, t, 'Either "url" or "tiles" is required.'))), o)) {
          case 'vector':
          case 'raster':
          case 'raster-dem':
            return (s = s.concat(sn({ key: i, value: t, valueSpec: r[`source_${o.replace('-', '_')}`], style: e.style, styleSpec: r, objectElementValidators: Jg }))), s;
          case 'geojson':
            if (((s = sn({ key: i, value: t, valueSpec: r.source_geojson, style: n, styleSpec: r, objectElementValidators: Jg })), t.cluster))
              for (const a in t.clusterProperties) {
                const [l, c] = t.clusterProperties[a],
                  u = typeof l == 'string' ? [l, ['accumulated'], ['get', a]] : l;
                s.push(..._s({ key: `${i}.${a}.map`, value: c, expressionContext: 'cluster-map' })), s.push(..._s({ key: `${i}.${a}.reduce`, value: u, expressionContext: 'cluster-reduce' }));
              }
            return s;
          case 'video':
            return sn({ key: i, value: t, valueSpec: r.source_video, style: n, styleSpec: r });
          case 'image':
            return sn({ key: i, value: t, valueSpec: r.source_image, style: n, styleSpec: r });
          case 'canvas':
            return [new Vt(i, null, 'Please use runtime APIs to add canvas sources, rather than including them in stylesheets.', 'source.canvas')];
          default:
            return jc({ key: `${i}.type`, value: t.type, valueSpec: { values: lM(r) }, style: n, styleSpec: r });
        }
      }
      function lM(e) {
        return e.source.reduce((t, i) => {
          const r = e[i];
          return r.type.type === 'enum' && (t = t.concat(Object.keys(r.type.values))), t;
        }, []);
      }
      function ty(e) {
        const t = e.value;
        let i = [];
        if (!t) return i;
        const r = $e(t);
        return r !== 'string'
          ? ((i = i.concat([new Vt(e.key, t, `string expected, "${r}" found`)])), i)
          : ((function (n) {
              const o = n.indexOf('://') === -1;
              try {
                return new URL(n, o ? 'http://example.com' : void 0), !0;
              } catch {
                return !1;
              }
            })(t) || (i = i.concat([new Vt(e.key, t, `invalid url "${t}"`)])),
            i);
      }
      function ey(e) {
        const t = e.value,
          i = e.styleSpec,
          r = i.light,
          n = e.style;
        let o = [];
        const s = $e(t);
        if (t === void 0) return o;
        if (s !== 'object') return (o = o.concat([new Vt('light', t, `object expected, ${s} found`)])), o;
        for (const a in t) {
          const l = a.match(/^(.*)-transition$/);
          o = o.concat(l && r[l[1]] && r[l[1]].transition ? or({ key: a, value: t[a], valueSpec: i.transition, style: n, styleSpec: i }) : r[a] ? or({ key: a, value: t[a], valueSpec: r[a], style: n, styleSpec: i }) : [new Vt(a, t[a], `unknown property "${a}"`)]);
        }
        return o;
      }
      function iy(e) {
        const t = e.value;
        let i = [];
        if (!t) return i;
        const r = $e(t);
        if (r !== 'object') return (i = i.concat([new Vt('light-3d', t, `object expected, ${r} found`)])), i;
        const n = e.styleSpec,
          o = n['light-3d'],
          s = e.key,
          a = e.style,
          l = e.style.lights;
        for (const h of ['type', 'id']) if (!(h in t)) return (i = i.concat([new Vt('light-3d', t, `missing property ${h} on light`)])), i;
        if (t.type && l)
          for (let h = 0; h < e.arrayIndex; h++) {
            const d = Gi(t.type),
              f = l[h];
            Gi(f.type) === d && i.push(new Vt(s, t.id, `duplicate light type "${t.type}", previously defined at line ${f.id.__line__}`));
          }
        const c = `properties_light_${t.type}`;
        if (!(c in n)) return (i = i.concat([new Vt('light-3d', t, `Invalid light type ${t.type}`)])), i;
        const u = n[c];
        for (const h in t)
          if (h === 'properties') {
            const d = t[h],
              f = $e(d);
            if (f !== 'object') return (i = i.concat([new Vt('properties', d, `object expected, ${f} found`)])), i;
            for (const p in d) i = i.concat(u[p] ? or({ key: p, value: d[p], valueSpec: u[p], style: a, styleSpec: n }) : [new cs(e.key, d[p], `unknown property "${p}"`)]);
          } else {
            const d = h.match(/^(.*)-transition$/);
            i = i.concat(d && o[d[1]] && o[d[1]].transition ? or({ key: h, value: t[h], valueSpec: n.transition, style: a, styleSpec: n }) : o[h] ? or({ key: h, value: t[h], valueSpec: o[h], style: a, styleSpec: n }) : [new cs(h, t[h], `unknown property "${h}"`)]);
          }
        return i;
      }
      function ry(e) {
        const t = e.value,
          i = e.key,
          r = e.style,
          n = e.styleSpec,
          o = n.terrain;
        let s = [];
        const a = $e(t);
        if (t === void 0 || a === 'null') return s;
        if (a !== 'object') return (s = s.concat([new Vt('terrain', t, `object expected, ${a} found`)])), s;
        for (const l in t) {
          const c = l.match(/^(.*)-transition$/);
          s = s.concat(c && o[c[1]] && o[c[1]].transition ? or({ key: l, value: t[l], valueSpec: n.transition, style: r, styleSpec: n }) : o[l] ? or({ key: l, value: t[l], valueSpec: o[l], style: r, styleSpec: n }) : [new cs(l, t[l], `unknown property "${l}"`)]);
        }
        if (t.source) {
          const l = r.sources && r.sources[t.source],
            c = l && Gi(l.type);
          l ? c !== 'raster-dem' && s.push(new Vt(i, t.source, `terrain cannot be used with a source of type ${String(c)}, it only be used with a "raster-dem" source type`)) : s.push(new Vt(i, t.source, `source "${t.source}" not found`));
        } else s.push(new Vt(i, t, 'terrain is missing required property "source"'));
        return s;
      }
      function ny(e) {
        const t = e.value,
          i = e.style,
          r = e.styleSpec,
          n = r.fog;
        let o = [];
        const s = $e(t);
        if (t === void 0) return o;
        if (s !== 'object') return (o = o.concat([new Vt('fog', t, `object expected, ${s} found`)])), o;
        for (const a in t) {
          const l = a.match(/^(.*)-transition$/);
          o = o.concat(l && n[l[1]] && n[l[1]].transition ? or({ key: a, value: t[a], valueSpec: r.transition, style: i, styleSpec: r }) : n[a] ? or({ key: a, value: t[a], valueSpec: n[a], style: i, styleSpec: r }) : [new cs(a, t[a], `unknown property "${a}"`)]);
        }
        return o;
      }
      const oy = {
        '*': () => [],
        array: Fg,
        boolean: function (e) {
          const t = e.value,
            i = e.key,
            r = $e(t);
          return r !== 'boolean' ? [new Vt(i, t, `boolean expected, ${r} found`)] : [];
        },
        number: Ng,
        color: function (e) {
          const t = e.key,
            i = e.value,
            r = $e(i);
          return r !== 'string' ? [new Vt(t, i, `color expected, ${r} found`)] : yd(i) === null ? [new Vt(t, i, `color expected, "${i}" found`)] : [];
        },
        enum: jc,
        filter: pf,
        function: Ug,
        layer: Kg,
        object: sn,
        source: Qg,
        model: ty,
        light: ey,
        'light-3d': iy,
        terrain: ry,
        fog: ny,
        string: aa,
        formatted: function (e) {
          return aa(e).length === 0 ? [] : _s(e);
        },
        resolvedImage: function (e) {
          return aa(e).length === 0 ? [] : _s(e);
        },
        projection: function (e) {
          const t = e.value,
            i = e.styleSpec,
            r = i.projection,
            n = e.style;
          let o = [];
          const s = $e(t);
          if (s === 'object') for (const a in t) o = o.concat(or({ key: a, value: t[a], valueSpec: r[a], style: n, styleSpec: i }));
          else s !== 'string' && (o = o.concat([new Vt('projection', t, `object or string expected, ${s} found`)]));
          return o;
        },
        import: function (e) {
          const { value: t, styleSpec: i } = e,
            { data: r, ...n } = t;
          Object.defineProperty(n, '__line__', { value: t.__line__, enumerable: !1 });
          let o = sn(Qn({}, e, { value: n, valueSpec: i.import }));
          return Gi(n.id) === '' && o.push(new Vt(`${e.key}.id`, n, "import id can't be an empty string")), r && (o = o.concat(sy(r, i, { key: `${e.key}.data` }))), o;
        },
      };
      function or(e, t = !1) {
        const i = e.value,
          r = e.valueSpec,
          n = e.styleSpec;
        if (r.expression && Fc(Gi(i))) return Ug(e);
        if (r.expression && Nc(to(i))) return _s(e);
        if (r.type && oy[r.type]) {
          const o = oy[r.type](e);
          return t === !0 && o.length > 0 && $e(e.value) === 'array' ? _s(e) : o;
        }
        return sn(Qn({}, e, { valueSpec: r.type ? n[r.type] : r }));
      }
      function cM(e) {
        const t = e.value,
          i = e.key,
          r = aa(e);
        return r.length || (t.indexOf('{fontstack}') === -1 && r.push(new Vt(i, t, '"glyphs" url must include a "{fontstack}" token')), t.indexOf('{range}') === -1 && r.push(new Vt(i, t, '"glyphs" url must include a "{range}" token'))), r;
      }
      function sy(e, t = Q, i = {}) {
        return or({ key: i.key || '', value: e, valueSpec: t.$root, styleSpec: t, style: e, objectElementValidators: { glyphs: cM, '*': () => [] } });
      }
      function la(e, t = Q) {
        return _n(sy(e, t));
      }
      const uM = (e) => _n(Qg(e)),
        hM = (e) => _n(ey(e)),
        dM = (e) => _n(iy(e)),
        fM = (e) => _n(ry(e)),
        pM = (e) => _n(ny(e)),
        mM = (e) => _n(Kg(e)),
        mf = (e) => _n(pf(e)),
        _M = (e) => _n(Xg(e)),
        gM = (e) => _n(Yg(e)),
        yM = (e) => _n(ty(e));
      function _n(e) {
        return e.slice().sort((t, i) => (t.line && i.line ? t.line - i.line : 0));
      }
      function $c(e, t) {
        let i = !1;
        if (t && t.length) for (const r of t) r instanceof cs ? B(r.message) : (e.fire(new re(new Error(r.message))), (i = !0));
        return i;
      }
      var xM = Rn,
        Io = 3;
      function Rn(e, t, i) {
        var r = (this.cells = []);
        if (e instanceof ArrayBuffer) {
          this.arrayBuffer = e;
          var n = new Int32Array(this.arrayBuffer);
          (e = n[0]), (this.d = (t = n[1]) + 2 * (i = n[2]));
          for (var o = 0; o < this.d * this.d; o++) {
            var s = n[Io + o],
              a = n[Io + o + 1];
            r.push(s === a ? null : n.subarray(s, a));
          }
          var l = n[Io + r.length + 1];
          (this.keys = n.subarray(n[Io + r.length], l)), (this.bboxes = n.subarray(l)), (this.insert = this._insertReadonly);
        } else {
          this.d = t + 2 * i;
          for (var c = 0; c < this.d * this.d; c++) r.push([]);
          (this.keys = []), (this.bboxes = []);
        }
        (this.n = t), (this.extent = e), (this.padding = i), (this.scale = t / e), (this.uid = 0);
        var u = (i / t) * e;
        (this.min = -u), (this.max = e + u);
      }
      (Rn.prototype.insert = function (e, t, i, r, n) {
        this._forEachCell(t, i, r, n, this._insertCell, this.uid++), this.keys.push(e), this.bboxes.push(t), this.bboxes.push(i), this.bboxes.push(r), this.bboxes.push(n);
      }),
        (Rn.prototype._insertReadonly = function () {
          throw 'Cannot insert into a GridIndex created from an ArrayBuffer.';
        }),
        (Rn.prototype._insertCell = function (e, t, i, r, n, o) {
          this.cells[n].push(o);
        }),
        (Rn.prototype.query = function (e, t, i, r, n) {
          var o = this.min,
            s = this.max;
          if (e <= o && t <= o && s <= i && s <= r && !n) return Array.prototype.slice.call(this.keys);
          var a = [];
          return this._forEachCell(e, t, i, r, this._queryCell, a, {}, n), a;
        }),
        (Rn.prototype._queryCell = function (e, t, i, r, n, o, s, a) {
          var l = this.cells[n];
          if (l !== null)
            for (var c = this.keys, u = this.bboxes, h = 0; h < l.length; h++) {
              var d = l[h];
              if (s[d] === void 0) {
                var f = 4 * d;
                (a ? a(u[f + 0], u[f + 1], u[f + 2], u[f + 3]) : e <= u[f + 2] && t <= u[f + 3] && i >= u[f + 0] && r >= u[f + 1]) ? ((s[d] = !0), o.push(c[d])) : (s[d] = !1);
              }
            }
        }),
        (Rn.prototype._forEachCell = function (e, t, i, r, n, o, s, a) {
          for (var l = this._convertToCellCoord(e), c = this._convertToCellCoord(t), u = this._convertToCellCoord(i), h = this._convertToCellCoord(r), d = l; d <= u; d++)
            for (var f = c; f <= h; f++) {
              var p = this.d * f + d;
              if ((!a || a(this._convertFromCellCoord(d), this._convertFromCellCoord(f), this._convertFromCellCoord(d + 1), this._convertFromCellCoord(f + 1))) && n.call(this, e, t, i, r, p, o, s, a)) return;
            }
        }),
        (Rn.prototype._convertFromCellCoord = function (e) {
          return (e - this.padding) / this.scale;
        }),
        (Rn.prototype._convertToCellCoord = function (e) {
          return Math.max(0, Math.min(this.d - 1, Math.floor(e * this.scale) + this.padding));
        }),
        (Rn.prototype.toArrayBuffer = function () {
          if (this.arrayBuffer) return this.arrayBuffer;
          for (var e = this.cells, t = Io + this.cells.length + 1 + 1, i = 0, r = 0; r < this.cells.length; r++) i += this.cells[r].length;
          var n = new Int32Array(t + i + this.keys.length + this.bboxes.length);
          (n[0] = this.extent), (n[1] = this.n), (n[2] = this.padding);
          for (var o = t, s = 0; s < e.length; s++) {
            var a = e[s];
            (n[Io + s] = o), n.set(a, o), (o += a.length);
          }
          return (n[Io + e.length] = o), n.set(this.keys, o), (n[Io + e.length + 1] = o += this.keys.length), n.set(this.bboxes, o), (o += this.bboxes.length), n.buffer;
        });
      var ca = ze(xM);
      const Hc = {};
      function Gt(e, t, i = {}) {
        Object.defineProperty(e, '_classRegistryKey', { value: t, writeable: !1 }), (Hc[t] = { klass: e, omit: i.omit || [] });
      }
      Gt(Object, 'Object'),
        (ca.serialize = function (e, t) {
          const i = e.toArrayBuffer();
          return t && t.add(i), { buffer: i };
        }),
        (ca.deserialize = function (e) {
          return new ca(e.buffer);
        }),
        Object.defineProperty(ca, 'name', { value: 'Grid' }),
        Gt(ca, 'Grid'),
        Gt(pe, 'Color'),
        Gt(Error, 'Error'),
        Gt(mt, 'AJAXError'),
        Gt(on, 'ResolvedImage'),
        Gt(Uc, 'StylePropertyFunction'),
        Gt(cf, 'StyleExpression', { omit: ['_evaluator'] }),
        Gt(Ao, 'ZoomDependentExpression'),
        Gt(uf, 'ZoomConstantExpression'),
        Gt(zn, 'CompoundExpression', { omit: ['_evaluate'] });
      for (const e in pl) Hc[pl[e]._classRegistryKey] || Gt(pl[e], `Expression${e}`);
      function ay(e) {
        return e && typeof ArrayBuffer < 'u' && (e instanceof ArrayBuffer || (e.constructor && e.constructor.name === 'ArrayBuffer'));
      }
      function ly(e) {
        return U.ImageBitmap && e instanceof U.ImageBitmap;
      }
      function ua(e, t) {
        if (e == null || typeof e == 'boolean' || typeof e == 'number' || typeof e == 'string' || e instanceof Boolean || e instanceof Number || e instanceof String || e instanceof Date || e instanceof RegExp) return e;
        if (ay(e) || ly(e)) return t && t.add(e), e;
        if (ArrayBuffer.isView(e)) {
          const i = e;
          return t && t.add(i.buffer), i;
        }
        if (e instanceof U.ImageData) return t && t.add(e.data.buffer), e;
        if (Array.isArray(e)) {
          const i = [];
          for (const r of e) i.push(ua(r, t));
          return i;
        }
        if (e instanceof Map) {
          const i = { $name: 'Map' };
          for (const [r, n] of e.entries()) i[r] = ua(n);
          return i;
        }
        if (typeof e == 'object') {
          const i = e.constructor,
            r = i._classRegistryKey;
          if (!r) throw new Error(`can't serialize object of unregistered class ${r}`);
          const n = i.serialize ? i.serialize(e, t) : {};
          if (!i.serialize) {
            for (const o in e) e.hasOwnProperty(o) && (Hc[r].omit.indexOf(o) >= 0 || (n[o] = ua(e[o], t)));
            e instanceof Error && (n.message = e.message);
          }
          if (n.$name) throw new Error('$name property is reserved for worker serialization logic.');
          return r !== 'Object' && (n.$name = r), n;
        }
        throw new Error("can't serialize object of type " + typeof e);
      }
      function ha(e) {
        if (e == null || typeof e == 'boolean' || typeof e == 'number' || typeof e == 'string' || e instanceof Boolean || e instanceof Number || e instanceof String || e instanceof Date || e instanceof RegExp || ay(e) || ly(e) || ArrayBuffer.isView(e) || e instanceof U.ImageData) return e;
        if (Array.isArray(e)) return e.map(ha);
        if (typeof e == 'object') {
          const t = e.$name || 'Object';
          if (t === 'Map') {
            const n = new Map();
            for (const o of Object.keys(e)) o !== '$name' && n.set(o, ha(e[o]));
            return n;
          }
          const { klass: i } = Hc[t];
          if (!i) throw new Error(`can't deserialize unregistered class ${t}`);
          if (i.deserialize) return i.deserialize(e);
          const r = Object.create(i.prototype);
          for (const n of Object.keys(e)) n !== '$name' && (r[n] = ha(e[n]));
          return r;
        }
        throw new Error("can't deserialize object of type " + typeof e);
      }
      const $t = {
        'Latin-1 Supplement': (e) => e >= 128 && e <= 255,
        Arabic: (e) => e >= 1536 && e <= 1791,
        'Arabic Supplement': (e) => e >= 1872 && e <= 1919,
        'Arabic Extended-A': (e) => e >= 2208 && e <= 2303,
        'Hangul Jamo': (e) => e >= 4352 && e <= 4607,
        'Unified Canadian Aboriginal Syllabics': (e) => e >= 5120 && e <= 5759,
        Khmer: (e) => e >= 6016 && e <= 6143,
        'Unified Canadian Aboriginal Syllabics Extended': (e) => e >= 6320 && e <= 6399,
        'General Punctuation': (e) => e >= 8192 && e <= 8303,
        'Letterlike Symbols': (e) => e >= 8448 && e <= 8527,
        'Number Forms': (e) => e >= 8528 && e <= 8591,
        'Miscellaneous Technical': (e) => e >= 8960 && e <= 9215,
        'Control Pictures': (e) => e >= 9216 && e <= 9279,
        'Optical Character Recognition': (e) => e >= 9280 && e <= 9311,
        'Enclosed Alphanumerics': (e) => e >= 9312 && e <= 9471,
        'Geometric Shapes': (e) => e >= 9632 && e <= 9727,
        'Miscellaneous Symbols': (e) => e >= 9728 && e <= 9983,
        'Miscellaneous Symbols and Arrows': (e) => e >= 11008 && e <= 11263,
        'CJK Radicals Supplement': (e) => e >= 11904 && e <= 12031,
        'Kangxi Radicals': (e) => e >= 12032 && e <= 12255,
        'Ideographic Description Characters': (e) => e >= 12272 && e <= 12287,
        'CJK Symbols and Punctuation': (e) => e >= 12288 && e <= 12351,
        Hiragana: (e) => e >= 12352 && e <= 12447,
        Katakana: (e) => e >= 12448 && e <= 12543,
        Bopomofo: (e) => e >= 12544 && e <= 12591,
        'Hangul Compatibility Jamo': (e) => e >= 12592 && e <= 12687,
        Kanbun: (e) => e >= 12688 && e <= 12703,
        'Bopomofo Extended': (e) => e >= 12704 && e <= 12735,
        'CJK Strokes': (e) => e >= 12736 && e <= 12783,
        'Katakana Phonetic Extensions': (e) => e >= 12784 && e <= 12799,
        'Enclosed CJK Letters and Months': (e) => e >= 12800 && e <= 13055,
        'CJK Compatibility': (e) => e >= 13056 && e <= 13311,
        'CJK Unified Ideographs Extension A': (e) => e >= 13312 && e <= 19903,
        'Yijing Hexagram Symbols': (e) => e >= 19904 && e <= 19967,
        'CJK Unified Ideographs': (e) => e >= 19968 && e <= 40959,
        'Yi Syllables': (e) => e >= 40960 && e <= 42127,
        'Yi Radicals': (e) => e >= 42128 && e <= 42191,
        'Hangul Jamo Extended-A': (e) => e >= 43360 && e <= 43391,
        'Hangul Syllables': (e) => e >= 44032 && e <= 55215,
        'Hangul Jamo Extended-B': (e) => e >= 55216 && e <= 55295,
        'Private Use Area': (e) => e >= 57344 && e <= 63743,
        'CJK Compatibility Ideographs': (e) => e >= 63744 && e <= 64255,
        'Arabic Presentation Forms-A': (e) => e >= 64336 && e <= 65023,
        'Vertical Forms': (e) => e >= 65040 && e <= 65055,
        'CJK Compatibility Forms': (e) => e >= 65072 && e <= 65103,
        'Small Form Variants': (e) => e >= 65104 && e <= 65135,
        'Arabic Presentation Forms-B': (e) => e >= 65136 && e <= 65279,
        'Halfwidth and Fullwidth Forms': (e) => e >= 65280 && e <= 65519,
        'CJK Unified Ideographs Extension B': (e) => e >= 131072 && e <= 173791,
      };
      function _f(e) {
        for (const t of e) if (gf(t.charCodeAt(0))) return !0;
        return !1;
      }
      function vM(e) {
        for (const t of e) if (!bM(t.charCodeAt(0))) return !1;
        return !0;
      }
      function bM(e) {
        return !($t.Arabic(e) || $t['Arabic Supplement'](e) || $t['Arabic Extended-A'](e) || $t['Arabic Presentation Forms-A'](e) || $t['Arabic Presentation Forms-B'](e));
      }
      function gf(e) {
        return !(e !== 746 && e !== 747 && (e < 4352 || !($t['Bopomofo Extended'](e) || $t.Bopomofo(e) || ($t['CJK Compatibility Forms'](e) && !(e >= 65097 && e <= 65103)) || $t['CJK Compatibility Ideographs'](e) || $t['CJK Compatibility'](e) || $t['CJK Radicals Supplement'](e) || $t['CJK Strokes'](e) || !(!$t['CJK Symbols and Punctuation'](e) || (e >= 12296 && e <= 12305) || (e >= 12308 && e <= 12319) || e === 12336) || $t['CJK Unified Ideographs Extension A'](e) || $t['CJK Unified Ideographs'](e) || $t['Enclosed CJK Letters and Months'](e) || $t['Hangul Compatibility Jamo'](e) || $t['Hangul Jamo Extended-A'](e) || $t['Hangul Jamo Extended-B'](e) || $t['Hangul Jamo'](e) || $t['Hangul Syllables'](e) || $t.Hiragana(e) || $t['Ideographic Description Characters'](e) || $t.Kanbun(e) || $t['Kangxi Radicals'](e) || $t['Katakana Phonetic Extensions'](e) || ($t.Katakana(e) && e !== 12540) || !(!$t['Halfwidth and Fullwidth Forms'](e) || e === 65288 || e === 65289 || e === 65293 || (e >= 65306 && e <= 65310) || e === 65339 || e === 65341 || e === 65343 || (e >= 65371 && e <= 65503) || e === 65507 || (e >= 65512 && e <= 65519)) || !(!$t['Small Form Variants'](e) || (e >= 65112 && e <= 65118) || (e >= 65123 && e <= 65126)) || $t['Unified Canadian Aboriginal Syllabics'](e) || $t['Unified Canadian Aboriginal Syllabics Extended'](e) || $t['Vertical Forms'](e) || $t['Yijing Hexagram Symbols'](e) || $t['Yi Syllables'](e) || $t['Yi Radicals'](e))));
      }
      function cy(e) {
        return !(
          gf(e) ||
          (function (t) {
            return !!(($t['Latin-1 Supplement'](t) && (t === 167 || t === 169 || t === 174 || t === 177 || t === 188 || t === 189 || t === 190 || t === 215 || t === 247)) || ($t['General Punctuation'](t) && (t === 8214 || t === 8224 || t === 8225 || t === 8240 || t === 8241 || t === 8251 || t === 8252 || t === 8258 || t === 8263 || t === 8264 || t === 8265 || t === 8273)) || $t['Letterlike Symbols'](t) || $t['Number Forms'](t) || ($t['Miscellaneous Technical'](t) && ((t >= 8960 && t <= 8967) || (t >= 8972 && t <= 8991) || (t >= 8996 && t <= 9e3) || t === 9003 || (t >= 9085 && t <= 9114) || (t >= 9150 && t <= 9165) || t === 9167 || (t >= 9169 && t <= 9179) || (t >= 9186 && t <= 9215))) || ($t['Control Pictures'](t) && t !== 9251) || $t['Optical Character Recognition'](t) || $t['Enclosed Alphanumerics'](t) || $t['Geometric Shapes'](t) || ($t['Miscellaneous Symbols'](t) && !(t >= 9754 && t <= 9759)) || ($t['Miscellaneous Symbols and Arrows'](t) && ((t >= 11026 && t <= 11055) || (t >= 11088 && t <= 11097) || (t >= 11192 && t <= 11243))) || $t['CJK Symbols and Punctuation'](t) || $t.Katakana(t) || $t['Private Use Area'](t) || $t['CJK Compatibility Forms'](t) || $t['Small Form Variants'](t) || $t['Halfwidth and Fullwidth Forms'](t) || t === 8734 || t === 8756 || t === 8757 || (t >= 9984 && t <= 10087) || (t >= 10102 && t <= 10131) || t === 65532 || t === 65533);
          })(e)
        );
      }
      function uy(e) {
        return (e >= 1424 && e <= 2303) || $t['Arabic Presentation Forms-A'](e) || $t['Arabic Presentation Forms-B'](e);
      }
      function wM(e, t) {
        return !((!t && uy(e)) || (e >= 2304 && e <= 3583) || (e >= 3840 && e <= 4255) || $t.Khmer(e));
      }
      function TM(e) {
        for (const t of e) if (uy(t.charCodeAt(0))) return !0;
        return !1;
      }
      const yf = 'deferred',
        xf = 'loading',
        vf = 'loaded';
      let bf = null,
        Dr = 'unavailable',
        Co = null;
      const hy = function (e) {
        e && typeof e == 'string' && e.indexOf('NetworkError') > -1 && (Dr = 'error'), bf && bf(e);
      };
      function wf() {
        Tf.fire(new wt('pluginStateChange', { pluginStatus: Dr, pluginURL: Co }));
      }
      const Tf = new Oi(),
        Ef = function () {
          return Dr;
        },
        dy = function () {
          if (Dr !== yf || !Co) throw new Error('rtl-text-plugin cannot be downloaded unless a pluginURL is specified');
          (Dr = xf),
            wf(),
            Co &&
              Dt({ url: Co }, (e) => {
                e ? hy(e) : ((Dr = vf), wf());
              });
        },
        an = {
          applyArabicShaping: null,
          processBidirectionalText: null,
          processStyledBidirectionalText: null,
          isLoaded: () => Dr === vf || an.applyArabicShaping != null,
          isLoading: () => Dr === xf,
          setState(e) {
            (Dr = e.pluginStatus), (Co = e.pluginURL);
          },
          isParsed: () => an.applyArabicShaping != null && an.processBidirectionalText != null && an.processStyledBidirectionalText != null,
          getPluginURL: () => Co,
        };
      class gi {
        constructor(t, i) {
          (this.zoom = t), i ? ((this.now = i.now), (this.fadeDuration = i.fadeDuration), (this.transition = i.transition), (this.pitch = i.pitch), (this.brightness = i.brightness)) : ((this.now = 0), (this.fadeDuration = 0), (this.transition = {}), (this.pitch = 0), (this.brightness = 0));
        }
        isSupportedScript(t) {
          return (function (i, r) {
            for (const n of i) if (!wM(n.charCodeAt(0), r)) return !1;
            return !0;
          })(t, an.isLoaded());
        }
      }
      class Wc {
        constructor(t, i, r) {
          (this.property = t),
            (this.value = i),
            (this.expression = (function (n, o, s) {
              if (Fc(n)) return new Uc(n, o);
              if (Nc(n) || (Array.isArray(n) && n.length > 0)) {
                const a = hf(n, o, s);
                if (a.result === 'error') throw new Error(a.value.map((l) => `${l.key}: ${l.message}`).join(', '));
                return a.value;
              }
              {
                let a = n;
                return typeof n == 'string' && o.type === 'color' && (a = pe.parse(n)), { kind: 'constant', isConfigDependent: !1, evaluate: () => a };
              }
            })(i === void 0 ? t.specification.default : i, t.specification, r));
        }
        isDataDriven() {
          return this.expression.kind === 'source' || this.expression.kind === 'composite';
        }
        possiblyEvaluate(t, i, r) {
          return this.property.possiblyEvaluate(this, t, i, r);
        }
      }
      class Mf {
        constructor(t, i) {
          (this.property = t), (this.value = new Wc(t, void 0, i));
        }
        transitioned(t, i) {
          return new fy(this.property, this.value, i, Ft({}, t.transition, this.transition), t.now);
        }
        untransitioned() {
          return new fy(this.property, this.value, null, {}, 0);
        }
      }
      class _l {
        constructor(t, i) {
          (this._properties = t), (this._values = Object.create(t.defaultTransitionablePropertyValues)), (this._options = i), (this.isConfigDependent = !1);
        }
        getValue(t) {
          return P(this._values[t].value.value);
        }
        setValue(t, i) {
          this._values.hasOwnProperty(t) || (this._values[t] = new Mf(this._values[t].property, this._options)), (this._values[t].value = new Wc(this._values[t].property, i === null ? void 0 : P(i), this._options)), (this.isConfigDependent = this.isConfigDependent || this._values[t].value.expression.isConfigDependent);
        }
        setTransitionOrValue(t, i) {
          i && (this._options = i);
          const r = this._properties.properties;
          if (t)
            for (const n in t) {
              const o = t[n];
              if (xt(n, '-transition')) {
                const s = n.slice(0, -11);
                r[s] && this.setTransition(s, o);
              } else r[n] && this.setValue(n, o);
            }
        }
        getTransition(t) {
          return P(this._values[t].transition);
        }
        setTransition(t, i) {
          this._values.hasOwnProperty(t) || (this._values[t] = new Mf(this._values[t].property)), (this._values[t].transition = P(i) || void 0);
        }
        serialize() {
          const t = {};
          for (const i of Object.keys(this._values)) {
            const r = this.getValue(i);
            r !== void 0 && (t[i] = r);
            const n = this.getTransition(i);
            n !== void 0 && (t[`${i}-transition`] = n);
          }
          return t;
        }
        transitioned(t, i) {
          const r = new py(this._properties);
          for (const n of Object.keys(this._values)) r._values[n] = this._values[n].transitioned(t, i._values[n]);
          return r;
        }
        untransitioned() {
          const t = new py(this._properties);
          for (const i of Object.keys(this._values)) t._values[i] = this._values[i].untransitioned();
          return t;
        }
      }
      class fy {
        constructor(t, i, r, n, o) {
          const s = n.delay || 0,
            a = n.duration || 0;
          (o = o || 0), (this.property = t), (this.value = i), (this.begin = o + s), (this.end = this.begin + a), t.specification.transition && (n.delay || n.duration) && (this.prior = r);
        }
        possiblyEvaluate(t, i, r) {
          const n = t.now || 0,
            o = this.value.possiblyEvaluate(t, i, r),
            s = this.prior;
          if (s) {
            if (n > this.end) return (this.prior = null), o;
            if (this.value.isDataDriven()) return (this.prior = null), o;
            if (n < this.begin) return s.possiblyEvaluate(t, i, r);
            {
              const a = (n - this.begin) / (this.end - this.begin);
              return this.property.interpolate(s.possiblyEvaluate(t, i, r), o, mi(a));
            }
          }
          return o;
        }
      }
      class py {
        constructor(t) {
          (this._properties = t), (this._values = Object.create(t.defaultTransitioningPropertyValues));
        }
        possiblyEvaluate(t, i, r) {
          const n = new gl(this._properties);
          for (const o of Object.keys(this._values)) n._values[o] = this._values[o].possiblyEvaluate(t, i, r);
          return n;
        }
        hasTransition() {
          for (const t of Object.keys(this._values)) if (this._values[t].prior) return !0;
          return !1;
        }
      }
      class EM {
        constructor(t, i) {
          (this._properties = t), (this._values = Object.create(t.defaultPropertyValues)), (this._options = i), (this.isConfigDependent = !1);
        }
        getValue(t) {
          return P(this._values[t].value);
        }
        setValue(t, i) {
          (this._values[t] = new Wc(this._values[t].property, i === null ? void 0 : P(i), this._options)), (this.isConfigDependent = this.isConfigDependent || this._values[t].expression.isConfigDependent);
        }
        serialize() {
          const t = {};
          for (const i of Object.keys(this._values)) {
            const r = this.getValue(i);
            r !== void 0 && (t[i] = r);
          }
          return t;
        }
        possiblyEvaluate(t, i, r) {
          const n = new gl(this._properties);
          for (const o of Object.keys(this._values)) n._values[o] = this._values[o].possiblyEvaluate(t, i, r);
          return n;
        }
      }
      class da {
        constructor(t, i, r) {
          (this.property = t), (this.value = i), (this.parameters = r);
        }
        isConstant() {
          return this.value.kind === 'constant';
        }
        constantOr(t) {
          return this.value.kind === 'constant' ? this.value.value : t;
        }
        evaluate(t, i, r, n) {
          return this.property.evaluate(this.value, this.parameters, t, i, r, n);
        }
      }
      class gl {
        constructor(t) {
          (this._properties = t), (this._values = Object.create(t.defaultPossiblyEvaluatedValues));
        }
        get(t) {
          return this._values[t];
        }
      }
      class vt {
        constructor(t) {
          this.specification = t;
        }
        possiblyEvaluate(t, i) {
          return t.expression.evaluate(i);
        }
        interpolate(t, i, r) {
          const n = Lc[this.specification.type];
          return n ? n(t, i, r) : t;
        }
      }
      class Xt {
        constructor(t, i) {
          (this.specification = t), (this.overrides = i);
        }
        possiblyEvaluate(t, i, r, n) {
          return new da(this, t.expression.kind === 'constant' || t.expression.kind === 'camera' ? { kind: 'constant', value: t.expression.evaluate(i, null, {}, r, n) } : t.expression, i);
        }
        interpolate(t, i, r) {
          if (t.value.kind !== 'constant' || i.value.kind !== 'constant') return t;
          if (t.value.value === void 0 || i.value.value === void 0) return new da(this, { kind: 'constant', value: void 0 }, t.parameters);
          const n = Lc[this.specification.type];
          return n ? new da(this, { kind: 'constant', value: n(t.value.value, i.value.value, r) }, t.parameters) : t;
        }
        evaluate(t, i, r, n, o, s) {
          return t.kind === 'constant' ? t.value : t.evaluate(i, r, n, o, s);
        }
      }
      class yl {
        constructor(t) {
          this.specification = t;
        }
        possiblyEvaluate(t, i, r, n) {
          return !!t.expression.evaluate(i, null, {}, r, n);
        }
        interpolate() {
          return !1;
        }
      }
      class Mi {
        constructor(t) {
          (this.properties = t), (this.defaultPropertyValues = {}), (this.defaultTransitionablePropertyValues = {}), (this.defaultTransitioningPropertyValues = {}), (this.defaultPossiblyEvaluatedValues = {}), (this.overridableProperties = []);
          const i = new gi(0, {});
          for (const r in t) {
            const n = t[r];
            n.specification.overridable && this.overridableProperties.push(r);
            const o = (this.defaultPropertyValues[r] = new Wc(n, void 0)),
              s = (this.defaultTransitionablePropertyValues[r] = new Mf(n));
            (this.defaultTransitioningPropertyValues[r] = s.untransitioned()), (this.defaultPossiblyEvaluatedValues[r] = o.possiblyEvaluate(i));
          }
        }
      }
      Gt(Xt, 'DataDrivenProperty'), Gt(vt, 'DataConstantProperty'), Gt(yl, 'ColorRampProperty');
      const Xc = '';
      function my(e) {
        return e.indexOf(Xc) >= 0;
      }
      function pr(e, t) {
        return t ? `${e}${Xc}${t}` : e;
      }
      function Yc(e) {
        const t = e.indexOf(Xc);
        return t >= 0 ? e.slice(0, t) : e;
      }
      const _y = '-transition';
      class Hr extends Oi {
        constructor(t, i, r) {
          if ((super(), (this.id = t.id), (this.type = t.type), (this._featureFilter = { filter: () => !0, needGeometry: !1, needFeature: !1 }), (this._filterCompiled = !1), (this.isConfigDependent = !1), t.type !== 'custom' && ((this.metadata = t.metadata), (this.minzoom = t.minzoom), (this.maxzoom = t.maxzoom), t.type !== 'background' && t.type !== 'sky' && t.type !== 'slot' && ((this.source = t.source), (this.sourceLayer = t['source-layer']), (this.filter = t.filter)), (this.options = r), t.slot && (this.slot = t.slot), i.layout && ((this._unevaluatedLayout = new EM(i.layout, r)), (this.isConfigDependent = this.isConfigDependent || this._unevaluatedLayout.isConfigDependent)), i.paint))) {
            this._transitionablePaint = new _l(i.paint, r);
            for (const n in t.paint) this.setPaintProperty(n, t.paint[n], { validate: !1 });
            for (const n in t.layout) this.setLayoutProperty(n, t.layout[n], { validate: !1 });
            (this.isConfigDependent = this.isConfigDependent || this._transitionablePaint.isConfigDependent), (this._transitioningPaint = this._transitionablePaint.untransitioned()), (this.paint = new gl(i.paint));
          }
        }
        setScope(t) {
          (this.scope = t), (this.fqid = pr(this.id, t));
        }
        getLayoutProperty(t) {
          return t === 'visibility' ? this.visibility : this._unevaluatedLayout.getValue(t);
        }
        setLayoutProperty(t, i, r = {}) {
          if (i != null && this._validate(gM, `layers.${this.id}.layout.${t}`, t, i, r)) return;
          if (this.type === 'custom' && t === 'visibility') return void (this.visibility = i);
          const n = this._unevaluatedLayout;
          n._properties.properties[t] && (n.setValue(t, i), (this.isConfigDependent = this.isConfigDependent || n.isConfigDependent), t === 'visibility' && this.possiblyEvaluateVisibility());
        }
        possiblyEvaluateVisibility() {
          this.visibility = this._unevaluatedLayout._values.visibility.possiblyEvaluate({ zoom: 0 });
        }
        getPaintProperty(t) {
          return xt(t, _y) ? this._transitionablePaint.getTransition(t.slice(0, -11)) : this._transitionablePaint.getValue(t);
        }
        setPaintProperty(t, i, r = {}) {
          if (i != null && this._validate(_M, `layers.${this.id}.paint.${t}`, t, i, r)) return !1;
          const n = this._transitionablePaint,
            o = n._properties.properties;
          if (xt(t, _y)) {
            const d = t.slice(0, -11);
            return o[d] && n.setTransition(d, i || void 0), !1;
          }
          if (!o[t]) return !1;
          const s = n._values[t],
            a = s.value.isDataDriven(),
            l = s.value;
          n.setValue(t, i), (this.isConfigDependent = this.isConfigDependent || n.isConfigDependent), this._handleSpecialPaintPropertyUpdate(t);
          const c = n._values[t].value,
            u = c.isDataDriven(),
            h = xt(t, 'pattern') || t === 'line-dasharray';
          return u || a || h || this._handleOverridablePaintPropertyUpdate(t, l, c);
        }
        _handleSpecialPaintPropertyUpdate(t) {}
        getProgramIds() {
          return null;
        }
        getDefaultProgramParams(t, i) {
          return null;
        }
        _handleOverridablePaintPropertyUpdate(t, i, r) {
          return !1;
        }
        isHidden(t) {
          return !!(this.minzoom && t < this.minzoom) || !!(this.maxzoom && t >= this.maxzoom) || this.visibility === 'none';
        }
        updateTransitions(t) {
          this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint);
        }
        hasTransition() {
          return this._transitioningPaint.hasTransition();
        }
        recalculate(t, i) {
          this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, i)), (this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, i));
        }
        serialize() {
          return tt({ id: this.id, type: this.type, slot: this.slot, source: this.source, 'source-layer': this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() }, (t, i) => !(t === void 0 || (i === 'layout' && !Object.keys(t).length) || (i === 'paint' && !Object.keys(t).length)));
        }
        _validate(t, i, r, n, o = {}) {
          return (!o || o.validate !== !1) && $c(this, t.call(la, { key: i, layerType: this.type, objectKey: r, value: n, styleSpec: Q, style: { glyphs: !0, sprite: !0 } }));
        }
        is3D() {
          return !1;
        }
        isSky() {
          return !1;
        }
        isTileClipped() {
          return !1;
        }
        hasOffscreenPass() {
          return !1;
        }
        hasShadowPass() {
          return !1;
        }
        canCastShadows() {
          return !1;
        }
        hasLightBeamPass() {
          return !1;
        }
        cutoffRange() {
          return 0;
        }
        resize() {}
        isStateDependent() {
          for (const t in this.paint._values) {
            const i = this.paint.get(t);
            if (i instanceof da && ms(i.property.specification) && (i.value.kind === 'source' || i.value.kind === 'composite') && i.value.isStateDependent) return !0;
          }
          return !1;
        }
        compileFilter() {
          this._filterCompiled || ((this._featureFilter = Gc(this.filter)), (this._filterCompiled = !0));
        }
        invalidateCompiledFilter() {
          this._filterCompiled = !1;
        }
        dynamicFilter() {
          return this._featureFilter.dynamicFilter;
        }
        dynamicFilterNeedsFeature() {
          return this._featureFilter.needFeature;
        }
        getLayerRenderingStats() {
          return this._stats;
        }
        resetLayerRenderingStats() {
          this._stats && ((this._stats.numRenderedVerticesInShadowPass = 0), (this._stats.numRenderedVerticesInTransparentPass = 0));
        }
      }
      class MM {
        constructor() {
          (this._changed = !1), (this._updatedLayers = {}), (this._removedLayers = {}), (this._updatedSourceCaches = {}), (this._updatedPaintProps = new Set()), (this._updatedImages = new Set());
        }
        isDirty() {
          return this._changed;
        }
        setDirty() {
          this._changed = !0;
        }
        getUpdatedSourceCaches() {
          return this._updatedSourceCaches;
        }
        updateSourceCache(t, i) {
          (this._updatedSourceCaches[t] = i), this.setDirty();
        }
        discardSourceCacheUpdate(t) {
          delete this._updatedSourceCaches[t];
        }
        updateLayer(t) {
          const i = t.scope;
          (this._updatedLayers[i] = this._updatedLayers[i] || new Set()), this._updatedLayers[i].add(t.id), this.setDirty();
        }
        removeLayer(t) {
          const i = t.scope;
          (this._removedLayers[i] = this._removedLayers[i] || {}), (this._updatedLayers[i] = this._updatedLayers[i] || new Set()), (this._removedLayers[i][t.id] = t), this._updatedLayers[i].delete(t.id), this._updatedPaintProps.delete(t.fqid), this.setDirty();
        }
        getRemovedLayer(t) {
          return this._removedLayers[t.scope] ? this._removedLayers[t.scope][t.id] : null;
        }
        discardLayerRemoval(t) {
          this._removedLayers[t.scope] && delete this._removedLayers[t.scope][t.id];
        }
        getLayerUpdatesByScope() {
          const t = {};
          for (const i in this._updatedLayers) (t[i] = t[i] || {}), (t[i].updatedIds = Array.from(this._updatedLayers[i].values()));
          for (const i in this._removedLayers) (t[i] = t[i] || {}), (t[i].removedIds = Object.keys(this._removedLayers[i]));
          return t;
        }
        getUpdatedPaintProperties() {
          return this._updatedPaintProps;
        }
        updatePaintProperties(t) {
          this._updatedPaintProps.add(t.fqid), this.setDirty();
        }
        getUpdatedImages() {
          return Array.from(this._updatedImages.values());
        }
        updateImage(t) {
          this._updatedImages.add(t), this.setDirty();
        }
        resetUpdatedImages() {
          this._updatedImages.clear();
        }
        reset() {
          (this._changed = !1), (this._updatedLayers = {}), (this._removedLayers = {}), (this._updatedSourceCaches = {}), this._updatedPaintProps.clear(), this._updatedImages.clear();
        }
      }
      const SM = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
      class Kc {
        constructor(t, i) {
          (this._structArray = t), (this._pos1 = i * this.size), (this._pos2 = this._pos1 / 2), (this._pos4 = this._pos1 / 4), (this._pos8 = this._pos1 / 8);
        }
      }
      class yi {
        constructor() {
          (this.isTransferred = !1), (this.capacity = -1), this.resize(0);
        }
        static serialize(t, i) {
          return t._trim(), i && ((t.isTransferred = !0), i.add(t.arrayBuffer)), { length: t.length, arrayBuffer: t.arrayBuffer };
        }
        static deserialize(t) {
          const i = Object.create(this.prototype);
          return (i.arrayBuffer = t.arrayBuffer), (i.length = t.length), (i.capacity = t.arrayBuffer.byteLength / i.bytesPerElement), i._refreshViews(), i;
        }
        _trim() {
          this.length !== this.capacity && ((this.capacity = this.length), (this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement)), this._refreshViews());
        }
        clear() {
          this.length = 0;
        }
        resize(t) {
          this.reserve(t), (this.length = t);
        }
        reserve(t) {
          if (t > this.capacity) {
            (this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128)), (this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement));
            const i = this.uint8;
            this._refreshViews(), i && this.uint8.set(i);
          }
        }
        _refreshViews() {
          throw new Error('_refreshViews() must be implemented by each concrete StructArray layout');
        }
        destroy() {
          (this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null), (this.arrayBuffer = null);
        }
      }
      function Ne(e, t = 1) {
        let i = 0,
          r = 0;
        return {
          members: e.map((n) => {
            const o = SM[n.type].BYTES_PER_ELEMENT,
              s = (i = gy(i, Math.max(t, o))),
              a = n.components || 1;
            return (r = Math.max(r, o)), (i += o * a), { name: n.name, type: n.type, components: a, offset: s };
          }),
          size: gy(i, Math.max(r, t)),
          alignment: t,
        };
      }
      function gy(e, t) {
        return Math.ceil(e / t) * t;
      }
      class Rr extends yi {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)), (this.int16 = new Int16Array(this.arrayBuffer));
        }
        emplaceBack(t, i) {
          const r = this.length;
          return this.resize(r + 1), this.emplace(r, t, i);
        }
        emplace(t, i, r) {
          const n = 2 * t;
          return (this.int16[n + 0] = i), (this.int16[n + 1] = r), t;
        }
      }
      (Rr.prototype.bytesPerElement = 4), Gt(Rr, 'StructArrayLayout2i4');
      class Jc extends yi {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)), (this.int16 = new Int16Array(this.arrayBuffer));
        }
        emplaceBack(t, i, r) {
          const n = this.length;
          return this.resize(n + 1), this.emplace(n, t, i, r);
        }
        emplace(t, i, r, n) {
          const o = 3 * t;
          return (this.int16[o + 0] = i), (this.int16[o + 1] = r), (this.int16[o + 2] = n), t;
        }
      }
      (Jc.prototype.bytesPerElement = 6), Gt(Jc, 'StructArrayLayout3i6');
      class gs extends yi {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)), (this.int16 = new Int16Array(this.arrayBuffer));
        }
        emplaceBack(t, i, r, n) {
          const o = this.length;
          return this.resize(o + 1), this.emplace(o, t, i, r, n);
        }
        emplace(t, i, r, n, o) {
          const s = 4 * t;
          return (this.int16[s + 0] = i), (this.int16[s + 1] = r), (this.int16[s + 2] = n), (this.int16[s + 3] = o), t;
        }
      }
      (gs.prototype.bytesPerElement = 8), Gt(gs, 'StructArrayLayout4i8');
      class Sf extends yi {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)), (this.int16 = new Int16Array(this.arrayBuffer));
        }
        emplaceBack(t, i, r, n, o) {
          const s = this.length;
          return this.resize(s + 1), this.emplace(s, t, i, r, n, o);
        }
        emplace(t, i, r, n, o, s) {
          const a = 5 * t;
          return (this.int16[a + 0] = i), (this.int16[a + 1] = r), (this.int16[a + 2] = n), (this.int16[a + 3] = o), (this.int16[a + 4] = s), t;
        }
      }
      (Sf.prototype.bytesPerElement = 10), Gt(Sf, 'StructArrayLayout5i10');
      class Af extends yi {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)), (this.int16 = new Int16Array(this.arrayBuffer)), (this.float32 = new Float32Array(this.arrayBuffer));
        }
        emplaceBack(t, i, r, n, o, s, a) {
          const l = this.length;
          return this.resize(l + 1), this.emplace(l, t, i, r, n, o, s, a);
        }
        emplace(t, i, r, n, o, s, a, l) {
          const c = 6 * t,
            u = 12 * t,
            h = 3 * t;
          return (this.int16[c + 0] = i), (this.int16[c + 1] = r), (this.uint8[u + 4] = n), (this.uint8[u + 5] = o), (this.uint8[u + 6] = s), (this.uint8[u + 7] = a), (this.float32[h + 2] = l), t;
        }
      }
      (Af.prototype.bytesPerElement = 12), Gt(Af, 'StructArrayLayout2i4ub1f12');
      class ro extends yi {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)), (this.float32 = new Float32Array(this.arrayBuffer));
        }
        emplaceBack(t, i, r, n) {
          const o = this.length;
          return this.resize(o + 1), this.emplace(o, t, i, r, n);
        }
        emplace(t, i, r, n, o) {
          const s = 4 * t;
          return (this.float32[s + 0] = i), (this.float32[s + 1] = r), (this.float32[s + 2] = n), (this.float32[s + 3] = o), t;
        }
      }
      (ro.prototype.bytesPerElement = 16), Gt(ro, 'StructArrayLayout4f16');
      class Po extends yi {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)), (this.uint16 = new Uint16Array(this.arrayBuffer)), (this.float32 = new Float32Array(this.arrayBuffer));
        }
        emplaceBack(t, i, r, n, o) {
          const s = this.length;
          return this.resize(s + 1), this.emplace(s, t, i, r, n, o);
        }
        emplace(t, i, r, n, o, s) {
          const a = 6 * t,
            l = 3 * t;
          return (this.uint16[a + 0] = i), (this.uint16[a + 1] = r), (this.uint16[a + 2] = n), (this.uint16[a + 3] = o), (this.float32[l + 2] = s), t;
        }
      }
      (Po.prototype.bytesPerElement = 12), Gt(Po, 'StructArrayLayout4ui1f12');
      class Qc extends yi {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)), (this.uint16 = new Uint16Array(this.arrayBuffer));
        }
        emplaceBack(t, i, r, n) {
          const o = this.length;
          return this.resize(o + 1), this.emplace(o, t, i, r, n);
        }
        emplace(t, i, r, n, o) {
          const s = 4 * t;
          return (this.uint16[s + 0] = i), (this.uint16[s + 1] = r), (this.uint16[s + 2] = n), (this.uint16[s + 3] = o), t;
        }
      }
      (Qc.prototype.bytesPerElement = 8), Gt(Qc, 'StructArrayLayout4ui8');
      class tu extends yi {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)), (this.int16 = new Int16Array(this.arrayBuffer));
        }
        emplaceBack(t, i, r, n, o, s) {
          const a = this.length;
          return this.resize(a + 1), this.emplace(a, t, i, r, n, o, s);
        }
        emplace(t, i, r, n, o, s, a) {
          const l = 6 * t;
          return (this.int16[l + 0] = i), (this.int16[l + 1] = r), (this.int16[l + 2] = n), (this.int16[l + 3] = o), (this.int16[l + 4] = s), (this.int16[l + 5] = a), t;
        }
      }
      (tu.prototype.bytesPerElement = 12), Gt(tu, 'StructArrayLayout6i12');
      class If extends yi {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)), (this.int16 = new Int16Array(this.arrayBuffer)), (this.uint16 = new Uint16Array(this.arrayBuffer));
        }
        emplaceBack(t, i, r, n, o, s, a, l, c, u, h, d) {
          const f = this.length;
          return this.resize(f + 1), this.emplace(f, t, i, r, n, o, s, a, l, c, u, h, d);
        }
        emplace(t, i, r, n, o, s, a, l, c, u, h, d, f) {
          const p = 12 * t;
          return (this.int16[p + 0] = i), (this.int16[p + 1] = r), (this.int16[p + 2] = n), (this.int16[p + 3] = o), (this.uint16[p + 4] = s), (this.uint16[p + 5] = a), (this.uint16[p + 6] = l), (this.uint16[p + 7] = c), (this.int16[p + 8] = u), (this.int16[p + 9] = h), (this.int16[p + 10] = d), (this.int16[p + 11] = f), t;
        }
      }
      (If.prototype.bytesPerElement = 24), Gt(If, 'StructArrayLayout4i4ui4i24');
      class Cf extends yi {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)), (this.int16 = new Int16Array(this.arrayBuffer)), (this.float32 = new Float32Array(this.arrayBuffer));
        }
        emplaceBack(t, i, r, n, o, s) {
          const a = this.length;
          return this.resize(a + 1), this.emplace(a, t, i, r, n, o, s);
        }
        emplace(t, i, r, n, o, s, a) {
          const l = 10 * t,
            c = 5 * t;
          return (this.int16[l + 0] = i), (this.int16[l + 1] = r), (this.int16[l + 2] = n), (this.float32[c + 2] = o), (this.float32[c + 3] = s), (this.float32[c + 4] = a), t;
        }
      }
      (Cf.prototype.bytesPerElement = 20), Gt(Cf, 'StructArrayLayout3i3f20');
      class Pf extends yi {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)), (this.uint32 = new Uint32Array(this.arrayBuffer));
        }
        emplaceBack(t) {
          const i = this.length;
          return this.resize(i + 1), this.emplace(i, t);
        }
        emplace(t, i) {
          return (this.uint32[1 * t + 0] = i), t;
        }
      }
      (Pf.prototype.bytesPerElement = 4), Gt(Pf, 'StructArrayLayout1ul4');
      class zo extends yi {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)), (this.uint16 = new Uint16Array(this.arrayBuffer));
        }
        emplaceBack(t, i) {
          const r = this.length;
          return this.resize(r + 1), this.emplace(r, t, i);
        }
        emplace(t, i, r) {
          const n = 2 * t;
          return (this.uint16[n + 0] = i), (this.uint16[n + 1] = r), t;
        }
      }
      (zo.prototype.bytesPerElement = 4), Gt(zo, 'StructArrayLayout2ui4');
      class zf extends yi {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)), (this.int16 = new Int16Array(this.arrayBuffer)), (this.float32 = new Float32Array(this.arrayBuffer)), (this.uint32 = new Uint32Array(this.arrayBuffer)), (this.uint16 = new Uint16Array(this.arrayBuffer));
        }
        emplaceBack(t, i, r, n, o, s, a, l, c, u, h, d, f) {
          const p = this.length;
          return this.resize(p + 1), this.emplace(p, t, i, r, n, o, s, a, l, c, u, h, d, f);
        }
        emplace(t, i, r, n, o, s, a, l, c, u, h, d, f, p) {
          const _ = 20 * t,
            g = 10 * t;
          return (this.int16[_ + 0] = i), (this.int16[_ + 1] = r), (this.int16[_ + 2] = n), (this.int16[_ + 3] = o), (this.int16[_ + 4] = s), (this.float32[g + 3] = a), (this.float32[g + 4] = l), (this.float32[g + 5] = c), (this.float32[g + 6] = u), (this.int16[_ + 14] = h), (this.uint32[g + 8] = d), (this.uint16[_ + 18] = f), (this.uint16[_ + 19] = p), t;
        }
      }
      (zf.prototype.bytesPerElement = 40), Gt(zf, 'StructArrayLayout5i4f1i1ul2ui40');
      class eu extends yi {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)), (this.int16 = new Int16Array(this.arrayBuffer));
        }
        emplaceBack(t, i, r, n, o, s, a) {
          const l = this.length;
          return this.resize(l + 1), this.emplace(l, t, i, r, n, o, s, a);
        }
        emplace(t, i, r, n, o, s, a, l) {
          const c = 8 * t;
          return (this.int16[c + 0] = i), (this.int16[c + 1] = r), (this.int16[c + 2] = n), (this.int16[c + 4] = o), (this.int16[c + 5] = s), (this.int16[c + 6] = a), (this.int16[c + 7] = l), t;
        }
      }
      (eu.prototype.bytesPerElement = 16), Gt(eu, 'StructArrayLayout3i2i2i16');
      class Df extends yi {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)), (this.float32 = new Float32Array(this.arrayBuffer)), (this.int16 = new Int16Array(this.arrayBuffer));
        }
        emplaceBack(t, i, r, n, o) {
          const s = this.length;
          return this.resize(s + 1), this.emplace(s, t, i, r, n, o);
        }
        emplace(t, i, r, n, o, s) {
          const a = 4 * t,
            l = 8 * t;
          return (this.float32[a + 0] = i), (this.float32[a + 1] = r), (this.float32[a + 2] = n), (this.int16[l + 6] = o), (this.int16[l + 7] = s), t;
        }
      }
      (Df.prototype.bytesPerElement = 16), Gt(Df, 'StructArrayLayout2f1f2i16');
      class Rf extends yi {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)), (this.float32 = new Float32Array(this.arrayBuffer));
        }
        emplaceBack(t, i, r, n) {
          const o = this.length;
          return this.resize(o + 1), this.emplace(o, t, i, r, n);
        }
        emplace(t, i, r, n, o) {
          const s = 12 * t,
            a = 3 * t;
          return (this.uint8[s + 0] = i), (this.uint8[s + 1] = r), (this.float32[a + 1] = n), (this.float32[a + 2] = o), t;
        }
      }
      (Rf.prototype.bytesPerElement = 12), Gt(Rf, 'StructArrayLayout2ub2f12');
      class Fi extends yi {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)), (this.uint16 = new Uint16Array(this.arrayBuffer));
        }
        emplaceBack(t, i, r) {
          const n = this.length;
          return this.resize(n + 1), this.emplace(n, t, i, r);
        }
        emplace(t, i, r, n) {
          const o = 3 * t;
          return (this.uint16[o + 0] = i), (this.uint16[o + 1] = r), (this.uint16[o + 2] = n), t;
        }
      }
      (Fi.prototype.bytesPerElement = 6), Gt(Fi, 'StructArrayLayout3ui6');
      class Lf extends yi {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)), (this.int16 = new Int16Array(this.arrayBuffer)), (this.float32 = new Float32Array(this.arrayBuffer)), (this.uint16 = new Uint16Array(this.arrayBuffer)), (this.uint32 = new Uint32Array(this.arrayBuffer));
        }
        emplaceBack(t, i, r, n, o, s, a, l, c, u, h, d, f, p, _, g, y, v, w, T, b) {
          const E = this.length;
          return this.resize(E + 1), this.emplace(E, t, i, r, n, o, s, a, l, c, u, h, d, f, p, _, g, y, v, w, T, b);
        }
        emplace(t, i, r, n, o, s, a, l, c, u, h, d, f, p, _, g, y, v, w, T, b, E) {
          const S = 30 * t,
            I = 15 * t,
            C = 60 * t;
          return (this.int16[S + 0] = i), (this.int16[S + 1] = r), (this.int16[S + 2] = n), (this.float32[I + 2] = o), (this.float32[I + 3] = s), (this.uint16[S + 8] = a), (this.uint16[S + 9] = l), (this.uint32[I + 5] = c), (this.uint32[I + 6] = u), (this.uint32[I + 7] = h), (this.uint16[S + 16] = d), (this.uint16[S + 17] = f), (this.uint16[S + 18] = p), (this.float32[I + 10] = _), (this.float32[I + 11] = g), (this.uint8[C + 48] = y), (this.uint8[C + 49] = v), (this.uint8[C + 50] = w), (this.uint32[I + 13] = T), (this.int16[S + 28] = b), (this.uint8[C + 58] = E), t;
        }
      }
      (Lf.prototype.bytesPerElement = 60), Gt(Lf, 'StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60');
      class kf extends yi {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)), (this.float32 = new Float32Array(this.arrayBuffer)), (this.int16 = new Int16Array(this.arrayBuffer)), (this.uint16 = new Uint16Array(this.arrayBuffer)), (this.uint32 = new Uint32Array(this.arrayBuffer));
        }
        emplaceBack(t, i, r, n, o, s, a, l, c, u, h, d, f, p, _, g, y, v, w, T, b, E, S, I, C, z, k, O, V, R, G, Z) {
          const X = this.length;
          return this.resize(X + 1), this.emplace(X, t, i, r, n, o, s, a, l, c, u, h, d, f, p, _, g, y, v, w, T, b, E, S, I, C, z, k, O, V, R, G, Z);
        }
        emplace(t, i, r, n, o, s, a, l, c, u, h, d, f, p, _, g, y, v, w, T, b, E, S, I, C, z, k, O, V, R, G, Z, X) {
          const j = 20 * t,
            q = 40 * t,
            it = 80 * t;
          return (this.float32[j + 0] = i), (this.float32[j + 1] = r), (this.int16[q + 4] = n), (this.int16[q + 5] = o), (this.int16[q + 6] = s), (this.int16[q + 7] = a), (this.int16[q + 8] = l), (this.int16[q + 9] = c), (this.int16[q + 10] = u), (this.int16[q + 11] = h), (this.int16[q + 12] = d), (this.uint16[q + 13] = f), (this.uint16[q + 14] = p), (this.uint16[q + 15] = _), (this.uint16[q + 16] = g), (this.uint16[q + 17] = y), (this.uint16[q + 18] = v), (this.uint16[q + 19] = w), (this.uint16[q + 20] = T), (this.uint16[q + 21] = b), (this.uint16[q + 22] = E), (this.uint16[q + 23] = S), (this.uint16[q + 24] = I), (this.uint16[q + 25] = C), (this.uint16[q + 26] = z), (this.uint16[q + 27] = k), (this.uint32[j + 14] = O), (this.float32[j + 15] = V), (this.float32[j + 16] = R), (this.float32[j + 17] = G), (this.float32[j + 18] = Z), (this.uint8[it + 76] = X), t;
        }
      }
      (kf.prototype.bytesPerElement = 80), Gt(kf, 'StructArrayLayout2f9i15ui1ul4f1ub80');
      class xl extends yi {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)), (this.float32 = new Float32Array(this.arrayBuffer));
        }
        emplaceBack(t) {
          const i = this.length;
          return this.resize(i + 1), this.emplace(i, t);
        }
        emplace(t, i) {
          return (this.float32[1 * t + 0] = i), t;
        }
      }
      (xl.prototype.bytesPerElement = 4), Gt(xl, 'StructArrayLayout1f4');
      class ys extends yi {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)), (this.float32 = new Float32Array(this.arrayBuffer));
        }
        emplaceBack(t, i, r, n, o) {
          const s = this.length;
          return this.resize(s + 1), this.emplace(s, t, i, r, n, o);
        }
        emplace(t, i, r, n, o, s) {
          const a = 5 * t;
          return (this.float32[a + 0] = i), (this.float32[a + 1] = r), (this.float32[a + 2] = n), (this.float32[a + 3] = o), (this.float32[a + 4] = s), t;
        }
      }
      (ys.prototype.bytesPerElement = 20), Gt(ys, 'StructArrayLayout5f20');
      class Of extends yi {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)), (this.float32 = new Float32Array(this.arrayBuffer));
        }
        emplaceBack(t, i, r, n, o, s, a) {
          const l = this.length;
          return this.resize(l + 1), this.emplace(l, t, i, r, n, o, s, a);
        }
        emplace(t, i, r, n, o, s, a, l) {
          const c = 7 * t;
          return (this.float32[c + 0] = i), (this.float32[c + 1] = r), (this.float32[c + 2] = n), (this.float32[c + 3] = o), (this.float32[c + 4] = s), (this.float32[c + 5] = a), (this.float32[c + 6] = l), t;
        }
      }
      (Of.prototype.bytesPerElement = 28), Gt(Of, 'StructArrayLayout7f28');
      class Bf extends yi {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)), (this.uint32 = new Uint32Array(this.arrayBuffer)), (this.uint16 = new Uint16Array(this.arrayBuffer));
        }
        emplaceBack(t, i, r, n) {
          const o = this.length;
          return this.resize(o + 1), this.emplace(o, t, i, r, n);
        }
        emplace(t, i, r, n, o) {
          const s = 6 * t;
          return (this.uint32[3 * t + 0] = i), (this.uint16[s + 2] = r), (this.uint16[s + 3] = n), (this.uint16[s + 4] = o), t;
        }
      }
      (Bf.prototype.bytesPerElement = 12), Gt(Bf, 'StructArrayLayout1ul3ui12');
      class vl extends yi {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)), (this.uint16 = new Uint16Array(this.arrayBuffer));
        }
        emplaceBack(t) {
          const i = this.length;
          return this.resize(i + 1), this.emplace(i, t);
        }
        emplace(t, i) {
          return (this.uint16[1 * t + 0] = i), t;
        }
      }
      (vl.prototype.bytesPerElement = 2), Gt(vl, 'StructArrayLayout1ui2');
      class xs extends yi {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)), (this.float32 = new Float32Array(this.arrayBuffer));
        }
        emplaceBack(t, i, r) {
          const n = this.length;
          return this.resize(n + 1), this.emplace(n, t, i, r);
        }
        emplace(t, i, r, n) {
          const o = 3 * t;
          return (this.float32[o + 0] = i), (this.float32[o + 1] = r), (this.float32[o + 2] = n), t;
        }
      }
      (xs.prototype.bytesPerElement = 12), Gt(xs, 'StructArrayLayout3f12');
      class bl extends yi {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)), (this.float32 = new Float32Array(this.arrayBuffer));
        }
        emplaceBack(t, i) {
          const r = this.length;
          return this.resize(r + 1), this.emplace(r, t, i);
        }
        emplace(t, i, r) {
          const n = 2 * t;
          return (this.float32[n + 0] = i), (this.float32[n + 1] = r), t;
        }
      }
      (bl.prototype.bytesPerElement = 8), Gt(bl, 'StructArrayLayout2f8');
      class Ff extends yi {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)), (this.float32 = new Float32Array(this.arrayBuffer));
        }
        emplaceBack(t, i, r, n, o, s, a, l, c, u, h, d, f, p, _, g) {
          const y = this.length;
          return this.resize(y + 1), this.emplace(y, t, i, r, n, o, s, a, l, c, u, h, d, f, p, _, g);
        }
        emplace(t, i, r, n, o, s, a, l, c, u, h, d, f, p, _, g, y) {
          const v = 16 * t;
          return (this.float32[v + 0] = i), (this.float32[v + 1] = r), (this.float32[v + 2] = n), (this.float32[v + 3] = o), (this.float32[v + 4] = s), (this.float32[v + 5] = a), (this.float32[v + 6] = l), (this.float32[v + 7] = c), (this.float32[v + 8] = u), (this.float32[v + 9] = h), (this.float32[v + 10] = d), (this.float32[v + 11] = f), (this.float32[v + 12] = p), (this.float32[v + 13] = _), (this.float32[v + 14] = g), (this.float32[v + 15] = y), t;
        }
      }
      (Ff.prototype.bytesPerElement = 64), Gt(Ff, 'StructArrayLayout16f64');
      class iu extends yi {
        _refreshViews() {
          (this.uint8 = new Uint8Array(this.arrayBuffer)), (this.uint16 = new Uint16Array(this.arrayBuffer)), (this.float32 = new Float32Array(this.arrayBuffer));
        }
        emplaceBack(t, i, r, n, o, s, a) {
          const l = this.length;
          return this.resize(l + 1), this.emplace(l, t, i, r, n, o, s, a);
        }
        emplace(t, i, r, n, o, s, a, l) {
          const c = 10 * t,
            u = 5 * t;
          return (this.uint16[c + 0] = i), (this.uint16[c + 1] = r), (this.uint16[c + 2] = n), (this.uint16[c + 3] = o), (this.float32[u + 2] = s), (this.float32[u + 3] = a), (this.float32[u + 4] = l), t;
        }
      }
      (iu.prototype.bytesPerElement = 20), Gt(iu, 'StructArrayLayout4ui3f20');
      class Nf extends yi {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer);
        }
        emplaceBack(t) {
          const i = this.length;
          return this.resize(i + 1), this.emplace(i, t);
        }
        emplace(t, i) {
          return (this.uint8[1 * t + 0] = i), t;
        }
      }
      (Nf.prototype.bytesPerElement = 1), Gt(Nf, 'StructArrayLayout1ub1');
      class yy extends Kc {
        get projectedAnchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get projectedAnchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get projectedAnchorZ() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get tileAnchorX() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get tileAnchorY() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get x1() {
          return this._structArray.float32[this._pos4 + 3];
        }
        get y1() {
          return this._structArray.float32[this._pos4 + 4];
        }
        get x2() {
          return this._structArray.float32[this._pos4 + 5];
        }
        get y2() {
          return this._structArray.float32[this._pos4 + 6];
        }
        get padding() {
          return this._structArray.int16[this._pos2 + 14];
        }
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 8];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 19];
        }
      }
      yy.prototype.size = 40;
      class Uf extends zf {
        get(t) {
          return new yy(this, t);
        }
      }
      Gt(Uf, 'CollisionBoxArray');
      class xy extends Kc {
        get projectedAnchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get projectedAnchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get projectedAnchorZ() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get tileAnchorX() {
          return this._structArray.float32[this._pos4 + 2];
        }
        get tileAnchorY() {
          return this._structArray.float32[this._pos4 + 3];
        }
        get glyphStartIndex() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get numGlyphs() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get vertexStartIndex() {
          return this._structArray.uint32[this._pos4 + 5];
        }
        get lineStartIndex() {
          return this._structArray.uint32[this._pos4 + 6];
        }
        get lineLength() {
          return this._structArray.uint32[this._pos4 + 7];
        }
        get segment() {
          return this._structArray.uint16[this._pos2 + 16];
        }
        get lowerSize() {
          return this._structArray.uint16[this._pos2 + 17];
        }
        get upperSize() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get lineOffsetX() {
          return this._structArray.float32[this._pos4 + 10];
        }
        get lineOffsetY() {
          return this._structArray.float32[this._pos4 + 11];
        }
        get writingMode() {
          return this._structArray.uint8[this._pos1 + 48];
        }
        get placedOrientation() {
          return this._structArray.uint8[this._pos1 + 49];
        }
        set placedOrientation(t) {
          this._structArray.uint8[this._pos1 + 49] = t;
        }
        get hidden() {
          return this._structArray.uint8[this._pos1 + 50];
        }
        set hidden(t) {
          this._structArray.uint8[this._pos1 + 50] = t;
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 13];
        }
        set crossTileID(t) {
          this._structArray.uint32[this._pos4 + 13] = t;
        }
        get associatedIconIndex() {
          return this._structArray.int16[this._pos2 + 28];
        }
        get flipState() {
          return this._structArray.uint8[this._pos1 + 58];
        }
        set flipState(t) {
          this._structArray.uint8[this._pos1 + 58] = t;
        }
      }
      xy.prototype.size = 60;
      class vy extends Lf {
        get(t) {
          return new xy(this, t);
        }
      }
      Gt(vy, 'PlacedSymbolArray');
      class by extends Kc {
        get tileAnchorX() {
          return this._structArray.float32[this._pos4 + 0];
        }
        get tileAnchorY() {
          return this._structArray.float32[this._pos4 + 1];
        }
        get projectedAnchorX() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get projectedAnchorY() {
          return this._structArray.int16[this._pos2 + 5];
        }
        get projectedAnchorZ() {
          return this._structArray.int16[this._pos2 + 6];
        }
        get rightJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 7];
        }
        get centerJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 8];
        }
        get leftJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 9];
        }
        get verticalPlacedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 10];
        }
        get placedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 11];
        }
        get verticalPlacedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 12];
        }
        get key() {
          return this._structArray.uint16[this._pos2 + 13];
        }
        get textBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 14];
        }
        get textBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 15];
        }
        get verticalTextBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 16];
        }
        get verticalTextBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 17];
        }
        get iconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get iconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 19];
        }
        get verticalIconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 20];
        }
        get verticalIconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 21];
        }
        get featureIndex() {
          return this._structArray.uint16[this._pos2 + 22];
        }
        get numHorizontalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 23];
        }
        get numVerticalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 24];
        }
        get numIconVertices() {
          return this._structArray.uint16[this._pos2 + 25];
        }
        get numVerticalIconVertices() {
          return this._structArray.uint16[this._pos2 + 26];
        }
        get useRuntimeCollisionCircles() {
          return this._structArray.uint16[this._pos2 + 27];
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 14];
        }
        set crossTileID(t) {
          this._structArray.uint32[this._pos4 + 14] = t;
        }
        get textOffset0() {
          return this._structArray.float32[this._pos4 + 15];
        }
        get textOffset1() {
          return this._structArray.float32[this._pos4 + 16];
        }
        get collisionCircleDiameter() {
          return this._structArray.float32[this._pos4 + 17];
        }
        get zOffset() {
          return this._structArray.float32[this._pos4 + 18];
        }
        set zOffset(t) {
          this._structArray.float32[this._pos4 + 18] = t;
        }
        get hasIconTextFit() {
          return this._structArray.uint8[this._pos1 + 76];
        }
      }
      by.prototype.size = 80;
      class wy extends kf {
        get(t) {
          return new by(this, t);
        }
      }
      Gt(wy, 'SymbolInstanceArray');
      class Ty extends xl {
        getoffsetX(t) {
          return this.float32[1 * t + 0];
        }
      }
      Gt(Ty, 'GlyphOffsetArray');
      class Ey extends Rr {
        getx(t) {
          return this.int16[2 * t + 0];
        }
        gety(t) {
          return this.int16[2 * t + 1];
        }
      }
      Gt(Ey, 'SymbolLineVertexArray');
      class My extends Kc {
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 0];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 3];
        }
        get layoutVertexArrayOffset() {
          return this._structArray.uint16[this._pos2 + 4];
        }
      }
      My.prototype.size = 12;
      class Sy extends Bf {
        get(t) {
          return new My(this, t);
        }
      }
      Gt(Sy, 'FeatureIndexArray');
      class Ay extends zo {
        geta_centroid_pos0(t) {
          return this.uint16[2 * t + 0];
        }
        geta_centroid_pos1(t) {
          return this.uint16[2 * t + 1];
        }
      }
      Gt(Ay, 'FillExtrusionCentroidArray');
      const AM = Ne([{ name: 'a_pos', components: 2, type: 'Int16' }], 4),
        IM = Ne([
          { name: 'a_pos_3', components: 3, type: 'Int16' },
          { name: 'a_pos_normal_3', components: 3, type: 'Int16' },
        ]);
      class He {
        constructor(t = []) {
          this.segments = t;
        }
        _prepareSegment(t, i, r, n) {
          let o = this.segments[this.segments.length - 1];
          return t > He.MAX_VERTEX_ARRAY_LENGTH && B(`Max vertices per segment is ${He.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}`), (!o || o.vertexLength + t > He.MAX_VERTEX_ARRAY_LENGTH || o.sortKey !== n) && ((o = { vertexOffset: i, primitiveOffset: r, vertexLength: 0, primitiveLength: 0 }), n !== void 0 && (o.sortKey = n), this.segments.push(o)), o;
        }
        prepareSegment(t, i, r, n) {
          return this._prepareSegment(t, i.length, r.length, n);
        }
        get() {
          return this.segments;
        }
        destroy() {
          for (const t of this.segments) for (const i in t.vaos) t.vaos[i].destroy();
        }
        static simpleSegment(t, i, r, n) {
          return new He([{ vertexOffset: t, primitiveOffset: i, vertexLength: r, primitiveLength: n, vaos: {}, sortKey: 0 }]);
        }
      }
      function Iy(e, t) {
        return 256 * (e = Bt(Math.floor(e), 0, 255)) + Bt(Math.floor(t), 0, 255);
      }
      (He.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1), Gt(He, 'SegmentVector');
      const CM = Ne([
          { name: 'a_pattern', components: 4, type: 'Uint16' },
          { name: 'a_pixel_ratio', components: 1, type: 'Float32' },
        ]),
        PM = Ne([{ name: 'a_dash', components: 4, type: 'Uint16' }]);
      var ru = { exports: {} },
        Cy = { exports: {} };
      (function (e) {
        e.exports = function (t, i) {
          var r, n, o, s, a, l, c, u;
          for (n = t.length - (r = 3 & t.length), o = i, a = 3432918353, l = 461845907, u = 0; u < n; ) (c = (255 & t.charCodeAt(u)) | ((255 & t.charCodeAt(++u)) << 8) | ((255 & t.charCodeAt(++u)) << 16) | ((255 & t.charCodeAt(++u)) << 24)), ++u, (o = 27492 + (65535 & (s = (5 * (65535 & (o = ((o ^= c = ((65535 & (c = ((c = ((65535 & c) * a + ((((c >>> 16) * a) & 65535) << 16)) & 4294967295) << 15) | (c >>> 17))) * l + ((((c >>> 16) * l) & 65535) << 16)) & 4294967295) << 13) | (o >>> 19))) + (((5 * (o >>> 16)) & 65535) << 16)) & 4294967295)) + (((58964 + (s >>> 16)) & 65535) << 16));
          switch (((c = 0), r)) {
            case 3:
              c ^= (255 & t.charCodeAt(u + 2)) << 16;
            case 2:
              c ^= (255 & t.charCodeAt(u + 1)) << 8;
            case 1:
              o ^= c = ((65535 & (c = ((c = ((65535 & (c ^= 255 & t.charCodeAt(u))) * a + ((((c >>> 16) * a) & 65535) << 16)) & 4294967295) << 15) | (c >>> 17))) * l + ((((c >>> 16) * l) & 65535) << 16)) & 4294967295;
          }
          return (o ^= t.length), (o = (2246822507 * (65535 & (o ^= o >>> 16)) + (((2246822507 * (o >>> 16)) & 65535) << 16)) & 4294967295), (o = (3266489909 * (65535 & (o ^= o >>> 13)) + (((3266489909 * (o >>> 16)) & 65535) << 16)) & 4294967295), (o ^= o >>> 16) >>> 0;
        };
      })(Cy);
      var zM = Cy.exports,
        Py = { exports: {} };
      (function (e) {
        e.exports = function (t, i) {
          for (var r, n = t.length, o = i ^ n, s = 0; n >= 4; ) (r = 1540483477 * (65535 & (r = (255 & t.charCodeAt(s)) | ((255 & t.charCodeAt(++s)) << 8) | ((255 & t.charCodeAt(++s)) << 16) | ((255 & t.charCodeAt(++s)) << 24))) + (((1540483477 * (r >>> 16)) & 65535) << 16)), (o = (1540483477 * (65535 & o) + (((1540483477 * (o >>> 16)) & 65535) << 16)) ^ (r = 1540483477 * (65535 & (r ^= r >>> 24)) + (((1540483477 * (r >>> 16)) & 65535) << 16))), (n -= 4), ++s;
          switch (n) {
            case 3:
              o ^= (255 & t.charCodeAt(s + 2)) << 16;
            case 2:
              o ^= (255 & t.charCodeAt(s + 1)) << 8;
            case 1:
              o = 1540483477 * (65535 & (o ^= 255 & t.charCodeAt(s))) + (((1540483477 * (o >>> 16)) & 65535) << 16);
          }
          return (o = 1540483477 * (65535 & (o ^= o >>> 13)) + (((1540483477 * (o >>> 16)) & 65535) << 16)), (o ^= o >>> 15) >>> 0;
        };
      })(Py);
      var zy = zM,
        DM = Py.exports;
      (ru.exports = zy), (ru.exports.murmur3 = zy), (ru.exports.murmur2 = DM);
      var Vf = ze(ru.exports);
      class wl {
        constructor() {
          (this.ids = []), (this.uniqueIds = []), (this.positions = []), (this.indexed = !1);
        }
        add(t, i, r, n) {
          this.ids.push(Dy(t)), this.positions.push(i, r, n);
        }
        eachPosition(t, i) {
          const r = Dy(t);
          let n = 0,
            o = this.ids.length - 1;
          for (; n < o; ) {
            const s = (n + o) >> 1;
            this.ids[s] >= r ? (o = s) : (n = s + 1);
          }
          for (; this.ids[n] === r; ) i(this.positions[3 * n], this.positions[3 * n + 1], this.positions[3 * n + 2]), n++;
        }
        static serialize(t, i) {
          const r = new Float64Array(t.ids),
            n = new Uint32Array(t.positions);
          return jf(r, n, 0, r.length - 1), i && (i.add(r.buffer), i.add(n.buffer)), { ids: r, positions: n };
        }
        static deserialize(t) {
          const i = new wl();
          let r;
          (i.ids = t.ids), (i.positions = t.positions);
          for (const n of i.ids) n !== r && i.uniqueIds.push(n), (r = n);
          return (i.indexed = !0), i;
        }
      }
      function Dy(e) {
        const t = +e;
        return !isNaN(t) && Number.MIN_SAFE_INTEGER <= t && t <= Number.MAX_SAFE_INTEGER ? t : Vf(String(e));
      }
      function jf(e, t, i, r) {
        for (; i < r; ) {
          const n = e[(i + r) >> 1];
          let o = i - 1,
            s = r + 1;
          for (;;) {
            do o++;
            while (e[o] < n);
            do s--;
            while (e[s] > n);
            if (o >= s) break;
            nu(e, o, s), nu(t, 3 * o, 3 * s), nu(t, 3 * o + 1, 3 * s + 1), nu(t, 3 * o + 2, 3 * s + 2);
          }
          s - i < r - s ? (jf(e, t, i, s), (i = s + 1)) : (jf(e, t, s + 1, r), (r = s));
        }
      }
      function nu(e, t, i) {
        const r = e[t];
        (e[t] = e[i]), (e[i] = r);
      }
      Gt(wl, 'FeaturePositionMap');
      class no {
        constructor(t) {
          (this.gl = t.gl), (this.initialized = !1);
        }
        fetchUniformLocation(t, i) {
          return this.location || this.initialized || ((this.location = this.gl.getUniformLocation(t, i)), (this.initialized = !0)), !!this.location;
        }
      }
      class xe extends no {
        constructor(t) {
          super(t), (this.current = 0);
        }
        set(t, i, r) {
          this.fetchUniformLocation(t, i) && this.current !== r && ((this.current = r), this.gl.uniform1i(this.location, r));
        }
      }
      class yt extends no {
        constructor(t) {
          super(t), (this.current = 0);
        }
        set(t, i, r) {
          this.fetchUniformLocation(t, i) && this.current !== r && ((this.current = r), this.gl.uniform1f(this.location, r));
        }
      }
      class ve extends no {
        constructor(t) {
          super(t), (this.current = [0, 0]);
        }
        set(t, i, r) {
          this.fetchUniformLocation(t, i) && ((r[0] === this.current[0] && r[1] === this.current[1]) || ((this.current = r), this.gl.uniform2f(this.location, r[0], r[1])));
        }
      }
      class ce extends no {
        constructor(t) {
          super(t), (this.current = [0, 0, 0]);
        }
        set(t, i, r) {
          this.fetchUniformLocation(t, i) && ((r[0] === this.current[0] && r[1] === this.current[1] && r[2] === this.current[2]) || ((this.current = r), this.gl.uniform3f(this.location, r[0], r[1], r[2])));
        }
      }
      class Lr extends no {
        constructor(t) {
          super(t), (this.current = [0, 0, 0, 0]);
        }
        set(t, i, r) {
          this.fetchUniformLocation(t, i) && ((r[0] === this.current[0] && r[1] === this.current[1] && r[2] === this.current[2] && r[3] === this.current[3]) || ((this.current = r), this.gl.uniform4f(this.location, r[0], r[1], r[2], r[3])));
        }
      }
      class fa extends no {
        constructor(t) {
          super(t), (this.current = pe.transparent);
        }
        set(t, i, r) {
          this.fetchUniformLocation(t, i) && ((r.r === this.current.r && r.g === this.current.g && r.b === this.current.b && r.a === this.current.a) || ((this.current = r), this.gl.uniform4f(this.location, r.r, r.g, r.b, r.a)));
        }
      }
      const RM = new Float32Array(16);
      class se extends no {
        constructor(t) {
          super(t), (this.current = RM);
        }
        set(t, i, r) {
          if (this.fetchUniformLocation(t, i)) {
            if (r[12] !== this.current[12] || r[0] !== this.current[0]) return (this.current = r), void this.gl.uniformMatrix4fv(this.location, !1, r);
            for (let n = 1; n < 16; n++)
              if (r[n] !== this.current[n]) {
                (this.current = r), this.gl.uniformMatrix4fv(this.location, !1, r);
                break;
              }
          }
        }
      }
      const LM = new Float32Array(9);
      class Gf extends no {
        constructor(t) {
          super(t), (this.current = LM);
        }
        set(t, i, r) {
          if (this.fetchUniformLocation(t, i)) {
            for (let n = 0; n < 9; n++)
              if (r[n] !== this.current[n]) {
                (this.current = r), this.gl.uniformMatrix3fv(this.location, !1, r);
                break;
              }
          }
        }
      }
      const kM = new Float32Array(4);
      class qf extends no {
        constructor(t) {
          super(t), (this.current = kM);
        }
        set(t, i, r) {
          if (this.fetchUniformLocation(t, i)) {
            for (let n = 0; n < 4; n++)
              if (r[n] !== this.current[n]) {
                (this.current = r), this.gl.uniformMatrix2fv(this.location, !1, r);
                break;
              }
          }
        }
      }
      function Zf(e) {
        return [Iy(255 * e.r, 255 * e.g), Iy(255 * e.b, 255 * e.a)];
      }
      class Tl {
        constructor(t, i, r) {
          (this.value = t), (this.uniformNames = i.map((n) => `u_${n}`)), (this.type = r);
        }
        setUniform(t, i, r, n, o) {
          i.set(t, o, n.constantOr(this.value));
        }
        getBinding(t, i) {
          return this.type === 'color' ? new fa(t) : new yt(t);
        }
      }
      class pa {
        constructor(t, i) {
          (this.uniformNames = i.map((r) => `u_${r}`)), (this.pattern = null), (this.pixelRatio = 1);
        }
        setConstantPatternPositions(t) {
          (this.pixelRatio = t.pixelRatio || 1), (this.pattern = t.tl.concat(t.br));
        }
        setUniform(t, i, r, n, o) {
          const s = o === 'u_pattern' || o === 'u_dash' ? this.pattern : o === 'u_pixel_ratio' ? this.pixelRatio : null;
          s && i.set(t, o, s);
        }
        getBinding(t, i) {
          return i === 'u_pattern' || i === 'u_dash' ? new Lr(t) : new yt(t);
        }
      }
      class oo {
        constructor(t, i, r, n) {
          (this.expression = t), (this.type = r), (this.maxValue = 0), (this.paintVertexAttributes = i.map((o) => ({ name: `a_${o}`, type: 'Float32', components: r === 'color' ? 2 : 1, offset: 0 }))), (this.paintVertexArray = new n());
        }
        populatePaintArray(t, i, r, n, o, s, a) {
          const l = this.paintVertexArray.length,
            c = this.expression.evaluate(new gi(0, { brightness: s }), i, {}, o, n, a);
          this.paintVertexArray.resize(t), this._setPaintValue(l, t, c);
        }
        updatePaintArray(t, i, r, n, o, s, a) {
          const l = this.expression.evaluate({ zoom: 0, brightness: a }, r, n, void 0, o);
          this._setPaintValue(t, i, l);
        }
        _setPaintValue(t, i, r) {
          if (this.type === 'color') {
            const n = Zf(r);
            for (let o = t; o < i; o++) this.paintVertexArray.emplace(o, n[0], n[1]);
          } else {
            for (let n = t; n < i; n++) this.paintVertexArray.emplace(n, r);
            this.maxValue = Math.max(this.maxValue, Math.abs(r));
          }
        }
        upload(t) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : (this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant)));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
      }
      class gn {
        constructor(t, i, r, n, o, s) {
          (this.expression = t), (this.uniformNames = i.map((a) => `u_${a}_t`)), (this.type = r), (this.useIntegerZoom = n), (this.zoom = o), (this.maxValue = 0), (this.paintVertexAttributes = i.map((a) => ({ name: `a_${a}`, type: 'Float32', components: r === 'color' ? 4 : 2, offset: 0 }))), (this.paintVertexArray = new s());
        }
        populatePaintArray(t, i, r, n, o, s, a) {
          const l = this.expression.evaluate(new gi(this.zoom, { brightness: s }), i, {}, o, n, a),
            c = this.expression.evaluate(new gi(this.zoom + 1, { brightness: s }), i, {}, o, n, a),
            u = this.paintVertexArray.length;
          this.paintVertexArray.resize(t), this._setPaintValue(u, t, l, c);
        }
        updatePaintArray(t, i, r, n, o, s, a) {
          const l = this.expression.evaluate({ zoom: this.zoom, brightness: a }, r, n, void 0, o),
            c = this.expression.evaluate({ zoom: this.zoom + 1, brightness: a }, r, n, void 0, o);
          this._setPaintValue(t, i, l, c);
        }
        _setPaintValue(t, i, r, n) {
          if (this.type === 'color') {
            const o = Zf(r),
              s = Zf(n);
            for (let a = t; a < i; a++) this.paintVertexArray.emplace(a, o[0], o[1], s[0], s[1]);
          } else {
            for (let o = t; o < i; o++) this.paintVertexArray.emplace(o, r, n);
            this.maxValue = Math.max(this.maxValue, Math.abs(r), Math.abs(n));
          }
        }
        upload(t) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : (this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant)));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
        setUniform(t, i, r, n, o) {
          const s = this.useIntegerZoom ? Math.floor(r.zoom) : r.zoom,
            a = Bt(this.expression.interpolationFactor(s, this.zoom, this.zoom + 1), 0, 1);
          i.set(t, o, a);
        }
        getBinding(t, i) {
          return new yt(t);
        }
      }
      class Do {
        constructor(t, i, r, n, o) {
          (this.expression = t), (this.layerId = o), (this.paintVertexAttributes = (r === 'array' ? PM : CM).members);
          for (let s = 0; s < i.length; ++s);
          this.paintVertexArray = new n();
        }
        populatePaintArray(t, i, r) {
          const n = this.paintVertexArray.length;
          this.paintVertexArray.resize(t), this._setPaintValues(n, t, i.patterns && i.patterns[this.layerId], r);
        }
        updatePaintArray(t, i, r, n, o, s, a) {
          this._setPaintValues(t, i, r.patterns && r.patterns[this.layerId], s);
        }
        _setPaintValues(t, i, r, n) {
          if (!n || !r) return;
          const o = n[r];
          if (!o) return;
          const { tl: s, br: a, pixelRatio: l } = o;
          for (let c = t; c < i; c++) this.paintVertexArray.emplace(c, s[0], s[1], a[0], a[1], l);
        }
        upload(t) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
      }
      class vs {
        constructor(t, i, r = () => !0) {
          (this.binders = {}), (this._buffers = []);
          const n = [];
          for (const o in t.paint._values) {
            const s = t.paint.get(o);
            if (!r(o) || !(s instanceof da && ms(s.property.specification))) continue;
            const a = BM(o, t.type),
              l = s.value,
              c = s.property.specification.type,
              u = !!s.property.useIntegerZoom,
              h = o === 'line-dasharray' || o.endsWith('pattern'),
              d = o === 'line-dasharray' && t.layout.get('line-cap').value.kind !== 'constant';
            if (l.kind !== 'constant' || d)
              if (l.kind === 'source' || d || h) {
                const f = Ry(o, c, 'source');
                (this.binders[o] = h ? new Do(l, a, c, f, t.id) : new oo(l, a, c, f)), n.push(`/a_${o}`);
              } else {
                const f = Ry(o, c, 'composite');
                (this.binders[o] = new gn(l, a, c, u, i, f)), n.push(`/z_${o}`);
              }
            else (this.binders[o] = h ? new pa(l.value, a) : new Tl(l.value, a, c)), n.push(`/u_${o}`);
          }
          this.cacheKey = n.sort().join('');
        }
        getMaxValue(t) {
          const i = this.binders[t];
          return i instanceof oo || i instanceof gn ? i.maxValue : 0;
        }
        populatePaintArrays(t, i, r, n, o, s, a) {
          for (const l in this.binders) {
            const c = this.binders[l];
            (c instanceof oo || c instanceof gn || c instanceof Do) && c.populatePaintArray(t, i, r, n, o, s, a);
          }
        }
        setConstantPatternPositions(t) {
          for (const i in this.binders) {
            const r = this.binders[i];
            r instanceof pa && r.setConstantPatternPositions(t);
          }
        }
        updatePaintArrays(t, i, r, n, o, s, a, l) {
          let c = !1;
          const u = Object.keys(t),
            h = u.length !== 0,
            d = h ? u : i.uniqueIds;
          for (const f in this.binders) {
            const p = this.binders[f];
            if ((p instanceof oo || p instanceof gn || p instanceof Do) && (p.expression.isStateDependent === !0 || p.expression.isLightConstant === !1)) {
              const _ = o.paint.get(f);
              p.expression = _.value;
              for (const g of d) {
                const y = t[g.toString()];
                i.eachPosition(g, (v, w, T) => {
                  const b = n.feature(v);
                  p.updatePaintArray(w, T, b, y, s, a, l);
                });
              }
              if (!h)
                for (const g of r.uniqueIds) {
                  const y = t[g.toString()];
                  r.eachPosition(g, (v, w, T) => {
                    const b = n.feature(v);
                    p.updatePaintArray(w, T, b, y, s, a, l);
                  });
                }
              c = !0;
            }
          }
          return c;
        }
        defines() {
          const t = [];
          for (const i in this.binders) {
            const r = this.binders[i];
            (r instanceof Tl || r instanceof pa) && t.push(...r.uniformNames.map((n) => `#define HAS_UNIFORM_${n}`));
          }
          return t;
        }
        getBinderAttributes() {
          const t = [];
          for (const i in this.binders) {
            const r = this.binders[i];
            if (r instanceof oo || r instanceof gn || r instanceof Do) for (let n = 0; n < r.paintVertexAttributes.length; n++) t.push(r.paintVertexAttributes[n].name);
          }
          return t;
        }
        getBinderUniforms() {
          const t = [];
          for (const i in this.binders) {
            const r = this.binders[i];
            if (r instanceof Tl || r instanceof pa || r instanceof gn) for (const n of r.uniformNames) t.push(n);
          }
          return t;
        }
        getPaintVertexBuffers() {
          return this._buffers;
        }
        getUniforms(t) {
          const i = [];
          for (const r in this.binders) {
            const n = this.binders[r];
            if (n instanceof Tl || n instanceof pa || n instanceof gn) for (const o of n.uniformNames) i.push({ name: o, property: r, binding: n.getBinding(t, o) });
          }
          return i;
        }
        setUniforms(t, i, r, n, o) {
          for (const { name: s, property: a, binding: l } of r) this.binders[a].setUniform(t, l, o, n.get(a), s);
        }
        updatePaintBuffers() {
          this._buffers = [];
          for (const t in this.binders) {
            const i = this.binders[t];
            (i instanceof oo || i instanceof gn || i instanceof Do) && i.paintVertexBuffer && this._buffers.push(i.paintVertexBuffer);
          }
        }
        upload(t) {
          for (const i in this.binders) {
            const r = this.binders[i];
            (r instanceof oo || r instanceof gn || r instanceof Do) && r.upload(t);
          }
          this.updatePaintBuffers();
        }
        destroy() {
          for (const t in this.binders) {
            const i = this.binders[t];
            (i instanceof oo || i instanceof gn || i instanceof Do) && i.destroy();
          }
        }
      }
      class Ro {
        constructor(t, i, r = () => !0) {
          this.programConfigurations = {};
          for (const n of t) this.programConfigurations[n.id] = new vs(n, i, r);
          (this.needsUpload = !1), (this._featureMap = new wl()), (this._featureMapWithoutIds = new wl()), (this._bufferOffset = 0), (this._idlessCounter = 0);
        }
        populatePaintArrays(t, i, r, n, o, s, a, l) {
          for (const c in this.programConfigurations) this.programConfigurations[c].populatePaintArrays(t, i, n, o, s, a, l);
          i.id !== void 0 ? this._featureMap.add(i.id, r, this._bufferOffset, t) : (this._featureMapWithoutIds.add(this._idlessCounter, r, this._bufferOffset, t), (this._idlessCounter += 1)), (this._bufferOffset = t), (this.needsUpload = !0);
        }
        updatePaintArrays(t, i, r, n, o, s) {
          for (const a of r) this.needsUpload = this.programConfigurations[a.id].updatePaintArrays(t, this._featureMap, this._featureMapWithoutIds, i, a, n, o, s || 0) || this.needsUpload;
        }
        get(t) {
          return this.programConfigurations[t];
        }
        upload(t) {
          if (this.needsUpload) {
            for (const i in this.programConfigurations) this.programConfigurations[i].upload(t);
            this.needsUpload = !1;
          }
        }
        destroy() {
          for (const t in this.programConfigurations) this.programConfigurations[t].destroy();
        }
      }
      const OM = { 'text-opacity': ['opacity'], 'icon-opacity': ['opacity'], 'text-color': ['fill_color'], 'icon-color': ['fill_color'], 'text-emissive-strength': ['emissive_strength'], 'icon-emissive-strength': ['emissive_strength'], 'text-halo-color': ['halo_color'], 'icon-halo-color': ['halo_color'], 'text-halo-blur': ['halo_blur'], 'icon-halo-blur': ['halo_blur'], 'text-halo-width': ['halo_width'], 'icon-halo-width': ['halo_width'], 'line-gap-width': ['gapwidth'], 'line-pattern': ['pattern', 'pixel_ratio'], 'fill-pattern': ['pattern', 'pixel_ratio'], 'fill-extrusion-pattern': ['pattern', 'pixel_ratio'], 'line-dasharray': ['dash'] };
      function BM(e, t) {
        return OM[e] || [e.replace(`${t}-`, '').replace(/-/g, '_')];
      }
      const FM = { 'line-pattern': { source: Po, composite: Po }, 'fill-pattern': { source: Po, composite: Po }, 'fill-extrusion-pattern': { source: Po, composite: Po }, 'line-dasharray': { source: Qc, composite: Qc } },
        NM = { color: { source: bl, composite: ro }, number: { source: xl, composite: bl } };
      function Ry(e, t, i) {
        const r = FM[e];
        return (r && r[i]) || NM[t][i];
      }
      Gt(Tl, 'ConstantBinder'), Gt(pa, 'PatternConstantBinder'), Gt(oo, 'SourceExpressionBinder'), Gt(Do, 'PatternCompositeBinder'), Gt(gn, 'CompositeExpressionBinder'), Gt(vs, 'ProgramConfiguration', { omit: ['_buffers'] }), Gt(Ro, 'ProgramConfigurationSet');
      class kr {
        constructor(t, i) {
          t && (i ? this.setSouthWest(t).setNorthEast(i) : t.length === 4 ? this.setSouthWest([t[0], t[1]]).setNorthEast([t[2], t[3]]) : this.setSouthWest(t[0]).setNorthEast(t[1]));
        }
        setNorthEast(t) {
          return (this._ne = t instanceof ie ? new ie(t.lng, t.lat) : ie.convert(t)), this;
        }
        setSouthWest(t) {
          return (this._sw = t instanceof ie ? new ie(t.lng, t.lat) : ie.convert(t)), this;
        }
        extend(t) {
          const i = this._sw,
            r = this._ne;
          let n, o;
          if (t instanceof ie) (n = t), (o = t);
          else {
            if (!(t instanceof kr)) return Array.isArray(t) ? (t.length === 4 || t.every(Array.isArray) ? this.extend(kr.convert(t)) : this.extend(ie.convert(t))) : typeof t == 'object' && t !== null && t.hasOwnProperty('lat') && (t.hasOwnProperty('lon') || t.hasOwnProperty('lng')) ? this.extend(ie.convert(t)) : this;
            if (((n = t._sw), (o = t._ne), !n || !o)) return this;
          }
          return i || r ? ((i.lng = Math.min(n.lng, i.lng)), (i.lat = Math.min(n.lat, i.lat)), (r.lng = Math.max(o.lng, r.lng)), (r.lat = Math.max(o.lat, r.lat))) : ((this._sw = new ie(n.lng, n.lat)), (this._ne = new ie(o.lng, o.lat))), this;
        }
        getCenter() {
          return new ie((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
        }
        getSouthWest() {
          return this._sw;
        }
        getNorthEast() {
          return this._ne;
        }
        getNorthWest() {
          return new ie(this.getWest(), this.getNorth());
        }
        getSouthEast() {
          return new ie(this.getEast(), this.getSouth());
        }
        getWest() {
          return this._sw.lng;
        }
        getSouth() {
          return this._sw.lat;
        }
        getEast() {
          return this._ne.lng;
        }
        getNorth() {
          return this._ne.lat;
        }
        toArray() {
          return [this._sw.toArray(), this._ne.toArray()];
        }
        toString() {
          return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
        }
        isEmpty() {
          return !(this._sw && this._ne);
        }
        contains(t) {
          const { lng: i, lat: r } = ie.convert(t);
          let n = this._sw.lng <= i && i <= this._ne.lng;
          return this._sw.lng > this._ne.lng && (n = this._sw.lng >= i && i >= this._ne.lng), this._sw.lat <= r && r <= this._ne.lat && n;
        }
        static convert(t) {
          return !t || t instanceof kr ? t : new kr(t);
        }
      }
      var Yi = {},
        Ki = {};
      Object.defineProperty(Ki, '__esModule', { value: !0 }),
        (Ki.setMatrixArrayType = function (e) {
          Ki.ARRAY_TYPE = ky = e;
        }),
        (Ki.toRadian = function (e) {
          return e * VM;
        }),
        (Ki.equals = function (e, t) {
          return Math.abs(e - t) <= Ly * Math.max(1, Math.abs(e), Math.abs(t));
        }),
        (Ki.RANDOM = Ki.ARRAY_TYPE = Ki.EPSILON = void 0);
      var Ly = 1e-6;
      Ki.EPSILON = Ly;
      var ky = typeof Float32Array < 'u' ? Float32Array : Array;
      Ki.ARRAY_TYPE = ky;
      var UM = Math.random;
      Ki.RANDOM = UM;
      var VM = Math.PI / 180;
      Math.hypot ||
        (Math.hypot = function () {
          for (var e = 0, t = arguments.length; t--; ) e += arguments[t] * arguments[t];
          return Math.sqrt(e);
        });
      var xi = {};
      function $f(e) {
        return (
          ($f =
            typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
              ? function (t) {
                  return typeof t;
                }
              : function (t) {
                  return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t;
                }),
          $f(e)
        );
      }
      Object.defineProperty(xi, '__esModule', { value: !0 }),
        (xi.create = function () {
          var e = new Lo.ARRAY_TYPE(4);
          return Lo.ARRAY_TYPE != Float32Array && ((e[1] = 0), (e[2] = 0)), (e[0] = 1), (e[3] = 1), e;
        }),
        (xi.clone = function (e) {
          var t = new Lo.ARRAY_TYPE(4);
          return (t[0] = e[0]), (t[1] = e[1]), (t[2] = e[2]), (t[3] = e[3]), t;
        }),
        (xi.copy = function (e, t) {
          return (e[0] = t[0]), (e[1] = t[1]), (e[2] = t[2]), (e[3] = t[3]), e;
        }),
        (xi.identity = function (e) {
          return (e[0] = 1), (e[1] = 0), (e[2] = 0), (e[3] = 1), e;
        }),
        (xi.fromValues = function (e, t, i, r) {
          var n = new Lo.ARRAY_TYPE(4);
          return (n[0] = e), (n[1] = t), (n[2] = i), (n[3] = r), n;
        }),
        (xi.set = function (e, t, i, r, n) {
          return (e[0] = t), (e[1] = i), (e[2] = r), (e[3] = n), e;
        }),
        (xi.transpose = function (e, t) {
          if (e === t) {
            var i = t[1];
            (e[1] = t[2]), (e[2] = i);
          } else (e[0] = t[0]), (e[1] = t[2]), (e[2] = t[1]), (e[3] = t[3]);
          return e;
        }),
        (xi.invert = function (e, t) {
          var i = t[0],
            r = t[1],
            n = t[2],
            o = t[3],
            s = i * o - n * r;
          return s ? ((e[0] = o * (s = 1 / s)), (e[1] = -r * s), (e[2] = -n * s), (e[3] = i * s), e) : null;
        }),
        (xi.adjoint = function (e, t) {
          var i = t[0];
          return (e[0] = t[3]), (e[1] = -t[1]), (e[2] = -t[2]), (e[3] = i), e;
        }),
        (xi.determinant = function (e) {
          return e[0] * e[3] - e[2] * e[1];
        }),
        (xi.multiply = By),
        (xi.rotate = function (e, t, i) {
          var r = t[0],
            n = t[1],
            o = t[2],
            s = t[3],
            a = Math.sin(i),
            l = Math.cos(i);
          return (e[0] = r * l + o * a), (e[1] = n * l + s * a), (e[2] = r * -a + o * l), (e[3] = n * -a + s * l), e;
        }),
        (xi.scale = function (e, t, i) {
          var r = t[1],
            n = t[2],
            o = t[3],
            s = i[0],
            a = i[1];
          return (e[0] = t[0] * s), (e[1] = r * s), (e[2] = n * a), (e[3] = o * a), e;
        }),
        (xi.fromRotation = function (e, t) {
          var i = Math.sin(t),
            r = Math.cos(t);
          return (e[0] = r), (e[1] = i), (e[2] = -i), (e[3] = r), e;
        }),
        (xi.fromScaling = function (e, t) {
          return (e[0] = t[0]), (e[1] = 0), (e[2] = 0), (e[3] = t[1]), e;
        }),
        (xi.str = function (e) {
          return 'mat2(' + e[0] + ', ' + e[1] + ', ' + e[2] + ', ' + e[3] + ')';
        }),
        (xi.frob = function (e) {
          return Math.hypot(e[0], e[1], e[2], e[3]);
        }),
        (xi.LDU = function (e, t, i, r) {
          return (e[2] = r[2] / r[0]), (i[0] = r[0]), (i[1] = r[1]), (i[3] = r[3] - e[2] * i[1]), [e, t, i];
        }),
        (xi.add = function (e, t, i) {
          return (e[0] = t[0] + i[0]), (e[1] = t[1] + i[1]), (e[2] = t[2] + i[2]), (e[3] = t[3] + i[3]), e;
        }),
        (xi.subtract = Fy),
        (xi.exactEquals = function (e, t) {
          return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3];
        }),
        (xi.equals = function (e, t) {
          var i = e[0],
            r = e[1],
            n = e[2],
            o = e[3],
            s = t[0],
            a = t[1],
            l = t[2],
            c = t[3];
          return Math.abs(i - s) <= Lo.EPSILON * Math.max(1, Math.abs(i), Math.abs(s)) && Math.abs(r - a) <= Lo.EPSILON * Math.max(1, Math.abs(r), Math.abs(a)) && Math.abs(n - l) <= Lo.EPSILON * Math.max(1, Math.abs(n), Math.abs(l)) && Math.abs(o - c) <= Lo.EPSILON * Math.max(1, Math.abs(o), Math.abs(c));
        }),
        (xi.multiplyScalar = function (e, t, i) {
          return (e[0] = t[0] * i), (e[1] = t[1] * i), (e[2] = t[2] * i), (e[3] = t[3] * i), e;
        }),
        (xi.multiplyScalarAndAdd = function (e, t, i, r) {
          return (e[0] = t[0] + i[0] * r), (e[1] = t[1] + i[1] * r), (e[2] = t[2] + i[2] * r), (e[3] = t[3] + i[3] * r), e;
        }),
        (xi.sub = xi.mul = void 0);
      var Lo = (function (e, t) {
        if (e && e.__esModule) return e;
        if (e === null || ($f(e) !== 'object' && typeof e != 'function')) return { default: e };
        var i = Oy(void 0);
        if (i && i.has(e)) return i.get(e);
        var r = {},
          n = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var o in e)
          if (o !== 'default' && Object.prototype.hasOwnProperty.call(e, o)) {
            var s = n ? Object.getOwnPropertyDescriptor(e, o) : null;
            s && (s.get || s.set) ? Object.defineProperty(r, o, s) : (r[o] = e[o]);
          }
        return (r.default = e), i && i.set(e, r), r;
      })(Ki);
      function Oy(e) {
        if (typeof WeakMap != 'function') return null;
        var t = new WeakMap(),
          i = new WeakMap();
        return (Oy = function (r) {
          return r ? i : t;
        })(e);
      }
      function By(e, t, i) {
        var r = t[0],
          n = t[1],
          o = t[2],
          s = t[3],
          a = i[0],
          l = i[1],
          c = i[2],
          u = i[3];
        return (e[0] = r * a + o * l), (e[1] = n * a + s * l), (e[2] = r * c + o * u), (e[3] = n * c + s * u), e;
      }
      function Fy(e, t, i) {
        return (e[0] = t[0] - i[0]), (e[1] = t[1] - i[1]), (e[2] = t[2] - i[2]), (e[3] = t[3] - i[3]), e;
      }
      (xi.mul = By), (xi.sub = Fy);
      var Ti = {};
      function Hf(e) {
        return (
          (Hf =
            typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
              ? function (t) {
                  return typeof t;
                }
              : function (t) {
                  return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t;
                }),
          Hf(e)
        );
      }
      Object.defineProperty(Ti, '__esModule', { value: !0 }),
        (Ti.create = function () {
          var e = new Ln.ARRAY_TYPE(6);
          return Ln.ARRAY_TYPE != Float32Array && ((e[1] = 0), (e[2] = 0), (e[4] = 0), (e[5] = 0)), (e[0] = 1), (e[3] = 1), e;
        }),
        (Ti.clone = function (e) {
          var t = new Ln.ARRAY_TYPE(6);
          return (t[0] = e[0]), (t[1] = e[1]), (t[2] = e[2]), (t[3] = e[3]), (t[4] = e[4]), (t[5] = e[5]), t;
        }),
        (Ti.copy = function (e, t) {
          return (e[0] = t[0]), (e[1] = t[1]), (e[2] = t[2]), (e[3] = t[3]), (e[4] = t[4]), (e[5] = t[5]), e;
        }),
        (Ti.identity = function (e) {
          return (e[0] = 1), (e[1] = 0), (e[2] = 0), (e[3] = 1), (e[4] = 0), (e[5] = 0), e;
        }),
        (Ti.fromValues = function (e, t, i, r, n, o) {
          var s = new Ln.ARRAY_TYPE(6);
          return (s[0] = e), (s[1] = t), (s[2] = i), (s[3] = r), (s[4] = n), (s[5] = o), s;
        }),
        (Ti.set = function (e, t, i, r, n, o, s) {
          return (e[0] = t), (e[1] = i), (e[2] = r), (e[3] = n), (e[4] = o), (e[5] = s), e;
        }),
        (Ti.invert = function (e, t) {
          var i = t[0],
            r = t[1],
            n = t[2],
            o = t[3],
            s = t[4],
            a = t[5],
            l = i * o - r * n;
          return l ? ((e[0] = o * (l = 1 / l)), (e[1] = -r * l), (e[2] = -n * l), (e[3] = i * l), (e[4] = (n * a - o * s) * l), (e[5] = (r * s - i * a) * l), e) : null;
        }),
        (Ti.determinant = function (e) {
          return e[0] * e[3] - e[1] * e[2];
        }),
        (Ti.multiply = Uy),
        (Ti.rotate = function (e, t, i) {
          var r = t[0],
            n = t[1],
            o = t[2],
            s = t[3],
            a = t[4],
            l = t[5],
            c = Math.sin(i),
            u = Math.cos(i);
          return (e[0] = r * u + o * c), (e[1] = n * u + s * c), (e[2] = r * -c + o * u), (e[3] = n * -c + s * u), (e[4] = a), (e[5] = l), e;
        }),
        (Ti.scale = function (e, t, i) {
          var r = t[1],
            n = t[2],
            o = t[3],
            s = t[4],
            a = t[5],
            l = i[0],
            c = i[1];
          return (e[0] = t[0] * l), (e[1] = r * l), (e[2] = n * c), (e[3] = o * c), (e[4] = s), (e[5] = a), e;
        }),
        (Ti.translate = function (e, t, i) {
          var r = t[0],
            n = t[1],
            o = t[2],
            s = t[3],
            a = t[4],
            l = t[5],
            c = i[0],
            u = i[1];
          return (e[0] = r), (e[1] = n), (e[2] = o), (e[3] = s), (e[4] = r * c + o * u + a), (e[5] = n * c + s * u + l), e;
        }),
        (Ti.fromRotation = function (e, t) {
          var i = Math.sin(t),
            r = Math.cos(t);
          return (e[0] = r), (e[1] = i), (e[2] = -i), (e[3] = r), (e[4] = 0), (e[5] = 0), e;
        }),
        (Ti.fromScaling = function (e, t) {
          return (e[0] = t[0]), (e[1] = 0), (e[2] = 0), (e[3] = t[1]), (e[4] = 0), (e[5] = 0), e;
        }),
        (Ti.fromTranslation = function (e, t) {
          return (e[0] = 1), (e[1] = 0), (e[2] = 0), (e[3] = 1), (e[4] = t[0]), (e[5] = t[1]), e;
        }),
        (Ti.str = function (e) {
          return 'mat2d(' + e[0] + ', ' + e[1] + ', ' + e[2] + ', ' + e[3] + ', ' + e[4] + ', ' + e[5] + ')';
        }),
        (Ti.frob = function (e) {
          return Math.hypot(e[0], e[1], e[2], e[3], e[4], e[5], 1);
        }),
        (Ti.add = function (e, t, i) {
          return (e[0] = t[0] + i[0]), (e[1] = t[1] + i[1]), (e[2] = t[2] + i[2]), (e[3] = t[3] + i[3]), (e[4] = t[4] + i[4]), (e[5] = t[5] + i[5]), e;
        }),
        (Ti.subtract = Vy),
        (Ti.multiplyScalar = function (e, t, i) {
          return (e[0] = t[0] * i), (e[1] = t[1] * i), (e[2] = t[2] * i), (e[3] = t[3] * i), (e[4] = t[4] * i), (e[5] = t[5] * i), e;
        }),
        (Ti.multiplyScalarAndAdd = function (e, t, i, r) {
          return (e[0] = t[0] + i[0] * r), (e[1] = t[1] + i[1] * r), (e[2] = t[2] + i[2] * r), (e[3] = t[3] + i[3] * r), (e[4] = t[4] + i[4] * r), (e[5] = t[5] + i[5] * r), e;
        }),
        (Ti.exactEquals = function (e, t) {
          return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5];
        }),
        (Ti.equals = function (e, t) {
          var i = e[0],
            r = e[1],
            n = e[2],
            o = e[3],
            s = e[4],
            a = e[5],
            l = t[0],
            c = t[1],
            u = t[2],
            h = t[3],
            d = t[4],
            f = t[5];
          return Math.abs(i - l) <= Ln.EPSILON * Math.max(1, Math.abs(i), Math.abs(l)) && Math.abs(r - c) <= Ln.EPSILON * Math.max(1, Math.abs(r), Math.abs(c)) && Math.abs(n - u) <= Ln.EPSILON * Math.max(1, Math.abs(n), Math.abs(u)) && Math.abs(o - h) <= Ln.EPSILON * Math.max(1, Math.abs(o), Math.abs(h)) && Math.abs(s - d) <= Ln.EPSILON * Math.max(1, Math.abs(s), Math.abs(d)) && Math.abs(a - f) <= Ln.EPSILON * Math.max(1, Math.abs(a), Math.abs(f));
        }),
        (Ti.sub = Ti.mul = void 0);
      var Ln = (function (e, t) {
        if (e && e.__esModule) return e;
        if (e === null || (Hf(e) !== 'object' && typeof e != 'function')) return { default: e };
        var i = Ny(void 0);
        if (i && i.has(e)) return i.get(e);
        var r = {},
          n = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var o in e)
          if (o !== 'default' && Object.prototype.hasOwnProperty.call(e, o)) {
            var s = n ? Object.getOwnPropertyDescriptor(e, o) : null;
            s && (s.get || s.set) ? Object.defineProperty(r, o, s) : (r[o] = e[o]);
          }
        return (r.default = e), i && i.set(e, r), r;
      })(Ki);
      function Ny(e) {
        if (typeof WeakMap != 'function') return null;
        var t = new WeakMap(),
          i = new WeakMap();
        return (Ny = function (r) {
          return r ? i : t;
        })(e);
      }
      function Uy(e, t, i) {
        var r = t[0],
          n = t[1],
          o = t[2],
          s = t[3],
          a = t[4],
          l = t[5],
          c = i[0],
          u = i[1],
          h = i[2],
          d = i[3],
          f = i[4],
          p = i[5];
        return (e[0] = r * c + o * u), (e[1] = n * c + s * u), (e[2] = r * h + o * d), (e[3] = n * h + s * d), (e[4] = r * f + o * p + a), (e[5] = n * f + s * p + l), e;
      }
      function Vy(e, t, i) {
        return (e[0] = t[0] - i[0]), (e[1] = t[1] - i[1]), (e[2] = t[2] - i[2]), (e[3] = t[3] - i[3]), (e[4] = t[4] - i[4]), (e[5] = t[5] - i[5]), e;
      }
      (Ti.mul = Uy), (Ti.sub = Vy);
      var ti = {};
      function Wf(e) {
        return (
          (Wf =
            typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
              ? function (t) {
                  return typeof t;
                }
              : function (t) {
                  return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t;
                }),
          Wf(e)
        );
      }
      Object.defineProperty(ti, '__esModule', { value: !0 }),
        (ti.create = function () {
          var e = new Wr.ARRAY_TYPE(9);
          return Wr.ARRAY_TYPE != Float32Array && ((e[1] = 0), (e[2] = 0), (e[3] = 0), (e[5] = 0), (e[6] = 0), (e[7] = 0)), (e[0] = 1), (e[4] = 1), (e[8] = 1), e;
        }),
        (ti.fromMat4 = function (e, t) {
          return (e[0] = t[0]), (e[1] = t[1]), (e[2] = t[2]), (e[3] = t[4]), (e[4] = t[5]), (e[5] = t[6]), (e[6] = t[8]), (e[7] = t[9]), (e[8] = t[10]), e;
        }),
        (ti.clone = function (e) {
          var t = new Wr.ARRAY_TYPE(9);
          return (t[0] = e[0]), (t[1] = e[1]), (t[2] = e[2]), (t[3] = e[3]), (t[4] = e[4]), (t[5] = e[5]), (t[6] = e[6]), (t[7] = e[7]), (t[8] = e[8]), t;
        }),
        (ti.copy = function (e, t) {
          return (e[0] = t[0]), (e[1] = t[1]), (e[2] = t[2]), (e[3] = t[3]), (e[4] = t[4]), (e[5] = t[5]), (e[6] = t[6]), (e[7] = t[7]), (e[8] = t[8]), e;
        }),
        (ti.fromValues = function (e, t, i, r, n, o, s, a, l) {
          var c = new Wr.ARRAY_TYPE(9);
          return (c[0] = e), (c[1] = t), (c[2] = i), (c[3] = r), (c[4] = n), (c[5] = o), (c[6] = s), (c[7] = a), (c[8] = l), c;
        }),
        (ti.set = function (e, t, i, r, n, o, s, a, l, c) {
          return (e[0] = t), (e[1] = i), (e[2] = r), (e[3] = n), (e[4] = o), (e[5] = s), (e[6] = a), (e[7] = l), (e[8] = c), e;
        }),
        (ti.identity = function (e) {
          return (e[0] = 1), (e[1] = 0), (e[2] = 0), (e[3] = 0), (e[4] = 1), (e[5] = 0), (e[6] = 0), (e[7] = 0), (e[8] = 1), e;
        }),
        (ti.transpose = function (e, t) {
          if (e === t) {
            var i = t[1],
              r = t[2],
              n = t[5];
            (e[1] = t[3]), (e[2] = t[6]), (e[3] = i), (e[5] = t[7]), (e[6] = r), (e[7] = n);
          } else (e[0] = t[0]), (e[1] = t[3]), (e[2] = t[6]), (e[3] = t[1]), (e[4] = t[4]), (e[5] = t[7]), (e[6] = t[2]), (e[7] = t[5]), (e[8] = t[8]);
          return e;
        }),
        (ti.invert = function (e, t) {
          var i = t[0],
            r = t[1],
            n = t[2],
            o = t[3],
            s = t[4],
            a = t[5],
            l = t[6],
            c = t[7],
            u = t[8],
            h = u * s - a * c,
            d = -u * o + a * l,
            f = c * o - s * l,
            p = i * h + r * d + n * f;
          return p ? ((e[0] = h * (p = 1 / p)), (e[1] = (-u * r + n * c) * p), (e[2] = (a * r - n * s) * p), (e[3] = d * p), (e[4] = (u * i - n * l) * p), (e[5] = (-a * i + n * o) * p), (e[6] = f * p), (e[7] = (-c * i + r * l) * p), (e[8] = (s * i - r * o) * p), e) : null;
        }),
        (ti.adjoint = function (e, t) {
          var i = t[0],
            r = t[1],
            n = t[2],
            o = t[3],
            s = t[4],
            a = t[5],
            l = t[6],
            c = t[7],
            u = t[8];
          return (e[0] = s * u - a * c), (e[1] = n * c - r * u), (e[2] = r * a - n * s), (e[3] = a * l - o * u), (e[4] = i * u - n * l), (e[5] = n * o - i * a), (e[6] = o * c - s * l), (e[7] = r * l - i * c), (e[8] = i * s - r * o), e;
        }),
        (ti.determinant = function (e) {
          var t = e[3],
            i = e[4],
            r = e[5],
            n = e[6],
            o = e[7],
            s = e[8];
          return e[0] * (s * i - r * o) + e[1] * (-s * t + r * n) + e[2] * (o * t - i * n);
        }),
        (ti.multiply = Gy),
        (ti.translate = function (e, t, i) {
          var r = t[0],
            n = t[1],
            o = t[2],
            s = t[3],
            a = t[4],
            l = t[5],
            c = t[6],
            u = t[7],
            h = t[8],
            d = i[0],
            f = i[1];
          return (e[0] = r), (e[1] = n), (e[2] = o), (e[3] = s), (e[4] = a), (e[5] = l), (e[6] = d * r + f * s + c), (e[7] = d * n + f * a + u), (e[8] = d * o + f * l + h), e;
        }),
        (ti.rotate = function (e, t, i) {
          var r = t[0],
            n = t[1],
            o = t[2],
            s = t[3],
            a = t[4],
            l = t[5],
            c = t[6],
            u = t[7],
            h = t[8],
            d = Math.sin(i),
            f = Math.cos(i);
          return (e[0] = f * r + d * s), (e[1] = f * n + d * a), (e[2] = f * o + d * l), (e[3] = f * s - d * r), (e[4] = f * a - d * n), (e[5] = f * l - d * o), (e[6] = c), (e[7] = u), (e[8] = h), e;
        }),
        (ti.scale = function (e, t, i) {
          var r = i[0],
            n = i[1];
          return (e[0] = r * t[0]), (e[1] = r * t[1]), (e[2] = r * t[2]), (e[3] = n * t[3]), (e[4] = n * t[4]), (e[5] = n * t[5]), (e[6] = t[6]), (e[7] = t[7]), (e[8] = t[8]), e;
        }),
        (ti.fromTranslation = function (e, t) {
          return (e[0] = 1), (e[1] = 0), (e[2] = 0), (e[3] = 0), (e[4] = 1), (e[5] = 0), (e[6] = t[0]), (e[7] = t[1]), (e[8] = 1), e;
        }),
        (ti.fromRotation = function (e, t) {
          var i = Math.sin(t),
            r = Math.cos(t);
          return (e[0] = r), (e[1] = i), (e[2] = 0), (e[3] = -i), (e[4] = r), (e[5] = 0), (e[6] = 0), (e[7] = 0), (e[8] = 1), e;
        }),
        (ti.fromScaling = function (e, t) {
          return (e[0] = t[0]), (e[1] = 0), (e[2] = 0), (e[3] = 0), (e[4] = t[1]), (e[5] = 0), (e[6] = 0), (e[7] = 0), (e[8] = 1), e;
        }),
        (ti.fromMat2d = function (e, t) {
          return (e[0] = t[0]), (e[1] = t[1]), (e[2] = 0), (e[3] = t[2]), (e[4] = t[3]), (e[5] = 0), (e[6] = t[4]), (e[7] = t[5]), (e[8] = 1), e;
        }),
        (ti.fromQuat = function (e, t) {
          var i = t[0],
            r = t[1],
            n = t[2],
            o = t[3],
            s = i + i,
            a = r + r,
            l = n + n,
            c = i * s,
            u = r * s,
            h = r * a,
            d = n * s,
            f = n * a,
            p = n * l,
            _ = o * s,
            g = o * a,
            y = o * l;
          return (e[0] = 1 - h - p), (e[3] = u - y), (e[6] = d + g), (e[1] = u + y), (e[4] = 1 - c - p), (e[7] = f - _), (e[2] = d - g), (e[5] = f + _), (e[8] = 1 - c - h), e;
        }),
        (ti.normalFromMat4 = function (e, t) {
          var i = t[0],
            r = t[1],
            n = t[2],
            o = t[3],
            s = t[4],
            a = t[5],
            l = t[6],
            c = t[7],
            u = t[8],
            h = t[9],
            d = t[10],
            f = t[11],
            p = t[12],
            _ = t[13],
            g = t[14],
            y = t[15],
            v = i * a - r * s,
            w = i * l - n * s,
            T = i * c - o * s,
            b = r * l - n * a,
            E = r * c - o * a,
            S = n * c - o * l,
            I = u * _ - h * p,
            C = u * g - d * p,
            z = u * y - f * p,
            k = h * g - d * _,
            O = h * y - f * _,
            V = d * y - f * g,
            R = v * V - w * O + T * k + b * z - E * C + S * I;
          return R ? ((e[0] = (a * V - l * O + c * k) * (R = 1 / R)), (e[1] = (l * z - s * V - c * C) * R), (e[2] = (s * O - a * z + c * I) * R), (e[3] = (n * O - r * V - o * k) * R), (e[4] = (i * V - n * z + o * C) * R), (e[5] = (r * z - i * O - o * I) * R), (e[6] = (_ * S - g * E + y * b) * R), (e[7] = (g * T - p * S - y * w) * R), (e[8] = (p * E - _ * T + y * v) * R), e) : null;
        }),
        (ti.projection = function (e, t, i) {
          return (e[0] = 2 / t), (e[1] = 0), (e[2] = 0), (e[3] = 0), (e[4] = -2 / i), (e[5] = 0), (e[6] = -1), (e[7] = 1), (e[8] = 1), e;
        }),
        (ti.str = function (e) {
          return 'mat3(' + e[0] + ', ' + e[1] + ', ' + e[2] + ', ' + e[3] + ', ' + e[4] + ', ' + e[5] + ', ' + e[6] + ', ' + e[7] + ', ' + e[8] + ')';
        }),
        (ti.frob = function (e) {
          return Math.hypot(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8]);
        }),
        (ti.add = function (e, t, i) {
          return (e[0] = t[0] + i[0]), (e[1] = t[1] + i[1]), (e[2] = t[2] + i[2]), (e[3] = t[3] + i[3]), (e[4] = t[4] + i[4]), (e[5] = t[5] + i[5]), (e[6] = t[6] + i[6]), (e[7] = t[7] + i[7]), (e[8] = t[8] + i[8]), e;
        }),
        (ti.subtract = qy),
        (ti.multiplyScalar = function (e, t, i) {
          return (e[0] = t[0] * i), (e[1] = t[1] * i), (e[2] = t[2] * i), (e[3] = t[3] * i), (e[4] = t[4] * i), (e[5] = t[5] * i), (e[6] = t[6] * i), (e[7] = t[7] * i), (e[8] = t[8] * i), e;
        }),
        (ti.multiplyScalarAndAdd = function (e, t, i, r) {
          return (e[0] = t[0] + i[0] * r), (e[1] = t[1] + i[1] * r), (e[2] = t[2] + i[2] * r), (e[3] = t[3] + i[3] * r), (e[4] = t[4] + i[4] * r), (e[5] = t[5] + i[5] * r), (e[6] = t[6] + i[6] * r), (e[7] = t[7] + i[7] * r), (e[8] = t[8] + i[8] * r), e;
        }),
        (ti.exactEquals = function (e, t) {
          return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[7] === t[7] && e[8] === t[8];
        }),
        (ti.equals = function (e, t) {
          var i = e[0],
            r = e[1],
            n = e[2],
            o = e[3],
            s = e[4],
            a = e[5],
            l = e[6],
            c = e[7],
            u = e[8],
            h = t[0],
            d = t[1],
            f = t[2],
            p = t[3],
            _ = t[4],
            g = t[5],
            y = t[6],
            v = t[7],
            w = t[8];
          return Math.abs(i - h) <= Wr.EPSILON * Math.max(1, Math.abs(i), Math.abs(h)) && Math.abs(r - d) <= Wr.EPSILON * Math.max(1, Math.abs(r), Math.abs(d)) && Math.abs(n - f) <= Wr.EPSILON * Math.max(1, Math.abs(n), Math.abs(f)) && Math.abs(o - p) <= Wr.EPSILON * Math.max(1, Math.abs(o), Math.abs(p)) && Math.abs(s - _) <= Wr.EPSILON * Math.max(1, Math.abs(s), Math.abs(_)) && Math.abs(a - g) <= Wr.EPSILON * Math.max(1, Math.abs(a), Math.abs(g)) && Math.abs(l - y) <= Wr.EPSILON * Math.max(1, Math.abs(l), Math.abs(y)) && Math.abs(c - v) <= Wr.EPSILON * Math.max(1, Math.abs(c), Math.abs(v)) && Math.abs(u - w) <= Wr.EPSILON * Math.max(1, Math.abs(u), Math.abs(w));
        }),
        (ti.sub = ti.mul = void 0);
      var Wr = (function (e, t) {
        if (e && e.__esModule) return e;
        if (e === null || (Wf(e) !== 'object' && typeof e != 'function')) return { default: e };
        var i = jy(void 0);
        if (i && i.has(e)) return i.get(e);
        var r = {},
          n = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var o in e)
          if (o !== 'default' && Object.prototype.hasOwnProperty.call(e, o)) {
            var s = n ? Object.getOwnPropertyDescriptor(e, o) : null;
            s && (s.get || s.set) ? Object.defineProperty(r, o, s) : (r[o] = e[o]);
          }
        return (r.default = e), i && i.set(e, r), r;
      })(Ki);
      function jy(e) {
        if (typeof WeakMap != 'function') return null;
        var t = new WeakMap(),
          i = new WeakMap();
        return (jy = function (r) {
          return r ? i : t;
        })(e);
      }
      function Gy(e, t, i) {
        var r = t[0],
          n = t[1],
          o = t[2],
          s = t[3],
          a = t[4],
          l = t[5],
          c = t[6],
          u = t[7],
          h = t[8],
          d = i[0],
          f = i[1],
          p = i[2],
          _ = i[3],
          g = i[4],
          y = i[5],
          v = i[6],
          w = i[7],
          T = i[8];
        return (e[0] = d * r + f * s + p * c), (e[1] = d * n + f * a + p * u), (e[2] = d * o + f * l + p * h), (e[3] = _ * r + g * s + y * c), (e[4] = _ * n + g * a + y * u), (e[5] = _ * o + g * l + y * h), (e[6] = v * r + w * s + T * c), (e[7] = v * n + w * a + T * u), (e[8] = v * o + w * l + T * h), e;
      }
      function qy(e, t, i) {
        return (e[0] = t[0] - i[0]), (e[1] = t[1] - i[1]), (e[2] = t[2] - i[2]), (e[3] = t[3] - i[3]), (e[4] = t[4] - i[4]), (e[5] = t[5] - i[5]), (e[6] = t[6] - i[6]), (e[7] = t[7] - i[7]), (e[8] = t[8] - i[8]), e;
      }
      (ti.mul = Gy), (ti.sub = qy);
      var he = {};
      function Xf(e) {
        return (
          (Xf =
            typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
              ? function (t) {
                  return typeof t;
                }
              : function (t) {
                  return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t;
                }),
          Xf(e)
        );
      }
      Object.defineProperty(he, '__esModule', { value: !0 }),
        (he.create = function () {
          var e = new Ai.ARRAY_TYPE(16);
          return Ai.ARRAY_TYPE != Float32Array && ((e[1] = 0), (e[2] = 0), (e[3] = 0), (e[4] = 0), (e[6] = 0), (e[7] = 0), (e[8] = 0), (e[9] = 0), (e[11] = 0), (e[12] = 0), (e[13] = 0), (e[14] = 0)), (e[0] = 1), (e[5] = 1), (e[10] = 1), (e[15] = 1), e;
        }),
        (he.clone = function (e) {
          var t = new Ai.ARRAY_TYPE(16);
          return (t[0] = e[0]), (t[1] = e[1]), (t[2] = e[2]), (t[3] = e[3]), (t[4] = e[4]), (t[5] = e[5]), (t[6] = e[6]), (t[7] = e[7]), (t[8] = e[8]), (t[9] = e[9]), (t[10] = e[10]), (t[11] = e[11]), (t[12] = e[12]), (t[13] = e[13]), (t[14] = e[14]), (t[15] = e[15]), t;
        }),
        (he.copy = function (e, t) {
          return (e[0] = t[0]), (e[1] = t[1]), (e[2] = t[2]), (e[3] = t[3]), (e[4] = t[4]), (e[5] = t[5]), (e[6] = t[6]), (e[7] = t[7]), (e[8] = t[8]), (e[9] = t[9]), (e[10] = t[10]), (e[11] = t[11]), (e[12] = t[12]), (e[13] = t[13]), (e[14] = t[14]), (e[15] = t[15]), e;
        }),
        (he.fromValues = function (e, t, i, r, n, o, s, a, l, c, u, h, d, f, p, _) {
          var g = new Ai.ARRAY_TYPE(16);
          return (g[0] = e), (g[1] = t), (g[2] = i), (g[3] = r), (g[4] = n), (g[5] = o), (g[6] = s), (g[7] = a), (g[8] = l), (g[9] = c), (g[10] = u), (g[11] = h), (g[12] = d), (g[13] = f), (g[14] = p), (g[15] = _), g;
        }),
        (he.set = function (e, t, i, r, n, o, s, a, l, c, u, h, d, f, p, _, g) {
          return (e[0] = t), (e[1] = i), (e[2] = r), (e[3] = n), (e[4] = o), (e[5] = s), (e[6] = a), (e[7] = l), (e[8] = c), (e[9] = u), (e[10] = h), (e[11] = d), (e[12] = f), (e[13] = p), (e[14] = _), (e[15] = g), e;
        }),
        (he.identity = $y),
        (he.transpose = function (e, t) {
          if (e === t) {
            var i = t[1],
              r = t[2],
              n = t[3],
              o = t[6],
              s = t[7],
              a = t[11];
            (e[1] = t[4]), (e[2] = t[8]), (e[3] = t[12]), (e[4] = i), (e[6] = t[9]), (e[7] = t[13]), (e[8] = r), (e[9] = o), (e[11] = t[14]), (e[12] = n), (e[13] = s), (e[14] = a);
          } else (e[0] = t[0]), (e[1] = t[4]), (e[2] = t[8]), (e[3] = t[12]), (e[4] = t[1]), (e[5] = t[5]), (e[6] = t[9]), (e[7] = t[13]), (e[8] = t[2]), (e[9] = t[6]), (e[10] = t[10]), (e[11] = t[14]), (e[12] = t[3]), (e[13] = t[7]), (e[14] = t[11]), (e[15] = t[15]);
          return e;
        }),
        (he.invert = function (e, t) {
          var i = t[0],
            r = t[1],
            n = t[2],
            o = t[3],
            s = t[4],
            a = t[5],
            l = t[6],
            c = t[7],
            u = t[8],
            h = t[9],
            d = t[10],
            f = t[11],
            p = t[12],
            _ = t[13],
            g = t[14],
            y = t[15],
            v = i * a - r * s,
            w = i * l - n * s,
            T = i * c - o * s,
            b = r * l - n * a,
            E = r * c - o * a,
            S = n * c - o * l,
            I = u * _ - h * p,
            C = u * g - d * p,
            z = u * y - f * p,
            k = h * g - d * _,
            O = h * y - f * _,
            V = d * y - f * g,
            R = v * V - w * O + T * k + b * z - E * C + S * I;
          return R ? ((e[0] = (a * V - l * O + c * k) * (R = 1 / R)), (e[1] = (n * O - r * V - o * k) * R), (e[2] = (_ * S - g * E + y * b) * R), (e[3] = (d * E - h * S - f * b) * R), (e[4] = (l * z - s * V - c * C) * R), (e[5] = (i * V - n * z + o * C) * R), (e[6] = (g * T - p * S - y * w) * R), (e[7] = (u * S - d * T + f * w) * R), (e[8] = (s * O - a * z + c * I) * R), (e[9] = (r * z - i * O - o * I) * R), (e[10] = (p * E - _ * T + y * v) * R), (e[11] = (h * T - u * E - f * v) * R), (e[12] = (a * C - s * k - l * I) * R), (e[13] = (i * k - r * C + n * I) * R), (e[14] = (_ * w - p * b - g * v) * R), (e[15] = (u * b - h * w + d * v) * R), e) : null;
        }),
        (he.adjoint = function (e, t) {
          var i = t[0],
            r = t[1],
            n = t[2],
            o = t[3],
            s = t[4],
            a = t[5],
            l = t[6],
            c = t[7],
            u = t[8],
            h = t[9],
            d = t[10],
            f = t[11],
            p = t[12],
            _ = t[13],
            g = t[14],
            y = t[15];
          return (e[0] = a * (d * y - f * g) - h * (l * y - c * g) + _ * (l * f - c * d)), (e[1] = -(r * (d * y - f * g) - h * (n * y - o * g) + _ * (n * f - o * d))), (e[2] = r * (l * y - c * g) - a * (n * y - o * g) + _ * (n * c - o * l)), (e[3] = -(r * (l * f - c * d) - a * (n * f - o * d) + h * (n * c - o * l))), (e[4] = -(s * (d * y - f * g) - u * (l * y - c * g) + p * (l * f - c * d))), (e[5] = i * (d * y - f * g) - u * (n * y - o * g) + p * (n * f - o * d)), (e[6] = -(i * (l * y - c * g) - s * (n * y - o * g) + p * (n * c - o * l))), (e[7] = i * (l * f - c * d) - s * (n * f - o * d) + u * (n * c - o * l)), (e[8] = s * (h * y - f * _) - u * (a * y - c * _) + p * (a * f - c * h)), (e[9] = -(i * (h * y - f * _) - u * (r * y - o * _) + p * (r * f - o * h))), (e[10] = i * (a * y - c * _) - s * (r * y - o * _) + p * (r * c - o * a)), (e[11] = -(i * (a * f - c * h) - s * (r * f - o * h) + u * (r * c - o * a))), (e[12] = -(s * (h * g - d * _) - u * (a * g - l * _) + p * (a * d - l * h))), (e[13] = i * (h * g - d * _) - u * (r * g - n * _) + p * (r * d - n * h)), (e[14] = -(i * (a * g - l * _) - s * (r * g - n * _) + p * (r * l - n * a))), (e[15] = i * (a * d - l * h) - s * (r * d - n * h) + u * (r * l - n * a)), e;
        }),
        (he.determinant = function (e) {
          var t = e[0],
            i = e[1],
            r = e[2],
            n = e[3],
            o = e[4],
            s = e[5],
            a = e[6],
            l = e[7],
            c = e[8],
            u = e[9],
            h = e[10],
            d = e[11],
            f = e[12],
            p = e[13],
            _ = e[14],
            g = e[15];
          return (t * s - i * o) * (h * g - d * _) - (t * a - r * o) * (u * g - d * p) + (t * l - n * o) * (u * _ - h * p) + (i * a - r * s) * (c * g - d * f) - (i * l - n * s) * (c * _ - h * f) + (r * l - n * a) * (c * p - u * f);
        }),
        (he.multiply = Hy),
        (he.translate = function (e, t, i) {
          var r,
            n,
            o,
            s,
            a,
            l,
            c,
            u,
            h,
            d,
            f,
            p,
            _ = i[0],
            g = i[1],
            y = i[2];
          return t === e ? ((e[12] = t[0] * _ + t[4] * g + t[8] * y + t[12]), (e[13] = t[1] * _ + t[5] * g + t[9] * y + t[13]), (e[14] = t[2] * _ + t[6] * g + t[10] * y + t[14]), (e[15] = t[3] * _ + t[7] * g + t[11] * y + t[15])) : ((n = t[1]), (o = t[2]), (s = t[3]), (a = t[4]), (l = t[5]), (c = t[6]), (u = t[7]), (h = t[8]), (d = t[9]), (f = t[10]), (p = t[11]), (e[0] = r = t[0]), (e[1] = n), (e[2] = o), (e[3] = s), (e[4] = a), (e[5] = l), (e[6] = c), (e[7] = u), (e[8] = h), (e[9] = d), (e[10] = f), (e[11] = p), (e[12] = r * _ + a * g + h * y + t[12]), (e[13] = n * _ + l * g + d * y + t[13]), (e[14] = o * _ + c * g + f * y + t[14]), (e[15] = s * _ + u * g + p * y + t[15])), e;
        }),
        (he.scale = function (e, t, i) {
          var r = i[0],
            n = i[1],
            o = i[2];
          return (e[0] = t[0] * r), (e[1] = t[1] * r), (e[2] = t[2] * r), (e[3] = t[3] * r), (e[4] = t[4] * n), (e[5] = t[5] * n), (e[6] = t[6] * n), (e[7] = t[7] * n), (e[8] = t[8] * o), (e[9] = t[9] * o), (e[10] = t[10] * o), (e[11] = t[11] * o), (e[12] = t[12]), (e[13] = t[13]), (e[14] = t[14]), (e[15] = t[15]), e;
        }),
        (he.rotate = function (e, t, i, r) {
          var n,
            o,
            s,
            a,
            l,
            c,
            u,
            h,
            d,
            f,
            p,
            _,
            g,
            y,
            v,
            w,
            T,
            b,
            E,
            S,
            I,
            C,
            z,
            k,
            O = r[0],
            V = r[1],
            R = r[2],
            G = Math.hypot(O, V, R);
          return G < Ai.EPSILON ? null : ((O *= G = 1 / G), (V *= G), (R *= G), (n = Math.sin(i)), (o = Math.cos(i)), (l = t[1]), (c = t[2]), (u = t[3]), (d = t[5]), (f = t[6]), (p = t[7]), (g = t[9]), (y = t[10]), (v = t[11]), (E = O * V * (s = 1 - o) - R * n), (S = V * V * s + o), (I = R * V * s + O * n), (C = O * R * s + V * n), (z = V * R * s - O * n), (k = R * R * s + o), (e[0] = (a = t[0]) * (w = O * O * s + o) + (h = t[4]) * (T = V * O * s + R * n) + (_ = t[8]) * (b = R * O * s - V * n)), (e[1] = l * w + d * T + g * b), (e[2] = c * w + f * T + y * b), (e[3] = u * w + p * T + v * b), (e[4] = a * E + h * S + _ * I), (e[5] = l * E + d * S + g * I), (e[6] = c * E + f * S + y * I), (e[7] = u * E + p * S + v * I), (e[8] = a * C + h * z + _ * k), (e[9] = l * C + d * z + g * k), (e[10] = c * C + f * z + y * k), (e[11] = u * C + p * z + v * k), t !== e && ((e[12] = t[12]), (e[13] = t[13]), (e[14] = t[14]), (e[15] = t[15])), e);
        }),
        (he.rotateX = function (e, t, i) {
          var r = Math.sin(i),
            n = Math.cos(i),
            o = t[4],
            s = t[5],
            a = t[6],
            l = t[7],
            c = t[8],
            u = t[9],
            h = t[10],
            d = t[11];
          return t !== e && ((e[0] = t[0]), (e[1] = t[1]), (e[2] = t[2]), (e[3] = t[3]), (e[12] = t[12]), (e[13] = t[13]), (e[14] = t[14]), (e[15] = t[15])), (e[4] = o * n + c * r), (e[5] = s * n + u * r), (e[6] = a * n + h * r), (e[7] = l * n + d * r), (e[8] = c * n - o * r), (e[9] = u * n - s * r), (e[10] = h * n - a * r), (e[11] = d * n - l * r), e;
        }),
        (he.rotateY = function (e, t, i) {
          var r = Math.sin(i),
            n = Math.cos(i),
            o = t[0],
            s = t[1],
            a = t[2],
            l = t[3],
            c = t[8],
            u = t[9],
            h = t[10],
            d = t[11];
          return t !== e && ((e[4] = t[4]), (e[5] = t[5]), (e[6] = t[6]), (e[7] = t[7]), (e[12] = t[12]), (e[13] = t[13]), (e[14] = t[14]), (e[15] = t[15])), (e[0] = o * n - c * r), (e[1] = s * n - u * r), (e[2] = a * n - h * r), (e[3] = l * n - d * r), (e[8] = o * r + c * n), (e[9] = s * r + u * n), (e[10] = a * r + h * n), (e[11] = l * r + d * n), e;
        }),
        (he.rotateZ = function (e, t, i) {
          var r = Math.sin(i),
            n = Math.cos(i),
            o = t[0],
            s = t[1],
            a = t[2],
            l = t[3],
            c = t[4],
            u = t[5],
            h = t[6],
            d = t[7];
          return t !== e && ((e[8] = t[8]), (e[9] = t[9]), (e[10] = t[10]), (e[11] = t[11]), (e[12] = t[12]), (e[13] = t[13]), (e[14] = t[14]), (e[15] = t[15])), (e[0] = o * n + c * r), (e[1] = s * n + u * r), (e[2] = a * n + h * r), (e[3] = l * n + d * r), (e[4] = c * n - o * r), (e[5] = u * n - s * r), (e[6] = h * n - a * r), (e[7] = d * n - l * r), e;
        }),
        (he.fromTranslation = function (e, t) {
          return (e[0] = 1), (e[1] = 0), (e[2] = 0), (e[3] = 0), (e[4] = 0), (e[5] = 1), (e[6] = 0), (e[7] = 0), (e[8] = 0), (e[9] = 0), (e[10] = 1), (e[11] = 0), (e[12] = t[0]), (e[13] = t[1]), (e[14] = t[2]), (e[15] = 1), e;
        }),
        (he.fromScaling = function (e, t) {
          return (e[0] = t[0]), (e[1] = 0), (e[2] = 0), (e[3] = 0), (e[4] = 0), (e[5] = t[1]), (e[6] = 0), (e[7] = 0), (e[8] = 0), (e[9] = 0), (e[10] = t[2]), (e[11] = 0), (e[12] = 0), (e[13] = 0), (e[14] = 0), (e[15] = 1), e;
        }),
        (he.fromRotation = function (e, t, i) {
          var r,
            n,
            o,
            s = i[0],
            a = i[1],
            l = i[2],
            c = Math.hypot(s, a, l);
          return c < Ai.EPSILON ? null : ((s *= c = 1 / c), (a *= c), (l *= c), (r = Math.sin(t)), (n = Math.cos(t)), (e[0] = s * s * (o = 1 - n) + n), (e[1] = a * s * o + l * r), (e[2] = l * s * o - a * r), (e[3] = 0), (e[4] = s * a * o - l * r), (e[5] = a * a * o + n), (e[6] = l * a * o + s * r), (e[7] = 0), (e[8] = s * l * o + a * r), (e[9] = a * l * o - s * r), (e[10] = l * l * o + n), (e[11] = 0), (e[12] = 0), (e[13] = 0), (e[14] = 0), (e[15] = 1), e);
        }),
        (he.fromXRotation = function (e, t) {
          var i = Math.sin(t),
            r = Math.cos(t);
          return (e[0] = 1), (e[1] = 0), (e[2] = 0), (e[3] = 0), (e[4] = 0), (e[5] = r), (e[6] = i), (e[7] = 0), (e[8] = 0), (e[9] = -i), (e[10] = r), (e[11] = 0), (e[12] = 0), (e[13] = 0), (e[14] = 0), (e[15] = 1), e;
        }),
        (he.fromYRotation = function (e, t) {
          var i = Math.sin(t),
            r = Math.cos(t);
          return (e[0] = r), (e[1] = 0), (e[2] = -i), (e[3] = 0), (e[4] = 0), (e[5] = 1), (e[6] = 0), (e[7] = 0), (e[8] = i), (e[9] = 0), (e[10] = r), (e[11] = 0), (e[12] = 0), (e[13] = 0), (e[14] = 0), (e[15] = 1), e;
        }),
        (he.fromZRotation = function (e, t) {
          var i = Math.sin(t),
            r = Math.cos(t);
          return (e[0] = r), (e[1] = i), (e[2] = 0), (e[3] = 0), (e[4] = -i), (e[5] = r), (e[6] = 0), (e[7] = 0), (e[8] = 0), (e[9] = 0), (e[10] = 1), (e[11] = 0), (e[12] = 0), (e[13] = 0), (e[14] = 0), (e[15] = 1), e;
        }),
        (he.fromRotationTranslation = Wy),
        (he.fromQuat2 = function (e, t) {
          var i = new Ai.ARRAY_TYPE(3),
            r = -t[0],
            n = -t[1],
            o = -t[2],
            s = t[3],
            a = t[4],
            l = t[5],
            c = t[6],
            u = t[7],
            h = r * r + n * n + o * o + s * s;
          return h > 0 ? ((i[0] = (2 * (a * s + u * r + l * o - c * n)) / h), (i[1] = (2 * (l * s + u * n + c * r - a * o)) / h), (i[2] = (2 * (c * s + u * o + a * n - l * r)) / h)) : ((i[0] = 2 * (a * s + u * r + l * o - c * n)), (i[1] = 2 * (l * s + u * n + c * r - a * o)), (i[2] = 2 * (c * s + u * o + a * n - l * r))), Wy(e, t, i), e;
        }),
        (he.getTranslation = function (e, t) {
          return (e[0] = t[12]), (e[1] = t[13]), (e[2] = t[14]), e;
        }),
        (he.getScaling = Xy),
        (he.getRotation = function (e, t) {
          var i = new Ai.ARRAY_TYPE(3);
          Xy(i, t);
          var r = 1 / i[0],
            n = 1 / i[1],
            o = 1 / i[2],
            s = t[0] * r,
            a = t[1] * n,
            l = t[2] * o,
            c = t[4] * r,
            u = t[5] * n,
            h = t[6] * o,
            d = t[8] * r,
            f = t[9] * n,
            p = t[10] * o,
            _ = s + u + p,
            g = 0;
          return _ > 0 ? ((g = 2 * Math.sqrt(_ + 1)), (e[3] = 0.25 * g), (e[0] = (h - f) / g), (e[1] = (d - l) / g), (e[2] = (a - c) / g)) : s > u && s > p ? ((g = 2 * Math.sqrt(1 + s - u - p)), (e[3] = (h - f) / g), (e[0] = 0.25 * g), (e[1] = (a + c) / g), (e[2] = (d + l) / g)) : u > p ? ((g = 2 * Math.sqrt(1 + u - s - p)), (e[3] = (d - l) / g), (e[0] = (a + c) / g), (e[1] = 0.25 * g), (e[2] = (h + f) / g)) : ((g = 2 * Math.sqrt(1 + p - s - u)), (e[3] = (a - c) / g), (e[0] = (d + l) / g), (e[1] = (h + f) / g), (e[2] = 0.25 * g)), e;
        }),
        (he.fromRotationTranslationScale = function (e, t, i, r) {
          var n = t[0],
            o = t[1],
            s = t[2],
            a = t[3],
            l = n + n,
            c = o + o,
            u = s + s,
            h = n * l,
            d = n * c,
            f = n * u,
            p = o * c,
            _ = o * u,
            g = s * u,
            y = a * l,
            v = a * c,
            w = a * u,
            T = r[0],
            b = r[1],
            E = r[2];
          return (e[0] = (1 - (p + g)) * T), (e[1] = (d + w) * T), (e[2] = (f - v) * T), (e[3] = 0), (e[4] = (d - w) * b), (e[5] = (1 - (h + g)) * b), (e[6] = (_ + y) * b), (e[7] = 0), (e[8] = (f + v) * E), (e[9] = (_ - y) * E), (e[10] = (1 - (h + p)) * E), (e[11] = 0), (e[12] = i[0]), (e[13] = i[1]), (e[14] = i[2]), (e[15] = 1), e;
        }),
        (he.fromRotationTranslationScaleOrigin = function (e, t, i, r, n) {
          var o = t[0],
            s = t[1],
            a = t[2],
            l = t[3],
            c = o + o,
            u = s + s,
            h = a + a,
            d = o * c,
            f = o * u,
            p = o * h,
            _ = s * u,
            g = s * h,
            y = a * h,
            v = l * c,
            w = l * u,
            T = l * h,
            b = r[0],
            E = r[1],
            S = r[2],
            I = n[0],
            C = n[1],
            z = n[2],
            k = (1 - (_ + y)) * b,
            O = (f + T) * b,
            V = (p - w) * b,
            R = (f - T) * E,
            G = (1 - (d + y)) * E,
            Z = (g + v) * E,
            X = (p + w) * S,
            j = (g - v) * S,
            q = (1 - (d + _)) * S;
          return (e[0] = k), (e[1] = O), (e[2] = V), (e[3] = 0), (e[4] = R), (e[5] = G), (e[6] = Z), (e[7] = 0), (e[8] = X), (e[9] = j), (e[10] = q), (e[11] = 0), (e[12] = i[0] + I - (k * I + R * C + X * z)), (e[13] = i[1] + C - (O * I + G * C + j * z)), (e[14] = i[2] + z - (V * I + Z * C + q * z)), (e[15] = 1), e;
        }),
        (he.fromQuat = function (e, t) {
          var i = t[0],
            r = t[1],
            n = t[2],
            o = t[3],
            s = i + i,
            a = r + r,
            l = n + n,
            c = i * s,
            u = r * s,
            h = r * a,
            d = n * s,
            f = n * a,
            p = n * l,
            _ = o * s,
            g = o * a,
            y = o * l;
          return (e[0] = 1 - h - p), (e[1] = u + y), (e[2] = d - g), (e[3] = 0), (e[4] = u - y), (e[5] = 1 - c - p), (e[6] = f + _), (e[7] = 0), (e[8] = d + g), (e[9] = f - _), (e[10] = 1 - c - h), (e[11] = 0), (e[12] = 0), (e[13] = 0), (e[14] = 0), (e[15] = 1), e;
        }),
        (he.frustum = function (e, t, i, r, n, o, s) {
          var a = 1 / (i - t),
            l = 1 / (n - r),
            c = 1 / (o - s);
          return (e[0] = 2 * o * a), (e[1] = 0), (e[2] = 0), (e[3] = 0), (e[4] = 0), (e[5] = 2 * o * l), (e[6] = 0), (e[7] = 0), (e[8] = (i + t) * a), (e[9] = (n + r) * l), (e[10] = (s + o) * c), (e[11] = -1), (e[12] = 0), (e[13] = 0), (e[14] = s * o * 2 * c), (e[15] = 0), e;
        }),
        (he.perspectiveNO = Yy),
        (he.perspectiveZO = function (e, t, i, r, n) {
          var o,
            s = 1 / Math.tan(t / 2);
          return (e[0] = s / i), (e[1] = 0), (e[2] = 0), (e[3] = 0), (e[4] = 0), (e[5] = s), (e[6] = 0), (e[7] = 0), (e[8] = 0), (e[9] = 0), (e[11] = -1), (e[12] = 0), (e[13] = 0), (e[15] = 0), n != null && n !== 1 / 0 ? ((e[10] = n * (o = 1 / (r - n))), (e[14] = n * r * o)) : ((e[10] = -1), (e[14] = -r)), e;
        }),
        (he.perspectiveFromFieldOfView = function (e, t, i, r) {
          var n = Math.tan((t.upDegrees * Math.PI) / 180),
            o = Math.tan((t.downDegrees * Math.PI) / 180),
            s = Math.tan((t.leftDegrees * Math.PI) / 180),
            a = Math.tan((t.rightDegrees * Math.PI) / 180),
            l = 2 / (s + a),
            c = 2 / (n + o);
          return (e[0] = l), (e[1] = 0), (e[2] = 0), (e[3] = 0), (e[4] = 0), (e[5] = c), (e[6] = 0), (e[7] = 0), (e[8] = -(s - a) * l * 0.5), (e[9] = (n - o) * c * 0.5), (e[10] = r / (i - r)), (e[11] = -1), (e[12] = 0), (e[13] = 0), (e[14] = (r * i) / (i - r)), (e[15] = 0), e;
        }),
        (he.orthoNO = Ky),
        (he.orthoZO = function (e, t, i, r, n, o, s) {
          var a = 1 / (t - i),
            l = 1 / (r - n),
            c = 1 / (o - s);
          return (e[0] = -2 * a), (e[1] = 0), (e[2] = 0), (e[3] = 0), (e[4] = 0), (e[5] = -2 * l), (e[6] = 0), (e[7] = 0), (e[8] = 0), (e[9] = 0), (e[10] = c), (e[11] = 0), (e[12] = (t + i) * a), (e[13] = (n + r) * l), (e[14] = o * c), (e[15] = 1), e;
        }),
        (he.lookAt = function (e, t, i, r) {
          var n,
            o,
            s,
            a,
            l,
            c,
            u,
            h,
            d,
            f,
            p = t[0],
            _ = t[1],
            g = t[2],
            y = r[0],
            v = r[1],
            w = r[2],
            T = i[0],
            b = i[1],
            E = i[2];
          return Math.abs(p - T) < Ai.EPSILON && Math.abs(_ - b) < Ai.EPSILON && Math.abs(g - E) < Ai.EPSILON ? $y(e) : ((u = p - T), (h = _ - b), (d = g - E), (n = v * (d *= f = 1 / Math.hypot(u, h, d)) - w * (h *= f)), (o = w * (u *= f) - y * d), (s = y * h - v * u), (f = Math.hypot(n, o, s)) ? ((n *= f = 1 / f), (o *= f), (s *= f)) : ((n = 0), (o = 0), (s = 0)), (a = h * s - d * o), (l = d * n - u * s), (c = u * o - h * n), (f = Math.hypot(a, l, c)) ? ((a *= f = 1 / f), (l *= f), (c *= f)) : ((a = 0), (l = 0), (c = 0)), (e[0] = n), (e[1] = a), (e[2] = u), (e[3] = 0), (e[4] = o), (e[5] = l), (e[6] = h), (e[7] = 0), (e[8] = s), (e[9] = c), (e[10] = d), (e[11] = 0), (e[12] = -(n * p + o * _ + s * g)), (e[13] = -(a * p + l * _ + c * g)), (e[14] = -(u * p + h * _ + d * g)), (e[15] = 1), e);
        }),
        (he.targetTo = function (e, t, i, r) {
          var n = t[0],
            o = t[1],
            s = t[2],
            a = r[0],
            l = r[1],
            c = r[2],
            u = n - i[0],
            h = o - i[1],
            d = s - i[2],
            f = u * u + h * h + d * d;
          f > 0 && ((u *= f = 1 / Math.sqrt(f)), (h *= f), (d *= f));
          var p = l * d - c * h,
            _ = c * u - a * d,
            g = a * h - l * u;
          return (f = p * p + _ * _ + g * g) > 0 && ((p *= f = 1 / Math.sqrt(f)), (_ *= f), (g *= f)), (e[0] = p), (e[1] = _), (e[2] = g), (e[3] = 0), (e[4] = h * g - d * _), (e[5] = d * p - u * g), (e[6] = u * _ - h * p), (e[7] = 0), (e[8] = u), (e[9] = h), (e[10] = d), (e[11] = 0), (e[12] = n), (e[13] = o), (e[14] = s), (e[15] = 1), e;
        }),
        (he.str = function (e) {
          return 'mat4(' + e[0] + ', ' + e[1] + ', ' + e[2] + ', ' + e[3] + ', ' + e[4] + ', ' + e[5] + ', ' + e[6] + ', ' + e[7] + ', ' + e[8] + ', ' + e[9] + ', ' + e[10] + ', ' + e[11] + ', ' + e[12] + ', ' + e[13] + ', ' + e[14] + ', ' + e[15] + ')';
        }),
        (he.frob = function (e) {
          return Math.hypot(e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]);
        }),
        (he.add = function (e, t, i) {
          return (e[0] = t[0] + i[0]), (e[1] = t[1] + i[1]), (e[2] = t[2] + i[2]), (e[3] = t[3] + i[3]), (e[4] = t[4] + i[4]), (e[5] = t[5] + i[5]), (e[6] = t[6] + i[6]), (e[7] = t[7] + i[7]), (e[8] = t[8] + i[8]), (e[9] = t[9] + i[9]), (e[10] = t[10] + i[10]), (e[11] = t[11] + i[11]), (e[12] = t[12] + i[12]), (e[13] = t[13] + i[13]), (e[14] = t[14] + i[14]), (e[15] = t[15] + i[15]), e;
        }),
        (he.subtract = Jy),
        (he.multiplyScalar = function (e, t, i) {
          return (e[0] = t[0] * i), (e[1] = t[1] * i), (e[2] = t[2] * i), (e[3] = t[3] * i), (e[4] = t[4] * i), (e[5] = t[5] * i), (e[6] = t[6] * i), (e[7] = t[7] * i), (e[8] = t[8] * i), (e[9] = t[9] * i), (e[10] = t[10] * i), (e[11] = t[11] * i), (e[12] = t[12] * i), (e[13] = t[13] * i), (e[14] = t[14] * i), (e[15] = t[15] * i), e;
        }),
        (he.multiplyScalarAndAdd = function (e, t, i, r) {
          return (e[0] = t[0] + i[0] * r), (e[1] = t[1] + i[1] * r), (e[2] = t[2] + i[2] * r), (e[3] = t[3] + i[3] * r), (e[4] = t[4] + i[4] * r), (e[5] = t[5] + i[5] * r), (e[6] = t[6] + i[6] * r), (e[7] = t[7] + i[7] * r), (e[8] = t[8] + i[8] * r), (e[9] = t[9] + i[9] * r), (e[10] = t[10] + i[10] * r), (e[11] = t[11] + i[11] * r), (e[12] = t[12] + i[12] * r), (e[13] = t[13] + i[13] * r), (e[14] = t[14] + i[14] * r), (e[15] = t[15] + i[15] * r), e;
        }),
        (he.exactEquals = function (e, t) {
          return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[7] === t[7] && e[8] === t[8] && e[9] === t[9] && e[10] === t[10] && e[11] === t[11] && e[12] === t[12] && e[13] === t[13] && e[14] === t[14] && e[15] === t[15];
        }),
        (he.equals = function (e, t) {
          var i = e[0],
            r = e[1],
            n = e[2],
            o = e[3],
            s = e[4],
            a = e[5],
            l = e[6],
            c = e[7],
            u = e[8],
            h = e[9],
            d = e[10],
            f = e[11],
            p = e[12],
            _ = e[13],
            g = e[14],
            y = e[15],
            v = t[0],
            w = t[1],
            T = t[2],
            b = t[3],
            E = t[4],
            S = t[5],
            I = t[6],
            C = t[7],
            z = t[8],
            k = t[9],
            O = t[10],
            V = t[11],
            R = t[12],
            G = t[13],
            Z = t[14],
            X = t[15];
          return Math.abs(i - v) <= Ai.EPSILON * Math.max(1, Math.abs(i), Math.abs(v)) && Math.abs(r - w) <= Ai.EPSILON * Math.max(1, Math.abs(r), Math.abs(w)) && Math.abs(n - T) <= Ai.EPSILON * Math.max(1, Math.abs(n), Math.abs(T)) && Math.abs(o - b) <= Ai.EPSILON * Math.max(1, Math.abs(o), Math.abs(b)) && Math.abs(s - E) <= Ai.EPSILON * Math.max(1, Math.abs(s), Math.abs(E)) && Math.abs(a - S) <= Ai.EPSILON * Math.max(1, Math.abs(a), Math.abs(S)) && Math.abs(l - I) <= Ai.EPSILON * Math.max(1, Math.abs(l), Math.abs(I)) && Math.abs(c - C) <= Ai.EPSILON * Math.max(1, Math.abs(c), Math.abs(C)) && Math.abs(u - z) <= Ai.EPSILON * Math.max(1, Math.abs(u), Math.abs(z)) && Math.abs(h - k) <= Ai.EPSILON * Math.max(1, Math.abs(h), Math.abs(k)) && Math.abs(d - O) <= Ai.EPSILON * Math.max(1, Math.abs(d), Math.abs(O)) && Math.abs(f - V) <= Ai.EPSILON * Math.max(1, Math.abs(f), Math.abs(V)) && Math.abs(p - R) <= Ai.EPSILON * Math.max(1, Math.abs(p), Math.abs(R)) && Math.abs(_ - G) <= Ai.EPSILON * Math.max(1, Math.abs(_), Math.abs(G)) && Math.abs(g - Z) <= Ai.EPSILON * Math.max(1, Math.abs(g), Math.abs(Z)) && Math.abs(y - X) <= Ai.EPSILON * Math.max(1, Math.abs(y), Math.abs(X));
        }),
        (he.sub = he.mul = he.ortho = he.perspective = void 0);
      var Ai = (function (e, t) {
        if (e && e.__esModule) return e;
        if (e === null || (Xf(e) !== 'object' && typeof e != 'function')) return { default: e };
        var i = Zy(void 0);
        if (i && i.has(e)) return i.get(e);
        var r = {},
          n = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var o in e)
          if (o !== 'default' && Object.prototype.hasOwnProperty.call(e, o)) {
            var s = n ? Object.getOwnPropertyDescriptor(e, o) : null;
            s && (s.get || s.set) ? Object.defineProperty(r, o, s) : (r[o] = e[o]);
          }
        return (r.default = e), i && i.set(e, r), r;
      })(Ki);
      function Zy(e) {
        if (typeof WeakMap != 'function') return null;
        var t = new WeakMap(),
          i = new WeakMap();
        return (Zy = function (r) {
          return r ? i : t;
        })(e);
      }
      function $y(e) {
        return (e[0] = 1), (e[1] = 0), (e[2] = 0), (e[3] = 0), (e[4] = 0), (e[5] = 1), (e[6] = 0), (e[7] = 0), (e[8] = 0), (e[9] = 0), (e[10] = 1), (e[11] = 0), (e[12] = 0), (e[13] = 0), (e[14] = 0), (e[15] = 1), e;
      }
      function Hy(e, t, i) {
        var r = t[0],
          n = t[1],
          o = t[2],
          s = t[3],
          a = t[4],
          l = t[5],
          c = t[6],
          u = t[7],
          h = t[8],
          d = t[9],
          f = t[10],
          p = t[11],
          _ = t[12],
          g = t[13],
          y = t[14],
          v = t[15],
          w = i[0],
          T = i[1],
          b = i[2],
          E = i[3];
        return (e[0] = w * r + T * a + b * h + E * _), (e[1] = w * n + T * l + b * d + E * g), (e[2] = w * o + T * c + b * f + E * y), (e[3] = w * s + T * u + b * p + E * v), (e[4] = (w = i[4]) * r + (T = i[5]) * a + (b = i[6]) * h + (E = i[7]) * _), (e[5] = w * n + T * l + b * d + E * g), (e[6] = w * o + T * c + b * f + E * y), (e[7] = w * s + T * u + b * p + E * v), (e[8] = (w = i[8]) * r + (T = i[9]) * a + (b = i[10]) * h + (E = i[11]) * _), (e[9] = w * n + T * l + b * d + E * g), (e[10] = w * o + T * c + b * f + E * y), (e[11] = w * s + T * u + b * p + E * v), (e[12] = (w = i[12]) * r + (T = i[13]) * a + (b = i[14]) * h + (E = i[15]) * _), (e[13] = w * n + T * l + b * d + E * g), (e[14] = w * o + T * c + b * f + E * y), (e[15] = w * s + T * u + b * p + E * v), e;
      }
      function Wy(e, t, i) {
        var r = t[0],
          n = t[1],
          o = t[2],
          s = t[3],
          a = r + r,
          l = n + n,
          c = o + o,
          u = r * a,
          h = r * l,
          d = r * c,
          f = n * l,
          p = n * c,
          _ = o * c,
          g = s * a,
          y = s * l,
          v = s * c;
        return (e[0] = 1 - (f + _)), (e[1] = h + v), (e[2] = d - y), (e[3] = 0), (e[4] = h - v), (e[5] = 1 - (u + _)), (e[6] = p + g), (e[7] = 0), (e[8] = d + y), (e[9] = p - g), (e[10] = 1 - (u + f)), (e[11] = 0), (e[12] = i[0]), (e[13] = i[1]), (e[14] = i[2]), (e[15] = 1), e;
      }
      function Xy(e, t) {
        var i = t[4],
          r = t[5],
          n = t[6],
          o = t[8],
          s = t[9],
          a = t[10];
        return (e[0] = Math.hypot(t[0], t[1], t[2])), (e[1] = Math.hypot(i, r, n)), (e[2] = Math.hypot(o, s, a)), e;
      }
      function Yy(e, t, i, r, n) {
        var o,
          s = 1 / Math.tan(t / 2);
        return (e[0] = s / i), (e[1] = 0), (e[2] = 0), (e[3] = 0), (e[4] = 0), (e[5] = s), (e[6] = 0), (e[7] = 0), (e[8] = 0), (e[9] = 0), (e[11] = -1), (e[12] = 0), (e[13] = 0), (e[15] = 0), n != null && n !== 1 / 0 ? ((e[10] = (n + r) * (o = 1 / (r - n))), (e[14] = 2 * n * r * o)) : ((e[10] = -1), (e[14] = -2 * r)), e;
      }
      function Ky(e, t, i, r, n, o, s) {
        var a = 1 / (t - i),
          l = 1 / (r - n),
          c = 1 / (o - s);
        return (e[0] = -2 * a), (e[1] = 0), (e[2] = 0), (e[3] = 0), (e[4] = 0), (e[5] = -2 * l), (e[6] = 0), (e[7] = 0), (e[8] = 0), (e[9] = 0), (e[10] = 2 * c), (e[11] = 0), (e[12] = (t + i) * a), (e[13] = (n + r) * l), (e[14] = (s + o) * c), (e[15] = 1), e;
      }
      function Jy(e, t, i) {
        return (e[0] = t[0] - i[0]), (e[1] = t[1] - i[1]), (e[2] = t[2] - i[2]), (e[3] = t[3] - i[3]), (e[4] = t[4] - i[4]), (e[5] = t[5] - i[5]), (e[6] = t[6] - i[6]), (e[7] = t[7] - i[7]), (e[8] = t[8] - i[8]), (e[9] = t[9] - i[9]), (e[10] = t[10] - i[10]), (e[11] = t[11] - i[11]), (e[12] = t[12] - i[12]), (e[13] = t[13] - i[13]), (e[14] = t[14] - i[14]), (e[15] = t[15] - i[15]), e;
      }
      (he.perspective = Yy), (he.ortho = Ky), (he.mul = Hy), (he.sub = Jy);
      var ae = {},
        ue = {};
      function Yf(e) {
        return (
          (Yf =
            typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
              ? function (t) {
                  return typeof t;
                }
              : function (t) {
                  return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t;
                }),
          Yf(e)
        );
      }
      Object.defineProperty(ue, '__esModule', { value: !0 }),
        (ue.create = t0),
        (ue.clone = function (e) {
          var t = new so.ARRAY_TYPE(3);
          return (t[0] = e[0]), (t[1] = e[1]), (t[2] = e[2]), t;
        }),
        (ue.length = e0),
        (ue.fromValues = function (e, t, i) {
          var r = new so.ARRAY_TYPE(3);
          return (r[0] = e), (r[1] = t), (r[2] = i), r;
        }),
        (ue.copy = function (e, t) {
          return (e[0] = t[0]), (e[1] = t[1]), (e[2] = t[2]), e;
        }),
        (ue.set = function (e, t, i, r) {
          return (e[0] = t), (e[1] = i), (e[2] = r), e;
        }),
        (ue.add = function (e, t, i) {
          return (e[0] = t[0] + i[0]), (e[1] = t[1] + i[1]), (e[2] = t[2] + i[2]), e;
        }),
        (ue.subtract = i0),
        (ue.multiply = r0),
        (ue.divide = n0),
        (ue.ceil = function (e, t) {
          return (e[0] = Math.ceil(t[0])), (e[1] = Math.ceil(t[1])), (e[2] = Math.ceil(t[2])), e;
        }),
        (ue.floor = function (e, t) {
          return (e[0] = Math.floor(t[0])), (e[1] = Math.floor(t[1])), (e[2] = Math.floor(t[2])), e;
        }),
        (ue.min = function (e, t, i) {
          return (e[0] = Math.min(t[0], i[0])), (e[1] = Math.min(t[1], i[1])), (e[2] = Math.min(t[2], i[2])), e;
        }),
        (ue.max = function (e, t, i) {
          return (e[0] = Math.max(t[0], i[0])), (e[1] = Math.max(t[1], i[1])), (e[2] = Math.max(t[2], i[2])), e;
        }),
        (ue.round = function (e, t) {
          return (e[0] = Math.round(t[0])), (e[1] = Math.round(t[1])), (e[2] = Math.round(t[2])), e;
        }),
        (ue.scale = function (e, t, i) {
          return (e[0] = t[0] * i), (e[1] = t[1] * i), (e[2] = t[2] * i), e;
        }),
        (ue.scaleAndAdd = function (e, t, i, r) {
          return (e[0] = t[0] + i[0] * r), (e[1] = t[1] + i[1] * r), (e[2] = t[2] + i[2] * r), e;
        }),
        (ue.distance = o0),
        (ue.squaredDistance = s0),
        (ue.squaredLength = a0),
        (ue.negate = function (e, t) {
          return (e[0] = -t[0]), (e[1] = -t[1]), (e[2] = -t[2]), e;
        }),
        (ue.inverse = function (e, t) {
          return (e[0] = 1 / t[0]), (e[1] = 1 / t[1]), (e[2] = 1 / t[2]), e;
        }),
        (ue.normalize = function (e, t) {
          var i = t[0],
            r = t[1],
            n = t[2],
            o = i * i + r * r + n * n;
          return o > 0 && (o = 1 / Math.sqrt(o)), (e[0] = t[0] * o), (e[1] = t[1] * o), (e[2] = t[2] * o), e;
        }),
        (ue.dot = l0),
        (ue.cross = function (e, t, i) {
          var r = t[0],
            n = t[1],
            o = t[2],
            s = i[0],
            a = i[1],
            l = i[2];
          return (e[0] = n * l - o * a), (e[1] = o * s - r * l), (e[2] = r * a - n * s), e;
        }),
        (ue.lerp = function (e, t, i, r) {
          var n = t[0],
            o = t[1],
            s = t[2];
          return (e[0] = n + r * (i[0] - n)), (e[1] = o + r * (i[1] - o)), (e[2] = s + r * (i[2] - s)), e;
        }),
        (ue.hermite = function (e, t, i, r, n, o) {
          var s = o * o,
            a = s * (2 * o - 3) + 1,
            l = s * (o - 2) + o,
            c = s * (o - 1),
            u = s * (3 - 2 * o);
          return (e[0] = t[0] * a + i[0] * l + r[0] * c + n[0] * u), (e[1] = t[1] * a + i[1] * l + r[1] * c + n[1] * u), (e[2] = t[2] * a + i[2] * l + r[2] * c + n[2] * u), e;
        }),
        (ue.bezier = function (e, t, i, r, n, o) {
          var s = 1 - o,
            a = s * s,
            l = o * o,
            c = a * s,
            u = 3 * o * a,
            h = 3 * l * s,
            d = l * o;
          return (e[0] = t[0] * c + i[0] * u + r[0] * h + n[0] * d), (e[1] = t[1] * c + i[1] * u + r[1] * h + n[1] * d), (e[2] = t[2] * c + i[2] * u + r[2] * h + n[2] * d), e;
        }),
        (ue.random = function (e, t) {
          t = t || 1;
          var i = 2 * so.RANDOM() * Math.PI,
            r = 2 * so.RANDOM() - 1,
            n = Math.sqrt(1 - r * r) * t;
          return (e[0] = Math.cos(i) * n), (e[1] = Math.sin(i) * n), (e[2] = r * t), e;
        }),
        (ue.transformMat4 = function (e, t, i) {
          var r = t[0],
            n = t[1],
            o = t[2],
            s = i[3] * r + i[7] * n + i[11] * o + i[15];
          return (e[0] = (i[0] * r + i[4] * n + i[8] * o + i[12]) / (s = s || 1)), (e[1] = (i[1] * r + i[5] * n + i[9] * o + i[13]) / s), (e[2] = (i[2] * r + i[6] * n + i[10] * o + i[14]) / s), e;
        }),
        (ue.transformMat3 = function (e, t, i) {
          var r = t[0],
            n = t[1],
            o = t[2];
          return (e[0] = r * i[0] + n * i[3] + o * i[6]), (e[1] = r * i[1] + n * i[4] + o * i[7]), (e[2] = r * i[2] + n * i[5] + o * i[8]), e;
        }),
        (ue.transformQuat = function (e, t, i) {
          var r = i[0],
            n = i[1],
            o = i[2],
            s = t[0],
            a = t[1],
            l = t[2],
            c = n * l - o * a,
            u = o * s - r * l,
            h = r * a - n * s,
            d = n * h - o * u,
            f = o * c - r * h,
            p = r * u - n * c,
            _ = 2 * i[3];
          return (u *= _), (h *= _), (f *= 2), (p *= 2), (e[0] = s + (c *= _) + (d *= 2)), (e[1] = a + u + f), (e[2] = l + h + p), e;
        }),
        (ue.rotateX = function (e, t, i, r) {
          var n = [],
            o = [];
          return (n[0] = t[0] - i[0]), (n[1] = t[1] - i[1]), (n[2] = t[2] - i[2]), (o[0] = n[0]), (o[1] = n[1] * Math.cos(r) - n[2] * Math.sin(r)), (o[2] = n[1] * Math.sin(r) + n[2] * Math.cos(r)), (e[0] = o[0] + i[0]), (e[1] = o[1] + i[1]), (e[2] = o[2] + i[2]), e;
        }),
        (ue.rotateY = function (e, t, i, r) {
          var n = [],
            o = [];
          return (n[0] = t[0] - i[0]), (n[1] = t[1] - i[1]), (n[2] = t[2] - i[2]), (o[0] = n[2] * Math.sin(r) + n[0] * Math.cos(r)), (o[1] = n[1]), (o[2] = n[2] * Math.cos(r) - n[0] * Math.sin(r)), (e[0] = o[0] + i[0]), (e[1] = o[1] + i[1]), (e[2] = o[2] + i[2]), e;
        }),
        (ue.rotateZ = function (e, t, i, r) {
          var n = [],
            o = [];
          return (n[0] = t[0] - i[0]), (n[1] = t[1] - i[1]), (n[2] = t[2] - i[2]), (o[0] = n[0] * Math.cos(r) - n[1] * Math.sin(r)), (o[1] = n[0] * Math.sin(r) + n[1] * Math.cos(r)), (o[2] = n[2]), (e[0] = o[0] + i[0]), (e[1] = o[1] + i[1]), (e[2] = o[2] + i[2]), e;
        }),
        (ue.angle = function (e, t) {
          var i = e[0],
            r = e[1],
            n = e[2],
            o = t[0],
            s = t[1],
            a = t[2],
            l = Math.sqrt(i * i + r * r + n * n) * Math.sqrt(o * o + s * s + a * a),
            c = l && l0(e, t) / l;
          return Math.acos(Math.min(Math.max(c, -1), 1));
        }),
        (ue.zero = function (e) {
          return (e[0] = 0), (e[1] = 0), (e[2] = 0), e;
        }),
        (ue.str = function (e) {
          return 'vec3(' + e[0] + ', ' + e[1] + ', ' + e[2] + ')';
        }),
        (ue.exactEquals = function (e, t) {
          return e[0] === t[0] && e[1] === t[1] && e[2] === t[2];
        }),
        (ue.equals = function (e, t) {
          var i = e[0],
            r = e[1],
            n = e[2],
            o = t[0],
            s = t[1],
            a = t[2];
          return Math.abs(i - o) <= so.EPSILON * Math.max(1, Math.abs(i), Math.abs(o)) && Math.abs(r - s) <= so.EPSILON * Math.max(1, Math.abs(r), Math.abs(s)) && Math.abs(n - a) <= so.EPSILON * Math.max(1, Math.abs(n), Math.abs(a));
        }),
        (ue.forEach = ue.sqrLen = ue.len = ue.sqrDist = ue.dist = ue.div = ue.mul = ue.sub = void 0);
      var so = (function (e, t) {
        if (e && e.__esModule) return e;
        if (e === null || (Yf(e) !== 'object' && typeof e != 'function')) return { default: e };
        var i = Qy(void 0);
        if (i && i.has(e)) return i.get(e);
        var r = {},
          n = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var o in e)
          if (o !== 'default' && Object.prototype.hasOwnProperty.call(e, o)) {
            var s = n ? Object.getOwnPropertyDescriptor(e, o) : null;
            s && (s.get || s.set) ? Object.defineProperty(r, o, s) : (r[o] = e[o]);
          }
        return (r.default = e), i && i.set(e, r), r;
      })(Ki);
      function Qy(e) {
        if (typeof WeakMap != 'function') return null;
        var t = new WeakMap(),
          i = new WeakMap();
        return (Qy = function (r) {
          return r ? i : t;
        })(e);
      }
      function t0() {
        var e = new so.ARRAY_TYPE(3);
        return so.ARRAY_TYPE != Float32Array && ((e[0] = 0), (e[1] = 0), (e[2] = 0)), e;
      }
      function e0(e) {
        return Math.hypot(e[0], e[1], e[2]);
      }
      function i0(e, t, i) {
        return (e[0] = t[0] - i[0]), (e[1] = t[1] - i[1]), (e[2] = t[2] - i[2]), e;
      }
      function r0(e, t, i) {
        return (e[0] = t[0] * i[0]), (e[1] = t[1] * i[1]), (e[2] = t[2] * i[2]), e;
      }
      function n0(e, t, i) {
        return (e[0] = t[0] / i[0]), (e[1] = t[1] / i[1]), (e[2] = t[2] / i[2]), e;
      }
      function o0(e, t) {
        return Math.hypot(t[0] - e[0], t[1] - e[1], t[2] - e[2]);
      }
      function s0(e, t) {
        var i = t[0] - e[0],
          r = t[1] - e[1],
          n = t[2] - e[2];
        return i * i + r * r + n * n;
      }
      function a0(e) {
        var t = e[0],
          i = e[1],
          r = e[2];
        return t * t + i * i + r * r;
      }
      function l0(e, t) {
        return e[0] * t[0] + e[1] * t[1] + e[2] * t[2];
      }
      (ue.sub = i0), (ue.mul = r0), (ue.div = n0), (ue.dist = o0), (ue.sqrDist = s0), (ue.len = e0), (ue.sqrLen = a0);
      var ao,
        jM =
          ((ao = t0()),
          function (e, t, i, r, n, o) {
            var s, a;
            for (t || (t = 3), i || (i = 0), a = r ? Math.min(r * t + i, e.length) : e.length, s = i; s < a; s += t) (ao[0] = e[s]), (ao[1] = e[s + 1]), (ao[2] = e[s + 2]), n(ao, ao, o), (e[s] = ao[0]), (e[s + 1] = ao[1]), (e[s + 2] = ao[2]);
            return e;
          });
      ue.forEach = jM;
      var Te = {};
      function Kf(e) {
        return (
          (Kf =
            typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
              ? function (t) {
                  return typeof t;
                }
              : function (t) {
                  return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t;
                }),
          Kf(e)
        );
      }
      Object.defineProperty(Te, '__esModule', { value: !0 }),
        (Te.create = u0),
        (Te.clone = function (e) {
          var t = new ln.ARRAY_TYPE(4);
          return (t[0] = e[0]), (t[1] = e[1]), (t[2] = e[2]), (t[3] = e[3]), t;
        }),
        (Te.fromValues = function (e, t, i, r) {
          var n = new ln.ARRAY_TYPE(4);
          return (n[0] = e), (n[1] = t), (n[2] = i), (n[3] = r), n;
        }),
        (Te.copy = function (e, t) {
          return (e[0] = t[0]), (e[1] = t[1]), (e[2] = t[2]), (e[3] = t[3]), e;
        }),
        (Te.set = function (e, t, i, r, n) {
          return (e[0] = t), (e[1] = i), (e[2] = r), (e[3] = n), e;
        }),
        (Te.add = function (e, t, i) {
          return (e[0] = t[0] + i[0]), (e[1] = t[1] + i[1]), (e[2] = t[2] + i[2]), (e[3] = t[3] + i[3]), e;
        }),
        (Te.subtract = h0),
        (Te.multiply = d0),
        (Te.divide = f0),
        (Te.ceil = function (e, t) {
          return (e[0] = Math.ceil(t[0])), (e[1] = Math.ceil(t[1])), (e[2] = Math.ceil(t[2])), (e[3] = Math.ceil(t[3])), e;
        }),
        (Te.floor = function (e, t) {
          return (e[0] = Math.floor(t[0])), (e[1] = Math.floor(t[1])), (e[2] = Math.floor(t[2])), (e[3] = Math.floor(t[3])), e;
        }),
        (Te.min = function (e, t, i) {
          return (e[0] = Math.min(t[0], i[0])), (e[1] = Math.min(t[1], i[1])), (e[2] = Math.min(t[2], i[2])), (e[3] = Math.min(t[3], i[3])), e;
        }),
        (Te.max = function (e, t, i) {
          return (e[0] = Math.max(t[0], i[0])), (e[1] = Math.max(t[1], i[1])), (e[2] = Math.max(t[2], i[2])), (e[3] = Math.max(t[3], i[3])), e;
        }),
        (Te.round = function (e, t) {
          return (e[0] = Math.round(t[0])), (e[1] = Math.round(t[1])), (e[2] = Math.round(t[2])), (e[3] = Math.round(t[3])), e;
        }),
        (Te.scale = function (e, t, i) {
          return (e[0] = t[0] * i), (e[1] = t[1] * i), (e[2] = t[2] * i), (e[3] = t[3] * i), e;
        }),
        (Te.scaleAndAdd = function (e, t, i, r) {
          return (e[0] = t[0] + i[0] * r), (e[1] = t[1] + i[1] * r), (e[2] = t[2] + i[2] * r), (e[3] = t[3] + i[3] * r), e;
        }),
        (Te.distance = p0),
        (Te.squaredDistance = m0),
        (Te.length = _0),
        (Te.squaredLength = g0),
        (Te.negate = function (e, t) {
          return (e[0] = -t[0]), (e[1] = -t[1]), (e[2] = -t[2]), (e[3] = -t[3]), e;
        }),
        (Te.inverse = function (e, t) {
          return (e[0] = 1 / t[0]), (e[1] = 1 / t[1]), (e[2] = 1 / t[2]), (e[3] = 1 / t[3]), e;
        }),
        (Te.normalize = function (e, t) {
          var i = t[0],
            r = t[1],
            n = t[2],
            o = t[3],
            s = i * i + r * r + n * n + o * o;
          return s > 0 && (s = 1 / Math.sqrt(s)), (e[0] = i * s), (e[1] = r * s), (e[2] = n * s), (e[3] = o * s), e;
        }),
        (Te.dot = function (e, t) {
          return e[0] * t[0] + e[1] * t[1] + e[2] * t[2] + e[3] * t[3];
        }),
        (Te.cross = function (e, t, i, r) {
          var n = i[0] * r[1] - i[1] * r[0],
            o = i[0] * r[2] - i[2] * r[0],
            s = i[0] * r[3] - i[3] * r[0],
            a = i[1] * r[2] - i[2] * r[1],
            l = i[1] * r[3] - i[3] * r[1],
            c = i[2] * r[3] - i[3] * r[2],
            u = t[0],
            h = t[1],
            d = t[2],
            f = t[3];
          return (e[0] = h * c - d * l + f * a), (e[1] = -u * c + d * s - f * o), (e[2] = u * l - h * s + f * n), (e[3] = -u * a + h * o - d * n), e;
        }),
        (Te.lerp = function (e, t, i, r) {
          var n = t[0],
            o = t[1],
            s = t[2],
            a = t[3];
          return (e[0] = n + r * (i[0] - n)), (e[1] = o + r * (i[1] - o)), (e[2] = s + r * (i[2] - s)), (e[3] = a + r * (i[3] - a)), e;
        }),
        (Te.random = function (e, t) {
          var i, r, n, o, s, a;
          t = t || 1;
          do s = (i = 2 * ln.RANDOM() - 1) * i + (r = 2 * ln.RANDOM() - 1) * r;
          while (s >= 1);
          do a = (n = 2 * ln.RANDOM() - 1) * n + (o = 2 * ln.RANDOM() - 1) * o;
          while (a >= 1);
          var l = Math.sqrt((1 - s) / a);
          return (e[0] = t * i), (e[1] = t * r), (e[2] = t * n * l), (e[3] = t * o * l), e;
        }),
        (Te.transformMat4 = function (e, t, i) {
          var r = t[0],
            n = t[1],
            o = t[2],
            s = t[3];
          return (e[0] = i[0] * r + i[4] * n + i[8] * o + i[12] * s), (e[1] = i[1] * r + i[5] * n + i[9] * o + i[13] * s), (e[2] = i[2] * r + i[6] * n + i[10] * o + i[14] * s), (e[3] = i[3] * r + i[7] * n + i[11] * o + i[15] * s), e;
        }),
        (Te.transformQuat = function (e, t, i) {
          var r = t[0],
            n = t[1],
            o = t[2],
            s = i[0],
            a = i[1],
            l = i[2],
            c = i[3],
            u = c * r + a * o - l * n,
            h = c * n + l * r - s * o,
            d = c * o + s * n - a * r,
            f = -s * r - a * n - l * o;
          return (e[0] = u * c + f * -s + h * -l - d * -a), (e[1] = h * c + f * -a + d * -s - u * -l), (e[2] = d * c + f * -l + u * -a - h * -s), (e[3] = t[3]), e;
        }),
        (Te.zero = function (e) {
          return (e[0] = 0), (e[1] = 0), (e[2] = 0), (e[3] = 0), e;
        }),
        (Te.str = function (e) {
          return 'vec4(' + e[0] + ', ' + e[1] + ', ' + e[2] + ', ' + e[3] + ')';
        }),
        (Te.exactEquals = function (e, t) {
          return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3];
        }),
        (Te.equals = function (e, t) {
          var i = e[0],
            r = e[1],
            n = e[2],
            o = e[3],
            s = t[0],
            a = t[1],
            l = t[2],
            c = t[3];
          return Math.abs(i - s) <= ln.EPSILON * Math.max(1, Math.abs(i), Math.abs(s)) && Math.abs(r - a) <= ln.EPSILON * Math.max(1, Math.abs(r), Math.abs(a)) && Math.abs(n - l) <= ln.EPSILON * Math.max(1, Math.abs(n), Math.abs(l)) && Math.abs(o - c) <= ln.EPSILON * Math.max(1, Math.abs(o), Math.abs(c));
        }),
        (Te.forEach = Te.sqrLen = Te.len = Te.sqrDist = Te.dist = Te.div = Te.mul = Te.sub = void 0);
      var ln = (function (e, t) {
        if (e && e.__esModule) return e;
        if (e === null || (Kf(e) !== 'object' && typeof e != 'function')) return { default: e };
        var i = c0(void 0);
        if (i && i.has(e)) return i.get(e);
        var r = {},
          n = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var o in e)
          if (o !== 'default' && Object.prototype.hasOwnProperty.call(e, o)) {
            var s = n ? Object.getOwnPropertyDescriptor(e, o) : null;
            s && (s.get || s.set) ? Object.defineProperty(r, o, s) : (r[o] = e[o]);
          }
        return (r.default = e), i && i.set(e, r), r;
      })(Ki);
      function c0(e) {
        if (typeof WeakMap != 'function') return null;
        var t = new WeakMap(),
          i = new WeakMap();
        return (c0 = function (r) {
          return r ? i : t;
        })(e);
      }
      function u0() {
        var e = new ln.ARRAY_TYPE(4);
        return ln.ARRAY_TYPE != Float32Array && ((e[0] = 0), (e[1] = 0), (e[2] = 0), (e[3] = 0)), e;
      }
      function h0(e, t, i) {
        return (e[0] = t[0] - i[0]), (e[1] = t[1] - i[1]), (e[2] = t[2] - i[2]), (e[3] = t[3] - i[3]), e;
      }
      function d0(e, t, i) {
        return (e[0] = t[0] * i[0]), (e[1] = t[1] * i[1]), (e[2] = t[2] * i[2]), (e[3] = t[3] * i[3]), e;
      }
      function f0(e, t, i) {
        return (e[0] = t[0] / i[0]), (e[1] = t[1] / i[1]), (e[2] = t[2] / i[2]), (e[3] = t[3] / i[3]), e;
      }
      function p0(e, t) {
        return Math.hypot(t[0] - e[0], t[1] - e[1], t[2] - e[2], t[3] - e[3]);
      }
      function m0(e, t) {
        var i = t[0] - e[0],
          r = t[1] - e[1],
          n = t[2] - e[2],
          o = t[3] - e[3];
        return i * i + r * r + n * n + o * o;
      }
      function _0(e) {
        return Math.hypot(e[0], e[1], e[2], e[3]);
      }
      function g0(e) {
        var t = e[0],
          i = e[1],
          r = e[2],
          n = e[3];
        return t * t + i * i + r * r + n * n;
      }
      (Te.sub = h0), (Te.mul = d0), (Te.div = f0), (Te.dist = p0), (Te.sqrDist = m0), (Te.len = _0), (Te.sqrLen = g0);
      var GM = (function () {
        var e = u0();
        return function (t, i, r, n, o, s) {
          var a, l;
          for (i || (i = 4), r || (r = 0), l = n ? Math.min(n * i + r, t.length) : t.length, a = r; a < l; a += i) (e[0] = t[a]), (e[1] = t[a + 1]), (e[2] = t[a + 2]), (e[3] = t[a + 3]), o(e, e, s), (t[a] = e[0]), (t[a + 1] = e[1]), (t[a + 2] = e[2]), (t[a + 3] = e[3]);
          return t;
        };
      })();
      function Jf(e) {
        return (
          (Jf =
            typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
              ? function (t) {
                  return typeof t;
                }
              : function (t) {
                  return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t;
                }),
          Jf(e)
        );
      }
      (Te.forEach = GM),
        Object.defineProperty(ae, '__esModule', { value: !0 }),
        (ae.create = Qf),
        (ae.identity = function (e) {
          return (e[0] = 0), (e[1] = 0), (e[2] = 0), (e[3] = 1), e;
        }),
        (ae.setAxisAngle = x0),
        (ae.getAxisAngle = function (e, t) {
          var i = 2 * Math.acos(t[3]),
            r = Math.sin(i / 2);
          return r > bs.EPSILON ? ((e[0] = t[0] / r), (e[1] = t[1] / r), (e[2] = t[2] / r)) : ((e[0] = 1), (e[1] = 0), (e[2] = 0)), i;
        }),
        (ae.getAngle = function (e, t) {
          var i = M0(e, t);
          return Math.acos(2 * i * i - 1);
        }),
        (ae.multiply = v0),
        (ae.rotateX = function (e, t, i) {
          i *= 0.5;
          var r = t[0],
            n = t[1],
            o = t[2],
            s = t[3],
            a = Math.sin(i),
            l = Math.cos(i);
          return (e[0] = r * l + s * a), (e[1] = n * l + o * a), (e[2] = o * l - n * a), (e[3] = s * l - r * a), e;
        }),
        (ae.rotateY = function (e, t, i) {
          i *= 0.5;
          var r = t[0],
            n = t[1],
            o = t[2],
            s = t[3],
            a = Math.sin(i),
            l = Math.cos(i);
          return (e[0] = r * l - o * a), (e[1] = n * l + s * a), (e[2] = o * l + r * a), (e[3] = s * l - n * a), e;
        }),
        (ae.rotateZ = function (e, t, i) {
          i *= 0.5;
          var r = t[0],
            n = t[1],
            o = t[2],
            s = t[3],
            a = Math.sin(i),
            l = Math.cos(i);
          return (e[0] = r * l + n * a), (e[1] = n * l - r * a), (e[2] = o * l + s * a), (e[3] = s * l - o * a), e;
        }),
        (ae.calculateW = function (e, t) {
          var i = t[0],
            r = t[1],
            n = t[2];
          return (e[0] = i), (e[1] = r), (e[2] = n), (e[3] = Math.sqrt(Math.abs(1 - i * i - r * r - n * n))), e;
        }),
        (ae.exp = b0),
        (ae.ln = w0),
        (ae.pow = function (e, t, i) {
          return w0(e, t), E0(e, e, i), b0(e, e), e;
        }),
        (ae.slerp = su),
        (ae.random = function (e) {
          var t = bs.RANDOM(),
            i = bs.RANDOM(),
            r = bs.RANDOM(),
            n = Math.sqrt(1 - t),
            o = Math.sqrt(t);
          return (e[0] = n * Math.sin(2 * Math.PI * i)), (e[1] = n * Math.cos(2 * Math.PI * i)), (e[2] = o * Math.sin(2 * Math.PI * r)), (e[3] = o * Math.cos(2 * Math.PI * r)), e;
        }),
        (ae.invert = function (e, t) {
          var i = t[0],
            r = t[1],
            n = t[2],
            o = t[3],
            s = i * i + r * r + n * n + o * o,
            a = s ? 1 / s : 0;
          return (e[0] = -i * a), (e[1] = -r * a), (e[2] = -n * a), (e[3] = o * a), e;
        }),
        (ae.conjugate = function (e, t) {
          return (e[0] = -t[0]), (e[1] = -t[1]), (e[2] = -t[2]), (e[3] = t[3]), e;
        }),
        (ae.fromMat3 = T0),
        (ae.fromEuler = function (e, t, i, r) {
          var n = (0.5 * Math.PI) / 180;
          (t *= n), (i *= n), (r *= n);
          var o = Math.sin(t),
            s = Math.cos(t),
            a = Math.sin(i),
            l = Math.cos(i),
            c = Math.sin(r),
            u = Math.cos(r);
          return (e[0] = o * l * u - s * a * c), (e[1] = s * a * u + o * l * c), (e[2] = s * l * c - o * a * u), (e[3] = s * l * u + o * a * c), e;
        }),
        (ae.str = function (e) {
          return 'quat(' + e[0] + ', ' + e[1] + ', ' + e[2] + ', ' + e[3] + ')';
        }),
        (ae.setAxes = ae.sqlerp = ae.rotationTo = ae.equals = ae.exactEquals = ae.normalize = ae.sqrLen = ae.squaredLength = ae.len = ae.length = ae.lerp = ae.dot = ae.scale = ae.mul = ae.add = ae.set = ae.copy = ae.fromValues = ae.clone = void 0);
      var bs = ou(Ki),
        qM = ou(ti),
        lo = ou(ue),
        Xr = ou(Te);
      function y0(e) {
        if (typeof WeakMap != 'function') return null;
        var t = new WeakMap(),
          i = new WeakMap();
        return (y0 = function (r) {
          return r ? i : t;
        })(e);
      }
      function ou(e, t) {
        if (!t && e && e.__esModule) return e;
        if (e === null || (Jf(e) !== 'object' && typeof e != 'function')) return { default: e };
        var i = y0(t);
        if (i && i.has(e)) return i.get(e);
        var r = {},
          n = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var o in e)
          if (o !== 'default' && Object.prototype.hasOwnProperty.call(e, o)) {
            var s = n ? Object.getOwnPropertyDescriptor(e, o) : null;
            s && (s.get || s.set) ? Object.defineProperty(r, o, s) : (r[o] = e[o]);
          }
        return (r.default = e), i && i.set(e, r), r;
      }
      function Qf() {
        var e = new bs.ARRAY_TYPE(4);
        return bs.ARRAY_TYPE != Float32Array && ((e[0] = 0), (e[1] = 0), (e[2] = 0)), (e[3] = 1), e;
      }
      function x0(e, t, i) {
        i *= 0.5;
        var r = Math.sin(i);
        return (e[0] = r * t[0]), (e[1] = r * t[1]), (e[2] = r * t[2]), (e[3] = Math.cos(i)), e;
      }
      function v0(e, t, i) {
        var r = t[0],
          n = t[1],
          o = t[2],
          s = t[3],
          a = i[0],
          l = i[1],
          c = i[2],
          u = i[3];
        return (e[0] = r * u + s * a + n * c - o * l), (e[1] = n * u + s * l + o * a - r * c), (e[2] = o * u + s * c + r * l - n * a), (e[3] = s * u - r * a - n * l - o * c), e;
      }
      function b0(e, t) {
        var i = t[0],
          r = t[1],
          n = t[2],
          o = t[3],
          s = Math.sqrt(i * i + r * r + n * n),
          a = Math.exp(o),
          l = s > 0 ? (a * Math.sin(s)) / s : 0;
        return (e[0] = i * l), (e[1] = r * l), (e[2] = n * l), (e[3] = a * Math.cos(s)), e;
      }
      function w0(e, t) {
        var i = t[0],
          r = t[1],
          n = t[2],
          o = t[3],
          s = Math.sqrt(i * i + r * r + n * n),
          a = s > 0 ? Math.atan2(s, o) / s : 0;
        return (e[0] = i * a), (e[1] = r * a), (e[2] = n * a), (e[3] = 0.5 * Math.log(i * i + r * r + n * n + o * o)), e;
      }
      function su(e, t, i, r) {
        var n,
          o,
          s,
          a,
          l,
          c = t[0],
          u = t[1],
          h = t[2],
          d = t[3],
          f = i[0],
          p = i[1],
          _ = i[2],
          g = i[3];
        return (o = c * f + u * p + h * _ + d * g) < 0 && ((o = -o), (f = -f), (p = -p), (_ = -_), (g = -g)), 1 - o > bs.EPSILON ? ((n = Math.acos(o)), (s = Math.sin(n)), (a = Math.sin((1 - r) * n) / s), (l = Math.sin(r * n) / s)) : ((a = 1 - r), (l = r)), (e[0] = a * c + l * f), (e[1] = a * u + l * p), (e[2] = a * h + l * _), (e[3] = a * d + l * g), e;
      }
      function T0(e, t) {
        var i,
          r = t[0] + t[4] + t[8];
        if (r > 0) (i = Math.sqrt(r + 1)), (e[3] = 0.5 * i), (e[0] = (t[5] - t[7]) * (i = 0.5 / i)), (e[1] = (t[6] - t[2]) * i), (e[2] = (t[1] - t[3]) * i);
        else {
          var n = 0;
          t[4] > t[0] && (n = 1), t[8] > t[3 * n + n] && (n = 2);
          var o = (n + 1) % 3,
            s = (n + 2) % 3;
          (i = Math.sqrt(t[3 * n + n] - t[3 * o + o] - t[3 * s + s] + 1)), (e[n] = 0.5 * i), (e[3] = (t[3 * o + s] - t[3 * s + o]) * (i = 0.5 / i)), (e[o] = (t[3 * o + n] + t[3 * n + o]) * i), (e[s] = (t[3 * s + n] + t[3 * n + s]) * i);
        }
        return e;
      }
      (ae.clone = Xr.clone), (ae.fromValues = Xr.fromValues), (ae.copy = Xr.copy), (ae.set = Xr.set), (ae.add = Xr.add), (ae.mul = v0);
      var E0 = Xr.scale;
      ae.scale = E0;
      var M0 = Xr.dot;
      (ae.dot = M0), (ae.lerp = Xr.lerp);
      var S0 = Xr.length;
      (ae.length = S0), (ae.len = S0);
      var A0 = Xr.squaredLength;
      (ae.squaredLength = A0), (ae.sqrLen = A0);
      var tp = Xr.normalize;
      (ae.normalize = tp), (ae.exactEquals = Xr.exactEquals), (ae.equals = Xr.equals);
      var yn,
        I0,
        C0,
        ZM =
          ((yn = lo.create()),
          (I0 = lo.fromValues(1, 0, 0)),
          (C0 = lo.fromValues(0, 1, 0)),
          function (e, t, i) {
            var r = lo.dot(t, i);
            return r < -0.999999 ? (lo.cross(yn, I0, t), lo.len(yn) < 1e-6 && lo.cross(yn, C0, t), lo.normalize(yn, yn), x0(e, yn, Math.PI), e) : r > 0.999999 ? ((e[0] = 0), (e[1] = 0), (e[2] = 0), (e[3] = 1), e) : (lo.cross(yn, t, i), (e[0] = yn[0]), (e[1] = yn[1]), (e[2] = yn[2]), (e[3] = 1 + r), tp(e, e));
          });
      ae.rotationTo = ZM;
      var ep,
        ip,
        $M =
          ((ep = Qf()),
          (ip = Qf()),
          function (e, t, i, r, n, o) {
            return su(ep, t, n, o), su(ip, i, r, o), su(e, ep, ip, 2 * o * (1 - o)), e;
          });
      ae.sqlerp = $M;
      var xn,
        HM =
          ((xn = qM.create()),
          function (e, t, i, r) {
            return (xn[0] = i[0]), (xn[3] = i[1]), (xn[6] = i[2]), (xn[1] = r[0]), (xn[4] = r[1]), (xn[7] = r[2]), (xn[2] = -t[0]), (xn[5] = -t[1]), (xn[8] = -t[2]), tp(e, T0(e, xn));
          });
      ae.setAxes = HM;
      var Se = {};
      function rp(e) {
        return (
          (rp =
            typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
              ? function (t) {
                  return typeof t;
                }
              : function (t) {
                  return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t;
                }),
          rp(e)
        );
      }
      Object.defineProperty(Se, '__esModule', { value: !0 }),
        (Se.create = function () {
          var e = new vr.ARRAY_TYPE(8);
          return vr.ARRAY_TYPE != Float32Array && ((e[0] = 0), (e[1] = 0), (e[2] = 0), (e[4] = 0), (e[5] = 0), (e[6] = 0), (e[7] = 0)), (e[3] = 1), e;
        }),
        (Se.clone = function (e) {
          var t = new vr.ARRAY_TYPE(8);
          return (t[0] = e[0]), (t[1] = e[1]), (t[2] = e[2]), (t[3] = e[3]), (t[4] = e[4]), (t[5] = e[5]), (t[6] = e[6]), (t[7] = e[7]), t;
        }),
        (Se.fromValues = function (e, t, i, r, n, o, s, a) {
          var l = new vr.ARRAY_TYPE(8);
          return (l[0] = e), (l[1] = t), (l[2] = i), (l[3] = r), (l[4] = n), (l[5] = o), (l[6] = s), (l[7] = a), l;
        }),
        (Se.fromRotationTranslationValues = function (e, t, i, r, n, o, s) {
          var a = new vr.ARRAY_TYPE(8);
          (a[0] = e), (a[1] = t), (a[2] = i), (a[3] = r);
          var l = 0.5 * n,
            c = 0.5 * o,
            u = 0.5 * s;
          return (a[4] = l * r + c * i - u * t), (a[5] = c * r + u * e - l * i), (a[6] = u * r + l * t - c * e), (a[7] = -l * e - c * t - u * i), a;
        }),
        (Se.fromRotationTranslation = D0),
        (Se.fromTranslation = function (e, t) {
          return (e[0] = 0), (e[1] = 0), (e[2] = 0), (e[3] = 1), (e[4] = 0.5 * t[0]), (e[5] = 0.5 * t[1]), (e[6] = 0.5 * t[2]), (e[7] = 0), e;
        }),
        (Se.fromRotation = function (e, t) {
          return (e[0] = t[0]), (e[1] = t[1]), (e[2] = t[2]), (e[3] = t[3]), (e[4] = 0), (e[5] = 0), (e[6] = 0), (e[7] = 0), e;
        }),
        (Se.fromMat4 = function (e, t) {
          var i = co.create();
          P0.getRotation(i, t);
          var r = new vr.ARRAY_TYPE(3);
          return P0.getTranslation(r, t), D0(e, i, r), e;
        }),
        (Se.copy = R0),
        (Se.identity = function (e) {
          return (e[0] = 0), (e[1] = 0), (e[2] = 0), (e[3] = 1), (e[4] = 0), (e[5] = 0), (e[6] = 0), (e[7] = 0), e;
        }),
        (Se.set = function (e, t, i, r, n, o, s, a, l) {
          return (e[0] = t), (e[1] = i), (e[2] = r), (e[3] = n), (e[4] = o), (e[5] = s), (e[6] = a), (e[7] = l), e;
        }),
        (Se.getDual = function (e, t) {
          return (e[0] = t[4]), (e[1] = t[5]), (e[2] = t[6]), (e[3] = t[7]), e;
        }),
        (Se.setDual = function (e, t) {
          return (e[4] = t[0]), (e[5] = t[1]), (e[6] = t[2]), (e[7] = t[3]), e;
        }),
        (Se.getTranslation = function (e, t) {
          var i = t[4],
            r = t[5],
            n = t[6],
            o = t[7],
            s = -t[0],
            a = -t[1],
            l = -t[2],
            c = t[3];
          return (e[0] = 2 * (i * c + o * s + r * l - n * a)), (e[1] = 2 * (r * c + o * a + n * s - i * l)), (e[2] = 2 * (n * c + o * l + i * a - r * s)), e;
        }),
        (Se.translate = function (e, t, i) {
          var r = t[0],
            n = t[1],
            o = t[2],
            s = t[3],
            a = 0.5 * i[0],
            l = 0.5 * i[1],
            c = 0.5 * i[2],
            u = t[4],
            h = t[5],
            d = t[6],
            f = t[7];
          return (e[0] = r), (e[1] = n), (e[2] = o), (e[3] = s), (e[4] = s * a + n * c - o * l + u), (e[5] = s * l + o * a - r * c + h), (e[6] = s * c + r * l - n * a + d), (e[7] = -r * a - n * l - o * c + f), e;
        }),
        (Se.rotateX = function (e, t, i) {
          var r = -t[0],
            n = -t[1],
            o = -t[2],
            s = t[3],
            a = t[4],
            l = t[5],
            c = t[6],
            u = t[7],
            h = a * s + u * r + l * o - c * n,
            d = l * s + u * n + c * r - a * o,
            f = c * s + u * o + a * n - l * r,
            p = u * s - a * r - l * n - c * o;
          return co.rotateX(e, t, i), (e[4] = h * (s = e[3]) + p * (r = e[0]) + d * (o = e[2]) - f * (n = e[1])), (e[5] = d * s + p * n + f * r - h * o), (e[6] = f * s + p * o + h * n - d * r), (e[7] = p * s - h * r - d * n - f * o), e;
        }),
        (Se.rotateY = function (e, t, i) {
          var r = -t[0],
            n = -t[1],
            o = -t[2],
            s = t[3],
            a = t[4],
            l = t[5],
            c = t[6],
            u = t[7],
            h = a * s + u * r + l * o - c * n,
            d = l * s + u * n + c * r - a * o,
            f = c * s + u * o + a * n - l * r,
            p = u * s - a * r - l * n - c * o;
          return co.rotateY(e, t, i), (e[4] = h * (s = e[3]) + p * (r = e[0]) + d * (o = e[2]) - f * (n = e[1])), (e[5] = d * s + p * n + f * r - h * o), (e[6] = f * s + p * o + h * n - d * r), (e[7] = p * s - h * r - d * n - f * o), e;
        }),
        (Se.rotateZ = function (e, t, i) {
          var r = -t[0],
            n = -t[1],
            o = -t[2],
            s = t[3],
            a = t[4],
            l = t[5],
            c = t[6],
            u = t[7],
            h = a * s + u * r + l * o - c * n,
            d = l * s + u * n + c * r - a * o,
            f = c * s + u * o + a * n - l * r,
            p = u * s - a * r - l * n - c * o;
          return co.rotateZ(e, t, i), (e[4] = h * (s = e[3]) + p * (r = e[0]) + d * (o = e[2]) - f * (n = e[1])), (e[5] = d * s + p * n + f * r - h * o), (e[6] = f * s + p * o + h * n - d * r), (e[7] = p * s - h * r - d * n - f * o), e;
        }),
        (Se.rotateByQuatAppend = function (e, t, i) {
          var r = i[0],
            n = i[1],
            o = i[2],
            s = i[3],
            a = t[0],
            l = t[1],
            c = t[2],
            u = t[3];
          return (e[0] = a * s + u * r + l * o - c * n), (e[1] = l * s + u * n + c * r - a * o), (e[2] = c * s + u * o + a * n - l * r), (e[3] = u * s - a * r - l * n - c * o), (e[4] = (a = t[4]) * s + (u = t[7]) * r + (l = t[5]) * o - (c = t[6]) * n), (e[5] = l * s + u * n + c * r - a * o), (e[6] = c * s + u * o + a * n - l * r), (e[7] = u * s - a * r - l * n - c * o), e;
        }),
        (Se.rotateByQuatPrepend = function (e, t, i) {
          var r = t[0],
            n = t[1],
            o = t[2],
            s = t[3],
            a = i[0],
            l = i[1],
            c = i[2],
            u = i[3];
          return (e[0] = r * u + s * a + n * c - o * l), (e[1] = n * u + s * l + o * a - r * c), (e[2] = o * u + s * c + r * l - n * a), (e[3] = s * u - r * a - n * l - o * c), (e[4] = r * (u = i[7]) + s * (a = i[4]) + n * (c = i[6]) - o * (l = i[5])), (e[5] = n * u + s * l + o * a - r * c), (e[6] = o * u + s * c + r * l - n * a), (e[7] = s * u - r * a - n * l - o * c), e;
        }),
        (Se.rotateAroundAxis = function (e, t, i, r) {
          if (Math.abs(r) < vr.EPSILON) return R0(e, t);
          var n = Math.hypot(i[0], i[1], i[2]);
          r *= 0.5;
          var o = Math.sin(r),
            s = (o * i[0]) / n,
            a = (o * i[1]) / n,
            l = (o * i[2]) / n,
            c = Math.cos(r),
            u = t[0],
            h = t[1],
            d = t[2],
            f = t[3];
          (e[0] = u * c + f * s + h * l - d * a), (e[1] = h * c + f * a + d * s - u * l), (e[2] = d * c + f * l + u * a - h * s), (e[3] = f * c - u * s - h * a - d * l);
          var p = t[4],
            _ = t[5],
            g = t[6],
            y = t[7];
          return (e[4] = p * c + y * s + _ * l - g * a), (e[5] = _ * c + y * a + g * s - p * l), (e[6] = g * c + y * l + p * a - _ * s), (e[7] = y * c - p * s - _ * a - g * l), e;
        }),
        (Se.add = function (e, t, i) {
          return (e[0] = t[0] + i[0]), (e[1] = t[1] + i[1]), (e[2] = t[2] + i[2]), (e[3] = t[3] + i[3]), (e[4] = t[4] + i[4]), (e[5] = t[5] + i[5]), (e[6] = t[6] + i[6]), (e[7] = t[7] + i[7]), e;
        }),
        (Se.multiply = L0),
        (Se.scale = function (e, t, i) {
          return (e[0] = t[0] * i), (e[1] = t[1] * i), (e[2] = t[2] * i), (e[3] = t[3] * i), (e[4] = t[4] * i), (e[5] = t[5] * i), (e[6] = t[6] * i), (e[7] = t[7] * i), e;
        }),
        (Se.lerp = function (e, t, i, r) {
          var n = 1 - r;
          return k0(t, i) < 0 && (r = -r), (e[0] = t[0] * n + i[0] * r), (e[1] = t[1] * n + i[1] * r), (e[2] = t[2] * n + i[2] * r), (e[3] = t[3] * n + i[3] * r), (e[4] = t[4] * n + i[4] * r), (e[5] = t[5] * n + i[5] * r), (e[6] = t[6] * n + i[6] * r), (e[7] = t[7] * n + i[7] * r), e;
        }),
        (Se.invert = function (e, t) {
          var i = au(t);
          return (e[0] = -t[0] / i), (e[1] = -t[1] / i), (e[2] = -t[2] / i), (e[3] = t[3] / i), (e[4] = -t[4] / i), (e[5] = -t[5] / i), (e[6] = -t[6] / i), (e[7] = t[7] / i), e;
        }),
        (Se.conjugate = function (e, t) {
          return (e[0] = -t[0]), (e[1] = -t[1]), (e[2] = -t[2]), (e[3] = t[3]), (e[4] = -t[4]), (e[5] = -t[5]), (e[6] = -t[6]), (e[7] = t[7]), e;
        }),
        (Se.normalize = function (e, t) {
          var i = au(t);
          if (i > 0) {
            i = Math.sqrt(i);
            var r = t[0] / i,
              n = t[1] / i,
              o = t[2] / i,
              s = t[3] / i,
              a = t[4],
              l = t[5],
              c = t[6],
              u = t[7],
              h = r * a + n * l + o * c + s * u;
            (e[0] = r), (e[1] = n), (e[2] = o), (e[3] = s), (e[4] = (a - r * h) / i), (e[5] = (l - n * h) / i), (e[6] = (c - o * h) / i), (e[7] = (u - s * h) / i);
          }
          return e;
        }),
        (Se.str = function (e) {
          return 'quat2(' + e[0] + ', ' + e[1] + ', ' + e[2] + ', ' + e[3] + ', ' + e[4] + ', ' + e[5] + ', ' + e[6] + ', ' + e[7] + ')';
        }),
        (Se.exactEquals = function (e, t) {
          return e[0] === t[0] && e[1] === t[1] && e[2] === t[2] && e[3] === t[3] && e[4] === t[4] && e[5] === t[5] && e[6] === t[6] && e[7] === t[7];
        }),
        (Se.equals = function (e, t) {
          var i = e[0],
            r = e[1],
            n = e[2],
            o = e[3],
            s = e[4],
            a = e[5],
            l = e[6],
            c = e[7],
            u = t[0],
            h = t[1],
            d = t[2],
            f = t[3],
            p = t[4],
            _ = t[5],
            g = t[6],
            y = t[7];
          return Math.abs(i - u) <= vr.EPSILON * Math.max(1, Math.abs(i), Math.abs(u)) && Math.abs(r - h) <= vr.EPSILON * Math.max(1, Math.abs(r), Math.abs(h)) && Math.abs(n - d) <= vr.EPSILON * Math.max(1, Math.abs(n), Math.abs(d)) && Math.abs(o - f) <= vr.EPSILON * Math.max(1, Math.abs(o), Math.abs(f)) && Math.abs(s - p) <= vr.EPSILON * Math.max(1, Math.abs(s), Math.abs(p)) && Math.abs(a - _) <= vr.EPSILON * Math.max(1, Math.abs(a), Math.abs(_)) && Math.abs(l - g) <= vr.EPSILON * Math.max(1, Math.abs(l), Math.abs(g)) && Math.abs(c - y) <= vr.EPSILON * Math.max(1, Math.abs(c), Math.abs(y));
        }),
        (Se.sqrLen = Se.squaredLength = Se.len = Se.length = Se.dot = Se.mul = Se.setReal = Se.getReal = void 0);
      var vr = np(Ki),
        co = np(ae),
        P0 = np(he);
      function z0(e) {
        if (typeof WeakMap != 'function') return null;
        var t = new WeakMap(),
          i = new WeakMap();
        return (z0 = function (r) {
          return r ? i : t;
        })(e);
      }
      function np(e, t) {
        if (!t && e && e.__esModule) return e;
        if (e === null || (rp(e) !== 'object' && typeof e != 'function')) return { default: e };
        var i = z0(t);
        if (i && i.has(e)) return i.get(e);
        var r = {},
          n = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var o in e)
          if (o !== 'default' && Object.prototype.hasOwnProperty.call(e, o)) {
            var s = n ? Object.getOwnPropertyDescriptor(e, o) : null;
            s && (s.get || s.set) ? Object.defineProperty(r, o, s) : (r[o] = e[o]);
          }
        return (r.default = e), i && i.set(e, r), r;
      }
      function D0(e, t, i) {
        var r = 0.5 * i[0],
          n = 0.5 * i[1],
          o = 0.5 * i[2],
          s = t[0],
          a = t[1],
          l = t[2],
          c = t[3];
        return (e[0] = s), (e[1] = a), (e[2] = l), (e[3] = c), (e[4] = r * c + n * l - o * a), (e[5] = n * c + o * s - r * l), (e[6] = o * c + r * a - n * s), (e[7] = -r * s - n * a - o * l), e;
      }
      function R0(e, t) {
        return (e[0] = t[0]), (e[1] = t[1]), (e[2] = t[2]), (e[3] = t[3]), (e[4] = t[4]), (e[5] = t[5]), (e[6] = t[6]), (e[7] = t[7]), e;
      }
      function L0(e, t, i) {
        var r = t[0],
          n = t[1],
          o = t[2],
          s = t[3],
          a = i[4],
          l = i[5],
          c = i[6],
          u = i[7],
          h = t[4],
          d = t[5],
          f = t[6],
          p = t[7],
          _ = i[0],
          g = i[1],
          y = i[2],
          v = i[3];
        return (e[0] = r * v + s * _ + n * y - o * g), (e[1] = n * v + s * g + o * _ - r * y), (e[2] = o * v + s * y + r * g - n * _), (e[3] = s * v - r * _ - n * g - o * y), (e[4] = r * u + s * a + n * c - o * l + h * v + p * _ + d * y - f * g), (e[5] = n * u + s * l + o * a - r * c + d * v + p * g + f * _ - h * y), (e[6] = o * u + s * c + r * l - n * a + f * v + p * y + h * g - d * _), (e[7] = s * u - r * a - n * l - o * c + p * v - h * _ - d * g - f * y), e;
      }
      (Se.getReal = co.copy), (Se.setReal = co.copy), (Se.mul = L0);
      var k0 = co.dot;
      Se.dot = k0;
      var O0 = co.length;
      (Se.length = O0), (Se.len = O0);
      var au = co.squaredLength;
      (Se.squaredLength = au), (Se.sqrLen = au);
      var ge = {};
      function op(e) {
        return (
          (op =
            typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
              ? function (t) {
                  return typeof t;
                }
              : function (t) {
                  return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t;
                }),
          op(e)
        );
      }
      Object.defineProperty(ge, '__esModule', { value: !0 }),
        (ge.create = F0),
        (ge.clone = function (e) {
          var t = new ws.ARRAY_TYPE(2);
          return (t[0] = e[0]), (t[1] = e[1]), t;
        }),
        (ge.fromValues = function (e, t) {
          var i = new ws.ARRAY_TYPE(2);
          return (i[0] = e), (i[1] = t), i;
        }),
        (ge.copy = function (e, t) {
          return (e[0] = t[0]), (e[1] = t[1]), e;
        }),
        (ge.set = function (e, t, i) {
          return (e[0] = t), (e[1] = i), e;
        }),
        (ge.add = function (e, t, i) {
          return (e[0] = t[0] + i[0]), (e[1] = t[1] + i[1]), e;
        }),
        (ge.subtract = N0),
        (ge.multiply = U0),
        (ge.divide = V0),
        (ge.ceil = function (e, t) {
          return (e[0] = Math.ceil(t[0])), (e[1] = Math.ceil(t[1])), e;
        }),
        (ge.floor = function (e, t) {
          return (e[0] = Math.floor(t[0])), (e[1] = Math.floor(t[1])), e;
        }),
        (ge.min = function (e, t, i) {
          return (e[0] = Math.min(t[0], i[0])), (e[1] = Math.min(t[1], i[1])), e;
        }),
        (ge.max = function (e, t, i) {
          return (e[0] = Math.max(t[0], i[0])), (e[1] = Math.max(t[1], i[1])), e;
        }),
        (ge.round = function (e, t) {
          return (e[0] = Math.round(t[0])), (e[1] = Math.round(t[1])), e;
        }),
        (ge.scale = function (e, t, i) {
          return (e[0] = t[0] * i), (e[1] = t[1] * i), e;
        }),
        (ge.scaleAndAdd = function (e, t, i, r) {
          return (e[0] = t[0] + i[0] * r), (e[1] = t[1] + i[1] * r), e;
        }),
        (ge.distance = j0),
        (ge.squaredDistance = G0),
        (ge.length = q0),
        (ge.squaredLength = Z0),
        (ge.negate = function (e, t) {
          return (e[0] = -t[0]), (e[1] = -t[1]), e;
        }),
        (ge.inverse = function (e, t) {
          return (e[0] = 1 / t[0]), (e[1] = 1 / t[1]), e;
        }),
        (ge.normalize = function (e, t) {
          var i = t[0],
            r = t[1],
            n = i * i + r * r;
          return n > 0 && (n = 1 / Math.sqrt(n)), (e[0] = t[0] * n), (e[1] = t[1] * n), e;
        }),
        (ge.dot = function (e, t) {
          return e[0] * t[0] + e[1] * t[1];
        }),
        (ge.cross = function (e, t, i) {
          var r = t[0] * i[1] - t[1] * i[0];
          return (e[0] = e[1] = 0), (e[2] = r), e;
        }),
        (ge.lerp = function (e, t, i, r) {
          var n = t[0],
            o = t[1];
          return (e[0] = n + r * (i[0] - n)), (e[1] = o + r * (i[1] - o)), e;
        }),
        (ge.random = function (e, t) {
          t = t || 1;
          var i = 2 * ws.RANDOM() * Math.PI;
          return (e[0] = Math.cos(i) * t), (e[1] = Math.sin(i) * t), e;
        }),
        (ge.transformMat2 = function (e, t, i) {
          var r = t[0],
            n = t[1];
          return (e[0] = i[0] * r + i[2] * n), (e[1] = i[1] * r + i[3] * n), e;
        }),
        (ge.transformMat2d = function (e, t, i) {
          var r = t[0],
            n = t[1];
          return (e[0] = i[0] * r + i[2] * n + i[4]), (e[1] = i[1] * r + i[3] * n + i[5]), e;
        }),
        (ge.transformMat3 = function (e, t, i) {
          var r = t[0],
            n = t[1];
          return (e[0] = i[0] * r + i[3] * n + i[6]), (e[1] = i[1] * r + i[4] * n + i[7]), e;
        }),
        (ge.transformMat4 = function (e, t, i) {
          var r = t[0],
            n = t[1];
          return (e[0] = i[0] * r + i[4] * n + i[12]), (e[1] = i[1] * r + i[5] * n + i[13]), e;
        }),
        (ge.rotate = function (e, t, i, r) {
          var n = t[0] - i[0],
            o = t[1] - i[1],
            s = Math.sin(r),
            a = Math.cos(r);
          return (e[0] = n * a - o * s + i[0]), (e[1] = n * s + o * a + i[1]), e;
        }),
        (ge.angle = function (e, t) {
          var i = e[0],
            r = e[1],
            n = t[0],
            o = t[1],
            s = Math.sqrt(i * i + r * r) * Math.sqrt(n * n + o * o);
          return Math.acos(Math.min(Math.max(s && (i * n + r * o) / s, -1), 1));
        }),
        (ge.zero = function (e) {
          return (e[0] = 0), (e[1] = 0), e;
        }),
        (ge.str = function (e) {
          return 'vec2(' + e[0] + ', ' + e[1] + ')';
        }),
        (ge.exactEquals = function (e, t) {
          return e[0] === t[0] && e[1] === t[1];
        }),
        (ge.equals = function (e, t) {
          var i = e[0],
            r = e[1],
            n = t[0],
            o = t[1];
          return Math.abs(i - n) <= ws.EPSILON * Math.max(1, Math.abs(i), Math.abs(n)) && Math.abs(r - o) <= ws.EPSILON * Math.max(1, Math.abs(r), Math.abs(o));
        }),
        (ge.forEach = ge.sqrLen = ge.sqrDist = ge.dist = ge.div = ge.mul = ge.sub = ge.len = void 0);
      var ws = (function (e, t) {
        if (e && e.__esModule) return e;
        if (e === null || (op(e) !== 'object' && typeof e != 'function')) return { default: e };
        var i = B0(void 0);
        if (i && i.has(e)) return i.get(e);
        var r = {},
          n = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var o in e)
          if (o !== 'default' && Object.prototype.hasOwnProperty.call(e, o)) {
            var s = n ? Object.getOwnPropertyDescriptor(e, o) : null;
            s && (s.get || s.set) ? Object.defineProperty(r, o, s) : (r[o] = e[o]);
          }
        return (r.default = e), i && i.set(e, r), r;
      })(Ki);
      function B0(e) {
        if (typeof WeakMap != 'function') return null;
        var t = new WeakMap(),
          i = new WeakMap();
        return (B0 = function (r) {
          return r ? i : t;
        })(e);
      }
      function F0() {
        var e = new ws.ARRAY_TYPE(2);
        return ws.ARRAY_TYPE != Float32Array && ((e[0] = 0), (e[1] = 0)), e;
      }
      function N0(e, t, i) {
        return (e[0] = t[0] - i[0]), (e[1] = t[1] - i[1]), e;
      }
      function U0(e, t, i) {
        return (e[0] = t[0] * i[0]), (e[1] = t[1] * i[1]), e;
      }
      function V0(e, t, i) {
        return (e[0] = t[0] / i[0]), (e[1] = t[1] / i[1]), e;
      }
      function j0(e, t) {
        return Math.hypot(t[0] - e[0], t[1] - e[1]);
      }
      function G0(e, t) {
        var i = t[0] - e[0],
          r = t[1] - e[1];
        return i * i + r * r;
      }
      function q0(e) {
        return Math.hypot(e[0], e[1]);
      }
      function Z0(e) {
        var t = e[0],
          i = e[1];
        return t * t + i * i;
      }
      (ge.len = q0), (ge.sub = N0), (ge.mul = U0), (ge.div = V0), (ge.dist = j0), (ge.sqrDist = G0), (ge.sqrLen = Z0);
      var WM = (function () {
        var e = F0();
        return function (t, i, r, n, o, s) {
          var a, l;
          for (i || (i = 2), r || (r = 0), l = n ? Math.min(n * i + r, t.length) : t.length, a = r; a < l; a += i) (e[0] = t[a]), (e[1] = t[a + 1]), o(e, e, s), (t[a] = e[0]), (t[a + 1] = e[1]);
          return t;
        };
      })();
      function sp(e) {
        return (
          (sp =
            typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
              ? function (t) {
                  return typeof t;
                }
              : function (t) {
                  return t && typeof Symbol == 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t;
                }),
          sp(e)
        );
      }
      (ge.forEach = WM), Object.defineProperty(Yi, '__esModule', { value: !0 });
      var We = (Yi.vec4 = N = Yi.vec3 = Yi.vec2 = Yi.quat2 = sr = Yi.quat = J = Yi.mat4 = br = Yi.mat3 = Yi.mat2d = ma = Yi.mat2 = Yi.glMatrix = void 0),
        XM = kn(Ki);
      Yi.glMatrix = XM;
      var YM = kn(xi),
        ma = (Yi.mat2 = YM),
        KM = kn(Ti);
      Yi.mat2d = KM;
      var JM = kn(ti),
        br = (Yi.mat3 = JM),
        QM = kn(he),
        J = (Yi.mat4 = QM),
        tS = kn(ae),
        sr = (Yi.quat = tS),
        eS = kn(Se);
      Yi.quat2 = eS;
      var iS = kn(ge);
      Yi.vec2 = iS;
      var rS = kn(ue),
        N = (Yi.vec3 = rS),
        nS = kn(Te);
      function $0(e) {
        if (typeof WeakMap != 'function') return null;
        var t = new WeakMap(),
          i = new WeakMap();
        return ($0 = function (r) {
          return r ? i : t;
        })(e);
      }
      function kn(e, t) {
        if (!t && e && e.__esModule) return e;
        if (e === null || (sp(e) !== 'object' && typeof e != 'function')) return { default: e };
        var i = $0(t);
        if (i && i.has(e)) return i.get(e);
        var r = {},
          n = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var o in e)
          if (o !== 'default' && Object.prototype.hasOwnProperty.call(e, o)) {
            var s = n ? Object.getOwnPropertyDescriptor(e, o) : null;
            s && (s.get || s.set) ? Object.defineProperty(r, o, s) : (r[o] = e[o]);
          }
        return (r.default = e), i && i.set(e, r), r;
      }
      We = Yi.vec4 = nS;
      const oS = Ne([
          { type: 'Float32', name: 'a_globe_pos', components: 3 },
          { type: 'Float32', name: 'a_uv', components: 2 },
        ]),
        { members: lu } = oS,
        H0 = Ne([{ name: 'a_pos_3', components: 3, type: 'Int16' }]);
      var ko = Ne([{ name: 'a_pos', type: 'Int16', components: 2 }]),
        W0 = {};
      (function (e, t) {
        (function (i) {
          function r(o, s, a) {
            var l = n(256 * o, 256 * (s = Math.pow(2, a) - s - 1), a),
              c = n(256 * (o + 1), 256 * (s + 1), a);
            return l[0] + ',' + l[1] + ',' + c[0] + ',' + c[1];
          }
          function n(o, s, a) {
            var l = (2 * Math.PI * 6378137) / 256 / Math.pow(2, a);
            return [o * l - (2 * Math.PI * 6378137) / 2, s * l - (2 * Math.PI * 6378137) / 2];
          }
          (i.getURL = function (o, s, a, l, c, u) {
            return (u = u || {}), o + '?' + ['bbox=' + r(a, l, c), 'format=' + (u.format || 'image/png'), 'service=' + (u.service || 'WMS'), 'version=' + (u.version || '1.1.1'), 'request=' + (u.request || 'GetMap'), 'srs=' + (u.srs || 'EPSG:3857'), 'width=' + (u.width || 256), 'height=' + (u.height || 256), 'layers=' + s].join('&');
          }),
            (i.getTileBBox = r),
            (i.getMercCoords = n),
            Object.defineProperty(i, '__esModule', { value: !0 });
        })(t);
      })(0, W0);
      var sS = W0;
      class cn {
        constructor(t, i, r) {
          (this.z = t), (this.x = i), (this.y = r), (this.key = El(0, t, t, i, r));
        }
        equals(t) {
          return this.z === t.z && this.x === t.x && this.y === t.y;
        }
        url(t, i) {
          const r = sS.getTileBBox(this.x, this.y, this.z),
            n = (function (o, s, a) {
              let l,
                c = '';
              for (let u = o; u > 0; u--) (l = 1 << (u - 1)), (c += (s & l ? 1 : 0) + (a & l ? 2 : 0));
              return c;
            })(this.z, this.x, this.y);
          return t[(this.x + this.y) % t.length]
            .replace('{prefix}', (this.x % 16).toString(16) + (this.y % 16).toString(16))
            .replace(/{z}/g, String(this.z))
            .replace(/{x}/g, String(this.x))
            .replace(/{y}/g, String(i === 'tms' ? Math.pow(2, this.z) - this.y - 1 : this.y))
            .replace('{quadkey}', n)
            .replace('{bbox-epsg-3857}', r);
        }
        toString() {
          return `${this.z}/${this.x}/${this.y}`;
        }
      }
      class ap {
        constructor(t, i) {
          (this.wrap = t), (this.canonical = i), (this.key = El(t, i.z, i.z, i.x, i.y));
        }
      }
      class Le {
        constructor(t, i, r, n, o) {
          (this.overscaledZ = t), (this.wrap = i), (this.canonical = new cn(r, +n, +o)), (this.key = i === 0 && t === r ? this.canonical.key : El(i, t, r, n, o));
        }
        equals(t) {
          return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical);
        }
        scaledTo(t) {
          const i = this.canonical.z - t;
          return t > this.canonical.z ? new Le(t, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Le(t, this.wrap, t, this.canonical.x >> i, this.canonical.y >> i);
        }
        calculateScaledKey(t, i = !0) {
          if (this.overscaledZ === t && i) return this.key;
          if (t > this.canonical.z) return El(this.wrap * +i, t, this.canonical.z, this.canonical.x, this.canonical.y);
          {
            const r = this.canonical.z - t;
            return El(this.wrap * +i, t, t, this.canonical.x >> r, this.canonical.y >> r);
          }
        }
        isChildOf(t) {
          if (t.wrap !== this.wrap) return !1;
          const i = this.canonical.z - t.canonical.z;
          return t.overscaledZ === 0 || (t.overscaledZ < this.overscaledZ && t.canonical.z < this.canonical.z && t.canonical.x === this.canonical.x >> i && t.canonical.y === this.canonical.y >> i);
        }
        children(t) {
          if (this.overscaledZ >= t) return [new Le(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
          const i = this.canonical.z + 1,
            r = 2 * this.canonical.x,
            n = 2 * this.canonical.y;
          return [new Le(i, this.wrap, i, r, n), new Le(i, this.wrap, i, r + 1, n), new Le(i, this.wrap, i, r, n + 1), new Le(i, this.wrap, i, r + 1, n + 1)];
        }
        isLessThan(t) {
          return this.wrap < t.wrap || (!(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || (!(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || (!(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y)))));
        }
        wrapped() {
          return new Le(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        unwrapTo(t) {
          return new Le(this.overscaledZ, t, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        overscaleFactor() {
          return Math.pow(2, this.overscaledZ - this.canonical.z);
        }
        toUnwrapped() {
          return new ap(this.wrap, this.canonical);
        }
        toString() {
          return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
        }
      }
      function El(e, t, i, r, n) {
        const o = 1 << Math.min(i, 22);
        let s = o * (n % o) + (r % o);
        return e && i < 22 && (s += o * o * ((e < 0 ? -2 * e - 1 : 2 * e) % (1 << (2 * (22 - i))))), 16 * (32 * s + i) + (t - i);
      }
      const X0 = [
        (e) => {
          let t = e.canonical.x - 1,
            i = e.wrap;
          return t < 0 && ((t = (1 << e.canonical.z) - 1), i--), new Le(e.overscaledZ, i, e.canonical.z, t, e.canonical.y);
        },
        (e) => {
          let t = e.canonical.x + 1,
            i = e.wrap;
          return t === 1 << e.canonical.z && ((t = 0), i++), new Le(e.overscaledZ, i, e.canonical.z, t, e.canonical.y);
        },
        (e) => new Le(e.overscaledZ, e.wrap, e.canonical.z, e.canonical.x, (e.canonical.y === 0 ? 1 << e.canonical.z : e.canonical.y) - 1),
        (e) => new Le(e.overscaledZ, e.wrap, e.canonical.z, e.canonical.x, e.canonical.y === (1 << e.canonical.z) - 1 ? 0 : e.canonical.y + 1),
      ];
      Gt(cn, 'CanonicalTileID'), Gt(Le, 'OverscaledTileID', { omit: ['projMatrix', 'expandedProjMatrix'] });
      class cu {
        constructor(t, i) {
          (this.pos = t), (this.dir = i);
        }
        intersectsPlane(t, i, r) {
          const n = N.dot(i, this.dir);
          if (Math.abs(n) < 1e-6) return !1;
          const o = ((t[0] - this.pos[0]) * i[0] + (t[1] - this.pos[1]) * i[1] + (t[2] - this.pos[2]) * i[2]) / n;
          return (r[0] = this.pos[0] + this.dir[0] * o), (r[1] = this.pos[1] + this.dir[1] * o), (r[2] = this.pos[2] + this.dir[2] * o), !0;
        }
        closestPointOnSphere(t, i, r) {
          if (N.equals(this.pos, t) || i === 0) return (r[0] = r[1] = r[2] = 0), !1;
          const [n, o, s] = this.dir,
            a = this.pos[0] - t[0],
            l = this.pos[1] - t[1],
            c = this.pos[2] - t[2],
            u = n * n + o * o + s * s,
            h = 2 * (a * n + l * o + c * s),
            d = h * h - 4 * u * (a * a + l * l + c * c - i * i);
          if (d < 0) {
            const f = Math.max(-h / 2, 0),
              p = a + n * f,
              _ = l + o * f,
              g = c + s * f,
              y = Math.hypot(p, _, g);
            return (r[0] = (p * i) / y), (r[1] = (_ * i) / y), (r[2] = (g * i) / y), !1;
          }
          {
            const f = (-h - Math.sqrt(d)) / (2 * u);
            if (f < 0) {
              const p = Math.hypot(a, l, c);
              return (r[0] = (a * i) / p), (r[1] = (l * i) / p), (r[2] = (c * i) / p), !1;
            }
            return (r[0] = a + n * f), (r[1] = l + o * f), (r[2] = c + s * f), !0;
          }
        }
      }
      class lp {
        constructor(t, i, r, n, o) {
          (this.TL = t), (this.TR = i), (this.BR = r), (this.BL = n), (this.horizon = o);
        }
        static fromInvProjectionMatrix(t, i, r) {
          const n = [-1, 1, 1],
            o = [1, 1, 1],
            s = [1, -1, 1],
            a = [-1, -1, 1],
            l = N.transformMat4(n, n, t),
            c = N.transformMat4(o, o, t),
            u = N.transformMat4(s, s, t),
            h = N.transformMat4(a, a, t);
          return new lp(l, c, u, h, i / r);
        }
      }
      function Ml(e, t, i) {
        let r = 1 / 0,
          n = -1 / 0;
        const o = [];
        for (const s of e) {
          N.sub(o, s, t);
          const a = N.dot(o, i);
          (r = Math.min(r, a)), (n = Math.max(n, a));
        }
        return [r, n];
      }
      function Y0(e, t) {
        let i = !0;
        for (let r = 0; r < e.planes.length; r++) {
          const n = e.planes[r];
          let o = 0;
          for (let s = 0; s < t.length; s++) o += N.dot(n, t[s]) + n[3] >= 0;
          if (o === 0) return 0;
          o !== t.length && (i = !1);
        }
        return i ? 2 : 1;
      }
      function K0(e, t) {
        for (const i of e.projections) {
          const r = Ml(t, e.points[0], i.axis);
          if (i.projection[1] < r[0] || i.projection[0] > r[1]) return 0;
        }
        return 1;
      }
      function J0(e, t) {
        let i = 0;
        const r = [0, 0, 0, 0];
        for (let n = 0; n < e.length; n++) (r[0] = e[n][0]), (r[1] = e[n][1]), (r[2] = e[n][2]), (r[3] = 1), We.dot(r, t) >= 0 && i++;
        return i;
      }
      class uo {
        constructor(t, i) {
          (this.points = t || new Array(8).fill([0, 0, 0])), (this.planes = i || new Array(6).fill([0, 0, 0, 0])), (this.bounds = ni.fromPoints(this.points)), (this.projections = []), (this.frustumEdges = [N.sub([], this.points[2], this.points[3]), N.sub([], this.points[0], this.points[3]), N.sub([], this.points[4], this.points[0]), N.sub([], this.points[5], this.points[1]), N.sub([], this.points[6], this.points[2]), N.sub([], this.points[7], this.points[3])]);
          for (const r of this.frustumEdges) {
            const n = [0, -r[2], r[1]],
              o = [r[2], 0, -r[0]];
            this.projections.push({ axis: n, projection: Ml(this.points, this.points[0], n) }), this.projections.push({ axis: o, projection: Ml(this.points, this.points[0], o) });
          }
        }
        static fromInvProjectionMatrix(t, i, r, n) {
          const o = Math.pow(2, r),
            s = [
              [-1, 1, -1, 1],
              [1, 1, -1, 1],
              [1, -1, -1, 1],
              [-1, -1, -1, 1],
              [-1, 1, 1, 1],
              [1, 1, 1, 1],
              [1, -1, 1, 1],
              [-1, -1, 1, 1],
            ].map((c) => {
              const u = We.transformMat4([], c, t),
                h = (1 / u[3] / i) * o;
              return We.mul(u, u, [h, h, n ? 1 / u[3] : h, h]);
            }),
            a = [
              [0, 1, 2],
              [6, 5, 4],
              [0, 3, 7],
              [2, 1, 5],
              [3, 2, 6],
              [0, 4, 5],
            ].map((c) => {
              const u = N.sub([], s[c[0]], s[c[1]]),
                h = N.sub([], s[c[2]], s[c[1]]),
                d = N.normalize([], N.cross([], u, h)),
                f = -N.dot(d, s[c[1]]);
              return d.concat(f);
            }),
            l = [];
          for (let c = 0; c < s.length; c++) l.push([s[c][0], s[c][1], s[c][2]]);
          return new uo(l, a);
        }
        intersectsPrecise(t, i, r) {
          for (let n = 0; n < i.length; n++) if (!J0(t, i[n])) return 0;
          for (let n = 0; n < this.planes.length; n++) if (!J0(t, this.planes[n])) return 0;
          for (const n of r)
            for (const o of this.frustumEdges) {
              const s = N.cross([], n, o),
                a = N.length(s);
              if (a === 0) continue;
              N.scale(s, s, 1 / a);
              const l = Ml(this.points, this.points[0], s),
                c = Ml(t, this.points[0], s);
              if (l[0] > c[1] || c[0] > l[1]) return 0;
            }
          return 1;
        }
      }
      class ni {
        static fromPoints(t) {
          const i = [1 / 0, 1 / 0, 1 / 0],
            r = [-1 / 0, -1 / 0, -1 / 0];
          for (const n of t) N.min(i, i, n), N.max(r, r, n);
          return new ni(i, r);
        }
        static fromTileIdAndHeight(t, i, r) {
          const n = 1 << t.canonical.z,
            o = t.canonical.x,
            s = t.canonical.y;
          return new ni([o / n, s / n, i], [(o + 1) / n, (s + 1) / n, r]);
        }
        static applyTransform(t, i) {
          const r = t.getCorners();
          for (let n = 0; n < r.length; ++n) N.transformMat4(r[n], r[n], i);
          return ni.fromPoints(r);
        }
        static projectAabbCorners(t, i) {
          const r = t.getCorners();
          for (let n = 0; n < r.length; ++n) N.transformMat4(r[n], r[n], i);
          return r;
        }
        constructor(t, i) {
          (this.min = t), (this.max = i), (this.center = N.scale([], N.add([], this.min, this.max), 0.5));
        }
        quadrant(t) {
          const i = [t % 2 == 0, t < 2],
            r = N.clone(this.min),
            n = N.clone(this.max);
          for (let o = 0; o < i.length; o++) (r[o] = i[o] ? this.min[o] : this.center[o]), (n[o] = i[o] ? this.center[o] : this.max[o]);
          return (n[2] = this.max[2]), new ni(r, n);
        }
        distanceX(t) {
          return Math.max(Math.min(this.max[0], t[0]), this.min[0]) - t[0];
        }
        distanceY(t) {
          return Math.max(Math.min(this.max[1], t[1]), this.min[1]) - t[1];
        }
        distanceZ(t) {
          return Math.max(Math.min(this.max[2], t[2]), this.min[2]) - t[2];
        }
        getCorners() {
          const t = this.min,
            i = this.max;
          return [
            [t[0], t[1], t[2]],
            [i[0], t[1], t[2]],
            [i[0], i[1], t[2]],
            [t[0], i[1], t[2]],
            [t[0], t[1], i[2]],
            [i[0], t[1], i[2]],
            [i[0], i[1], i[2]],
            [t[0], i[1], i[2]],
          ];
        }
        intersects(t) {
          return this.intersectsAabb(t.bounds) ? Y0(t, this.getCorners()) : 0;
        }
        intersectsFlat(t) {
          return this.intersectsAabb(t.bounds)
            ? Y0(t, [
                [this.min[0], this.min[1], 0],
                [this.max[0], this.min[1], 0],
                [this.max[0], this.max[1], 0],
                [this.min[0], this.max[1], 0],
              ])
            : 0;
        }
        intersectsPrecise(t, i) {
          return i || this.intersects(t) ? K0(t, this.getCorners()) : 0;
        }
        intersectsPreciseFlat(t, i) {
          return i || this.intersectsFlat(t)
            ? K0(t, [
                [this.min[0], this.min[1], 0],
                [this.max[0], this.min[1], 0],
                [this.max[0], this.max[1], 0],
                [this.min[0], this.max[1], 0],
              ])
            : 0;
        }
        intersectsAabb(t) {
          for (let i = 0; i < 3; ++i) if (this.min[i] > t.max[i] || t.min[i] > this.max[i]) return !1;
          return !0;
        }
        intersectsAabbXY(t) {
          return !(this.min[0] > t.max[0] || t.min[0] > this.max[0] || this.min[1] > t.max[1] || t.min[1] > this.max[1]);
        }
        encapsulate(t) {
          for (let i = 0; i < 3; i++) (this.min[i] = Math.min(this.min[i], t.min[i])), (this.max[i] = Math.max(this.max[i], t.max[i]));
        }
        encapsulatePoint(t) {
          for (let i = 0; i < 3; i++) (this.min[i] = Math.min(this.min[i], t[i])), (this.max[i] = Math.max(this.max[i], t[i]));
        }
        closestPoint(t) {
          return [Math.max(Math.min(this.max[0], t[0]), this.min[0]), Math.max(Math.min(this.max[1], t[1]), this.min[1]), Math.max(Math.min(this.max[2], t[2]), this.min[2])];
        }
      }
      Gt(ni, 'Aabb');
      const Sl = 5,
        Oo = 6,
        mr = lt / Math.PI / 2,
        aS = 16383,
        _a = 64,
        cp = [_a, 32, 16],
        un = -mr,
        hn = mr,
        lS = [new ni([un, un, un], [hn, hn, hn]), new ni([un, un, un], [0, 0, hn]), new ni([0, un, un], [hn, 0, hn]), new ni([un, 0, un], [0, hn, hn]), new ni([0, 0, un], [hn, hn, hn])];
      function uu(e) {
        return (e * mr) / ya;
      }
      function Q0(e, t, i, r = !0) {
        const n = N.scale([], e._camera.position, e.worldSize),
          o = [t, i, 1, 1];
        We.transformMat4(o, o, e.pixelMatrixInverse), We.scale(o, o, 1 / o[3]);
        const s = N.sub([], o, n),
          a = N.normalize([], s),
          l = e.globeMatrix,
          c = [l[12], l[13], l[14]],
          u = N.sub([], c, n),
          h = N.length(u),
          d = N.normalize([], u),
          f = e.worldSize / (2 * Math.PI),
          p = N.dot(d, a),
          _ = Math.asin(f / h);
        if (_ < Math.acos(p)) {
          if (!r) return null;
          const k = [],
            O = [];
          N.scale(k, a, h / p), N.normalize(O, N.sub(O, k, u)), N.normalize(a, N.add(a, u, N.scale(a, O, Math.tan(_) * h)));
        }
        const g = [];
        new cu(n, a).closestPointOnSphere(c, f, g);
        const y = N.normalize([], Ie(l, 0)),
          v = N.normalize([], Ie(l, 1)),
          w = N.normalize([], Ie(l, 2)),
          T = N.dot(y, g),
          b = N.dot(v, g),
          E = N.dot(w, g),
          S = Vi(Math.asin(-b / f));
        let I = Vi(Math.atan2(T, E));
        I =
          e.center.lng +
          (function (k, O) {
            const V = ((O - k + 180) % 360) - 180;
            return V < -180 ? V + 360 : V;
          })(e.center.lng, I);
        const C = qi(I),
          z = Bt(Hi(S), 0, 1);
        return new Me(C, z);
      }
      class cS {
        constructor(t, i, r) {
          (this.a = N.sub([], t, r)), (this.b = N.sub([], i, r)), (this.center = r);
          const n = N.normalize([], this.a),
            o = N.normalize([], this.b);
          this.angle = Math.acos(N.dot(n, o));
        }
      }
      function up(e, t) {
        if (e.angle === 0) return null;
        let i;
        return (
          (i = e.a[t] === 0 ? (1 / e.angle) * 0.5 * Math.PI : (1 / e.angle) * Math.atan(e.b[t] / e.a[t] / Math.sin(e.angle) - 1 / Math.tan(e.angle))),
          i < 0 || i > 1
            ? null
            : (function (r, n, o, s) {
                const a = Math.sin(o);
                return r * (Math.sin((1 - s) * o) / a) + n * (Math.sin(s * o) / a);
              })(e.a[t], e.b[t], e.angle, Bt(i, 0, 1)) + e.center[t]
        );
      }
      function Yr(e) {
        if (e.z <= 1) return lS[e.z + 2 * e.y + e.x];
        const t = dp(hu(e));
        return ni.fromPoints(t);
      }
      function ho(e, t, i) {
        return N.scale(e, e, 1 - i), N.scaleAndAdd(e, e, t, i);
      }
      function tx(e, t) {
        const i = Ji(t.zoom);
        if (i === 0) return Yr(e);
        const r = hu(e),
          n = dp(r),
          o = qi(r.getWest()) * t.worldSize,
          s = qi(r.getEast()) * t.worldSize,
          a = Hi(r.getNorth()) * t.worldSize,
          l = Hi(r.getSouth()) * t.worldSize,
          c = [o, a, 0],
          u = [s, a, 0],
          h = [o, l, 0],
          d = [s, l, 0],
          f = J.invert([], t.globeMatrix);
        return N.transformMat4(c, c, f), N.transformMat4(u, u, f), N.transformMat4(h, h, f), N.transformMat4(d, d, f), (n[0] = ho(n[0], h, i)), (n[1] = ho(n[1], d, i)), (n[2] = ho(n[2], u, i)), (n[3] = ho(n[3], c, i)), ni.fromPoints(n);
      }
      function ex(e, t, i) {
        for (const r of e) N.transformMat4(r, r, t), N.scale(r, r, i);
      }
      function hp(e, t, i, r) {
        const n = t / e.worldSize,
          o = e.globeMatrix;
        if (i.z <= 1) {
          const C = Yr(i).getCorners();
          return ex(C, o, n), ni.fromPoints(C);
        }
        const s = hu(i, r),
          a = dp(s);
        ex(a, o, n);
        const l = Number.MAX_VALUE,
          c = [-l, -l, -l],
          u = [l, l, l];
        if (s.contains(e.center)) {
          for (const k of a) N.min(u, u, k), N.max(c, c, k);
          c[2] = 0;
          const C = e.point,
            z = [C.x * n, C.y * n, 0];
          return N.min(u, u, z), N.max(c, c, z), new ni(u, c);
        }
        const h = [o[12] * n, o[13] * n, o[14] * n],
          d = s.getCenter(),
          f = Bt(e.center.lat, -Ii, Ii),
          p = Bt(d.lat, -Ii, Ii),
          _ = qi(e.center.lng),
          g = Hi(f);
        let y = _ - qi(d.lng);
        const v = g - Hi(p);
        y > 0.5 ? (y -= 1) : y < -0.5 && (y += 1);
        let w = 0;
        if (Math.abs(y) > Math.abs(v)) w = y >= 0 ? 1 : 3;
        else {
          w = v >= 0 ? 0 : 2;
          const C = [o[4] * n, o[5] * n, o[6] * n],
            z = -Math.sin(ne(v >= 0 ? s.getSouth() : s.getNorth())) * mr;
          N.scaleAndAdd(h, h, C, z);
        }
        const T = a[w],
          b = a[(w + 1) % 4],
          E = new cS(T, b, h),
          S = [up(E, 0) || T[0], up(E, 1) || T[1], up(E, 2) || T[2]],
          I = Ji(e.zoom);
        if (I > 0) {
          const C = (function ({ x: k, y: O, z: V }, R, G, Z, X) {
            const j = 1 / (1 << V);
            let q = k * j,
              it = q + j,
              st = O * j,
              nt = st + j,
              ut = 0;
            const ht = (q + it) / 2 - Z;
            return (
              ht > 0.5 ? (ut = -1) : ht < -0.5 && (ut = 1),
              (q = ((q + ut) * R - (Z *= R)) * G + Z),
              (it = ((it + ut) * R - Z) * G + Z),
              (st = (st * R - (X *= R)) * G + X),
              (nt = (nt * R - X) * G + X),
              [
                [q, nt, 0],
                [it, nt, 0],
                [it, st, 0],
                [q, st, 0],
              ]
            );
          })(i, t, e._pixelsPerMercatorPixel, _, g);
          for (let k = 0; k < a.length; k++) ho(a[k], C[k], I);
          const z = N.add([], C[w], C[(w + 1) % 4]);
          N.scale(z, z, 0.5), ho(S, z, I);
        }
        for (const C of a) N.min(u, u, C), N.max(c, c, C);
        return (u[2] = Math.min(T[2], b[2])), N.min(u, u, S), N.max(c, c, S), new ni(u, c);
      }
      function hu({ x: e, y: t, z: i }, r = !1) {
        const n = 1 / (1 << i),
          o = new ie(Or(e * n), t === (1 << i) - 1 && r ? -90 : Ni((t + 1) * n)),
          s = new ie(Or((e + 1) * n), t === 0 && r ? 90 : Ni(t * n));
        return new kr(o, s);
      }
      function dp(e) {
        const t = ne(e.getNorth()),
          i = ne(e.getSouth()),
          r = Math.cos(t),
          n = Math.cos(i),
          o = Math.sin(t),
          s = Math.sin(i),
          a = e.getWest(),
          l = e.getEast();
        return [ga(n, s, a), ga(n, s, l), ga(r, o, l), ga(r, o, a)];
      }
      function ga(e, t, i, r = mr) {
        return (i = ne(i)), [e * Math.sin(i) * r, -t * r, e * Math.cos(i) * r];
      }
      function wr(e, t, i) {
        return ga(Math.cos(ne(e)), Math.sin(ne(e)), t, i);
      }
      function Al(e, t, i, r) {
        const n = 1 << i.z,
          o = (e / lt + i.x) / n;
        return wr(Ni((t / lt + i.y) / n), Or(o), r);
      }
      function du({ min: e, max: t }) {
        return aS / Math.max(t[0] - e[0], t[1] - e[1], t[2] - e[2]);
      }
      const ix = new Float64Array(16);
      function Bo(e) {
        const t = du(e),
          i = J.fromScaling(ix, [t, t, t]);
        return J.translate(i, i, N.negate([], e.min));
      }
      function fp(e) {
        const t = J.fromTranslation(ix, e.min),
          i = 1 / du(e);
        return J.scale(t, t, [i, i, i]);
      }
      function pp(e) {
        const t = lt / (2 * Math.PI);
        return e / (2 * Math.PI) / t;
      }
      function rx(e, t) {
        return (lt / (512 * Math.pow(2, e))) * du(Yr(t));
      }
      function nx(e, t, i, r, n) {
        const o = pp(i),
          s = [e, t, -i / (2 * Math.PI)],
          a = J.identity(new Float64Array(16));
        return J.translate(a, a, s), J.scale(a, a, [o, o, o]), J.rotateX(a, a, ne(-n)), J.rotateY(a, a, ne(-r)), a;
      }
      function ox(e) {
        const t = e.pixelsPerMeter,
          i = t / Je(1, e.center.lat),
          r = J.identity(new Float64Array(16));
        return J.translate(r, r, [e.point.x, e.point.y, 0]), J.scale(r, r, [i, i, t]), Float32Array.from(r);
      }
      function Ji(e) {
        return Zr(Sl, Oo, e);
      }
      function sx(e, t, i) {
        const r = J.identity(new Float64Array(16)),
          n = (t / (1 << e) - 0.5) * Math.PI * 2;
        return J.rotateY(r, i.globeMatrix, n), Float32Array.from(r);
      }
      function ax(e, t, i) {
        const r = Ji(i.zoom),
          n = e.style.map._antialias,
          o = t.options.extStandardDerivativesForceOff || (e.terrain && e.terrain.exaggeration() > 0);
        return r === 0 && !n && !o;
      }
      function lx(e, t, i, r) {
        const n = t.getNorth(),
          o = t.getSouth(),
          s = t.getWest(),
          a = t.getEast(),
          l = 1 << e.z,
          c = a - s,
          u = n - o,
          h = c / _a,
          d = -u / cp[i],
          f = [0, h, 0, d, 0, 0, n, s, 0];
        if (e.z > 0) {
          const p = 180 / r;
          br.multiply(f, f, [p / c + 1, 0, 0, 0, p / u + 1, 0, (-0.5 * p) / h, (0.5 * p) / d, 1]);
        }
        return (f[2] = l), (f[5] = e.x), (f[8] = e.y), f;
      }
      function uS(e) {
        const t = Ii - 5;
        e = (Bt(e, -t, t) / t) * 90;
        const i = Math.pow(Math.abs(Math.sin(ne(e))), 3);
        return Math.round(i * (cp.length - 1));
      }
      function cx(e) {
        const t = [0, 0, 0],
          i = J.identity(new Float64Array(16));
        return J.multiply(i, e.pixelMatrix, e.globeMatrix), N.transformMat4(t, t, i), new H(t[0], t[1]);
      }
      function ux(e, t) {
        const i = wr(t.lat, t.lng),
          r = (function (o) {
            const s = wr(o._center.lat, o._center.lng),
              a = N.fromValues(0, 1, 0);
            let l = N.cross([], a, s);
            const c = J.fromRotation([], -o.angle, s);
            (l = N.transformMat4(l, l, c)), J.fromRotation(c, -o._pitch, l);
            const u = N.normalize([], s);
            return N.scale(u, u, uu(o.cameraToCenterDistance / o.pixelsPerMeter)), N.transformMat4(u, u, c), N.add([], s, u);
          })(e),
          n = N.subtract([], r, i);
        return N.angle(n, i);
      }
      function fu(e, t) {
        return ux(e, t) > (Math.PI / 2) * 1.01;
      }
      const hx = ne(85),
        hS = Math.cos(hx),
        dS = Math.sin(hx);
      class fS {
        constructor(t) {
          this._createGrid(t), this._createPoles(t);
        }
        destroy() {
          this._poleIndexBuffer.destroy(), this._gridBuffer.destroy(), this._gridIndexBuffer.destroy(), this._poleNorthVertexBuffer.destroy(), this._poleSouthVertexBuffer.destroy();
          for (const t of this._poleSegments) t.destroy();
          for (const t of this._gridSegments) t.withSkirts.destroy(), t.withoutSkirts.destroy();
        }
        _fillGridMeshWithLods(t, i) {
          const r = new Rr(),
            n = new Fi(),
            o = [],
            s = t + 1 + 2,
            a = i[0] + 1,
            l = i[0] + 1 + (1 + i.length),
            c = (u, h, d) => {
              let f = u === s - 1 ? u - 2 : u === 0 ? u : u - 1;
              return (f += d ? 24575 : 0), [f, h];
            };
          for (let u = 0; u < s; ++u) r.emplaceBack(...c(u, 0, !0));
          for (let u = 0; u < a; ++u) for (let h = 0; h < s; ++h) r.emplaceBack(...c(h, u, (h === 0 || h === s - 1) && !0));
          for (let u = 0; u < i.length; ++u) {
            const h = i[u];
            for (let d = 0; d < s; ++d) r.emplaceBack(...c(d, h, !0));
          }
          for (let u = 0; u < i.length; ++u) {
            const h = n.length,
              d = i[u] + 1 + 2,
              f = new Fi();
            for (let g = 0; g < d - 1; g++) {
              const y = g === d - 2,
                v = y ? s * (l - i.length + u - g) : s;
              for (let w = 0; w < s - 1; w++) {
                const T = g * s + w;
                g === 0 || y || w === 0 || w === s - 2 ? (f.emplaceBack(T + 1, T, T + v), f.emplaceBack(T + v, T + v + 1, T + 1)) : (n.emplaceBack(T + 1, T, T + v), n.emplaceBack(T + v, T + v + 1, T + 1));
              }
            }
            const p = He.simpleSegment(0, h, r.length, n.length - h);
            for (let g = 0; g < f.uint16.length; g += 3) n.emplaceBack(f.uint16[g], f.uint16[g + 1], f.uint16[g + 2]);
            const _ = He.simpleSegment(0, h, r.length, n.length - h);
            o.push({ withoutSkirts: p, withSkirts: _ });
          }
          return { vertices: r, indices: n, segments: o };
        }
        _createGrid(t) {
          const i = this._fillGridMeshWithLods(_a, cp);
          (this._gridSegments = i.segments), (this._gridBuffer = t.createVertexBuffer(i.vertices, ko.members)), (this._gridIndexBuffer = t.createIndexBuffer(i.indices, !0));
        }
        _createPoles(t) {
          const i = new Fi();
          for (let a = 0; a <= _a; a++) i.emplaceBack(0, a + 1, a + 2);
          this._poleIndexBuffer = t.createIndexBuffer(i, !0);
          const r = new ys(),
            n = new ys(),
            o = new ys(),
            s = new ys();
          this._poleSegments = [];
          for (let a = 0, l = 0; a < Sl; a++) {
            const c = 360 / (1 << a);
            r.emplaceBack(0, -mr, 0, 0.5, 0), n.emplaceBack(0, -mr, 0, 0.5, 1), o.emplaceBack(0, -mr, 0, 0.5, 0.5), s.emplaceBack(0, -mr, 0, 0.5, 0.5);
            for (let u = 0; u <= _a; u++) {
              let h = u / _a,
                d = 0;
              const f = ee(0, c, h),
                [p, _, g] = ga(hS, dS, f, mr);
              r.emplaceBack(p, _, g, h, d), n.emplaceBack(p, _, g, h, 1 - d);
              const y = ne(f);
              (h = 0.5 + 0.5 * Math.sin(y)), (d = 0.5 + 0.5 * Math.cos(y)), o.emplaceBack(p, _, g, h, d), s.emplaceBack(p, _, g, h, 1 - d);
            }
            this._poleSegments.push(He.simpleSegment(l, 0, 66, 64)), (l += 66);
          }
          (this._poleNorthVertexBuffer = t.createVertexBuffer(r, lu, !1)), (this._poleSouthVertexBuffer = t.createVertexBuffer(n, lu, !1)), (this._texturedPoleNorthVertexBuffer = t.createVertexBuffer(o, lu, !1)), (this._texturedPoleSouthVertexBuffer = t.createVertexBuffer(s, lu, !1));
        }
        getGridBuffers(t, i) {
          return [this._gridBuffer, this._gridIndexBuffer, i ? this._gridSegments[t].withSkirts : this._gridSegments[t].withoutSkirts];
        }
        getPoleBuffers(t, i) {
          return [i ? this._texturedPoleNorthVertexBuffer : this._poleNorthVertexBuffer, i ? this._texturedPoleSouthVertexBuffer : this._poleSouthVertexBuffer, this._poleIndexBuffer, this._poleSegments[t]];
        }
      }
      const ya = 63710088e-1,
        mp = 2 * Math.PI * ya;
      class Fo {
        constructor(t, i) {
          if (isNaN(t) || isNaN(i)) throw new Error(`Invalid LngLat object: (${t}, ${i})`);
          if (((this.lng = +t), (this.lat = +i), this.lat > 90 || this.lat < -90)) throw new Error('Invalid LngLat latitude value: must be between -90 and 90');
        }
        wrap() {
          return new Fo(en(this.lng, -180, 180), this.lat);
        }
        toArray() {
          return [this.lng, this.lat];
        }
        toString() {
          return `LngLat(${this.lng}, ${this.lat})`;
        }
        distanceTo(t) {
          const i = Math.PI / 180,
            r = this.lat * i,
            n = t.lat * i,
            o = Math.sin(r) * Math.sin(n) + Math.cos(r) * Math.cos(n) * Math.cos((t.lng - this.lng) * i);
          return ya * Math.acos(Math.min(o, 1));
        }
        toBounds(t = 0) {
          const i = (360 * t) / 40075017,
            r = i / Math.cos((Math.PI / 180) * this.lat);
          return new kr(new Fo(this.lng - r, this.lat - i), new Fo(this.lng + r, this.lat + i));
        }
        toEcef(t) {
          const i = uu(t);
          return wr(this.lat, this.lng, mr + i);
        }
        static convert(t) {
          if (t instanceof Fo) return t;
          if (Array.isArray(t) && (t.length === 2 || t.length === 3)) return new Fo(Number(t[0]), Number(t[1]));
          if (!Array.isArray(t) && typeof t == 'object' && t !== null) return new Fo(Number('lng' in t ? t.lng : t.lon), Number(t.lat));
          throw new Error('`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]');
        }
      }
      var ie = Fo;
      const pS = 0,
        mS = 25.5;
      function pu(e) {
        return mp * Math.cos((e * Math.PI) / 180);
      }
      function qi(e) {
        return (180 + e) / 360;
      }
      function Hi(e) {
        return (180 - (180 / Math.PI) * Math.log(Math.tan(Math.PI / 4 + (e * Math.PI) / 360))) / 360;
      }
      function Je(e, t) {
        return e / pu(t);
      }
      function Or(e) {
        return 360 * e - 180;
      }
      function Ni(e) {
        return (360 / Math.PI) * Math.atan(Math.exp(((180 - 360 * e) * Math.PI) / 180)) - 90;
      }
      function dx(e, t) {
        return e * pu(Ni(t));
      }
      const Ii = 85.051129;
      function fx(e) {
        return Math.cos(ne(Bt(e, -Ii, Ii)));
      }
      function No(e, t) {
        const i = Bt(t, pS, mS),
          r = Math.pow(2, i);
        return (fx(e) * mp) / (512 * r);
      }
      function _p(e) {
        return 1 / Math.cos((e * Math.PI) / 180);
      }
      function Il(e, t = 0) {
        const i = Math.exp(Math.PI * (1 - ((e.y + t / lt) / (1 << e.z)) * 2));
        return (80150034 * i) / (i * i + 1) / lt / (1 << e.z);
      }
      class Me {
        constructor(t, i, r = 0) {
          (this.x = +t), (this.y = +i), (this.z = +r);
        }
        static fromLngLat(t, i = 0) {
          const r = ie.convert(t);
          return new Me(qi(r.lng), Hi(r.lat), Je(i, r.lat));
        }
        toLngLat() {
          return new ie(Or(this.x), Ni(this.y));
        }
        toAltitude() {
          return dx(this.z, this.y);
        }
        meterInMercatorCoordinateUnits() {
          return (1 / mp) * _p(Ni(this.y));
        }
      }
      function gp(e, t, i, r, n, o, s, a, l) {
        const c = (t + r) / 2,
          u = (i + n) / 2,
          h = new H(c, u);
        a(h),
          (function (d, f, p, _, g, y) {
            const v = p - g,
              w = _ - y;
            return Math.abs((_ - f) * v - (p - d) * w) / Math.hypot(v, w);
          })(h.x, h.y, o.x, o.y, s.x, s.y) >= l
            ? (gp(e, t, i, c, u, o, h, a, l), gp(e, c, u, r, n, h, s, a, l))
            : e.push(s);
      }
      function px(e, t, i) {
        let r = e[0],
          n = r.x,
          o = r.y;
        t(r);
        const s = [r];
        for (let a = 1; a < e.length; a++) {
          const l = e[a],
            { x: c, y: u } = l;
          t(l), gp(s, n, o, c, u, r, l, t, i), (n = c), (o = u), (r = l);
        }
        return s;
      }
      function yp(e, t, i, r) {
        if (r(t, i)) {
          const n = t.add(i)._mult(0.5);
          yp(e, t, n, r), yp(e, n, i, r);
        } else e.push(i);
      }
      function _S(e, t) {
        let i = e[0];
        const r = [i];
        for (let n = 1; n < e.length; n++) {
          const o = e[n];
          yp(r, i, o, t), (i = o);
        }
        return r;
      }
      const xp = Math.pow(2, 14) - 1,
        mx = -xp - 1;
      function gS(e, t) {
        const i = Math.round(e.x * t),
          r = Math.round(e.y * t);
        return (e.x = Bt(i, mx, xp)), (e.y = Bt(r, mx, xp)), (i < e.x || i > e.x + 1 || r < e.y || r > e.y + 1) && B('Geometry exceeds allowed extent, reduce your vector tile buffer size'), e;
      }
      function On(e, t, i) {
        const r = e.loadGeometry(),
          n = e.extent,
          o = lt / n;
        if (t && i && i.projection.isReprojectedInTileSpace) {
          const s = 1 << t.z,
            { scale: a, x: l, y: c, projection: u } = i,
            h = (d) => {
              const f = Or((t.x + d.x / n) / s),
                p = Ni((t.y + d.y / n) / s),
                _ = u.project(f, p);
              (d.x = (_.x * a - l) * n), (d.y = (_.y * a - c) * n);
            };
          for (let d = 0; d < r.length; d++)
            if (e.type !== 1) r[d] = px(r[d], h, 1);
            else {
              const f = [];
              for (const p of r[d]) p.x < 0 || p.x >= n || p.y < 0 || p.y >= n || (h(p), f.push(p));
              r[d] = f;
            }
        }
        for (const s of r) for (const a of s) gS(a, o);
        return r;
      }
      function Uo(e, t) {
        return { type: e.type, id: e.id, properties: e.properties, geometry: t ? On(e) : [] };
      }
      function mu(e, t, i, r, n) {
        e.emplaceBack(2 * t + (r + 1) / 2, 2 * i + (n + 1) / 2);
      }
      function _u(e, t, i) {
        e.emplaceBack(t.x, t.y, t.z, i[0] * 16384, i[1] * 16384, i[2] * 16384);
      }
      class vp {
        constructor(t) {
          (this.zoom = t.zoom), (this.overscaling = t.overscaling), (this.layers = t.layers), (this.layerIds = this.layers.map((i) => i.fqid)), (this.index = t.index), (this.hasPattern = !1), (this.projection = t.projection), (this.layoutVertexArray = new Rr()), (this.indexArray = new Fi()), (this.segments = new He()), (this.programConfigurations = new Ro(t.layers, t.zoom)), (this.stateDependentLayerIds = this.layers.filter((i) => i.isStateDependent()).map((i) => i.id));
        }
        populate(t, i, r, n) {
          const o = this.layers[0],
            s = [];
          let a = null;
          o.type === 'circle' && (a = o.layout.get('circle-sort-key'));
          for (const { feature: c, id: u, index: h, sourceLayerIndex: d } of t) {
            const f = this.layers[0]._featureFilter.needGeometry,
              p = Uo(c, f);
            if (!this.layers[0]._featureFilter.filter(new gi(this.zoom), p, r)) continue;
            const _ = a ? a.evaluate(p, {}, r) : void 0,
              g = { id: u, properties: c.properties, type: c.type, sourceLayerIndex: d, index: h, geometry: f ? p.geometry : On(c, r, n), patterns: {}, sortKey: _ };
            s.push(g);
          }
          a && s.sort((c, u) => c.sortKey - u.sortKey);
          let l = null;
          n.projection.name === 'globe' && ((this.globeExtVertexArray = new tu()), (l = n.projection));
          for (const c of s) {
            const { geometry: u, index: h, sourceLayerIndex: d } = c,
              f = t[h].feature;
            this.addFeature(c, u, h, i.availableImages, r, l, i.brightness), i.featureIndex.insert(f, u, h, d, this.index);
          }
        }
        update(t, i, r, n, o) {
          const s = Object.keys(t).length !== 0;
          (s && !this.stateDependentLayers.length) || this.programConfigurations.updatePaintArrays(t, i, s ? this.stateDependentLayers : this.layers, r, n, o);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t) {
          this.uploaded || ((this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, AM.members)), (this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.globeExtVertexArray && (this.globeExtVertexBuffer = t.createVertexBuffer(this.globeExtVertexArray, IM.members))), this.programConfigurations.upload(t), (this.uploaded = !0);
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
        }
        addFeature(t, i, r, n, o, s, a) {
          for (const l of i)
            for (const c of l) {
              const u = c.x,
                h = c.y;
              if (u < 0 || u >= lt || h < 0 || h >= lt) continue;
              if (s) {
                const p = s.projectTilePoint(u, h, o),
                  _ = s.upVector(o, u, h),
                  g = this.globeExtVertexArray;
                _u(g, p, _), _u(g, p, _), _u(g, p, _), _u(g, p, _);
              }
              const d = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t.sortKey),
                f = d.vertexLength;
              mu(this.layoutVertexArray, u, h, -1, -1), mu(this.layoutVertexArray, u, h, 1, -1), mu(this.layoutVertexArray, u, h, 1, 1), mu(this.layoutVertexArray, u, h, -1, 1), this.indexArray.emplaceBack(f, f + 1, f + 2), this.indexArray.emplaceBack(f, f + 2, f + 3), (d.vertexLength += 4), (d.primitiveLength += 2);
            }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, {}, n, o, a);
        }
      }
      function _x(e, t) {
        for (let i = 0; i < e.length; i++) if (Vo(t, e[i])) return !0;
        for (let i = 0; i < t.length; i++) if (Vo(e, t[i])) return !0;
        return !!bp(e, t);
      }
      function yS(e, t, i) {
        return !!Vo(e, t) || !!wp(t, e, i);
      }
      function gx(e, t) {
        if (e.length === 1) return xx(t, e[0]);
        for (let i = 0; i < t.length; i++) {
          const r = t[i];
          for (let n = 0; n < r.length; n++) if (Vo(e, r[n])) return !0;
        }
        for (let i = 0; i < e.length; i++) if (xx(t, e[i])) return !0;
        for (let i = 0; i < t.length; i++) if (bp(e, t[i])) return !0;
        return !1;
      }
      function xS(e, t, i) {
        if (e.length > 1) {
          if (bp(e, t)) return !0;
          for (let r = 0; r < t.length; r++) if (wp(t[r], e, i)) return !0;
        }
        for (let r = 0; r < e.length; r++) if (wp(e[r], t, i)) return !0;
        return !1;
      }
      function bp(e, t) {
        if (e.length === 0 || t.length === 0) return !1;
        for (let i = 0; i < e.length - 1; i++) {
          const r = e[i],
            n = e[i + 1];
          for (let o = 0; o < t.length - 1; o++) if (vS(r, n, t[o], t[o + 1])) return !0;
        }
        return !1;
      }
      function vS(e, t, i, r) {
        return et(e, i, r) !== et(t, i, r) && et(e, t, i) !== et(e, t, r);
      }
      function wp(e, t, i) {
        const r = i * i;
        if (t.length === 1) return e.distSqr(t[0]) < r;
        for (let n = 1; n < t.length; n++) if (yx(e, t[n - 1], t[n]) < r) return !0;
        return !1;
      }
      function yx(e, t, i) {
        const r = t.distSqr(i);
        if (r === 0) return e.distSqr(t);
        const n = ((e.x - t.x) * (i.x - t.x) + (e.y - t.y) * (i.y - t.y)) / r;
        return e.distSqr(n < 0 ? t : n > 1 ? i : i.sub(t)._mult(n)._add(t));
      }
      function xx(e, t) {
        let i,
          r,
          n,
          o = !1;
        for (let s = 0; s < e.length; s++) {
          i = e[s];
          for (let a = 0, l = i.length - 1; a < i.length; l = a++) (r = i[a]), (n = i[l]), r.y > t.y != n.y > t.y && t.x < ((n.x - r.x) * (t.y - r.y)) / (n.y - r.y) + r.x && (o = !o);
        }
        return o;
      }
      function Vo(e, t) {
        let i = !1;
        for (let r = 0, n = e.length - 1; r < e.length; n = r++) {
          const o = e[r],
            s = e[n];
          o.y > t.y != s.y > t.y && t.x < ((s.x - o.x) * (t.y - o.y)) / (s.y - o.y) + o.x && (i = !i);
        }
        return i;
      }
      function vx(e, t, i, r, n) {
        for (const s of e) if (t <= s.x && i <= s.y && r >= s.x && n >= s.y) return !0;
        const o = [new H(t, i), new H(t, n), new H(r, n), new H(r, i)];
        if (e.length > 2) {
          for (const s of o) if (Vo(e, s)) return !0;
        }
        for (let s = 0; s < e.length - 1; s++) if (bS(e[s], e[s + 1], o)) return !0;
        return !1;
      }
      function bS(e, t, i) {
        const r = i[0],
          n = i[2];
        if ((e.x < r.x && t.x < r.x) || (e.x > n.x && t.x > n.x) || (e.y < r.y && t.y < r.y) || (e.y > n.y && t.y > n.y)) return !1;
        const o = et(e, t, i[0]);
        return o !== et(e, t, i[1]) || o !== et(e, t, i[2]) || o !== et(e, t, i[3]);
      }
      function xa(e, t, i, r, n, o) {
        let s = t.y - e.y,
          a = e.x - t.x;
        if ((o = o || 0)) {
          const l = s * s + a * a;
          if (l === 0) return !0;
          const c = Math.sqrt(l);
          (s /= c), (a /= c);
        }
        return !((i.x - e.x) * s + (i.y - e.y) * a - o < 0 || (r.x - e.x) * s + (r.y - e.y) * a - o < 0 || (n.x - e.x) * s + (n.y - e.y) * a - o < 0);
      }
      function Tp(e, t, i, r, n, o, s) {
        return !(xa(e, t, r, n, o, s) || xa(t, i, r, n, o, s) || xa(i, e, r, n, o, s) || xa(r, n, e, t, i, s) || xa(n, o, e, t, i, s) || xa(o, r, e, t, i, s));
      }
      function va(e, t, i) {
        const r = t.paint.get(e).value;
        return r.kind === 'constant' ? r.value : i.programConfigurations.get(t.id).getMaxValue(e);
      }
      function gu(e) {
        return Math.sqrt(e[0] * e[0] + e[1] * e[1]);
      }
      function bx(e, t, i, r, n) {
        if (!t[0] && !t[1]) return e;
        const o = H.convert(t)._mult(n);
        i === 'viewport' && o._rotate(-r);
        const s = [];
        for (let a = 0; a < e.length; a++) s.push(e[a].sub(o));
        return s;
      }
      function wx(e, t, i, r) {
        const n = H.convert(e)._mult(r);
        return t === 'viewport' && n._rotate(-i), n;
      }
      Gt(vp, 'CircleBucket', { omit: ['layers'] });
      const wS = new Mi({ 'circle-sort-key': new Xt(Q.layout_circle['circle-sort-key']), visibility: new vt(Q.layout_circle.visibility) });
      var TS = { paint: new Mi({ 'circle-radius': new Xt(Q.paint_circle['circle-radius']), 'circle-color': new Xt(Q.paint_circle['circle-color']), 'circle-blur': new Xt(Q.paint_circle['circle-blur']), 'circle-opacity': new Xt(Q.paint_circle['circle-opacity']), 'circle-translate': new vt(Q.paint_circle['circle-translate']), 'circle-translate-anchor': new vt(Q.paint_circle['circle-translate-anchor']), 'circle-pitch-scale': new vt(Q.paint_circle['circle-pitch-scale']), 'circle-pitch-alignment': new vt(Q.paint_circle['circle-pitch-alignment']), 'circle-stroke-width': new Xt(Q.paint_circle['circle-stroke-width']), 'circle-stroke-color': new Xt(Q.paint_circle['circle-stroke-color']), 'circle-stroke-opacity': new Xt(Q.paint_circle['circle-stroke-opacity']), 'circle-emissive-strength': new vt(Q.paint_circle['circle-emissive-strength']) }), layout: wS };
      const ES = J.create(),
        MS = (e, t, i, r, n, o) => {
          const s = e.transform,
            a = s.projection.name === 'globe';
          let l;
          if (o.paint.get('circle-pitch-alignment') === 'map')
            if (a) {
              const u = rx(s.zoom, t.canonical) * s._pixelsPerMercatorPixel;
              l = Float32Array.from([u, 0, 0, u]);
            } else l = s.calculatePixelsToTileUnitsMatrix(i);
          else l = new Float32Array([s.pixelsToGLUnits[0], 0, 0, s.pixelsToGLUnits[1]]);
          const c = { u_camera_to_center_distance: e.transform.getCameraToCenterDistance(s.projection), u_matrix: e.translatePosMatrix(t.projMatrix, i, o.paint.get('circle-translate'), o.paint.get('circle-translate-anchor')), u_device_pixel_ratio: oe.devicePixelRatio, u_extrude_scale: l, u_inv_rot_matrix: ES, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0], u_emissive_strength: o.paint.get('circle-emissive-strength') };
          if (a) {
            (c.u_inv_rot_matrix = r), (c.u_merc_center = n), (c.u_tile_id = [t.canonical.x, t.canonical.y, 1 << t.canonical.z]), (c.u_zoom_transition = Ji(s.zoom));
            const u = n[0] * lt,
              h = n[1] * lt;
            c.u_up_dir = s.projection.upVector(new cn(0, 0, 0), u, h);
          }
          return c;
        },
        Tx = (e) => {
          const t = [];
          return e.paint.get('circle-pitch-alignment') === 'map' && t.push('PITCH_WITH_MAP'), e.paint.get('circle-pitch-scale') === 'map' && t.push('SCALE_WITH_MAP'), t;
        };
      function Ex(e, t, i, r, n, o, s, a, l) {
        if (o && e.queryGeometry.isAboveHorizon) return !1;
        o && (l *= e.pixelToTileUnitsFactor);
        const c = e.tileID.canonical,
          u = i.projection.upVectorScale(c, i.center.lat, i.worldSize).metersToTile;
        for (const h of t)
          for (const d of h) {
            const f = d.add(a),
              p = n && i.elevation ? i.elevation.exaggeration() * n.getElevationAt(f.x, f.y, !0) : 0,
              _ = i.projection.projectTilePoint(f.x, f.y, c);
            if (p > 0) {
              const w = i.projection.upVector(c, f.x, f.y);
              (_.x += w[0] * u * p), (_.y += w[1] * u * p), (_.z += w[2] * u * p);
            }
            const g = o ? f : SS(_.x, _.y, _.z, r),
              y = o ? e.tilespaceRays.map((w) => IS(w, p)) : e.queryGeometry.screenGeometry,
              v = We.transformMat4([], [_.x, _.y, _.z, 1], r);
            if ((!s && o ? (l *= v[3] / i.cameraToCenterDistance) : s && !o && (l *= i.cameraToCenterDistance / v[3]), o)) {
              const w = Ni((d.y / lt + c.y) / (1 << c.z));
              l /= i.projection.pixelsPerMeter(w, 1) / Je(1, w);
            }
            if (yS(y, g, l)) return !0;
          }
        return !1;
      }
      function SS(e, t, i, r) {
        const n = We.transformMat4([], [e, t, i, 1], r);
        return new H(n[0] / n[3], n[1] / n[3]);
      }
      const Mx = N.fromValues(0, 0, 0),
        AS = N.fromValues(0, 0, 1);
      function IS(e, t) {
        const i = N.create();
        return (Mx[2] = t), e.intersectsPlane(Mx, AS, i), new H(i[0], i[1]);
      }
      class Sx extends vp {}
      function Ax(e, { width: t, height: i }, r, n) {
        if (n) {
          if (n instanceof Uint8ClampedArray) n = new Uint8Array(n.buffer);
          else if (n.length !== t * i * r) throw new RangeError('mismatched image size');
        } else n = new Uint8Array(t * i * r);
        return (e.width = t), (e.height = i), (e.data = n), e;
      }
      function Ix(e, t, i) {
        const { width: r, height: n } = t;
        (r === e.width && n === e.height) || (Ep(e, t, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(e.width, r), height: Math.min(e.height, n) }, i), (e.width = r), (e.height = n), (e.data = t.data));
      }
      function Ep(e, t, i, r, n, o) {
        if (n.width === 0 || n.height === 0) return t;
        if (n.width > e.width || n.height > e.height || i.x > e.width - n.width || i.y > e.height - n.height) throw new RangeError('out of range source coordinates for image copy');
        if (n.width > t.width || n.height > t.height || r.x > t.width - n.width || r.y > t.height - n.height) throw new RangeError('out of range destination coordinates for image copy');
        const s = e.data,
          a = t.data;
        for (let l = 0; l < n.height; l++) {
          const c = ((i.y + l) * e.width + i.x) * o,
            u = ((r.y + l) * t.width + r.x) * o;
          for (let h = 0; h < n.width * o; h++) a[u + h] = s[c + h];
        }
        return t;
      }
      Gt(Sx, 'HeatmapBucket', { omit: ['layers'] });
      class fo {
        constructor(t, i) {
          Ax(this, t, 1, i);
        }
        resize(t) {
          Ix(this, new fo(t), 1);
        }
        clone() {
          return new fo({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(t, i, r, n, o) {
          Ep(t, i, r, n, o, 1);
        }
      }
      class Li {
        constructor(t, i) {
          Ax(this, t, 4, i);
        }
        resize(t) {
          Ix(this, new Li(t), 4);
        }
        replace(t, i) {
          i ? this.data.set(t) : (this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t);
        }
        clone() {
          return new Li({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(t, i, r, n, o) {
          Ep(t, i, r, n, o, 4);
        }
      }
      class Cx {
        constructor(t, i) {
          (this.width = t.width), (this.height = t.height), (this.data = i instanceof Uint8Array ? new Float32Array(i.buffer) : i);
        }
      }
      Gt(fo, 'AlphaImage'), Gt(Li, 'RGBAImage');
      const CS = new Mi({ visibility: new vt(Q.layout_heatmap.visibility) });
      var PS = { paint: new Mi({ 'heatmap-radius': new Xt(Q.paint_heatmap['heatmap-radius']), 'heatmap-weight': new Xt(Q.paint_heatmap['heatmap-weight']), 'heatmap-intensity': new vt(Q.paint_heatmap['heatmap-intensity']), 'heatmap-color': new yl(Q.paint_heatmap['heatmap-color']), 'heatmap-opacity': new vt(Q.paint_heatmap['heatmap-opacity']) }), layout: CS };
      function yu(e) {
        const t = {},
          i = e.resolution || 256,
          r = e.clips ? e.clips.length : 1,
          n = e.image || new Li({ width: i, height: r }),
          o = (s, a, l) => {
            t[e.evaluationKey] = l;
            const c = e.expression.evaluate(t);
            c && ((n.data[s + a + 0] = Math.floor((255 * c.r) / c.a)), (n.data[s + a + 1] = Math.floor((255 * c.g) / c.a)), (n.data[s + a + 2] = Math.floor((255 * c.b) / c.a)), (n.data[s + a + 3] = Math.floor(255 * c.a)));
          };
        if (e.clips)
          for (let s = 0, a = 0; s < r; ++s, a += 4 * i)
            for (let l = 0, c = 0; l < i; l++, c += 4) {
              const u = l / (i - 1),
                { start: h, end: d } = e.clips[s];
              o(a, c, h * (1 - u) + d * u);
            }
        else for (let s = 0, a = 0; s < i; s++, a += 4) o(0, a, s / (i - 1));
        return n;
      }
      const zS = new Mi({ visibility: new vt(Q.layout_hillshade.visibility) });
      var DS = { paint: new Mi({ 'hillshade-illumination-direction': new vt(Q.paint_hillshade['hillshade-illumination-direction']), 'hillshade-illumination-anchor': new vt(Q.paint_hillshade['hillshade-illumination-anchor']), 'hillshade-exaggeration': new vt(Q.paint_hillshade['hillshade-exaggeration']), 'hillshade-shadow-color': new vt(Q.paint_hillshade['hillshade-shadow-color']), 'hillshade-highlight-color': new vt(Q.paint_hillshade['hillshade-highlight-color']), 'hillshade-accent-color': new vt(Q.paint_hillshade['hillshade-accent-color']), 'hillshade-emissive-strength': new vt(Q.paint_hillshade['hillshade-emissive-strength']) }), layout: zS };
      const RS = Ne([{ name: 'a_pos', components: 2, type: 'Int16' }], 4),
        { members: LS } = RS;
      var Mp = { exports: {} };
      function xu(e, t, i) {
        i = i || 2;
        var r,
          n,
          o,
          s,
          a,
          l,
          c,
          u = t && t.length,
          h = u ? t[0] * i : e.length,
          d = Px(e, 0, h, i, !0),
          f = [];
        if (!d || d.next === d.prev) return f;
        if (
          (u &&
            (d = (function (_, g, y, v) {
              var w,
                T,
                b,
                E = [];
              for (w = 0, T = g.length; w < T; w++) (b = Px(_, g[w] * v, w < T - 1 ? g[w + 1] * v : _.length, v, !1)) === b.next && (b.steiner = !0), E.push(jS(b));
              for (E.sort(NS), w = 0; w < E.length; w++) y = US(E[w], y);
              return y;
            })(e, t, d, i)),
          e.length > 80 * i)
        ) {
          (r = o = e[0]), (n = s = e[1]);
          for (var p = i; p < h; p += i) (a = e[p]) < r && (r = a), (l = e[p + 1]) < n && (n = l), a > o && (o = a), l > s && (s = l);
          c = (c = Math.max(o - r, s - n)) !== 0 ? 32767 / c : 0;
        }
        return Cl(d, f, i, r, n, c, 0), f;
      }
      function Px(e, t, i, r, n) {
        var o, s;
        if (n === Ip(e, t, i, r) > 0) for (o = t; o < i; o += r) s = Rx(o, e[o], e[o + 1], s);
        else for (o = i - r; o >= t; o -= r) s = Rx(o, e[o], e[o + 1], s);
        return s && vu(s, s.next) && (zl(s), (s = s.next)), s;
      }
      function Ts(e, t) {
        if (!e) return e;
        t || (t = e);
        var i,
          r = e;
        do
          if (((i = !1), r.steiner || (!vu(r, r.next) && Zi(r.prev, r, r.next) !== 0))) r = r.next;
          else {
            if ((zl(r), (r = t = r.prev) === r.next)) break;
            i = !0;
          }
        while (i || r !== t);
        return t;
      }
      function Cl(e, t, i, r, n, o, s) {
        if (e) {
          !s &&
            o &&
            (function (u, h, d, f) {
              var p = u;
              do p.z === 0 && (p.z = Sp(p.x, p.y, h, d, f)), (p.prevZ = p.prev), (p.nextZ = p.next), (p = p.next);
              while (p !== u);
              (p.prevZ.nextZ = null),
                (p.prevZ = null),
                (function (_) {
                  var g,
                    y,
                    v,
                    w,
                    T,
                    b,
                    E,
                    S,
                    I = 1;
                  do {
                    for (y = _, _ = null, T = null, b = 0; y; ) {
                      for (b++, v = y, E = 0, g = 0; g < I && (E++, (v = v.nextZ)); g++);
                      for (S = I; E > 0 || (S > 0 && v); ) E !== 0 && (S === 0 || !v || y.z <= v.z) ? ((w = y), (y = y.nextZ), E--) : ((w = v), (v = v.nextZ), S--), T ? (T.nextZ = w) : (_ = w), (w.prevZ = T), (T = w);
                      y = v;
                    }
                    (T.nextZ = null), (I *= 2);
                  } while (b > 1);
                })(p);
            })(e, r, n, o);
          for (var a, l, c = e; e.prev !== e.next; )
            if (((a = e.prev), (l = e.next), o ? OS(e, r, n, o) : kS(e))) t.push((a.i / i) | 0), t.push((e.i / i) | 0), t.push((l.i / i) | 0), zl(e), (e = l.next), (c = l.next);
            else if ((e = l) === c) {
              s ? (s === 1 ? Cl((e = BS(Ts(e), t, i)), t, i, r, n, o, 2) : s === 2 && FS(e, t, i, r, n, o)) : Cl(Ts(e), t, i, r, n, o, 1);
              break;
            }
        }
      }
      function kS(e) {
        var t = e.prev,
          i = e,
          r = e.next;
        if (Zi(t, i, r) >= 0) return !1;
        for (var n = t.x, o = i.x, s = r.x, a = t.y, l = i.y, c = r.y, u = n < o ? (n < s ? n : s) : o < s ? o : s, h = a < l ? (a < c ? a : c) : l < c ? l : c, d = n > o ? (n > s ? n : s) : o > s ? o : s, f = a > l ? (a > c ? a : c) : l > c ? l : c, p = r.next; p !== t; ) {
          if (p.x >= u && p.x <= d && p.y >= h && p.y <= f && ba(n, a, o, l, s, c, p.x, p.y) && Zi(p.prev, p, p.next) >= 0) return !1;
          p = p.next;
        }
        return !0;
      }
      function OS(e, t, i, r) {
        var n = e.prev,
          o = e,
          s = e.next;
        if (Zi(n, o, s) >= 0) return !1;
        for (var a = n.x, l = o.x, c = s.x, u = n.y, h = o.y, d = s.y, f = a < l ? (a < c ? a : c) : l < c ? l : c, p = u < h ? (u < d ? u : d) : h < d ? h : d, _ = a > l ? (a > c ? a : c) : l > c ? l : c, g = u > h ? (u > d ? u : d) : h > d ? h : d, y = Sp(f, p, t, i, r), v = Sp(_, g, t, i, r), w = e.prevZ, T = e.nextZ; w && w.z >= y && T && T.z <= v; ) {
          if ((w.x >= f && w.x <= _ && w.y >= p && w.y <= g && w !== n && w !== s && ba(a, u, l, h, c, d, w.x, w.y) && Zi(w.prev, w, w.next) >= 0) || ((w = w.prevZ), T.x >= f && T.x <= _ && T.y >= p && T.y <= g && T !== n && T !== s && ba(a, u, l, h, c, d, T.x, T.y) && Zi(T.prev, T, T.next) >= 0)) return !1;
          T = T.nextZ;
        }
        for (; w && w.z >= y; ) {
          if (w.x >= f && w.x <= _ && w.y >= p && w.y <= g && w !== n && w !== s && ba(a, u, l, h, c, d, w.x, w.y) && Zi(w.prev, w, w.next) >= 0) return !1;
          w = w.prevZ;
        }
        for (; T && T.z <= v; ) {
          if (T.x >= f && T.x <= _ && T.y >= p && T.y <= g && T !== n && T !== s && ba(a, u, l, h, c, d, T.x, T.y) && Zi(T.prev, T, T.next) >= 0) return !1;
          T = T.nextZ;
        }
        return !0;
      }
      function BS(e, t, i) {
        var r = e;
        do {
          var n = r.prev,
            o = r.next.next;
          !vu(n, o) && zx(n, r, r.next, o) && Pl(n, o) && Pl(o, n) && (t.push((n.i / i) | 0), t.push((r.i / i) | 0), t.push((o.i / i) | 0), zl(r), zl(r.next), (r = e = o)), (r = r.next);
        } while (r !== e);
        return Ts(r);
      }
      function FS(e, t, i, r, n, o) {
        var s = e;
        do {
          for (var a = s.next.next; a !== s.prev; ) {
            if (s.i !== a.i && GS(s, a)) {
              var l = Dx(s, a);
              return (s = Ts(s, s.next)), (l = Ts(l, l.next)), Cl(s, t, i, r, n, o, 0), void Cl(l, t, i, r, n, o, 0);
            }
            a = a.next;
          }
          s = s.next;
        } while (s !== e);
      }
      function NS(e, t) {
        return e.x - t.x;
      }
      function US(e, t) {
        var i = (function (n, o) {
          var s,
            a = o,
            l = n.x,
            c = n.y,
            u = -1 / 0;
          do {
            if (c <= a.y && c >= a.next.y && a.next.y !== a.y) {
              var h = a.x + ((c - a.y) * (a.next.x - a.x)) / (a.next.y - a.y);
              if (h <= l && h > u && ((u = h), (s = a.x < a.next.x ? a : a.next), h === l)) return s;
            }
            a = a.next;
          } while (a !== o);
          if (!s) return null;
          var d,
            f = s,
            p = s.x,
            _ = s.y,
            g = 1 / 0;
          a = s;
          do l >= a.x && a.x >= p && l !== a.x && ba(c < _ ? l : u, c, p, _, c < _ ? u : l, c, a.x, a.y) && ((d = Math.abs(c - a.y) / (l - a.x)), Pl(a, n) && (d < g || (d === g && (a.x > s.x || (a.x === s.x && VS(s, a))))) && ((s = a), (g = d))), (a = a.next);
          while (a !== f);
          return s;
        })(e, t);
        if (!i) return t;
        var r = Dx(i, e);
        return Ts(r, r.next), Ts(i, i.next);
      }
      function VS(e, t) {
        return Zi(e.prev, e, t.prev) < 0 && Zi(t.next, e, e.next) < 0;
      }
      function Sp(e, t, i, r, n) {
        return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = ((e - i) * n) | 0) | (e << 8))) | (e << 4))) | (e << 2))) | (e << 1))) | ((t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = ((t - r) * n) | 0) | (t << 8))) | (t << 4))) | (t << 2))) | (t << 1))) << 1);
      }
      function jS(e) {
        var t = e,
          i = e;
        do (t.x < i.x || (t.x === i.x && t.y < i.y)) && (i = t), (t = t.next);
        while (t !== e);
        return i;
      }
      function ba(e, t, i, r, n, o, s, a) {
        return (n - s) * (t - a) >= (e - s) * (o - a) && (e - s) * (r - a) >= (i - s) * (t - a) && (i - s) * (o - a) >= (n - s) * (r - a);
      }
      function GS(e, t) {
        return (
          e.next.i !== t.i &&
          e.prev.i !== t.i &&
          !(function (i, r) {
            var n = i;
            do {
              if (n.i !== i.i && n.next.i !== i.i && n.i !== r.i && n.next.i !== r.i && zx(n, n.next, i, r)) return !0;
              n = n.next;
            } while (n !== i);
            return !1;
          })(e, t) &&
          ((Pl(e, t) &&
            Pl(t, e) &&
            (function (i, r) {
              var n = i,
                o = !1,
                s = (i.x + r.x) / 2,
                a = (i.y + r.y) / 2;
              do n.y > a != n.next.y > a && n.next.y !== n.y && s < ((n.next.x - n.x) * (a - n.y)) / (n.next.y - n.y) + n.x && (o = !o), (n = n.next);
              while (n !== i);
              return o;
            })(e, t) &&
            (Zi(e.prev, e, t.prev) || Zi(e, t.prev, t))) ||
            (vu(e, t) && Zi(e.prev, e, e.next) > 0 && Zi(t.prev, t, t.next) > 0))
        );
      }
      function Zi(e, t, i) {
        return (t.y - e.y) * (i.x - t.x) - (t.x - e.x) * (i.y - t.y);
      }
      function vu(e, t) {
        return e.x === t.x && e.y === t.y;
      }
      function zx(e, t, i, r) {
        var n = wu(Zi(e, t, i)),
          o = wu(Zi(e, t, r)),
          s = wu(Zi(i, r, e)),
          a = wu(Zi(i, r, t));
        return (n !== o && s !== a) || !(n !== 0 || !bu(e, i, t)) || !(o !== 0 || !bu(e, r, t)) || !(s !== 0 || !bu(i, e, r)) || !(a !== 0 || !bu(i, t, r));
      }
      function bu(e, t, i) {
        return t.x <= Math.max(e.x, i.x) && t.x >= Math.min(e.x, i.x) && t.y <= Math.max(e.y, i.y) && t.y >= Math.min(e.y, i.y);
      }
      function wu(e) {
        return e > 0 ? 1 : e < 0 ? -1 : 0;
      }
      function Pl(e, t) {
        return Zi(e.prev, e, e.next) < 0 ? Zi(e, t, e.next) >= 0 && Zi(e, e.prev, t) >= 0 : Zi(e, t, e.prev) < 0 || Zi(e, e.next, t) < 0;
      }
      function Dx(e, t) {
        var i = new Ap(e.i, e.x, e.y),
          r = new Ap(t.i, t.x, t.y),
          n = e.next,
          o = t.prev;
        return (e.next = t), (t.prev = e), (i.next = n), (n.prev = i), (r.next = i), (i.prev = r), (o.next = r), (r.prev = o), r;
      }
      function Rx(e, t, i, r) {
        var n = new Ap(e, t, i);
        return r ? ((n.next = r.next), (n.prev = r), (r.next.prev = n), (r.next = n)) : ((n.prev = n), (n.next = n)), n;
      }
      function zl(e) {
        (e.next.prev = e.prev), (e.prev.next = e.next), e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ);
      }
      function Ap(e, t, i) {
        (this.i = e), (this.x = t), (this.y = i), (this.prev = null), (this.next = null), (this.z = 0), (this.prevZ = null), (this.nextZ = null), (this.steiner = !1);
      }
      function Ip(e, t, i, r) {
        for (var n = 0, o = t, s = i - r; o < i; o += r) (n += (e[s] - e[o]) * (e[o + 1] + e[s + 1])), (s = o);
        return n;
      }
      (Mp.exports = xu),
        (Mp.exports.default = xu),
        (xu.deviation = function (e, t, i, r) {
          var n = t && t.length,
            o = Math.abs(Ip(e, 0, n ? t[0] * i : e.length, i));
          if (n) for (var s = 0, a = t.length; s < a; s++) o -= Math.abs(Ip(e, t[s] * i, s < a - 1 ? t[s + 1] * i : e.length, i));
          var l = 0;
          for (s = 0; s < r.length; s += 3) {
            var c = r[s] * i,
              u = r[s + 1] * i,
              h = r[s + 2] * i;
            l += Math.abs((e[c] - e[h]) * (e[u + 1] - e[c + 1]) - (e[c] - e[u]) * (e[h + 1] - e[c + 1]));
          }
          return o === 0 && l === 0 ? 0 : Math.abs((l - o) / o);
        }),
        (xu.flatten = function (e) {
          for (var t = e[0][0].length, i = { vertices: [], holes: [], dimensions: t }, r = 0, n = 0; n < e.length; n++) {
            for (var o = 0; o < e[n].length; o++) for (var s = 0; s < t; s++) i.vertices.push(e[n][o][s]);
            n > 0 && i.holes.push((r += e[n - 1].length));
          }
          return i;
        });
      var Tu = ze(Mp.exports);
      function Cp(e, t) {
        const i = e.length;
        if (i <= 1) return [e];
        const r = [];
        let n, o;
        for (let s = 0; s < i; s++) {
          const a = K(e[s]);
          a !== 0 && ((e[s].area = Math.abs(a)), o === void 0 && (o = a < 0), o === a < 0 ? (n && r.push(n), (n = [e[s]])) : n.push(e[s]));
        }
        if ((n && r.push(n), t > 1)) for (let s = 0; s < r.length; s++) r[s].length <= t || (SE(r[s], t, 1, r[s].length - 1, qS), (r[s] = r[s].slice(0, t)));
        return r;
      }
      function qS(e, t) {
        return t.area - e.area;
      }
      function Pp(e, t, i) {
        const r = i.patternDependencies;
        let n = !1;
        for (const o of t) {
          const s = o.paint.get(`${e}-pattern`);
          s.isConstant() || (n = !0);
          const a = s.constantOr(null);
          a && ((n = !0), (r[a] = !0));
        }
        return n;
      }
      function zp(e, t, i, r, n) {
        const o = n.patternDependencies;
        for (const s of t) {
          const a = s.paint.get(`${e}-pattern`).value;
          if (a.kind !== 'constant') {
            let l = a.evaluate({ zoom: r }, i, {}, n.availableImages);
            (l = l && l.name ? l.name : l), (o[l] = !0), (i.patterns[s.id] = l);
          }
        }
        return i;
      }
      class Eu {
        constructor(t) {
          (this.zoom = t.zoom), (this.overscaling = t.overscaling), (this.layers = t.layers), (this.layerIds = this.layers.map((i) => i.fqid)), (this.index = t.index), (this.hasPattern = !1), (this.patternFeatures = []), (this.layoutVertexArray = new Rr()), (this.indexArray = new Fi()), (this.indexArray2 = new zo()), (this.programConfigurations = new Ro(t.layers, t.zoom)), (this.segments = new He()), (this.segments2 = new He()), (this.stateDependentLayerIds = this.layers.filter((i) => i.isStateDependent()).map((i) => i.id)), (this.projection = t.projection);
        }
        populate(t, i, r, n) {
          this.hasPattern = Pp('fill', this.layers, i);
          const o = this.layers[0].layout.get('fill-sort-key'),
            s = [];
          for (const { feature: a, id: l, index: c, sourceLayerIndex: u } of t) {
            const h = this.layers[0]._featureFilter.needGeometry,
              d = Uo(a, h);
            if (!this.layers[0]._featureFilter.filter(new gi(this.zoom), d, r)) continue;
            const f = o ? o.evaluate(d, {}, r, i.availableImages) : void 0,
              p = { id: l, properties: a.properties, type: a.type, sourceLayerIndex: u, index: c, geometry: h ? d.geometry : On(a, r, n), patterns: {}, sortKey: f };
            s.push(p);
          }
          o && s.sort((a, l) => a.sortKey - l.sortKey);
          for (const a of s) {
            const { geometry: l, index: c, sourceLayerIndex: u } = a;
            if (this.hasPattern) {
              const h = zp('fill', this.layers, a, this.zoom, i);
              this.patternFeatures.push(h);
            } else this.addFeature(a, l, c, r, {}, i.availableImages, i.brightness);
            i.featureIndex.insert(t[c].feature, l, c, u, this.index);
          }
        }
        update(t, i, r, n, o) {
          const s = Object.keys(t).length !== 0;
          (s && !this.stateDependentLayers.length) || this.programConfigurations.updatePaintArrays(t, i, s ? this.stateDependentLayers : this.layers, r, n, o);
        }
        addFeatures(t, i, r, n, o, s) {
          for (const a of this.patternFeatures) this.addFeature(a, a.geometry, a.index, i, r, n, s);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t) {
          this.uploaded || ((this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, LS)), (this.indexBuffer = t.createIndexBuffer(this.indexArray)), (this.indexBuffer2 = t.createIndexBuffer(this.indexArray2))), this.programConfigurations.upload(t), (this.uploaded = !0);
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
        }
        addFeature(t, i, r, n, o, s = [], a) {
          for (const l of Cp(i, 500)) {
            let c = 0;
            for (const _ of l) c += _.length;
            const u = this.segments.prepareSegment(c, this.layoutVertexArray, this.indexArray),
              h = u.vertexLength,
              d = [],
              f = [];
            for (const _ of l) {
              if (_.length === 0) continue;
              _ !== l[0] && f.push(d.length / 2);
              const g = this.segments2.prepareSegment(_.length, this.layoutVertexArray, this.indexArray2),
                y = g.vertexLength;
              this.layoutVertexArray.emplaceBack(_[0].x, _[0].y), this.indexArray2.emplaceBack(y + _.length - 1, y), d.push(_[0].x), d.push(_[0].y);
              for (let v = 1; v < _.length; v++) this.layoutVertexArray.emplaceBack(_[v].x, _[v].y), this.indexArray2.emplaceBack(y + v - 1, y + v), d.push(_[v].x), d.push(_[v].y);
              (g.vertexLength += _.length), (g.primitiveLength += _.length);
            }
            const p = Tu(d, f);
            for (let _ = 0; _ < p.length; _ += 3) this.indexArray.emplaceBack(h + p[_], h + p[_ + 1], h + p[_ + 2]);
            (u.vertexLength += c), (u.primitiveLength += p.length / 3);
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, o, s, n, a);
        }
      }
      Gt(Eu, 'FillBucket', { omit: ['layers', 'patternFeatures'] });
      const ZS = new Mi({ 'fill-sort-key': new Xt(Q.layout_fill['fill-sort-key']), visibility: new vt(Q.layout_fill.visibility) });
      var $S = { paint: new Mi({ 'fill-antialias': new vt(Q.paint_fill['fill-antialias']), 'fill-opacity': new Xt(Q.paint_fill['fill-opacity']), 'fill-color': new Xt(Q.paint_fill['fill-color']), 'fill-outline-color': new Xt(Q.paint_fill['fill-outline-color']), 'fill-translate': new vt(Q.paint_fill['fill-translate']), 'fill-translate-anchor': new vt(Q.paint_fill['fill-translate-anchor']), 'fill-pattern': new Xt(Q.paint_fill['fill-pattern']), 'fill-emissive-strength': new vt(Q.paint_fill['fill-emissive-strength']) }), layout: ZS };
      const HS = Ne([{ name: 'a_pos_normal_ed', components: 4, type: 'Int16' }]),
        WS = Ne([
          { name: 'a_pos_end', components: 4, type: 'Int16' },
          { name: 'a_angular_offset_factor', components: 1, type: 'Int16' },
        ]),
        XS = Ne([{ name: 'a_centroid_pos', components: 2, type: 'Uint16' }]),
        YS = Ne([{ name: 'a_hidden_by_landmark', components: 1, type: 'Uint8' }]),
        KS = Ne([
          { name: 'a_pos_3', components: 3, type: 'Int16' },
          { name: 'a_pos_normal_3', components: 3, type: 'Int16' },
        ]),
        { members: JS } = HS;
      var Mu = {},
        QS = ur,
        Lx = wa;
      function wa(e, t, i, r, n) {
        (this.properties = {}), (this.extent = i), (this.type = 0), (this._pbf = e), (this._geometry = -1), (this._keys = r), (this._values = n), e.readFields(tA, this, t);
      }
      function tA(e, t, i) {
        e == 1
          ? (t.id = i.readVarint())
          : e == 2
          ? (function (r, n) {
              for (var o = r.readVarint() + r.pos; r.pos < o; ) {
                var s = n._keys[r.readVarint()],
                  a = n._values[r.readVarint()];
                n.properties[s] = a;
              }
            })(i, t)
          : e == 3
          ? (t.type = i.readVarint())
          : e == 4 && (t._geometry = i.pos);
      }
      function eA(e) {
        for (var t, i, r = 0, n = 0, o = e.length, s = o - 1; n < o; s = n++) r += ((i = e[s]).x - (t = e[n]).x) * (t.y + i.y);
        return r;
      }
      (wa.types = ['Unknown', 'Point', 'LineString', 'Polygon']),
        (wa.prototype.loadGeometry = function () {
          var e = this._pbf;
          e.pos = this._geometry;
          for (var t, i = e.readVarint() + e.pos, r = 1, n = 0, o = 0, s = 0, a = []; e.pos < i; ) {
            if (n <= 0) {
              var l = e.readVarint();
              (r = 7 & l), (n = l >> 3);
            }
            if ((n--, r === 1 || r === 2)) (o += e.readSVarint()), (s += e.readSVarint()), r === 1 && (t && a.push(t), (t = [])), t.push(new QS(o, s));
            else {
              if (r !== 7) throw new Error('unknown command ' + r);
              t && t.push(t[0].clone());
            }
          }
          return t && a.push(t), a;
        }),
        (wa.prototype.bbox = function () {
          var e = this._pbf;
          e.pos = this._geometry;
          for (var t = e.readVarint() + e.pos, i = 1, r = 0, n = 0, o = 0, s = 1 / 0, a = -1 / 0, l = 1 / 0, c = -1 / 0; e.pos < t; ) {
            if (r <= 0) {
              var u = e.readVarint();
              (i = 7 & u), (r = u >> 3);
            }
            if ((r--, i === 1 || i === 2)) (n += e.readSVarint()) < s && (s = n), n > a && (a = n), (o += e.readSVarint()) < l && (l = o), o > c && (c = o);
            else if (i !== 7) throw new Error('unknown command ' + i);
          }
          return [s, l, a, c];
        }),
        (wa.prototype.toGeoJSON = function (e, t, i) {
          var r,
            n,
            o = this.extent * Math.pow(2, i),
            s = this.extent * e,
            a = this.extent * t,
            l = this.loadGeometry(),
            c = wa.types[this.type];
          function u(f) {
            for (var p = 0; p < f.length; p++) {
              var _ = f[p];
              f[p] = [(360 * (_.x + s)) / o - 180, (360 / Math.PI) * Math.atan(Math.exp(((180 - (360 * (_.y + a)) / o) * Math.PI) / 180)) - 90];
            }
          }
          switch (this.type) {
            case 1:
              var h = [];
              for (r = 0; r < l.length; r++) h[r] = l[r][0];
              u((l = h));
              break;
            case 2:
              for (r = 0; r < l.length; r++) u(l[r]);
              break;
            case 3:
              for (
                l = (function (f) {
                  var p = f.length;
                  if (p <= 1) return [f];
                  for (var _, g, y = [], v = 0; v < p; v++) {
                    var w = eA(f[v]);
                    w !== 0 && (g === void 0 && (g = w < 0), g === w < 0 ? (_ && y.push(_), (_ = [f[v]])) : _.push(f[v]));
                  }
                  return _ && y.push(_), y;
                })(l),
                  r = 0;
                r < l.length;
                r++
              )
                for (n = 0; n < l[r].length; n++) u(l[r][n]);
          }
          l.length === 1 ? (l = l[0]) : (c = 'Multi' + c);
          var d = { type: 'Feature', geometry: { type: c, coordinates: l }, properties: this.properties };
          return 'id' in this && (d.id = this.id), d;
        });
      var iA = Lx,
        kx = Ox;
      function Ox(e, t) {
        (this.version = 1), (this.name = null), (this.extent = 4096), (this.length = 0), (this._pbf = e), (this._keys = []), (this._values = []), (this._features = []), e.readFields(rA, this, t), (this.length = this._features.length);
      }
      function rA(e, t, i) {
        e === 15
          ? (t.version = i.readVarint())
          : e === 1
          ? (t.name = i.readString())
          : e === 5
          ? (t.extent = i.readVarint())
          : e === 2
          ? t._features.push(i.pos)
          : e === 3
          ? t._keys.push(i.readString())
          : e === 4 &&
            t._values.push(
              (function (r) {
                for (var n = null, o = r.readVarint() + r.pos; r.pos < o; ) {
                  var s = r.readVarint() >> 3;
                  n = s === 1 ? r.readString() : s === 2 ? r.readFloat() : s === 3 ? r.readDouble() : s === 4 ? r.readVarint64() : s === 5 ? r.readVarint() : s === 6 ? r.readSVarint() : s === 7 ? r.readBoolean() : null;
                }
                return n;
              })(i)
            );
      }
      Ox.prototype.feature = function (e) {
        if (e < 0 || e >= this._features.length) throw new Error('feature index out of bounds');
        this._pbf.pos = this._features[e];
        var t = this._pbf.readVarint() + this._pbf.pos;
        return new iA(this._pbf, t, this.extent, this._keys, this._values);
      };
      var nA = kx;
      function oA(e, t, i) {
        if (e === 3) {
          var r = new nA(i, i.readVarint() + i.pos);
          r.length && (t[r.name] = r);
        }
      }
      var Dp = (Mu.VectorTile = function (e, t) {
          this.layers = e.readFields(oA, {}, t);
        }),
        Su = (Mu.VectorTileFeature = Lx);
      function Au(e, t, i, r) {
        const n = [],
          o =
            r === 0
              ? (s, a, l, c, u, h) => {
                  s.push(new H(h, l + ((h - a) / (c - a)) * (u - l)));
                }
              : (s, a, l, c, u, h) => {
                  s.push(new H(a + ((h - l) / (u - l)) * (c - a), h));
                };
        for (const s of e) {
          const a = [];
          for (const l of s) {
            if (l.length <= 2) continue;
            const c = [];
            for (let d = 0; d < l.length - 1; d++) {
              const f = l[d].x,
                p = l[d].y,
                _ = l[d + 1].x,
                g = l[d + 1].y,
                y = r === 0 ? f : p,
                v = r === 0 ? _ : g;
              y < t ? v > t && o(c, f, p, _, g, t) : y > i ? v < i && o(c, f, p, _, g, i) : c.push(l[d]), v < t && y >= t && o(c, f, p, _, g, t), v > i && y <= i && o(c, f, p, _, g, i);
            }
            let u = l[l.length - 1];
            const h = r === 0 ? u.x : u.y;
            h >= t && h <= i && c.push(u), c.length && ((u = c[c.length - 1]), (c[0].x === u.x && c[0].y === u.y) || c.push(c[0]), a.push(c));
          }
          a.length && n.push(a);
        }
        return n;
      }
      Mu.VectorTileLayer = kx;
      class Bx {
        constructor(t) {
          (this._stringToNumber = {}), (this._numberToString = []);
          for (let i = 0; i < t.length; i++) {
            const r = t[i];
            (this._stringToNumber[r] = i), (this._numberToString[i] = r);
          }
        }
        encode(t) {
          return this._stringToNumber[t];
        }
        decode(t) {
          return this._numberToString[t];
        }
      }
      var sA = {
          read: function (e, t, i, r, n) {
            var o,
              s,
              a = 8 * n - r - 1,
              l = (1 << a) - 1,
              c = l >> 1,
              u = -7,
              h = i ? n - 1 : 0,
              d = i ? -1 : 1,
              f = e[t + h];
            for (h += d, o = f & ((1 << -u) - 1), f >>= -u, u += a; u > 0; o = 256 * o + e[t + h], h += d, u -= 8);
            for (s = o & ((1 << -u) - 1), o >>= -u, u += r; u > 0; s = 256 * s + e[t + h], h += d, u -= 8);
            if (o === 0) o = 1 - c;
            else {
              if (o === l) return s ? NaN : (1 / 0) * (f ? -1 : 1);
              (s += Math.pow(2, r)), (o -= c);
            }
            return (f ? -1 : 1) * s * Math.pow(2, o - r);
          },
          write: function (e, t, i, r, n, o) {
            var s,
              a,
              l,
              c = 8 * o - n - 1,
              u = (1 << c) - 1,
              h = u >> 1,
              d = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
              f = r ? 0 : o - 1,
              p = r ? 1 : -1,
              _ = t < 0 || (t === 0 && 1 / t < 0) ? 1 : 0;
            for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? ((a = isNaN(t) ? 1 : 0), (s = u)) : ((s = Math.floor(Math.log(t) / Math.LN2)), t * (l = Math.pow(2, -s)) < 1 && (s--, (l *= 2)), (t += s + h >= 1 ? d / l : d * Math.pow(2, 1 - h)) * l >= 2 && (s++, (l /= 2)), s + h >= u ? ((a = 0), (s = u)) : s + h >= 1 ? ((a = (t * l - 1) * Math.pow(2, n)), (s += h)) : ((a = t * Math.pow(2, h - 1) * Math.pow(2, n)), (s = 0))); n >= 8; e[i + f] = 255 & a, f += p, a /= 256, n -= 8);
            for (s = (s << n) | a, c += n; c > 0; e[i + f] = 255 & s, f += p, s /= 256, c -= 8);
            e[i + f - p] |= 128 * _;
          },
        },
        Fx = hi,
        Iu = sA;
      function hi(e) {
        (this.buf = ArrayBuffer.isView && ArrayBuffer.isView(e) ? e : new Uint8Array(e || 0)), (this.pos = 0), (this.type = 0), (this.length = this.buf.length);
      }
      (hi.Varint = 0), (hi.Fixed64 = 1), (hi.Bytes = 2), (hi.Fixed32 = 5);
      var Rp = 4294967296,
        Nx = 1 / Rp,
        Ux = typeof TextDecoder > 'u' ? null : new TextDecoder('utf8');
      function po(e) {
        return e.type === hi.Bytes ? e.readVarint() + e.pos : e.pos + 1;
      }
      function Ta(e, t, i) {
        return i ? 4294967296 * t + (e >>> 0) : 4294967296 * (t >>> 0) + (e >>> 0);
      }
      function Vx(e, t, i) {
        var r = t <= 16383 ? 1 : t <= 2097151 ? 2 : t <= 268435455 ? 3 : Math.floor(Math.log(t) / (7 * Math.LN2));
        i.realloc(r);
        for (var n = i.pos - 1; n >= e; n--) i.buf[n + r] = i.buf[n];
      }
      function aA(e, t) {
        for (var i = 0; i < e.length; i++) t.writeVarint(e[i]);
      }
      function lA(e, t) {
        for (var i = 0; i < e.length; i++) t.writeSVarint(e[i]);
      }
      function cA(e, t) {
        for (var i = 0; i < e.length; i++) t.writeFloat(e[i]);
      }
      function uA(e, t) {
        for (var i = 0; i < e.length; i++) t.writeDouble(e[i]);
      }
      function hA(e, t) {
        for (var i = 0; i < e.length; i++) t.writeBoolean(e[i]);
      }
      function dA(e, t) {
        for (var i = 0; i < e.length; i++) t.writeFixed32(e[i]);
      }
      function fA(e, t) {
        for (var i = 0; i < e.length; i++) t.writeSFixed32(e[i]);
      }
      function pA(e, t) {
        for (var i = 0; i < e.length; i++) t.writeFixed64(e[i]);
      }
      function mA(e, t) {
        for (var i = 0; i < e.length; i++) t.writeSFixed64(e[i]);
      }
      function Cu(e, t) {
        return (e[t] | (e[t + 1] << 8) | (e[t + 2] << 16)) + 16777216 * e[t + 3];
      }
      function Ea(e, t, i) {
        (e[i] = t), (e[i + 1] = t >>> 8), (e[i + 2] = t >>> 16), (e[i + 3] = t >>> 24);
      }
      function jx(e, t) {
        return (e[t] | (e[t + 1] << 8) | (e[t + 2] << 16)) + (e[t + 3] << 24);
      }
      hi.prototype = {
        destroy: function () {
          this.buf = null;
        },
        readFields: function (e, t, i) {
          for (i = i || this.length; this.pos < i; ) {
            var r = this.readVarint(),
              n = r >> 3,
              o = this.pos;
            (this.type = 7 & r), e(n, t, this), this.pos === o && this.skip(r);
          }
          return t;
        },
        readMessage: function (e, t) {
          return this.readFields(e, t, this.readVarint() + this.pos);
        },
        readFixed32: function () {
          var e = Cu(this.buf, this.pos);
          return (this.pos += 4), e;
        },
        readSFixed32: function () {
          var e = jx(this.buf, this.pos);
          return (this.pos += 4), e;
        },
        readFixed64: function () {
          var e = Cu(this.buf, this.pos) + Cu(this.buf, this.pos + 4) * Rp;
          return (this.pos += 8), e;
        },
        readSFixed64: function () {
          var e = Cu(this.buf, this.pos) + jx(this.buf, this.pos + 4) * Rp;
          return (this.pos += 8), e;
        },
        readFloat: function () {
          var e = Iu.read(this.buf, this.pos, !0, 23, 4);
          return (this.pos += 4), e;
        },
        readDouble: function () {
          var e = Iu.read(this.buf, this.pos, !0, 52, 8);
          return (this.pos += 8), e;
        },
        readVarint: function (e) {
          var t,
            i,
            r = this.buf;
          return (
            (t = 127 & (i = r[this.pos++])),
            i < 128
              ? t
              : ((t |= (127 & (i = r[this.pos++])) << 7),
                i < 128
                  ? t
                  : ((t |= (127 & (i = r[this.pos++])) << 14),
                    i < 128
                      ? t
                      : ((t |= (127 & (i = r[this.pos++])) << 21),
                        i < 128
                          ? t
                          : (function (n, o, s) {
                              var a,
                                l,
                                c = s.buf;
                              if (((a = (112 & (l = c[s.pos++])) >> 4), l < 128 || ((a |= (127 & (l = c[s.pos++])) << 3), l < 128) || ((a |= (127 & (l = c[s.pos++])) << 10), l < 128) || ((a |= (127 & (l = c[s.pos++])) << 17), l < 128) || ((a |= (127 & (l = c[s.pos++])) << 24), l < 128) || ((a |= (1 & (l = c[s.pos++])) << 31), l < 128))) return Ta(n, a, o);
                              throw new Error('Expected varint not more than 10 bytes');
                            })((t |= (15 & (i = r[this.pos])) << 28), e, this))))
          );
        },
        readVarint64: function () {
          return this.readVarint(!0);
        },
        readSVarint: function () {
          var e = this.readVarint();
          return e % 2 == 1 ? (e + 1) / -2 : e / 2;
        },
        readBoolean: function () {
          return !!this.readVarint();
        },
        readString: function () {
          var e = this.readVarint() + this.pos,
            t = this.pos;
          return (
            (this.pos = e),
            e - t >= 12 && Ux
              ? (function (i, r, n) {
                  return Ux.decode(i.subarray(r, n));
                })(this.buf, t, e)
              : (function (i, r, n) {
                  for (var o = '', s = r; s < n; ) {
                    var a,
                      l,
                      c,
                      u = i[s],
                      h = null,
                      d = u > 239 ? 4 : u > 223 ? 3 : u > 191 ? 2 : 1;
                    if (s + d > n) break;
                    d === 1 ? u < 128 && (h = u) : d === 2 ? (192 & (a = i[s + 1])) == 128 && (h = ((31 & u) << 6) | (63 & a)) <= 127 && (h = null) : d === 3 ? ((l = i[s + 2]), (192 & (a = i[s + 1])) == 128 && (192 & l) == 128 && ((h = ((15 & u) << 12) | ((63 & a) << 6) | (63 & l)) <= 2047 || (h >= 55296 && h <= 57343)) && (h = null)) : d === 4 && ((l = i[s + 2]), (c = i[s + 3]), (192 & (a = i[s + 1])) == 128 && (192 & l) == 128 && (192 & c) == 128 && ((h = ((15 & u) << 18) | ((63 & a) << 12) | ((63 & l) << 6) | (63 & c)) <= 65535 || h >= 1114112) && (h = null)), h === null ? ((h = 65533), (d = 1)) : h > 65535 && ((h -= 65536), (o += String.fromCharCode(((h >>> 10) & 1023) | 55296)), (h = 56320 | (1023 & h))), (o += String.fromCharCode(h)), (s += d);
                  }
                  return o;
                })(this.buf, t, e)
          );
        },
        readBytes: function () {
          var e = this.readVarint() + this.pos,
            t = this.buf.subarray(this.pos, e);
          return (this.pos = e), t;
        },
        readPackedVarint: function (e, t) {
          if (this.type !== hi.Bytes) return e.push(this.readVarint(t));
          var i = po(this);
          for (e = e || []; this.pos < i; ) e.push(this.readVarint(t));
          return e;
        },
        readPackedSVarint: function (e) {
          if (this.type !== hi.Bytes) return e.push(this.readSVarint());
          var t = po(this);
          for (e = e || []; this.pos < t; ) e.push(this.readSVarint());
          return e;
        },
        readPackedBoolean: function (e) {
          if (this.type !== hi.Bytes) return e.push(this.readBoolean());
          var t = po(this);
          for (e = e || []; this.pos < t; ) e.push(this.readBoolean());
          return e;
        },
        readPackedFloat: function (e) {
          if (this.type !== hi.Bytes) return e.push(this.readFloat());
          var t = po(this);
          for (e = e || []; this.pos < t; ) e.push(this.readFloat());
          return e;
        },
        readPackedDouble: function (e) {
          if (this.type !== hi.Bytes) return e.push(this.readDouble());
          var t = po(this);
          for (e = e || []; this.pos < t; ) e.push(this.readDouble());
          return e;
        },
        readPackedFixed32: function (e) {
          if (this.type !== hi.Bytes) return e.push(this.readFixed32());
          var t = po(this);
          for (e = e || []; this.pos < t; ) e.push(this.readFixed32());
          return e;
        },
        readPackedSFixed32: function (e) {
          if (this.type !== hi.Bytes) return e.push(this.readSFixed32());
          var t = po(this);
          for (e = e || []; this.pos < t; ) e.push(this.readSFixed32());
          return e;
        },
        readPackedFixed64: function (e) {
          if (this.type !== hi.Bytes) return e.push(this.readFixed64());
          var t = po(this);
          for (e = e || []; this.pos < t; ) e.push(this.readFixed64());
          return e;
        },
        readPackedSFixed64: function (e) {
          if (this.type !== hi.Bytes) return e.push(this.readSFixed64());
          var t = po(this);
          for (e = e || []; this.pos < t; ) e.push(this.readSFixed64());
          return e;
        },
        skip: function (e) {
          var t = 7 & e;
          if (t === hi.Varint) for (; this.buf[this.pos++] > 127; );
          else if (t === hi.Bytes) this.pos = this.readVarint() + this.pos;
          else if (t === hi.Fixed32) this.pos += 4;
          else {
            if (t !== hi.Fixed64) throw new Error('Unimplemented type: ' + t);
            this.pos += 8;
          }
        },
        writeTag: function (e, t) {
          this.writeVarint((e << 3) | t);
        },
        realloc: function (e) {
          for (var t = this.length || 16; t < this.pos + e; ) t *= 2;
          if (t !== this.length) {
            var i = new Uint8Array(t);
            i.set(this.buf), (this.buf = i), (this.length = t);
          }
        },
        finish: function () {
          return (this.length = this.pos), (this.pos = 0), this.buf.subarray(0, this.length);
        },
        writeFixed32: function (e) {
          this.realloc(4), Ea(this.buf, e, this.pos), (this.pos += 4);
        },
        writeSFixed32: function (e) {
          this.realloc(4), Ea(this.buf, e, this.pos), (this.pos += 4);
        },
        writeFixed64: function (e) {
          this.realloc(8), Ea(this.buf, -1 & e, this.pos), Ea(this.buf, Math.floor(e * Nx), this.pos + 4), (this.pos += 8);
        },
        writeSFixed64: function (e) {
          this.realloc(8), Ea(this.buf, -1 & e, this.pos), Ea(this.buf, Math.floor(e * Nx), this.pos + 4), (this.pos += 8);
        },
        writeVarint: function (e) {
          (e = +e || 0) > 268435455 || e < 0
            ? (function (t, i) {
                var r, n;
                if ((t >= 0 ? ((r = t % 4294967296 | 0), (n = (t / 4294967296) | 0)) : ((n = ~(-t / 4294967296)), 4294967295 ^ (r = ~(-t % 4294967296)) ? (r = (r + 1) | 0) : ((r = 0), (n = (n + 1) | 0))), t >= 18446744073709552e3 || t < -18446744073709552e3)) throw new Error("Given varint doesn't fit into 10 bytes");
                i.realloc(10),
                  (function (o, s, a) {
                    (a.buf[a.pos++] = (127 & o) | 128), (o >>>= 7), (a.buf[a.pos++] = (127 & o) | 128), (o >>>= 7), (a.buf[a.pos++] = (127 & o) | 128), (o >>>= 7), (a.buf[a.pos++] = (127 & o) | 128), (a.buf[a.pos] = 127 & (o >>>= 7));
                  })(r, 0, i),
                  (function (o, s) {
                    var a = (7 & o) << 4;
                    (s.buf[s.pos++] |= a | ((o >>>= 3) ? 128 : 0)), o && ((s.buf[s.pos++] = (127 & o) | ((o >>>= 7) ? 128 : 0)), o && ((s.buf[s.pos++] = (127 & o) | ((o >>>= 7) ? 128 : 0)), o && ((s.buf[s.pos++] = (127 & o) | ((o >>>= 7) ? 128 : 0)), o && ((s.buf[s.pos++] = (127 & o) | ((o >>>= 7) ? 128 : 0)), o && (s.buf[s.pos++] = 127 & o)))));
                  })(n, i);
              })(e, this)
            : (this.realloc(4), (this.buf[this.pos++] = (127 & e) | (e > 127 ? 128 : 0)), e <= 127 || ((this.buf[this.pos++] = (127 & (e >>>= 7)) | (e > 127 ? 128 : 0)), e <= 127 || ((this.buf[this.pos++] = (127 & (e >>>= 7)) | (e > 127 ? 128 : 0)), e <= 127 || (this.buf[this.pos++] = (e >>> 7) & 127))));
        },
        writeSVarint: function (e) {
          this.writeVarint(e < 0 ? 2 * -e - 1 : 2 * e);
        },
        writeBoolean: function (e) {
          this.writeVarint(!!e);
        },
        writeString: function (e) {
          (e = String(e)), this.realloc(4 * e.length), this.pos++;
          var t = this.pos;
          this.pos = (function (r, n, o) {
            for (var s, a, l = 0; l < n.length; l++) {
              if ((s = n.charCodeAt(l)) > 55295 && s < 57344) {
                if (!a) {
                  s > 56319 || l + 1 === n.length ? ((r[o++] = 239), (r[o++] = 191), (r[o++] = 189)) : (a = s);
                  continue;
                }
                if (s < 56320) {
                  (r[o++] = 239), (r[o++] = 191), (r[o++] = 189), (a = s);
                  continue;
                }
                (s = ((a - 55296) << 10) | (s - 56320) | 65536), (a = null);
              } else a && ((r[o++] = 239), (r[o++] = 191), (r[o++] = 189), (a = null));
              s < 128 ? (r[o++] = s) : (s < 2048 ? (r[o++] = (s >> 6) | 192) : (s < 65536 ? (r[o++] = (s >> 12) | 224) : ((r[o++] = (s >> 18) | 240), (r[o++] = ((s >> 12) & 63) | 128)), (r[o++] = ((s >> 6) & 63) | 128)), (r[o++] = (63 & s) | 128));
            }
            return o;
          })(this.buf, e, this.pos);
          var i = this.pos - t;
          i >= 128 && Vx(t, i, this), (this.pos = t - 1), this.writeVarint(i), (this.pos += i);
        },
        writeFloat: function (e) {
          this.realloc(4), Iu.write(this.buf, e, this.pos, !0, 23, 4), (this.pos += 4);
        },
        writeDouble: function (e) {
          this.realloc(8), Iu.write(this.buf, e, this.pos, !0, 52, 8), (this.pos += 8);
        },
        writeBytes: function (e) {
          var t = e.length;
          this.writeVarint(t), this.realloc(t);
          for (var i = 0; i < t; i++) this.buf[this.pos++] = e[i];
        },
        writeRawMessage: function (e, t) {
          this.pos++;
          var i = this.pos;
          e(t, this);
          var r = this.pos - i;
          r >= 128 && Vx(i, r, this), (this.pos = i - 1), this.writeVarint(r), (this.pos += r);
        },
        writeMessage: function (e, t, i) {
          this.writeTag(e, hi.Bytes), this.writeRawMessage(t, i);
        },
        writePackedVarint: function (e, t) {
          t.length && this.writeMessage(e, aA, t);
        },
        writePackedSVarint: function (e, t) {
          t.length && this.writeMessage(e, lA, t);
        },
        writePackedBoolean: function (e, t) {
          t.length && this.writeMessage(e, hA, t);
        },
        writePackedFloat: function (e, t) {
          t.length && this.writeMessage(e, cA, t);
        },
        writePackedDouble: function (e, t) {
          t.length && this.writeMessage(e, uA, t);
        },
        writePackedFixed32: function (e, t) {
          t.length && this.writeMessage(e, dA, t);
        },
        writePackedSFixed32: function (e, t) {
          t.length && this.writeMessage(e, fA, t);
        },
        writePackedFixed64: function (e, t) {
          t.length && this.writeMessage(e, pA, t);
        },
        writePackedSFixed64: function (e, t) {
          t.length && this.writeMessage(e, mA, t);
        },
        writeBytesField: function (e, t) {
          this.writeTag(e, hi.Bytes), this.writeBytes(t);
        },
        writeFixed32Field: function (e, t) {
          this.writeTag(e, hi.Fixed32), this.writeFixed32(t);
        },
        writeSFixed32Field: function (e, t) {
          this.writeTag(e, hi.Fixed32), this.writeSFixed32(t);
        },
        writeFixed64Field: function (e, t) {
          this.writeTag(e, hi.Fixed64), this.writeFixed64(t);
        },
        writeSFixed64Field: function (e, t) {
          this.writeTag(e, hi.Fixed64), this.writeSFixed64(t);
        },
        writeVarintField: function (e, t) {
          this.writeTag(e, hi.Varint), this.writeVarint(t);
        },
        writeSVarintField: function (e, t) {
          this.writeTag(e, hi.Varint), this.writeSVarint(t);
        },
        writeStringField: function (e, t) {
          this.writeTag(e, hi.Bytes), this.writeString(t);
        },
        writeFloatField: function (e, t) {
          this.writeTag(e, hi.Fixed32), this.writeFloat(t);
        },
        writeDoubleField: function (e, t) {
          this.writeTag(e, hi.Fixed64), this.writeDouble(t);
        },
        writeBooleanField: function (e, t) {
          this.writeVarintField(e, !!t);
        },
      };
      var Pu = ze(Fx);
      const _A = ['tile', 'layer', 'source', 'sourceLayer', 'state'];
      class Gx {
        constructor(t, i, r, n, o) {
          (this.type = 'Feature'), (this._vectorTileFeature = t), (this._z = i), (this._x = r), (this._y = n), (this.properties = t.properties), (this.id = o);
        }
        get geometry() {
          return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry), this._geometry;
        }
        set geometry(t) {
          this._geometry = t;
        }
        toJSON() {
          const t = { type: 'Feature', state: void 0, geometry: this.geometry, properties: this.properties };
          this.id !== void 0 && (t.id = this.id);
          for (const i of _A) this[i] !== void 0 && (t[i] = this[i]);
          return t;
        }
      }
      class gA {
        constructor() {
          (this.state = {}), (this.stateChanges = {}), (this.deletedStates = {});
        }
        updateState(t, i, r) {
          const n = String(i);
          if (((this.stateChanges[t] = this.stateChanges[t] || {}), (this.stateChanges[t][n] = this.stateChanges[t][n] || {}), Ft(this.stateChanges[t][n], r), this.deletedStates[t] === null)) {
            this.deletedStates[t] = {};
            for (const o in this.state[t]) o !== n && (this.deletedStates[t][o] = null);
          } else if (this.deletedStates[t] && this.deletedStates[t][n] === null) {
            this.deletedStates[t][n] = {};
            for (const o in this.state[t][n]) r[o] || (this.deletedStates[t][n][o] = null);
          } else for (const o in r) this.deletedStates[t] && this.deletedStates[t][n] && this.deletedStates[t][n][o] === null && delete this.deletedStates[t][n][o];
        }
        removeFeatureState(t, i, r) {
          if (this.deletedStates[t] === null) return;
          const n = String(i);
          if (((this.deletedStates[t] = this.deletedStates[t] || {}), r && i !== void 0)) this.deletedStates[t][n] !== null && ((this.deletedStates[t][n] = this.deletedStates[t][n] || {}), (this.deletedStates[t][n][r] = null));
          else if (i !== void 0)
            if (this.stateChanges[t] && this.stateChanges[t][n]) for (r in ((this.deletedStates[t][n] = {}), this.stateChanges[t][n])) this.deletedStates[t][n][r] = null;
            else this.deletedStates[t][n] = null;
          else this.deletedStates[t] = null;
        }
        getState(t, i) {
          const r = String(i),
            n = Ft({}, (this.state[t] || {})[r], (this.stateChanges[t] || {})[r]);
          if (this.deletedStates[t] === null) return {};
          if (this.deletedStates[t]) {
            const o = this.deletedStates[t][i];
            if (o === null) return {};
            for (const s in o) delete n[s];
          }
          return n;
        }
        initializeTileState(t, i) {
          t.setFeatureState(this.state, i);
        }
        coalesceChanges(t, i) {
          const r = {};
          for (const n in this.stateChanges) {
            this.state[n] = this.state[n] || {};
            const o = {};
            for (const s in this.stateChanges[n]) this.state[n][s] || (this.state[n][s] = {}), Ft(this.state[n][s], this.stateChanges[n][s]), (o[s] = this.state[n][s]);
            r[n] = o;
          }
          for (const n in this.deletedStates) {
            this.state[n] = this.state[n] || {};
            const o = {};
            if (this.deletedStates[n] === null) for (const s in this.state[n]) (o[s] = {}), (this.state[n][s] = {});
            else
              for (const s in this.deletedStates[n]) {
                if (this.deletedStates[n][s] === null) this.state[n][s] = {};
                else if (this.state[n][s]) for (const a of Object.keys(this.deletedStates[n][s])) delete this.state[n][s][a];
                o[s] = this.state[n][s];
              }
            (r[n] = r[n] || {}), Ft(r[n], o);
          }
          if (((this.stateChanges = {}), (this.deletedStates = {}), Object.keys(r).length !== 0)) for (const n in t) t[n].setFeatureState(r, i);
        }
      }
      class qx {
        constructor(t) {
          (this.size = t), (this.minimums = []), (this.maximums = []), (this.leaves = []);
        }
        getElevation(t, i) {
          const r = this.toIdx(t, i);
          return { min: this.minimums[r], max: this.maximums[r] };
        }
        isLeaf(t, i) {
          return this.leaves[this.toIdx(t, i)];
        }
        toIdx(t, i) {
          return i * this.size + t;
        }
      }
      function Zx(e, t, i, r) {
        let n = 0,
          o = Number.MAX_VALUE;
        for (let s = 0; s < 3; s++)
          if (Math.abs(r[s]) < 1e-15) {
            if (i[s] < e[s] || i[s] > t[s]) return null;
          } else {
            const a = 1 / r[s];
            let l = (e[s] - i[s]) * a,
              c = (t[s] - i[s]) * a;
            if (l > c) {
              const u = l;
              (l = c), (c = u);
            }
            if ((l > n && (n = l), c < o && (o = c), n > o)) return null;
          }
        return n;
      }
      function $x(e, t, i, r, n, o, s, a, l, c, u) {
        const h = r - e,
          d = n - t,
          f = o - i,
          p = s - e,
          _ = a - t,
          g = l - i,
          y = u[1] * g - u[2] * _,
          v = u[2] * p - u[0] * g,
          w = u[0] * _ - u[1] * p,
          T = h * y + d * v + f * w;
        if (Math.abs(T) < 1e-15) return null;
        const b = 1 / T,
          E = c[0] - e,
          S = c[1] - t,
          I = c[2] - i,
          C = (E * y + S * v + I * w) * b;
        if (C < 0 || C > 1) return null;
        const z = S * f - I * d,
          k = I * h - E * f,
          O = E * d - S * h,
          V = (u[0] * z + u[1] * k + u[2] * O) * b;
        return V < 0 || C + V > 1 ? null : (p * z + _ * k + g * O) * b;
      }
      function Hx(e, t, i) {
        return (e - t) / (i - t);
      }
      function Wx(e, t, i, r, n, o, s, a, l) {
        const c = 1 << i,
          u = o - r,
          h = s - n,
          d = ((e + 1) / c) * u + r,
          f = ((t + 0) / c) * h + n,
          p = ((t + 1) / c) * h + n;
        (a[0] = ((e + 0) / c) * u + r), (a[1] = f), (l[0] = d), (l[1] = p);
      }
      class Xx {
        constructor(t) {
          if (
            ((this.maximums = []),
            (this.minimums = []),
            (this.leaves = []),
            (this.childOffsets = []),
            (this.nodeCount = 0),
            (this.dem = t),
            (this._siblingOffset = [
              [0, 0],
              [1, 0],
              [0, 1],
              [1, 1],
            ]),
            !this.dem)
          )
            return;
          const i = (function (o) {
              const s = Math.ceil(Math.log2(o.dim / 8)),
                a = [];
              let l = Math.ceil(Math.pow(2, s));
              const c = 1 / l,
                u = (f, p, _, g, y) => {
                  const v = g ? 1 : 0,
                    w = (f + 1) * _ - v,
                    T = p * _,
                    b = (p + 1) * _ - v;
                  (y[0] = f * _), (y[1] = T), (y[2] = w), (y[3] = b);
                };
              let h = new qx(l);
              const d = [];
              for (let f = 0; f < l * l; f++) {
                u(f % l, Math.floor(f / l), c, !1, d);
                const p = jo(d[0], d[1], o),
                  _ = jo(d[2], d[1], o),
                  g = jo(d[2], d[3], o),
                  y = jo(d[0], d[3], o);
                h.minimums.push(Math.min(p, _, g, y)), h.maximums.push(Math.max(p, _, g, y)), h.leaves.push(1);
              }
              for (a.push(h), l /= 2; l >= 1; l /= 2) {
                const f = a[a.length - 1];
                h = new qx(l);
                for (let p = 0; p < l * l; p++) {
                  u(p % l, Math.floor(p / l), 2, !0, d);
                  const _ = f.getElevation(d[0], d[1]),
                    g = f.getElevation(d[2], d[1]),
                    y = f.getElevation(d[2], d[3]),
                    v = f.getElevation(d[0], d[3]),
                    w = f.isLeaf(d[0], d[1]),
                    T = f.isLeaf(d[2], d[1]),
                    b = f.isLeaf(d[2], d[3]),
                    E = f.isLeaf(d[0], d[3]),
                    S = Math.min(_.min, g.min, y.min, v.min),
                    I = Math.max(_.max, g.max, y.max, v.max),
                    C = w && T && b && E;
                  h.maximums.push(I), h.minimums.push(S), h.leaves.push(I - S <= 5 && C ? 1 : 0);
                }
                a.push(h);
              }
              return a;
            })(this.dem),
            r = i.length - 1,
            n = i[r];
          this._addNode(n.minimums[0], n.maximums[0], n.leaves[0]), this._construct(i, 0, 0, r, 0);
        }
        raycastRoot(t, i, r, n, o, s, a = 1) {
          return Zx([t, i, -100], [r, n, this.maximums[0] * a], o, s);
        }
        raycast(t, i, r, n, o, s, a = 1) {
          if (!this.nodeCount) return null;
          const l = this.raycastRoot(t, i, r, n, o, s, a);
          if (l == null) return null;
          const c = [],
            u = [],
            h = [],
            d = [],
            f = [{ idx: 0, t: l, nodex: 0, nodey: 0, depth: 0 }];
          for (; f.length > 0; ) {
            const { idx: p, t: _, nodex: g, nodey: y, depth: v } = f.pop();
            if (this.leaves[p]) {
              Wx(g, y, v, t, i, r, n, h, d);
              const T = 1 << v,
                b = (g + 0) / T,
                E = (g + 1) / T,
                S = (y + 0) / T,
                I = (y + 1) / T,
                C = jo(b, S, this.dem) * a,
                z = jo(E, S, this.dem) * a,
                k = jo(E, I, this.dem) * a,
                O = jo(b, I, this.dem) * a,
                V = $x(h[0], h[1], C, d[0], h[1], z, d[0], d[1], k, o, s),
                R = $x(d[0], d[1], k, h[0], d[1], O, h[0], h[1], C, o, s),
                G = Math.min(V !== null ? V : Number.MAX_VALUE, R !== null ? R : Number.MAX_VALUE);
              if (G !== Number.MAX_VALUE) return G;
              {
                const Z = N.scaleAndAdd([], o, s, _);
                if (Yx(C, z, O, k, Hx(Z[0], h[0], d[0]), Hx(Z[1], h[1], d[1])) >= Z[2]) return _;
              }
              continue;
            }
            let w = 0;
            for (let T = 0; T < this._siblingOffset.length; T++) {
              Wx((g << 1) + this._siblingOffset[T][0], (y << 1) + this._siblingOffset[T][1], v + 1, t, i, r, n, h, d), (h[2] = -100), (d[2] = this.maximums[this.childOffsets[p] + T] * a);
              const b = Zx(h, d, o, s);
              if (b != null) {
                const E = b;
                c[T] = E;
                let S = !1;
                for (let I = 0; I < w && !S; I++) E >= c[u[I]] && (u.splice(I, 0, T), (S = !0));
                S || (u[w] = T), w++;
              }
            }
            for (let T = 0; T < w; T++) {
              const b = u[T];
              f.push({ idx: this.childOffsets[p] + b, t: c[b], nodex: (g << 1) + this._siblingOffset[b][0], nodey: (y << 1) + this._siblingOffset[b][1], depth: v + 1 });
            }
          }
          return null;
        }
        _addNode(t, i, r) {
          return this.minimums.push(t), this.maximums.push(i), this.leaves.push(r), this.childOffsets.push(0), this.nodeCount++;
        }
        _construct(t, i, r, n, o) {
          if (t[n].isLeaf(i, r) === 1) return;
          this.childOffsets[o] || (this.childOffsets[o] = this.nodeCount);
          const s = n - 1,
            a = t[s];
          let l = 0,
            c = 0;
          for (let u = 0; u < this._siblingOffset.length; u++) {
            const h = 2 * i + this._siblingOffset[u][0],
              d = 2 * r + this._siblingOffset[u][1],
              f = a.getElevation(h, d),
              p = a.isLeaf(h, d),
              _ = this._addNode(f.min, f.max, p);
            p && (l |= 1 << u), c || (c = _);
          }
          for (let u = 0; u < this._siblingOffset.length; u++) l & (1 << u) || this._construct(t, 2 * i + this._siblingOffset[u][0], 2 * r + this._siblingOffset[u][1], s, c + u);
        }
      }
      function Yx(e, t, i, r, n, o) {
        return ee(ee(e, i, o), ee(t, r, o), n);
      }
      function jo(e, t, i) {
        const r = i.dim,
          n = Bt(e * r - 0.5, 0, r - 1),
          o = Bt(t * r - 0.5, 0, r - 1),
          s = Math.floor(n),
          a = Math.floor(o),
          l = Math.min(s + 1, r - 1),
          c = Math.min(a + 1, r - 1);
        return Yx(i.get(s, a), i.get(l, a), i.get(s, c), i.get(l, c), n - s, o - a);
      }
      const yA = { mapbox: [6553.6, 25.6, 0.1, 1e4], terrarium: [256, 1, 1 / 256, 32768] };
      function xA(e, t, i) {
        return (256 * e * 256 + 256 * t + i) / 10 - 1e4;
      }
      function vA(e, t, i) {
        return 256 * e + t + i / 256 - 32768;
      }
      class zu {
        get tree() {
          return this._tree || this._buildQuadTree(), this._tree;
        }
        constructor(t, i, r, n = !1) {
          if (((this.uid = t), i.height !== i.width)) throw new RangeError('DEM tiles must be square');
          if (r && r !== 'mapbox' && r !== 'terrarium') return B(`"${r}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
          this.stride = i.height;
          const o = (this.dim = i.height - 2),
            s = new Uint32Array(i.data.buffer);
          if (((this.pixels = new Uint8Array(i.data.buffer)), (this.floatView = new Float32Array(i.data.buffer)), (this.borderReady = n), (this._modifiedForSources = {}), !n)) {
            for (let l = 0; l < o; l++) (s[this._idx(-1, l)] = s[this._idx(0, l)]), (s[this._idx(o, l)] = s[this._idx(o - 1, l)]), (s[this._idx(l, -1)] = s[this._idx(l, 0)]), (s[this._idx(l, o)] = s[this._idx(l, o - 1)]);
            (s[this._idx(-1, -1)] = s[this._idx(0, 0)]), (s[this._idx(o, -1)] = s[this._idx(o - 1, 0)]), (s[this._idx(-1, o)] = s[this._idx(0, o - 1)]), (s[this._idx(o, o)] = s[this._idx(o - 1, o - 1)]);
          }
          const a = r === 'terrarium' ? vA : xA;
          for (let l = 0; l < s.length; ++l) {
            const c = 4 * l;
            this.floatView[l] = a(this.pixels[c], this.pixels[c + 1], this.pixels[c + 2]);
          }
          this._timestamp = oe.now();
        }
        _buildQuadTree() {
          this._tree = new Xx(this);
        }
        get(t, i, r = !1) {
          r && ((t = Bt(t, -1, this.dim)), (i = Bt(i, -1, this.dim)));
          const n = this._idx(t, i);
          return this.floatView[n];
        }
        set(t, i, r) {
          const n = this._idx(t, i),
            o = this.floatView[n];
          return (this.floatView[n] = r), r - o;
        }
        static getUnpackVector(t) {
          return yA[t];
        }
        _idx(t, i) {
          if (t < -1 || t >= this.dim + 1 || i < -1 || i >= this.dim + 1) throw new RangeError('out of range source coordinates for DEM data');
          return (i + 1) * this.stride + (t + 1);
        }
        static pack(t, i) {
          const r = [0, 0, 0, 0],
            n = zu.getUnpackVector(i);
          let o = Math.floor((t + n[3]) / n[2]);
          return (r[2] = o % 256), (o = Math.floor(o / 256)), (r[1] = o % 256), (o = Math.floor(o / 256)), (r[0] = o), r;
        }
        getPixels() {
          return new Cx({ width: this.stride, height: this.stride }, this.pixels);
        }
        backfillBorder(t, i, r) {
          if (this.dim !== t.dim) throw new Error('dem dimension mismatch');
          let n = i * this.dim,
            o = i * this.dim + this.dim,
            s = r * this.dim,
            a = r * this.dim + this.dim;
          switch (i) {
            case -1:
              n = o - 1;
              break;
            case 1:
              o = n + 1;
          }
          switch (r) {
            case -1:
              s = a - 1;
              break;
            case 1:
              a = s + 1;
          }
          const l = -i * this.dim,
            c = -r * this.dim;
          for (let u = s; u < a; u++)
            for (let h = n; h < o; h++) {
              const d = 4 * this._idx(h, u),
                f = 4 * this._idx(h + l, u + c);
              (this.pixels[d + 0] = t.pixels[f + 0]), (this.pixels[d + 1] = t.pixels[f + 1]), (this.pixels[d + 2] = t.pixels[f + 2]), (this.pixels[d + 3] = t.pixels[f + 3]);
            }
        }
        onDeserialize() {
          this._tree && (this._tree.dem = this);
        }
      }
      Gt(zu, 'DEMData'), Gt(Xx, 'DemMinMaxQuadTree', { omit: ['dem'] });
      class bA {
        isDataAvailableAtPoint(t) {
          const i = this._source();
          if (this.isUsingMockSource() || !i || t.y < 0 || t.y > 1) return !1;
          const r = i.getSource().maxzoom,
            n = 1 << r,
            o = Math.floor(t.x),
            s = Math.floor((t.x - o) * n),
            a = Math.floor(t.y * n),
            l = this.findDEMTileFor(new Le(r, o, r, s, a));
          return !(!l || !l.dem);
        }
        getAtPointOrZero(t, i = 0) {
          return this.getAtPoint(t, i) || 0;
        }
        getAtPoint(t, i, r = !0) {
          if (this.isUsingMockSource()) return null;
          i == null && (i = null);
          const n = this._source();
          if (!n || t.y < 0 || t.y > 1) return i;
          const o = n.getSource().maxzoom,
            s = 1 << o,
            a = Math.floor(t.x),
            l = t.x - a,
            c = new Le(o, a, o, Math.floor(l * s), Math.floor(t.y * s)),
            u = this.findDEMTileFor(c);
          if (!u || !u.dem) return i;
          const h = u.dem,
            d = 1 << u.tileID.canonical.z,
            f = (l * d - u.tileID.canonical.x) * h.dim,
            p = (t.y * d - u.tileID.canonical.y) * h.dim,
            _ = Math.floor(f),
            g = Math.floor(p);
          return (r ? this.exaggeration() : 1) * ee(ee(h.get(_, g), h.get(_, g + 1), p - g), ee(h.get(_ + 1, g), h.get(_ + 1, g + 1), p - g), f - _);
        }
        getAtTileOffset(t, i, r) {
          const n = 1 << t.canonical.z;
          return this.getAtPointOrZero(new Me(t.wrap + (t.canonical.x + i / lt) / n, (t.canonical.y + r / lt) / n));
        }
        getAtTileOffsetFunc(t, i, r, n) {
          return (o) => {
            const s = this.getAtTileOffset(t, o.x, o.y),
              a = n.upVector(t.canonical, o.x, o.y),
              l = n.upVectorScale(t.canonical, i, r).metersToTile;
            return N.scale(a, a, s * l), a;
          };
        }
        getForTilePoints(t, i, r, n) {
          if (this.isUsingMockSource()) return !1;
          const o = Ma.create(this, t, n);
          return (
            !!o &&
            (i.forEach((s) => {
              s[2] = this.exaggeration() * o.getElevationAt(s[0], s[1], r);
            }),
            !0)
          );
        }
        getMinMaxForTile(t) {
          if (this.isUsingMockSource()) return null;
          const i = this.findDEMTileFor(t);
          if (!i || !i.dem) return null;
          const r = i.dem.tree,
            n = i.tileID,
            o = 1 << (t.canonical.z - n.canonical.z);
          let s = t.canonical.x / o - n.canonical.x,
            a = t.canonical.y / o - n.canonical.y,
            l = 0;
          for (let c = 0; c < t.canonical.z - n.canonical.z && !r.leaves[l]; c++) {
            (s *= 2), (a *= 2);
            const u = 2 * Math.floor(a) + Math.floor(s);
            (l = r.childOffsets[l] + u), (s %= 1), (a %= 1);
          }
          return { min: this.exaggeration() * r.minimums[l], max: this.exaggeration() * r.maximums[l] };
        }
        getMinElevationBelowMSL() {
          throw new Error('Pure virtual method called.');
        }
        raycast(t, i, r) {
          throw new Error('Pure virtual method called.');
        }
        pointCoordinate(t) {
          throw new Error('Pure virtual method called.');
        }
        _source() {
          throw new Error('Pure virtual method called.');
        }
        isUsingMockSource() {
          throw new Error('Pure virtual method called.');
        }
        exaggeration() {
          throw new Error('Pure virtual method called.');
        }
        findDEMTileFor(t) {
          throw new Error('Pure virtual method called.');
        }
        get visibleDemTiles() {
          throw new Error('Getter must be implemented in subclass.');
        }
        getMinMaxForVisibleTiles() {
          const t = this.visibleDemTiles;
          if (t.length === 0) return null;
          let i = !1,
            r = Number.MAX_VALUE,
            n = Number.MIN_VALUE;
          for (const o of t) {
            const s = this.getMinMaxForTile(o.tileID);
            s && ((r = Math.min(r, s.min)), (n = Math.max(n, s.max)), (i = !0));
          }
          return i ? { min: r, max: n } : null;
        }
      }
      class Ma {
        constructor(t, i, r) {
          (this._demTile = t), (this._dem = this._demTile.dem), (this._scale = i), (this._offset = r);
        }
        static create(t, i, r) {
          const n = r || t.findDEMTileFor(i);
          if (!n || !n.dem) return;
          const o = n.dem,
            s = n.tileID,
            a = 1 << (i.canonical.z - s.canonical.z);
          return new Ma(n, o.dim / lt / a, [(i.canonical.x / a - s.canonical.x) * o.dim, (i.canonical.y / a - s.canonical.y) * o.dim]);
        }
        tileCoordToPixel(t, i) {
          const r = i * this._scale + this._offset[1],
            n = Math.floor(t * this._scale + this._offset[0]),
            o = Math.floor(r);
          return new H(n, o);
        }
        getElevationAt(t, i, r, n) {
          const o = t * this._scale + this._offset[0],
            s = i * this._scale + this._offset[1],
            a = Math.floor(o),
            l = Math.floor(s),
            c = this._dem;
          return (n = !!n), r ? ee(ee(c.get(a, l, n), c.get(a, l + 1, n), s - l), ee(c.get(a + 1, l, n), c.get(a + 1, l + 1, n), s - l), o - a) : c.get(a, l, n);
        }
        getElevationAtPixel(t, i, r) {
          return this._dem.get(t, i, !!r);
        }
        getMeterToDEM(t) {
          return (1 << this._demTile.tileID.canonical.z) * Je(1, t) * this._dem.stride;
        }
      }
      class Lp {
        constructor(t, i) {
          (this.tileID = t), (this.x = t.canonical.x), (this.y = t.canonical.y), (this.z = t.canonical.z), (this.grid = new ca(lt, 16, 0)), (this.featureIndexArray = new Sy()), (this.promoteId = i);
        }
        insert(t, i, r, n, o, s = 0) {
          const a = this.featureIndexArray.length;
          this.featureIndexArray.emplaceBack(r, n, o, s);
          const l = this.grid;
          for (let c = 0; c < i.length; c++) {
            const u = i[c],
              h = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (let d = 0; d < u.length; d++) {
              const f = u[d];
              (h[0] = Math.min(h[0], f.x)), (h[1] = Math.min(h[1], f.y)), (h[2] = Math.max(h[2], f.x)), (h[3] = Math.max(h[3], f.y));
            }
            h[0] < lt && h[1] < lt && h[2] >= 0 && h[3] >= 0 && l.insert(a, h[0], h[1], h[2], h[3]);
          }
        }
        loadVTLayers() {
          if (!this.vtLayers) {
            (this.vtLayers = new Dp(new Pu(this.rawTileData)).layers), (this.sourceLayerCoder = new Bx(this.vtLayers ? Object.keys(this.vtLayers).sort() : ['_geojsonTileLayer'])), (this.vtFeatures = {});
            for (const t in this.vtLayers) this.vtFeatures[t] = [];
          }
          return this.vtLayers;
        }
        query(t, i, r, n) {
          this.loadVTLayers();
          const o = t.params || {},
            s = Gc(o.filter),
            a = t.tileResult,
            l = t.transform,
            c = a.bufferedTilespaceBounds,
            u = this.grid.query(c.min.x, c.min.y, c.max.x, c.max.y, (p, _, g, y) => vx(a.bufferedTilespaceGeometry, p, _, g, y));
          u.sort(wA);
          let h = null;
          l.elevation && u.length > 0 && (h = Ma.create(l.elevation, this.tileID));
          const d = {};
          let f;
          for (let p = 0; p < u.length; p++) {
            const _ = u[p];
            if (_ === f) continue;
            f = _;
            const g = this.featureIndexArray.get(_);
            let y = null;
            this.loadMatchingFeature(d, g, s, o.layers, o.availableImages, i, r, n, (v, w, T, b = 0) => (y || (y = On(v, this.tileID.canonical, t.tileTransform)), w.queryIntersectsFeature(a, v, T, y, this.z, t.transform, t.pixelPosMatrix, h, b)));
          }
          return d;
        }
        loadMatchingFeature(t, i, r, n, o, s, a, l, c) {
          const { featureIndex: u, bucketIndex: h, sourceLayerIndex: d, layoutVertexArrayOffset: f } = i,
            p = this.bucketLayerIDs[h];
          if (
            n &&
            !(function (v, w) {
              for (let T = 0; T < v.length; T++) if (w.indexOf(v[T]) >= 0) return !0;
              return !1;
            })(n, p)
          )
            return;
          const _ = this.sourceLayerCoder.decode(d),
            g = this.vtLayers[_].feature(u);
          if (r.needGeometry) {
            const v = Uo(g, !0);
            if (!r.filter(new gi(this.tileID.overscaledZ), v, this.tileID.canonical)) return;
          } else if (!r.filter(new gi(this.tileID.overscaledZ), g)) return;
          const y = this.getId(g, _);
          for (let v = 0; v < p.length; v++) {
            const w = p[v];
            if (n && n.indexOf(w) < 0) continue;
            const T = s[w];
            if (!T) continue;
            let b = {};
            y !== void 0 && l && (b = l.getState(T.sourceLayer || '_geojsonTileLayer', y));
            const E = Ft({}, a[w]);
            (E.paint = Kx(E.paint, T.paint, g, b, o)), (E.layout = Kx(E.layout, T.layout, g, b, o));
            const S = !c || c(g, T, b, f);
            if (!S) continue;
            const I = new Gx(g, this.z, this.x, this.y, y);
            I.layer = E;
            let C = t[w];
            C === void 0 && (C = t[w] = []), C.push({ featureIndex: u, feature: I, intersectionZ: S });
          }
        }
        lookupSymbolFeatures(t, i, r, n, o, s, a, l) {
          const c = {};
          this.loadVTLayers();
          const u = Gc(o);
          for (const h of t) this.loadMatchingFeature(c, { bucketIndex: r, sourceLayerIndex: n, featureIndex: h, layoutVertexArrayOffset: 0 }, u, s, a, l, i);
          return c;
        }
        loadFeature(t) {
          const { featureIndex: i, sourceLayerIndex: r } = t;
          this.loadVTLayers();
          const n = this.sourceLayerCoder.decode(r),
            o = this.vtFeatures[n];
          if (o[i]) return o[i];
          const s = this.vtLayers[n].feature(i);
          return (o[i] = s), s;
        }
        hasLayer(t) {
          for (const i of this.bucketLayerIDs) for (const r of i) if (t === r) return !0;
          return !1;
        }
        getId(t, i) {
          let r = t.id;
          if (this.promoteId) {
            const n = typeof this.promoteId == 'string' ? this.promoteId : this.promoteId[i];
            n != null && (r = t.properties[n]), typeof r == 'boolean' && (r = Number(r));
          }
          return r;
        }
      }
      function Kx(e, t, i, r, n) {
        return zt(e, (o, s) => {
          const a = t instanceof gl ? t.get(s) : null;
          return a && a.evaluate ? a.evaluate(i, r, n) : a;
        });
      }
      function wA(e, t) {
        return t - e;
      }
      Gt(Lp, 'FeatureIndex', { omit: ['rawTileData', 'sourceLayerCoder'] });
      const TA = Ne(
          [
            { name: 'a_pos_offset', components: 4, type: 'Int16' },
            { name: 'a_tex_size', components: 4, type: 'Uint16' },
            { name: 'a_pixeloffset', components: 4, type: 'Int16' },
          ],
          4
        ),
        EA = Ne(
          [
            { name: 'a_globe_anchor', components: 3, type: 'Int16' },
            { name: 'a_globe_normal', components: 3, type: 'Float32' },
          ],
          4
        ),
        MA = Ne([{ name: 'a_projected_pos', components: 4, type: 'Float32' }], 4);
      Ne([{ name: 'a_fade_opacity', components: 1, type: 'Uint32' }], 4);
      const SA = Ne([{ name: 'a_z_offset', components: 1, type: 'Float32' }], 4),
        AA = Ne([{ name: 'a_texb', components: 2, type: 'Uint16' }]),
        IA = Ne([
          { name: 'a_placed', components: 2, type: 'Uint8' },
          { name: 'a_shift', components: 2, type: 'Float32' },
        ]),
        CA = Ne([
          { name: 'a_size_scale', components: 1, type: 'Float32' },
          { name: 'a_padding', components: 2, type: 'Float32' },
          { name: 'a_z_offset', components: 1, type: 'Float32' },
        ]);
      Ne([
        { type: 'Int16', name: 'projectedAnchorX' },
        { type: 'Int16', name: 'projectedAnchorY' },
        { type: 'Int16', name: 'projectedAnchorZ' },
        { type: 'Int16', name: 'tileAnchorX' },
        { type: 'Int16', name: 'tileAnchorY' },
        { type: 'Float32', name: 'x1' },
        { type: 'Float32', name: 'y1' },
        { type: 'Float32', name: 'x2' },
        { type: 'Float32', name: 'y2' },
        { type: 'Int16', name: 'padding' },
        { type: 'Uint32', name: 'featureIndex' },
        { type: 'Uint16', name: 'sourceLayerIndex' },
        { type: 'Uint16', name: 'bucketIndex' },
      ]);
      const Jx = Ne(
          [
            { name: 'a_pos', components: 3, type: 'Int16' },
            { name: 'a_anchor_pos', components: 2, type: 'Int16' },
            { name: 'a_extrude', components: 2, type: 'Int16' },
          ],
          4
        ),
        PA = Ne(
          [
            { name: 'a_pos_2f', components: 2, type: 'Float32' },
            { name: 'a_radius', components: 1, type: 'Float32' },
            { name: 'a_flags', components: 2, type: 'Int16' },
          ],
          4
        );
      Ne([{ name: 'triangle', components: 3, type: 'Uint16' }]),
        Ne([
          { type: 'Int16', name: 'projectedAnchorX' },
          { type: 'Int16', name: 'projectedAnchorY' },
          { type: 'Int16', name: 'projectedAnchorZ' },
          { type: 'Float32', name: 'tileAnchorX' },
          { type: 'Float32', name: 'tileAnchorY' },
          { type: 'Uint16', name: 'glyphStartIndex' },
          { type: 'Uint16', name: 'numGlyphs' },
          { type: 'Uint32', name: 'vertexStartIndex' },
          { type: 'Uint32', name: 'lineStartIndex' },
          { type: 'Uint32', name: 'lineLength' },
          { type: 'Uint16', name: 'segment' },
          { type: 'Uint16', name: 'lowerSize' },
          { type: 'Uint16', name: 'upperSize' },
          { type: 'Float32', name: 'lineOffsetX' },
          { type: 'Float32', name: 'lineOffsetY' },
          { type: 'Uint8', name: 'writingMode' },
          { type: 'Uint8', name: 'placedOrientation' },
          { type: 'Uint8', name: 'hidden' },
          { type: 'Uint32', name: 'crossTileID' },
          { type: 'Int16', name: 'associatedIconIndex' },
          { type: 'Uint8', name: 'flipState' },
        ]),
        Ne([
          { type: 'Float32', name: 'tileAnchorX' },
          { type: 'Float32', name: 'tileAnchorY' },
          { type: 'Int16', name: 'projectedAnchorX' },
          { type: 'Int16', name: 'projectedAnchorY' },
          { type: 'Int16', name: 'projectedAnchorZ' },
          { type: 'Int16', name: 'rightJustifiedTextSymbolIndex' },
          { type: 'Int16', name: 'centerJustifiedTextSymbolIndex' },
          { type: 'Int16', name: 'leftJustifiedTextSymbolIndex' },
          { type: 'Int16', name: 'verticalPlacedTextSymbolIndex' },
          { type: 'Int16', name: 'placedIconSymbolIndex' },
          { type: 'Int16', name: 'verticalPlacedIconSymbolIndex' },
          { type: 'Uint16', name: 'key' },
          { type: 'Uint16', name: 'textBoxStartIndex' },
          { type: 'Uint16', name: 'textBoxEndIndex' },
          { type: 'Uint16', name: 'verticalTextBoxStartIndex' },
          { type: 'Uint16', name: 'verticalTextBoxEndIndex' },
          { type: 'Uint16', name: 'iconBoxStartIndex' },
          { type: 'Uint16', name: 'iconBoxEndIndex' },
          { type: 'Uint16', name: 'verticalIconBoxStartIndex' },
          { type: 'Uint16', name: 'verticalIconBoxEndIndex' },
          { type: 'Uint16', name: 'featureIndex' },
          { type: 'Uint16', name: 'numHorizontalGlyphVertices' },
          { type: 'Uint16', name: 'numVerticalGlyphVertices' },
          { type: 'Uint16', name: 'numIconVertices' },
          { type: 'Uint16', name: 'numVerticalIconVertices' },
          { type: 'Uint16', name: 'useRuntimeCollisionCircles' },
          { type: 'Uint32', name: 'crossTileID' },
          { type: 'Float32', components: 2, name: 'textOffset' },
          { type: 'Float32', name: 'collisionCircleDiameter' },
          { type: 'Float32', name: 'zOffset' },
          { type: 'Uint8', name: 'hasIconTextFit' },
        ]),
        Ne([{ type: 'Float32', name: 'offsetX' }]),
        Ne([
          { type: 'Int16', name: 'x' },
          { type: 'Int16', name: 'y' },
        ]);
      var Qi = 24;
      const vn = 128;
      function kp(e, t) {
        const { expression: i } = t;
        if (i.kind === 'constant') return { kind: 'constant', layoutSize: i.evaluate(new gi(e + 1)) };
        if (i.kind === 'source') return { kind: 'source' };
        {
          const { zoomStops: r, interpolationType: n } = i;
          let o = 0;
          for (; o < r.length && r[o] <= e; ) o++;
          o = Math.max(0, o - 1);
          let s = o;
          for (; s < r.length && r[s] < e + 1; ) s++;
          s = Math.min(r.length - 1, s);
          const a = r[o],
            l = r[s];
          return i.kind === 'composite' ? { kind: 'composite', minZoom: a, maxZoom: l, interpolationType: n } : { kind: 'camera', minZoom: a, maxZoom: l, minSize: i.evaluate(new gi(a)), maxSize: i.evaluate(new gi(l)), interpolationType: n };
        }
      }
      function Dl(e, { uSize: t, uSizeT: i }, { lowerSize: r, upperSize: n }) {
        return e.kind === 'source' ? r / vn : e.kind === 'composite' ? ee(r / vn, n / vn, i) : t;
      }
      function Bn(e, t) {
        let i = 0,
          r = 0;
        if (e.kind === 'constant') r = e.layoutSize;
        else if (e.kind !== 'source') {
          const { interpolationType: n, minZoom: o, maxZoom: s } = e,
            a = n ? Bt(Dn.interpolationFactor(n, t, o, s), 0, 1) : 0;
          e.kind === 'camera' ? (r = ee(e.minSize, e.maxSize, a)) : (i = a);
        }
        return { uSizeT: i, uSize: r };
      }
      var zA = Object.freeze({ __proto__: null, SIZE_PACK_FACTOR: vn, evaluateSizeForFeature: Dl, evaluateSizeForZoom: Bn, getSizeData: kp });
      function DA(e, t, i) {
        return (
          e.sections.forEach((r) => {
            r.text = (function (n, o, s) {
              const a = o.layout.get('text-transform').evaluate(s, {});
              return a === 'uppercase' ? (n = n.toLocaleUpperCase()) : a === 'lowercase' && (n = n.toLocaleLowerCase()), an.applyArabicShaping && (n = an.applyArabicShaping(n)), n;
            })(r.text, t, i);
          }),
          e
        );
      }
      const Rl = { '!': '', '#': '', $: '', '%': '', '&': '', '(': '', ')': '', '*': '', '+': '', ',': '', '-': '', '.': '', '/': '', ':': '', ';': '', '<': '', '=': '', '>': '', '?': '', '@': '', '[': '', '\\': '', ']': '', '^': '', _: '', '`': '', '{': '', '|': '', '}': '', '~': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '', '': '' };
      function RA(e) {
        return e === '' || e === '' || e === '' || e === '' || e === '' || e === '' || e === '' || e === '' || e === '' || e === '' || e === '' || e === '' || e === '' || e === '' || e === '' || e === '' || e === '';
      }
      function LA(e) {
        return e === '' || e === '' || e === '' || e === '' || e === '' || e === '' || e === '' || e === '' || e === '' || e === '';
      }
      const Op = 3;
      function kA(e, t, i) {
        (t.glyphs = []), e === 1 && i.readMessage(OA, t);
      }
      function OA(e, t, i) {
        if (e === 3) {
          const { id: r, bitmap: n, width: o, height: s, left: a, top: l, advance: c } = i.readMessage(BA, {});
          t.glyphs.push({ id: r, bitmap: new fo({ width: o + 2 * Op, height: s + 2 * Op }, n), metrics: { width: o, height: s, left: a, top: l, advance: c } });
        } else e === 4 ? (t.ascender = i.readSVarint()) : e === 5 && (t.descender = i.readSVarint());
      }
      function BA(e, t, i) {
        e === 1 ? (t.id = i.readVarint()) : e === 2 ? (t.bitmap = i.readBytes()) : e === 3 ? (t.width = i.readVarint()) : e === 4 ? (t.height = i.readVarint()) : e === 5 ? (t.left = i.readSVarint()) : e === 6 ? (t.top = i.readSVarint()) : e === 7 && (t.advance = i.readVarint());
      }
      const Qx = Op,
        di = { horizontal: 1, vertical: 2, horizontalOnly: 3 },
        tv = -17;
      class Ll {
        constructor() {
          (this.scale = 1), (this.fontStack = ''), (this.imageName = null);
        }
        static forText(t, i) {
          const r = new Ll();
          return (r.scale = t || 1), (r.fontStack = i), r;
        }
        static forImage(t) {
          const i = new Ll();
          return (i.imageName = t), i;
        }
      }
      class Sa {
        constructor() {
          (this.text = ''), (this.sectionIndex = []), (this.sections = []), (this.imageSectionID = null);
        }
        static fromFeature(t, i) {
          const r = new Sa();
          for (let n = 0; n < t.sections.length; n++) {
            const o = t.sections[n];
            o.image ? r.addImageSection(o) : r.addTextSection(o, i);
          }
          return r;
        }
        length() {
          return this.text.length;
        }
        getSection(t) {
          return this.sections[this.sectionIndex[t]];
        }
        getSections() {
          return this.sections;
        }
        getSectionIndex(t) {
          return this.sectionIndex[t];
        }
        getCodePoint(t) {
          return this.text.codePointAt(t);
        }
        verticalizePunctuation(t) {
          this.text = (function (i, r) {
            let n = '';
            for (let o = 0; o < i.length; o++) {
              const s = i.charCodeAt(o + 1) || null,
                a = i.charCodeAt(o - 1) || null;
              n += (!r && ((s && cy(s) && !Rl[i[o + 1]]) || (a && cy(a) && !Rl[i[o - 1]]))) || !Rl[i[o]] ? i[o] : Rl[i[o]];
            }
            return n;
          })(this.text, t);
        }
        trim() {
          let t = 0;
          for (let r = 0; r < this.text.length && Du[this.text.charCodeAt(r)]; r++) t++;
          let i = this.text.length;
          for (let r = this.text.length - 1; r >= 0 && r >= t && Du[this.text.charCodeAt(r)]; r--) i--;
          (this.text = this.text.substring(t, i)), (this.sectionIndex = this.sectionIndex.slice(t, i));
        }
        substring(t, i) {
          const r = new Sa();
          return (r.text = this.text.substring(t, i)), (r.sectionIndex = this.sectionIndex.slice(t, i)), (r.sections = this.sections), r;
        }
        toString() {
          return this.text;
        }
        getMaxScale() {
          return this.sectionIndex.reduce((t, i) => Math.max(t, this.sections[i].scale), 0);
        }
        addTextSection(t, i) {
          (this.text += t.text), this.sections.push(Ll.forText(t.scale, t.fontStack || i));
          const r = this.sections.length - 1;
          for (let n = 0; n < t.text.length; ++n) this.sectionIndex.push(r);
        }
        addImageSection(t) {
          const i = t.image ? t.image.namePrimary : '';
          if (i.length === 0) return void B("Can't add FormattedSection with an empty image.");
          const r = this.getNextImageSectionCharCode();
          r ? ((this.text += String.fromCodePoint(r)), this.sections.push(Ll.forImage(i)), this.sectionIndex.push(this.sections.length - 1)) : B('Reached maximum number of images 6401');
        }
        getNextImageSectionCharCode() {
          return this.imageSectionID ? (this.imageSectionID >= 63743 ? null : ++this.imageSectionID) : ((this.imageSectionID = 57344), this.imageSectionID);
        }
      }
      function Bp(e, t, i, r, n, o, s, a, l, c, u, h, d, f, p) {
        const _ = Sa.fromFeature(e, n);
        h === di.vertical && _.verticalizePunctuation(d);
        let g = [];
        const y = (function (E, S, I, C, z, k) {
            if (!E) return [];
            const O = [],
              V = (function (X, j, q, it, st, nt) {
                let ut = 0;
                for (let ht = 0; ht < X.length(); ht++) {
                  const pt = X.getSection(ht);
                  ut += ev(X.getCodePoint(ht), pt, it, st, j, nt);
                }
                return ut / Math.max(1, Math.ceil(ut / q));
              })(E, S, I, C, z, k),
              R = E.text.indexOf('') >= 0;
            let G = 0;
            for (let X = 0; X < E.length(); X++) {
              const j = E.getSection(X),
                q = E.getCodePoint(X);
              if ((Du[q] || (G += ev(q, j, C, z, S, k)), X < E.length() - 1)) {
                const it = !((Z = q) < 11904 || !($t['Bopomofo Extended'](Z) || $t.Bopomofo(Z) || $t['CJK Compatibility Forms'](Z) || $t['CJK Compatibility Ideographs'](Z) || $t['CJK Compatibility'](Z) || $t['CJK Radicals Supplement'](Z) || $t['CJK Strokes'](Z) || $t['CJK Symbols and Punctuation'](Z) || $t['CJK Unified Ideographs Extension A'](Z) || $t['CJK Unified Ideographs'](Z) || $t['Enclosed CJK Letters and Months'](Z) || $t['Halfwidth and Fullwidth Forms'](Z) || $t.Hiragana(Z) || $t['Ideographic Description Characters'](Z) || $t['Kangxi Radicals'](Z) || $t['Katakana Phonetic Extensions'](Z) || $t.Katakana(Z) || $t['Vertical Forms'](Z) || $t['Yi Radicals'](Z) || $t['Yi Syllables'](Z)));
                (FA[q] || it || j.imageName) && O.push(rv(X + 1, G, V, O, NA(q, E.getCodePoint(X + 1), it && R), !1));
              }
            }
            var Z;
            return nv(rv(E.length(), G, V, O, 0, !0));
          })(_, c, o, t, r, f),
          { processBidirectionalText: v, processStyledBidirectionalText: w } = an;
        if (v && _.sections.length === 1) {
          const E = v(_.toString(), y);
          for (const S of E) {
            const I = new Sa();
            (I.text = S), (I.sections = _.sections);
            for (let C = 0; C < S.length; C++) I.sectionIndex.push(0);
            g.push(I);
          }
        } else if (w) {
          const E = w(_.text, _.sectionIndex, y);
          for (const S of E) {
            const I = new Sa();
            (I.text = S[0]), (I.sectionIndex = S[1]), (I.sections = _.sections), g.push(I);
          }
        } else
          g = (function (E, S) {
            const I = [],
              C = E.text;
            let z = 0;
            for (const k of S) I.push(E.substring(z, k)), (z = k);
            return z < C.length && I.push(E.substring(z, C.length)), I;
          })(_, y);
        const T = [],
          b = { positionedLines: T, text: _.toString(), top: u[1], bottom: u[1], left: u[0], right: u[0], writingMode: h, iconsInText: !1, verticalizable: !1, hasBaseline: !1 };
        return (
          (function (E, S, I, C, z, k, O, V, R, G, Z, X) {
            let j = 0,
              q = 0,
              it = 0;
            const st = V === 'right' ? 1 : V === 'left' ? 0 : 0.5;
            let nt = !1;
            for (const Ct of z) {
              const Pt = Ct.getSections();
              for (const Ot of Pt) {
                if (Ot.imageName) continue;
                const Ut = S[Ot.fontStack];
                if (Ut && ((nt = Ut.ascender !== void 0 && Ut.descender !== void 0), !nt)) break;
              }
              if (!nt) break;
            }
            let ut = 0;
            for (const Ct of z) {
              Ct.trim();
              const Pt = Ct.getMaxScale(),
                Ot = (Pt - 1) * Qi,
                Ut = { positionedGlyphs: [], lineOffset: 0 };
              E.positionedLines[ut] = Ut;
              const Qt = Ut.positionedGlyphs;
              let Ht = 0;
              if (!Ct.length()) {
                (q += k), ++ut;
                continue;
              }
              let Ce = 0,
                be = 0;
              for (let Kt = 0; Kt < Ct.length(); Kt++) {
                const Wt = Ct.getSection(Kt),
                  Ee = Ct.getSectionIndex(Kt),
                  Ae = Ct.getCodePoint(Kt);
                let fe = Wt.scale,
                  Qe = null,
                  Ci = null,
                  Xe = null,
                  oi = Qi,
                  Ri = 0;
                const Pi = !(R === di.horizontal || (!Z && !gf(Ae)) || (Z && (Du[Ae] || ((ht = Ae), $t.Arabic(ht) || $t['Arabic Supplement'](ht) || $t['Arabic Extended-A'](ht) || $t['Arabic Presentation Forms-A'](ht) || $t['Arabic Presentation Forms-B'](ht)))));
                if (Wt.imageName) {
                  const ci = C[Wt.imageName];
                  if (!ci) continue;
                  (Xe = Wt.imageName), (E.iconsInText = E.iconsInText || !0), (Ci = ci.paddedRect);
                  const je = ci.displaySize;
                  (fe = (fe * Qi) / X), (Qe = { width: je[0], height: je[1], left: 0, top: -Qx, advance: Pi ? je[1] : je[0], localGlyph: !1 }), (Ri = nt ? -Qe.height * fe : tv + Pt * Qi - je[1] * fe), (oi = Qe.advance);
                  const rr = (Pi ? je[0] : je[1]) * fe - Qi * Pt;
                  rr > 0 && rr > Ht && (Ht = rr);
                } else {
                  const ci = I[Wt.fontStack];
                  if (!ci) continue;
                  ci[Ae] && (Ci = ci[Ae]);
                  const je = S[Wt.fontStack];
                  if (!je) continue;
                  const rr = je.glyphs[Ae];
                  if (!rr) continue;
                  if (((Qe = rr.metrics), (oi = Ae !== 8203 ? Qi : 0), nt)) {
                    const Gn = je.ascender !== void 0 ? Math.abs(je.ascender) : 0,
                      _o = je.descender !== void 0 ? Math.abs(je.descender) : 0,
                      go = (Gn + _o) * fe;
                    Ce < go && ((Ce = go), (be = ((Gn - _o) / 2) * fe)), (Ri = -Gn * fe);
                  } else Ri = tv + (Pt - fe) * Qi;
                }
                Pi ? ((E.verticalizable = !0), Qt.push({ glyph: Ae, imageName: Xe, x: j, y: q + Ri, vertical: Pi, scale: fe, localGlyph: Qe.localGlyph, fontStack: Wt.fontStack, sectionIndex: Ee, metrics: Qe, rect: Ci }), (j += oi * fe + G)) : (Qt.push({ glyph: Ae, imageName: Xe, x: j, y: q + Ri, vertical: Pi, scale: fe, localGlyph: Qe.localGlyph, fontStack: Wt.fontStack, sectionIndex: Ee, metrics: Qe, rect: Ci }), (j += Qe.advance * fe + G));
              }
              Qt.length !== 0 && ((it = Math.max(j - G, it)), nt ? ov(Qt, st, Ht, be, (k * Pt) / 2) : ov(Qt, st, Ht, 0, k / 2)), (j = 0);
              const te = k * Pt + Ht;
              (Ut.lineOffset = Math.max(Ht, Ot)), (q += te), ++ut;
            }
            var ht;
            const pt = q,
              { horizontalAlign: at, verticalAlign: _t } = Ru(O);
            (function (Ct, Pt, Ot, Ut, Qt, Ht) {
              const Ce = (Pt - Ot) * Qt,
                be = -Ht * Ut;
              for (const te of Ct) for (const Kt of te.positionedGlyphs) (Kt.x += Ce), (Kt.y += be);
            })(E.positionedLines, st, at, _t, it, pt),
              (E.top += -_t * pt),
              (E.bottom = E.top + pt),
              (E.left += -at * it),
              (E.right = E.left + it),
              (E.hasBaseline = nt);
          })(b, t, i, r, g, s, a, l, h, c, d, p),
          !(function (E) {
            for (const S of E) if (S.positionedGlyphs.length !== 0) return !1;
            return !0;
          })(T) && b
        );
      }
      const Du = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 },
        FA = { 10: !0, 32: !0, 38: !0, 40: !0, 41: !0, 43: !0, 45: !0, 47: !0, 173: !0, 183: !0, 8203: !0, 8208: !0, 8211: !0, 8231: !0 };
      function ev(e, t, i, r, n, o) {
        if (t.imageName) {
          const s = r[t.imageName];
          return s ? (s.displaySize[0] * t.scale * Qi) / o + n : 0;
        }
        {
          const s = i[t.fontStack],
            a = s && s.glyphs[e];
          return a ? a.metrics.advance * t.scale + n : 0;
        }
      }
      function iv(e, t, i, r) {
        const n = Math.pow(e - t, 2);
        return r ? (e < t ? n / 2 : 2 * n) : n + Math.abs(i) * i;
      }
      function NA(e, t, i) {
        let r = 0;
        return e === 10 && (r -= 1e4), i && (r += 150), (e !== 40 && e !== 65288) || (r += 50), (t !== 41 && t !== 65289) || (r += 50), r;
      }
      function rv(e, t, i, r, n, o) {
        let s = null,
          a = iv(t, i, n, o);
        for (const l of r) {
          const c = iv(t - l.x, i, n, o) + l.badness;
          c <= a && ((s = l), (a = c));
        }
        return { index: e, x: t, priorBreak: s, badness: a };
      }
      function nv(e) {
        return e ? nv(e.priorBreak).concat(e.index) : [];
      }
      function Ru(e) {
        let t = 0.5,
          i = 0.5;
        switch (e) {
          case 'right':
          case 'top-right':
          case 'bottom-right':
            t = 1;
            break;
          case 'left':
          case 'top-left':
          case 'bottom-left':
            t = 0;
        }
        switch (e) {
          case 'bottom':
          case 'bottom-right':
          case 'bottom-left':
            i = 1;
            break;
          case 'top':
          case 'top-right':
          case 'top-left':
            i = 0;
        }
        return { horizontalAlign: t, verticalAlign: i };
      }
      function ov(e, t, i, r, n) {
        if (!(t || i || r || n)) return;
        const o = e.length - 1,
          s = e[o],
          a = (s.x + s.metrics.advance * s.scale) * t;
        for (let l = 0; l <= o; l++) (e[l].x -= a), (e[l].y += i + r + n);
      }
      function UA(e, t, i, r) {
        const { horizontalAlign: n, verticalAlign: o } = Ru(r),
          s = i[0] - e.displaySize[0] * n,
          a = i[1] - e.displaySize[1] * o;
        return { imagePrimary: e, imageSecondary: t, top: a, bottom: a + e.displaySize[1], left: s, right: s + e.displaySize[0] };
      }
      function sv(e, t, i, r, n, o) {
        const s = e.imagePrimary;
        let a;
        if (s.content) {
          const g = s.content,
            y = s.pixelRatio || 1;
          a = [g[0] / y, g[1] / y, s.displaySize[0] - g[2] / y, s.displaySize[1] - g[3] / y];
        }
        const l = t.left * o,
          c = t.right * o;
        let u, h, d, f;
        i === 'width' || i === 'both' ? ((f = n[0] + l - r[3]), (h = n[0] + c + r[1])) : ((f = n[0] + (l + c - s.displaySize[0]) / 2), (h = f + s.displaySize[0]));
        const p = t.top * o,
          _ = t.bottom * o;
        return i === 'height' || i === 'both' ? ((u = n[1] + p - r[0]), (d = n[1] + _ + r[2])) : ((u = n[1] + (p + _ - s.displaySize[1]) / 2), (d = u + s.displaySize[1])), { imagePrimary: s, imageSecondary: void 0, top: u, right: h, bottom: d, left: f, collisionPadding: a };
      }
      class mo extends H {
        constructor(t, i, r, n, o) {
          super(t, i), (this.angle = n), (this.z = r), o !== void 0 && (this.segment = o);
        }
        clone() {
          return new mo(this.x, this.y, this.z, this.angle, this.segment);
        }
      }
      function av(e, t, i, r, n) {
        if (t.segment === void 0) return !0;
        let o = t,
          s = t.segment + 1,
          a = 0;
        for (; a > -i / 2; ) {
          if ((s--, s < 0)) return !1;
          (a -= e[s].dist(o)), (o = e[s]);
        }
        (a += e[s].dist(e[s + 1])), s++;
        const l = [];
        let c = 0;
        for (; a < i / 2; ) {
          const u = e[s],
            h = e[s + 1];
          if (!h) return !1;
          let d = e[s - 1].angleTo(u) - u.angleTo(h);
          for (d = Math.abs(((d + 3 * Math.PI) % (2 * Math.PI)) - Math.PI), l.push({ distance: a, angleDelta: d }), c += d; a - l[0].distance > r; ) c -= l.shift().angleDelta;
          if (c > n) return !1;
          s++, (a += u.dist(h));
        }
        return !0;
      }
      function lv(e) {
        let t = 0;
        for (let i = 0; i < e.length - 1; i++) t += e[i].dist(e[i + 1]);
        return t;
      }
      function cv(e, t, i) {
        return e ? 0.6 * t * i : 0;
      }
      function uv(e, t) {
        return Math.max(e ? e.right - e.left : 0, t ? t.right - t.left : 0);
      }
      function VA(e, t, i, r, n, o) {
        const s = cv(i, n, o),
          a = uv(i, r) * o;
        let l = 0;
        const c = lv(e) / 2;
        for (let u = 0; u < e.length - 1; u++) {
          const h = e[u],
            d = e[u + 1],
            f = h.dist(d);
          if (l + f > c) {
            const p = (c - l) / f,
              _ = ee(h.x, d.x, p),
              g = ee(h.y, d.y, p),
              y = new mo(_, g, 0, d.angleTo(h), u);
            return !s || av(e, y, a, s, t) ? y : void 0;
          }
          l += f;
        }
      }
      function jA(e, t, i, r, n, o, s, a, l) {
        const c = cv(r, o, s),
          u = uv(r, n),
          h = u * s,
          d = e[0].x === 0 || e[0].x === l || e[0].y === 0 || e[0].y === l;
        return t - h < t / 4 && (t = h + t / 4), hv(e, d ? ((t / 2) * a) % t : ((u / 2 + 2 * o) * s * a) % t, t, c, i, h, d, !1, l);
      }
      function hv(e, t, i, r, n, o, s, a, l) {
        const c = o / 2,
          u = lv(e);
        let h = 0,
          d = t - i,
          f = [];
        for (let p = 0; p < e.length - 1; p++) {
          const _ = e[p],
            g = e[p + 1],
            y = _.dist(g),
            v = g.angleTo(_);
          for (; d + i < h + y; ) {
            d += i;
            const w = (d - h) / y,
              T = ee(_.x, g.x, w),
              b = ee(_.y, g.y, w);
            if (T >= 0 && T < l && b >= 0 && b < l && d - c >= 0 && d + c <= u) {
              const E = new mo(T, b, 0, v, p);
              (r && !av(e, E, o, r, n)) || f.push(E);
            }
          }
          h += y;
        }
        return a || f.length || s || (f = hv(e, h / 2, i, r, n, o, s, !0, l)), f;
      }
      function dv(e, t, i, r, n) {
        const o = [];
        for (let s = 0; s < e.length; s++) {
          const a = e[s];
          let l;
          for (let c = 0; c < a.length - 1; c++) {
            let u = a[c],
              h = a[c + 1];
            (u.x < t && h.x < t) || (u.x < t ? (u = new H(t, u.y + ((t - u.x) / (h.x - u.x)) * (h.y - u.y))._round()) : h.x < t && (h = new H(t, u.y + ((t - u.x) / (h.x - u.x)) * (h.y - u.y))._round()), (u.y < i && h.y < i) || (u.y < i ? (u = new H(u.x + ((i - u.y) / (h.y - u.y)) * (h.x - u.x), i)._round()) : h.y < i && (h = new H(u.x + ((i - u.y) / (h.y - u.y)) * (h.x - u.x), i)._round()), (u.x >= r && h.x >= r) || (u.x >= r ? (u = new H(r, u.y + ((r - u.x) / (h.x - u.x)) * (h.y - u.y))._round()) : h.x >= r && (h = new H(r, u.y + ((r - u.x) / (h.x - u.x)) * (h.y - u.y))._round()), (u.y >= n && h.y >= n) || (u.y >= n ? (u = new H(u.x + ((n - u.y) / (h.y - u.y)) * (h.x - u.x), n)._round()) : h.y >= n && (h = new H(u.x + ((n - u.y) / (h.y - u.y)) * (h.x - u.x), n)._round()), (l && u.equals(l[l.length - 1])) || ((l = [u]), o.push(l)), l.push(h)))));
          }
        }
        return o;
      }
      function Fp(e) {
        let t = 0,
          i = 0;
        for (const s of e) (t += s.w * s.h), (i = Math.max(i, s.w));
        e.sort((s, a) => a.h - s.h);
        const r = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(t / 0.95)), i), h: 1 / 0 }];
        let n = 0,
          o = 0;
        for (const s of e)
          for (let a = r.length - 1; a >= 0; a--) {
            const l = r[a];
            if (!(s.w > l.w || s.h > l.h)) {
              if (((s.x = l.x), (s.y = l.y), (o = Math.max(o, s.y + s.h)), (n = Math.max(n, s.x + s.w)), s.w === l.w && s.h === l.h)) {
                const c = r.pop();
                a < r.length && (r[a] = c);
              } else s.h === l.h ? ((l.x += s.w), (l.w -= s.w)) : s.w === l.w ? ((l.y += s.h), (l.h -= s.h)) : (r.push({ x: l.x + s.w, y: l.y, w: l.w - s.w, h: s.h }), (l.y += s.h), (l.h -= s.h));
              break;
            }
          }
        return { w: n, h: o, fill: t / (n * o) || 0 };
      }
      Gt(mo, 'Anchor');
      const Br = 1;
      class Np {
        constructor(t, { pixelRatio: i, version: r, stretchX: n, stretchY: o, content: s }) {
          (this.paddedRect = t), (this.pixelRatio = i), (this.stretchX = n), (this.stretchY = o), (this.content = s), (this.version = r);
        }
        get tl() {
          return [this.paddedRect.x + Br, this.paddedRect.y + Br];
        }
        get br() {
          return [this.paddedRect.x + this.paddedRect.w - Br, this.paddedRect.y + this.paddedRect.h - Br];
        }
        get displaySize() {
          return [(this.paddedRect.w - 2 * Br) / this.pixelRatio, (this.paddedRect.h - 2 * Br) / this.pixelRatio];
        }
      }
      class fv {
        constructor(t, i) {
          const r = {},
            n = {};
          this.haveRenderCallbacks = [];
          const o = [];
          this.addImages(t, r, o), this.addImages(i, n, o);
          const { w: s, h: a } = Fp(o),
            l = new Li({ width: s || 1, height: a || 1 });
          for (const c in t) {
            const u = t[c],
              h = r[c].paddedRect;
            Li.copy(u.data, l, { x: 0, y: 0 }, { x: h.x + Br, y: h.y + Br }, u.data);
          }
          for (const c in i) {
            const u = i[c],
              h = n[c].paddedRect,
              d = h.x + Br,
              f = h.y + Br,
              p = u.data.width,
              _ = u.data.height;
            Li.copy(u.data, l, { x: 0, y: 0 }, { x: d, y: f }, u.data), Li.copy(u.data, l, { x: 0, y: _ - 1 }, { x: d, y: f - 1 }, { width: p, height: 1 }), Li.copy(u.data, l, { x: 0, y: 0 }, { x: d, y: f + _ }, { width: p, height: 1 }), Li.copy(u.data, l, { x: p - 1, y: 0 }, { x: d - 1, y: f }, { width: 1, height: _ }), Li.copy(u.data, l, { x: 0, y: 0 }, { x: d + p, y: f }, { width: 1, height: _ });
          }
          (this.image = l), (this.iconPositions = r), (this.patternPositions = n);
        }
        addImages(t, i, r) {
          for (const n in t) {
            const o = t[n],
              s = { x: 0, y: 0, w: o.data.width + 2 * Br, h: o.data.height + 2 * Br };
            r.push(s), (i[n] = new Np(s, o)), o.hasRenderCallback && this.haveRenderCallbacks.push(n);
          }
        }
        patchUpdatedImages(t, i, r) {
          (this.haveRenderCallbacks = this.haveRenderCallbacks.filter((n) => t.hasImage(n, r))), t.dispatchRenderCallbacks(this.haveRenderCallbacks, r);
          for (const n in t.getUpdatedImages(r)) this.patchUpdatedImage(this.iconPositions[n], t.getImage(n, r), i), this.patchUpdatedImage(this.patternPositions[n], t.getImage(n, r), i);
        }
        patchUpdatedImage(t, i, r) {
          if (!t || !i || t.version === i.version) return;
          t.version = i.version;
          const [n, o] = t.tl;
          r.update(i.data, void 0, { x: n, y: o });
        }
      }
      Gt(Np, 'ImagePosition'), Gt(fv, 'ImageAtlas');
      const kl = 1e20;
      function pv(e, t, i, r, n, o, s, a, l) {
        for (let c = t; c < t + r; c++) mv(e, i * o + c, o, n, s, a, l);
        for (let c = i; c < i + n; c++) mv(e, c * o + t, 1, r, s, a, l);
      }
      function mv(e, t, i, r, n, o, s) {
        (o[0] = 0), (s[0] = -kl), (s[1] = kl), (n[0] = e[t]);
        for (let a = 1, l = 0, c = 0; a < r; a++) {
          n[a] = e[t + a * i];
          const u = a * a;
          do {
            const h = o[l];
            c = (n[a] - n[h] + u - h * h) / (a - h) / 2;
          } while (c <= s[l] && --l > -1);
          l++, (o[l] = a), (s[l] = c), (s[l + 1] = kl);
        }
        for (let a = 0, l = 0; a < r; a++) {
          for (; s[l + 1] < a; ) l++;
          const c = o[l],
            u = a - c;
          e[t + a * i] = n[c] + u * u;
        }
      }
      const bn = 2;
      class Aa {
        constructor(t, i, r) {
          (this.requestManager = t), (this.localGlyphMode = i), (this.localFontFamily = r), (this.urls = {}), (this.entries = {}), (this.localGlyphs = { 200: {}, 400: {}, 500: {}, 900: {} });
        }
        setURL(t, i) {
          this.urls[i] = t;
        }
        getGlyphs(t, i, r) {
          const n = [],
            o = this.urls[i] || Mt.GLYPHS_URL;
          for (const s in t) for (const a of t[s]) n.push({ stack: s, id: a });
          Yn(
            n,
            ({ stack: s, id: a }, l) => {
              let c = this.entries[s];
              c || (c = this.entries[s] = { glyphs: {}, requests: {}, ranges: {}, ascender: void 0, descender: void 0 });
              let u = c.glyphs[a];
              if (u !== void 0) return void l(null, { stack: s, id: a, glyph: u });
              if (((u = this._tinySDF(c, s, a)), u)) return (c.glyphs[a] = u), void l(null, { stack: s, id: a, glyph: u });
              const h = Math.floor(a / 256);
              if (256 * h > 65535) return void l(new Error('glyphs > 65535 not supported'));
              if (c.ranges[h]) return void l(null, { stack: s, id: a, glyph: u });
              let d = c.requests[h];
              d ||
                ((d = c.requests[h] = []),
                Aa.loadGlyphRange(s, h, o, this.requestManager, (f, p) => {
                  if (p) {
                    (c.ascender = p.ascender), (c.descender = p.descender);
                    for (const _ in p.glyphs) this._doesCharSupportLocalGlyph(+_) || (c.glyphs[+_] = p.glyphs[+_]);
                    c.ranges[h] = !0;
                  }
                  for (const _ of d) _(f, p);
                  delete c.requests[h];
                })),
                d.push((f, p) => {
                  f ? l(f) : p && l(null, { stack: s, id: a, glyph: p.glyphs[a] || null });
                });
            },
            (s, a) => {
              if (s) r(s);
              else if (a) {
                const l = {};
                for (const { stack: c, id: u, glyph: h } of a) l[c] === void 0 && (l[c] = {}), l[c].glyphs === void 0 && (l[c].glyphs = {}), (l[c].glyphs[u] = h && { id: h.id, bitmap: h.bitmap.clone(), metrics: h.metrics }), (l[c].ascender = this.entries[c].ascender), (l[c].descender = this.entries[c].descender);
                r(null, l);
              }
            }
          );
        }
        _doesCharSupportLocalGlyph(t) {
          return this.localGlyphMode !== 0 && (this.localGlyphMode === 2 ? !!this.localFontFamily : !!this.localFontFamily && ($t['CJK Unified Ideographs'](t) || $t['Hangul Syllables'](t) || $t.Hiragana(t) || $t.Katakana(t) || $t['CJK Symbols and Punctuation'](t) || $t['CJK Unified Ideographs Extension A'](t) || $t['CJK Unified Ideographs Extension B'](t)));
        }
        _tinySDF(t, i, r) {
          const n = this.localFontFamily;
          if (!n || !this._doesCharSupportLocalGlyph(r)) return;
          let o = t.tinySDF;
          if (!o) {
            let _ = '400';
            /bold/i.test(i) ? (_ = '900') : /medium/i.test(i) ? (_ = '500') : /light/i.test(i) && (_ = '200'), (o = t.tinySDF = new Aa.TinySDF({ fontFamily: n, fontWeight: _, fontSize: 24 * bn, buffer: 3 * bn, radius: 8 * bn })), (o.fontWeight = _);
          }
          if (this.localGlyphs[o.fontWeight][r]) return this.localGlyphs[o.fontWeight][r];
          const s = String.fromCodePoint(r),
            { data: a, width: l, height: c, glyphWidth: u, glyphHeight: h, glyphLeft: d, glyphTop: f, glyphAdvance: p } = o.draw(s);
          return (this.localGlyphs[o.fontWeight][r] = { id: r, bitmap: new fo({ width: l, height: c }, a), metrics: { width: u / bn, height: h / bn, left: d / bn, top: f / bn - 27, advance: p / bn, localGlyph: !0 } });
        }
      }
      (Aa.loadGlyphRange = function (e, t, i, r, n) {
        const o = 256 * t,
          s = o + 255,
          a = r.transformRequest(r.normalizeGlyphsURL(i).replace('{fontstack}', e).replace('{range}', `${o}-${s}`), dt.Glyphs);
        Dt(a, (l, c) => {
          if (l) n(l);
          else if (c) {
            const u = {},
              h = (function (d) {
                return new Pu(d).readFields(kA, {});
              })(c);
            for (const d of h.glyphs) u[d.id] = d;
            n(null, { glyphs: u, ascender: h.ascender, descender: h.descender });
          }
        });
      }),
        (Aa.TinySDF = class {
          constructor({ fontSize: e = 24, buffer: t = 3, radius: i = 8, cutoff: r = 0.25, fontFamily: n = 'sans-serif', fontWeight: o = 'normal', fontStyle: s = 'normal' } = {}) {
            (this.buffer = t), (this.cutoff = r), (this.radius = i);
            const a = (this.size = e + 4 * t),
              l = this._createCanvas(a),
              c = (this.ctx = l.getContext('2d', { willReadFrequently: !0 }));
            (c.font = `${s} ${o} ${e}px ${n}`), (c.textBaseline = 'alphabetic'), (c.textAlign = 'left'), (c.fillStyle = 'black'), (this.gridOuter = new Float64Array(a * a)), (this.gridInner = new Float64Array(a * a)), (this.f = new Float64Array(a)), (this.z = new Float64Array(a + 1)), (this.v = new Uint16Array(a));
          }
          _createCanvas(e) {
            const t = document.createElement('canvas');
            return (t.width = t.height = e), t;
          }
          draw(e) {
            const { width: t, actualBoundingBoxAscent: i, actualBoundingBoxDescent: r, actualBoundingBoxLeft: n, actualBoundingBoxRight: o } = this.ctx.measureText(e),
              s = Math.ceil(i),
              a = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(o - n))),
              l = Math.min(this.size - this.buffer, s + Math.ceil(r)),
              c = a + 2 * this.buffer,
              u = l + 2 * this.buffer,
              h = Math.max(c * u, 0),
              d = new Uint8ClampedArray(h),
              f = { data: d, width: c, height: u, glyphWidth: a, glyphHeight: l, glyphTop: s, glyphLeft: 0, glyphAdvance: t };
            if (a === 0 || l === 0) return f;
            const { ctx: p, buffer: _, gridInner: g, gridOuter: y } = this;
            p.clearRect(_, _, a, l), p.fillText(e, _, _ + s);
            const v = p.getImageData(_, _, a, l);
            y.fill(kl, 0, h), g.fill(0, 0, h);
            for (let w = 0; w < l; w++)
              for (let T = 0; T < a; T++) {
                const b = v.data[4 * (w * a + T) + 3] / 255;
                if (b === 0) continue;
                const E = (w + _) * c + T + _;
                if (b === 1) (y[E] = 0), (g[E] = kl);
                else {
                  const S = 0.5 - b;
                  (y[E] = S > 0 ? S * S : 0), (g[E] = S < 0 ? S * S : 0);
                }
              }
            pv(y, 0, 0, c, u, c, this.f, this.v, this.z), pv(g, _, _, a, l, c, this.f, this.v, this.z);
            for (let w = 0; w < h; w++) {
              const T = Math.sqrt(y[w]) - Math.sqrt(g[w]);
              d[w] = Math.round(255 - 255 * (T / this.radius + this.cutoff));
            }
            return f;
          }
        });
      const Go = Br;
      function _v(e, t, i, r) {
        const n = [],
          o = e.imagePrimary,
          s = o.pixelRatio,
          a = o.paddedRect.w - 2 * Go,
          l = o.paddedRect.h - 2 * Go,
          c = e.right - e.left,
          u = e.bottom - e.top,
          h = o.stretchX || [[0, a]],
          d = o.stretchY || [[0, l]],
          f = (k, O) => k + O[1] - O[0],
          p = h.reduce(f, 0),
          _ = d.reduce(f, 0),
          g = a - p,
          y = l - _;
        let v = 0,
          w = p,
          T = 0,
          b = _,
          E = 0,
          S = g,
          I = 0,
          C = y;
        if (o.content && r) {
          const k = o.content;
          (v = Lu(h, 0, k[0])), (T = Lu(d, 0, k[1])), (w = Lu(h, k[0], k[2])), (b = Lu(d, k[1], k[3])), (E = k[0] - v), (I = k[1] - T), (S = k[2] - k[0] - w), (C = k[3] - k[1] - b);
        }
        const z = (k, O, V, R) => {
          const G = ku(k.stretch - v, w, c, e.left),
            Z = Ou(k.fixed - E, S, k.stretch, p),
            X = ku(O.stretch - T, b, u, e.top),
            j = Ou(O.fixed - I, C, O.stretch, _),
            q = ku(V.stretch - v, w, c, e.left),
            it = Ou(V.fixed - E, S, V.stretch, p),
            st = ku(R.stretch - T, b, u, e.top),
            nt = Ou(R.fixed - I, C, R.stretch, _),
            ut = new H(G, X),
            ht = new H(q, X),
            pt = new H(q, st),
            at = new H(G, st),
            _t = new H(Z / s, j / s),
            Ct = new H(it / s, nt / s),
            Pt = (t * Math.PI) / 180;
          if (Pt) {
            const be = Math.sin(Pt),
              te = Math.cos(Pt),
              Kt = [te, -be, be, te];
            ut._matMult(Kt), ht._matMult(Kt), at._matMult(Kt), pt._matMult(Kt);
          }
          const Ot = k.stretch + k.fixed,
            Ut = V.stretch + V.fixed,
            Qt = O.stretch + O.fixed,
            Ht = R.stretch + R.fixed,
            Ce = e.imageSecondary;
          return { tl: ut, tr: ht, bl: at, br: pt, texPrimary: { x: o.paddedRect.x + Go + Ot, y: o.paddedRect.y + Go + Qt, w: Ut - Ot, h: Ht - Qt }, texSecondary: Ce ? { x: Ce.paddedRect.x + Go + Ot, y: Ce.paddedRect.y + Go + Qt, w: Ut - Ot, h: Ht - Qt } : void 0, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: _t, pixelOffsetBR: Ct, minFontScaleX: S / s / c, minFontScaleY: C / s / u, isSDF: i };
        };
        if (r && (o.stretchX || o.stretchY)) {
          const k = gv(h, g, p),
            O = gv(d, y, _);
          for (let V = 0; V < k.length - 1; V++) {
            const R = k[V],
              G = k[V + 1];
            for (let Z = 0; Z < O.length - 1; Z++) n.push(z(R, O[Z], G, O[Z + 1]));
          }
        } else n.push(z({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: a + 1 }, { fixed: 0, stretch: l + 1 }));
        return n;
      }
      function Lu(e, t, i) {
        let r = 0;
        for (const n of e) r += Math.max(t, Math.min(i, n[1])) - Math.max(t, Math.min(i, n[0]));
        return r;
      }
      function gv(e, t, i) {
        const r = [{ fixed: -Go, stretch: 0 }];
        for (const [n, o] of e) {
          const s = r[r.length - 1];
          r.push({ fixed: n - s.stretch, stretch: s.stretch }), r.push({ fixed: n - s.stretch, stretch: s.stretch + (o - n) });
        }
        return r.push({ fixed: t + Go, stretch: i }), r;
      }
      function ku(e, t, i, r) {
        return (e / t) * i + r;
      }
      function Ou(e, t, i, r) {
        return e - (t * i) / r;
      }
      function GA(e, t, i, r) {
        const n = t + e.positionedLines[r].lineOffset;
        return r === 0 ? i + n / 2 : i + (n + (t + e.positionedLines[r - 1].lineOffset)) / 2;
      }
      function qA(e, t = 1, i = !1) {
        let r = 1 / 0,
          n = 1 / 0,
          o = -1 / 0,
          s = -1 / 0;
        const a = e[0];
        for (let f = 0; f < a.length; f++) {
          const p = a[f];
          (!f || p.x < r) && (r = p.x), (!f || p.y < n) && (n = p.y), (!f || p.x > o) && (o = p.x), (!f || p.y > s) && (s = p.y);
        }
        const l = Math.min(o - r, s - n);
        let c = l / 2;
        const u = new Pd([], ZA);
        if (l === 0) return new H(r, n);
        for (let f = r; f < o; f += l) for (let p = n; p < s; p += l) u.push(new Ia(f + c, p + c, c, e));
        let h = (function (f) {
            let p = 0,
              _ = 0,
              g = 0;
            const y = f[0];
            for (let v = 0, w = y.length, T = w - 1; v < w; T = v++) {
              const b = y[v],
                E = y[T],
                S = b.x * E.y - E.x * b.y;
              (_ += (b.x + E.x) * S), (g += (b.y + E.y) * S), (p += 3 * S);
            }
            return new Ia(_ / p, g / p, 0, f);
          })(e),
          d = u.length;
        for (; u.length; ) {
          const f = u.pop();
          (f.d > h.d || !h.d) && ((h = f), i && console.log('found best %d after %d probes', Math.round(1e4 * f.d) / 1e4, d)), f.max - h.d <= t || ((c = f.h / 2), u.push(new Ia(f.p.x - c, f.p.y - c, c, e)), u.push(new Ia(f.p.x + c, f.p.y - c, c, e)), u.push(new Ia(f.p.x - c, f.p.y + c, c, e)), u.push(new Ia(f.p.x + c, f.p.y + c, c, e)), (d += 4));
        }
        return i && (console.log(`num probes: ${d}`), console.log(`best distance: ${h.d}`)), h.p;
      }
      function ZA(e, t) {
        return t.max - e.max;
      }
      class Ia {
        constructor(t, i, r, n) {
          (this.p = new H(t, i)),
            (this.h = r),
            (this.d = (function (o, s) {
              let a = !1,
                l = 1 / 0;
              for (let c = 0; c < s.length; c++) {
                const u = s[c];
                for (let h = 0, d = u.length, f = d - 1; h < d; f = h++) {
                  const p = u[h],
                    _ = u[f];
                  p.y > o.y != _.y > o.y && o.x < ((_.x - p.x) * (o.y - p.y)) / (_.y - p.y) + p.x && (a = !a), (l = Math.min(l, yx(o, p, _)));
                }
              }
              return (a ? 1 : -1) * Math.sqrt(l);
            })(this.p, n)),
            (this.max = this.d + this.h * Math.SQRT2);
        }
      }
      const Ca = 7,
        Up = Number.POSITIVE_INFINITY,
        $A = Math.sqrt(2);
      function Vp(e, [t, i]) {
        let r = 0,
          n = 0;
        if (i === Up) {
          t < 0 && (t = 0);
          const o = t / $A;
          switch (e) {
            case 'top-right':
            case 'top-left':
              n = o - Ca;
              break;
            case 'bottom-right':
            case 'bottom-left':
              n = -o + Ca;
              break;
            case 'bottom':
              n = -t + Ca;
              break;
            case 'top':
              n = t - Ca;
          }
          switch (e) {
            case 'top-right':
            case 'bottom-right':
              r = -o;
              break;
            case 'top-left':
            case 'bottom-left':
              r = o;
              break;
            case 'left':
              r = t;
              break;
            case 'right':
              r = -t;
          }
        } else {
          switch (((t = Math.abs(t)), (i = Math.abs(i)), e)) {
            case 'top-right':
            case 'top-left':
            case 'top':
              n = i - Ca;
              break;
            case 'bottom-right':
            case 'bottom-left':
            case 'bottom':
              n = -i + Ca;
          }
          switch (e) {
            case 'top-right':
            case 'bottom-right':
            case 'right':
              r = -t;
              break;
            case 'top-left':
            case 'bottom-left':
            case 'left':
              r = t;
          }
        }
        return [r, n];
      }
      function HA(e, t, i, r, n, o, s, a, l, c, u) {
        e.createArrays(), (e.tilePixelRatio = lt / (512 * e.overscaling)), (e.compareText = {}), (e.iconsNeedLinear = !1);
        const h = e.layers[0].layout,
          d = e.layers[0]._unevaluatedLayout._values,
          f = {};
        if (e.textSizeData.kind === 'composite') {
          const { minZoom: y, maxZoom: v } = e.textSizeData;
          f.compositeTextSizes = [d['text-size'].possiblyEvaluate(new gi(y), a), d['text-size'].possiblyEvaluate(new gi(v), a)];
        }
        if (e.iconSizeData.kind === 'composite') {
          const { minZoom: y, maxZoom: v } = e.iconSizeData;
          f.compositeIconSizes = [d['icon-size'].possiblyEvaluate(new gi(y), a), d['icon-size'].possiblyEvaluate(new gi(v), a)];
        }
        (f.layoutTextSize = d['text-size'].possiblyEvaluate(new gi(l + 1), a)), (f.layoutIconSize = d['icon-size'].possiblyEvaluate(new gi(l + 1), a)), (f.textMaxSize = d['text-size'].possiblyEvaluate(new gi(18), a));
        const p = h.get('text-rotation-alignment') === 'map' && h.get('symbol-placement') !== 'point',
          _ = h.get('text-size');
        let g = !1;
        for (const y of e.features)
          if (y.icon && y.icon.nameSecondary) {
            g = !0;
            break;
          }
        for (const y of e.features) {
          const v = h.get('text-font').evaluate(y, {}, a).join(','),
            w = _.evaluate(y, {}, a),
            T = f.layoutTextSize.evaluate(y, {}, a),
            b = (f.layoutIconSize.evaluate(y, {}, a), { horizontal: {}, vertical: void 0 }),
            E = y.text;
          let S,
            I = [0, 0];
          if (E) {
            const k = E.toString(),
              O = h.get('text-letter-spacing').evaluate(y, {}, a) * Qi,
              V = h.get('text-line-height').evaluate(y, {}, a) * Qi,
              R = vM(k) ? O : 0,
              G = h.get('text-anchor').evaluate(y, {}, a),
              Z = h.get('text-variable-anchor');
            if (!Z) {
              const st = h.get('text-radial-offset').evaluate(y, {}, a);
              I = st
                ? Vp(G, [st * Qi, Up])
                : h
                    .get('text-offset')
                    .evaluate(y, {}, a)
                    .map((nt) => nt * Qi);
            }
            let X = p ? 'center' : h.get('text-justify').evaluate(y, {}, a);
            const j = h.get('symbol-placement') === 'point',
              q = j ? h.get('text-max-width').evaluate(y, {}, a) * Qi : 1 / 0,
              it = (st) => {
                e.allowVerticalPlacement && _f(k) && (b.vertical = Bp(E, t, i, n, v, q, V, G, st, R, I, di.vertical, !0, T, w));
              };
            if (!p && Z) {
              const st = X === 'auto' ? Z.map((ut) => jp(ut)) : [X];
              let nt = !1;
              for (let ut = 0; ut < st.length; ut++) {
                const ht = st[ut];
                if (!b.horizontal[ht])
                  if (nt) b.horizontal[ht] = b.horizontal[0];
                  else {
                    const pt = Bp(E, t, i, n, v, q, V, 'center', ht, R, I, di.horizontal, !1, T, w);
                    pt && ((b.horizontal[ht] = pt), (nt = pt.positionedLines.length === 1));
                  }
              }
              it('left');
            } else {
              if ((X === 'auto' && (X = jp(G)), j || h.get('text-writing-mode').indexOf('horizontal') >= 0 || !_f(k))) {
                const st = Bp(E, t, i, n, v, q, V, G, X, R, I, di.horizontal, !1, T, w);
                st && (b.horizontal[X] = st);
              }
              it(j ? 'left' : X);
            }
          }
          let C = !1;
          if (y.icon && y.icon.namePrimary) {
            const k = r[y.icon.namePrimary];
            k && ((S = UA(n[y.icon.namePrimary], y.icon.nameSecondary ? n[y.icon.nameSecondary] : void 0, h.get('icon-offset').evaluate(y, {}, a), h.get('icon-anchor').evaluate(y, {}, a))), (C = k.sdf), e.sdfIcons === void 0 ? (e.sdfIcons = k.sdf) : e.sdfIcons !== k.sdf && B('Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer'), (k.pixelRatio !== e.pixelRatio || h.get('icon-rotate').constantOr(1) !== 0) && (e.iconsNeedLinear = !0));
          }
          const z = xv(b.horizontal) || b.vertical;
          e.iconsInText || (e.iconsInText = !!z && z.iconsInText), (z || S) && WA(e, y, b, S, r, f, T, 0, I, C, s, a, c, u, g);
        }
        o && e.generateCollisionDebugBuffers(l, e.collisionBoxArray);
      }
      function jp(e) {
        switch (e) {
          case 'right':
          case 'top-right':
          case 'bottom-right':
            return 'right';
          case 'left':
          case 'top-left':
          case 'bottom-left':
            return 'left';
        }
        return 'center';
      }
      function WA(e, t, i, r, n, o, s, a, l, c, u, h, d, f, p) {
        let _ = o.textMaxSize.evaluate(t, {}, h);
        _ === void 0 && (_ = s);
        const g = e.layers[0].layout,
          y = g.get('icon-offset').evaluate(t, {}, h),
          v = xv(i.horizontal) || i.vertical,
          w = d.name === 'globe',
          T = Qi,
          b = s / T,
          E = (e.tilePixelRatio * _) / T,
          S = ((G = e.overscaling), e.zoom > 18 && G > 2 && (G >>= 1), Math.max(lt / (512 * G), 1) * g.get('symbol-spacing')),
          I = g.get('text-padding') * e.tilePixelRatio,
          C = g.get('icon-padding') * e.tilePixelRatio,
          z = ne(g.get('text-max-angle')),
          k = g.get('text-rotation-alignment') === 'map' && g.get('symbol-placement') !== 'point',
          O = g.get('icon-rotation-alignment') === 'map' && g.get('symbol-placement') !== 'point',
          V = g.get('symbol-placement'),
          R = S / 2;
        var G;
        const Z = g.get('icon-text-fit').evaluate(t, {}, h),
          X = g.get('icon-text-fit-padding').evaluate(t, {}, h),
          j = Z !== 'none';
        let q;
        e.hasAnyIconTextFit === !1 && j && (e.hasAnyIconTextFit = !0), r && j && (e.allowVerticalPlacement && i.vertical && (q = sv(r, i.vertical, Z, X, y, b)), v && (r = sv(r, v, Z, X, y, b)));
        const it = (st, nt, ut) => {
          if (nt.x < 0 || nt.x >= lt || nt.y < 0 || nt.y >= lt) return;
          let ht = null;
          if (w) {
            const { x: pt, y: at, z: _t } = d.projectTilePoint(nt.x, nt.y, ut);
            ht = { anchor: new mo(pt, at, _t, 0, void 0), up: d.upVector(ut, nt.x, nt.y) };
          }
          (function (pt, at, _t, Ct, Pt, Ot, Ut, Qt, Ht, Ce, be, te, Kt, Wt, Ee, Ae, fe, Qe, Ci, Xe, oi, Ri, Pi, ci, je, rr, Gn) {
            const _o = pt.addToLineVertexArray(at, Ct);
            let go,
              rc,
              nc,
              zh,
              Mw,
              Sw,
              Aw,
              Iw = 0,
              Cw = 0,
              Pw = 0,
              zw = 0,
              jm = -1,
              Gm = -1;
            const qn = {};
            let Dw = Vf('');
            const Ds = _t ? _t.anchor : at,
              qm = Ht.layout.get('icon-text-fit').evaluate(oi, {}, je) !== 'none';
            let Zm = 0,
              $m = 0;
            if (
              (Ht._unevaluatedLayout.getValue('text-radial-offset') === void 0
                ? ([Zm, $m] = Ht.layout
                    .get('text-offset')
                    .evaluate(oi, {}, je)
                    .map((Nr) => Nr * Qi))
                : ((Zm = Ht.layout.get('text-radial-offset').evaluate(oi, {}, je) * Qi), ($m = Up)),
              pt.allowVerticalPlacement && Pt.vertical)
            ) {
              const Nr = Pt.vertical;
              if (Ee) (Sw = Gp(Nr)), Qt && (Aw = Gp(Qt));
              else {
                const Ur = Ht.layout.get('text-rotate').evaluate(oi, {}, je) + 90;
                (nc = Bu(Ce, Ds, at, be, te, Kt, Nr, Wt, Ur, Ae)), Qt && (zh = Bu(Ce, Ds, at, be, te, Kt, Qt, Qe, Ur));
              }
            }
            if (Ot) {
              const Nr = Ht.layout.get('icon-rotate').evaluate(oi, {}, je),
                Ur = _v(Ot, Nr, Pi, qm),
                Ua = Qt ? _v(Qt, Nr, Pi, qm) : void 0;
              (rc = Bu(Ce, Ds, at, be, te, Kt, Ot, Qe, Nr)), (Iw = 4 * Ur.length);
              const Rw = pt.iconSizeData;
              let Rs = null;
              Rw.kind === 'source' ? ((Rs = [vn * Ht.layout.get('icon-size').evaluate(oi, {}, je)]), Rs[0] > qo && B(`${pt.layerIds[0]}: Value for "icon-size" is >= ${Ol}. Reduce your "icon-size".`)) : Rw.kind === 'composite' && ((Rs = [vn * Ri.compositeIconSizes[0].evaluate(oi, {}, je), vn * Ri.compositeIconSizes[1].evaluate(oi, {}, je)]), (Rs[0] > qo || Rs[1] > qo) && B(`${pt.layerIds[0]}: Value for "icon-size" is >= ${Ol}. Reduce your "icon-size".`)), pt.addSymbols(pt.icon, Ur, Rs, Xe, Ci, oi, !1, _t, at, _o.lineStartIndex, _o.lineLength, -1, ci, je, rr, Gn), (jm = pt.icon.placedSymbolArray.length - 1), Ua && ((Cw = 4 * Ua.length), pt.addSymbols(pt.icon, Ua, Rs, Xe, Ci, oi, di.vertical, _t, at, _o.lineStartIndex, _o.lineLength, -1, ci, je, rr, Gn), (Gm = pt.icon.placedSymbolArray.length - 1));
            }
            for (const Nr in Pt.horizontal) {
              const Ur = Pt.horizontal[Nr];
              go || ((Dw = Vf(Ur.text)), Ee ? (Mw = Gp(Ur)) : (go = Bu(Ce, Ds, at, be, te, Kt, Ur, Wt, Ht.layout.get('text-rotate').evaluate(oi, {}, je), Ae)));
              const Ua = Ur.positionedLines.length === 1;
              if (((Pw += yv(pt, _t, at, Ur, Ut, Ht, Ee, oi, Ae, _o, Pt.vertical ? di.horizontal : di.horizontalOnly, Ua ? Object.keys(Pt.horizontal) : [Nr], qn, jm, Ri, ci, je, rr)), Ua)) break;
            }
            Pt.vertical && (zw += yv(pt, _t, at, Pt.vertical, Ut, Ht, Ee, oi, Ae, _o, di.vertical, ['vertical'], qn, Gm, Ri, ci, je, rr));
            let Jo = -1;
            const Hm = (Nr, Ur) => (Nr ? Math.max(Nr, Ur) : Ur);
            (Jo = Hm(Mw, Jo)), (Jo = Hm(Sw, Jo)), (Jo = Hm(Aw, Jo));
            const DD = Jo > -1 ? 1 : 0;
            pt.glyphOffsetArray.length >= Vl.MAX_GLYPHS && B('Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907'), oi.sortKey !== void 0 && pt.addToSortKeyRanges(pt.symbolInstances.length, oi.sortKey), pt.symbolInstances.emplaceBack(at.x, at.y, Ds.x, Ds.y, Ds.z, qn.right >= 0 ? qn.right : -1, qn.center >= 0 ? qn.center : -1, qn.left >= 0 ? qn.left : -1, qn.vertical >= 0 ? qn.vertical : -1, jm, Gm, Dw, go !== void 0 ? go : pt.collisionBoxArray.length, go !== void 0 ? go + 1 : pt.collisionBoxArray.length, nc !== void 0 ? nc : pt.collisionBoxArray.length, nc !== void 0 ? nc + 1 : pt.collisionBoxArray.length, rc !== void 0 ? rc : pt.collisionBoxArray.length, rc !== void 0 ? rc + 1 : pt.collisionBoxArray.length, zh || pt.collisionBoxArray.length, zh ? zh + 1 : pt.collisionBoxArray.length, be, Pw, zw, Iw, Cw, DD, 0, Zm, $m, Jo, 0, qm ? 1 : 0);
          })(e, nt, ht, st, i, r, n, q, e.layers[0], e.collisionBoxArray, t.index, t.sourceLayerIndex, e.index, I, k, l, 0, C, O, y, t, o, c, u, h, f, p);
        };
        if (V === 'line')
          for (const st of dv(t.geometry, 0, 0, lt, lt)) {
            const nt = jA(st, S, z, i.vertical || v, r, T, E, e.overscaling, lt);
            for (const ut of nt) (v && XA(e, v.text, R, ut)) || it(st, ut, h);
          }
        else if (V === 'line-center') {
          for (const st of t.geometry)
            if (st.length > 1) {
              const nt = VA(st, z, i.vertical || v, r, T, E);
              nt && it(st, nt, h);
            }
        } else if (t.type === 'Polygon')
          for (const st of Cp(t.geometry, 0)) {
            const nt = qA(st, 16);
            it(st[0], new mo(nt.x, nt.y, 0, 0, void 0), h);
          }
        else if (t.type === 'LineString') for (const st of t.geometry) it(st, new mo(st[0].x, st[0].y, 0, 0, void 0), h);
        else if (t.type === 'Point') for (const st of t.geometry) for (const nt of st) it([nt], new mo(nt.x, nt.y, 0, 0, void 0), h);
      }
      const Ol = 255,
        qo = Ol * vn;
      function yv(e, t, i, r, n, o, s, a, l, c, u, h, d, f, p, _, g, y) {
        const v = (function (b, E, S, I, C, z, k, O) {
            const V = [];
            if (E.positionedLines.length === 0) return V;
            const R = (I.layout.get('text-rotate').evaluate(z, {}) * Math.PI) / 180,
              G = (function (it) {
                const st = it[0],
                  nt = it[1],
                  ut = st * nt;
                return ut > 0 ? [st, -nt] : ut < 0 ? [-st, nt] : st === 0 ? [nt, st] : [nt, -st];
              })(S);
            let Z = Math.abs(E.top - E.bottom);
            for (const it of E.positionedLines) Z -= it.lineOffset;
            const X = E.positionedLines.length,
              j = Z / X;
            let q = E.top - S[1];
            for (let it = 0; it < X; ++it) {
              const st = E.positionedLines[it];
              q = GA(E, j, q, it);
              for (const nt of st.positionedGlyphs) {
                if (!nt.rect) continue;
                const ut = nt.rect || {};
                let ht = Qx + 1,
                  pt = !0,
                  at = 1,
                  _t = 0;
                if (nt.imageName) {
                  const Xe = k[nt.imageName];
                  if (!Xe) continue;
                  if (Xe.sdf) {
                    B('SDF images are not supported in formatted text and will be ignored.');
                    continue;
                  }
                  (pt = !1), (at = Xe.pixelRatio), (ht = Br / at);
                }
                const Ct = (C || O) && nt.vertical,
                  Pt = (nt.metrics.advance * nt.scale) / 2,
                  Ot = nt.metrics,
                  Ut = nt.rect;
                if (Ut === null) continue;
                O && E.verticalizable && (_t = nt.imageName ? Pt - (nt.metrics.width * nt.scale) / 2 : 0);
                const Qt = C ? [nt.x + Pt, nt.y] : [0, 0];
                let Ht = [0, 0],
                  Ce = [0, 0],
                  be = !1;
                C || (Ct ? ((Ce = [nt.x + Pt + G[0], nt.y + G[1] - _t]), (be = !0)) : (Ht = [nt.x + Pt + S[0], nt.y + S[1] - _t]));
                const te = (Ut.w * nt.scale) / (at * (nt.localGlyph ? bn : 1)),
                  Kt = (Ut.h * nt.scale) / (at * (nt.localGlyph ? bn : 1));
                let Wt, Ee, Ae, fe;
                if (Ct) {
                  const Xe = nt.y - q,
                    oi = new H(-Pt, Pt - Xe),
                    Ri = -Math.PI / 2,
                    Pi = new H(...Ce);
                  (Wt = new H(-Pt + Ht[0], Ht[1])), Wt._rotateAround(Ri, oi)._add(Pi), (Wt.x += -Xe + Pt), (Wt.y -= (Ot.left - ht) * nt.scale);
                  const ci = nt.imageName ? Ot.advance * nt.scale : Qi * nt.scale,
                    je = String.fromCodePoint(nt.glyph);
                  RA(je) ? (Wt.x += (1 - ht) * nt.scale) : LA(je) ? (Wt.x += ci - Ot.height * nt.scale + (-ht - 1) * nt.scale) : (Wt.x += nt.imageName || (Ot.width + 2 * ht === Ut.w && Ot.height + 2 * ht === Ut.h) ? (ci - Kt) / 2 : (ci - (Ot.height + 2 * ht) * nt.scale) / 2), (Ee = new H(Wt.x, Wt.y - te)), (Ae = new H(Wt.x + Kt, Wt.y)), (fe = new H(Wt.x + Kt, Wt.y - te));
                } else {
                  const Xe = (Ot.left - ht) * nt.scale - Pt + Ht[0],
                    oi = (-Ot.top - ht) * nt.scale + Ht[1],
                    Ri = Xe + te,
                    Pi = oi + Kt;
                  (Wt = new H(Xe, oi)), (Ee = new H(Ri, oi)), (Ae = new H(Xe, Pi)), (fe = new H(Ri, Pi));
                }
                if (R) {
                  let Xe;
                  (Xe = C ? new H(0, 0) : be ? new H(G[0], G[1]) : new H(S[0], S[1])), Wt._rotateAround(R, Xe), Ee._rotateAround(R, Xe), Ae._rotateAround(R, Xe), fe._rotateAround(R, Xe);
                }
                const Qe = new H(0, 0),
                  Ci = new H(0, 0);
                V.push({ tl: Wt, tr: Ee, bl: Ae, br: fe, texPrimary: ut, texSecondary: void 0, writingMode: E.writingMode, glyphOffset: Qt, sectionIndex: nt.sectionIndex, isSDF: pt, pixelOffsetTL: Qe, pixelOffsetBR: Ci, minFontScaleX: 0, minFontScaleY: 0 });
              }
            }
            return V;
          })(0, r, l, o, s, a, n, e.allowVerticalPlacement),
          w = e.textSizeData;
        let T = null;
        w.kind === 'source' ? ((T = [vn * o.layout.get('text-size').evaluate(a, {}, g)]), T[0] > qo && B(`${e.layerIds[0]}: Value for "text-size" is >= ${Ol}. Reduce your "text-size".`)) : w.kind === 'composite' && ((T = [vn * p.compositeTextSizes[0].evaluate(a, {}, g), vn * p.compositeTextSizes[1].evaluate(a, {}, g)]), (T[0] > qo || T[1] > qo) && B(`${e.layerIds[0]}: Value for "text-size" is >= ${Ol}. Reduce your "text-size".`)), e.addSymbols(e.text, v, T, l, s, a, u, t, i, c.lineStartIndex, c.lineLength, f, _, g, y, !1);
        for (const b of h) d[b] = e.text.placedSymbolArray.length - 1;
        return 4 * v.length;
      }
      function xv(e) {
        for (const t in e) return e[t];
        return null;
      }
      function Bu(e, t, i, r, n, o, s, a, l, c) {
        let u = s.top,
          h = s.bottom,
          d = s.left,
          f = s.right;
        const p = s.collisionPadding;
        if ((p && ((d -= p[0]), (u -= p[1]), (f += p[2]), (h += p[3])), l)) {
          const _ = new H(d, u),
            g = new H(f, u),
            y = new H(d, h),
            v = new H(f, h),
            w = ne(l);
          let T = new H(0, 0);
          c && (T = new H(c[0], c[1])), _._rotateAround(w, T), g._rotateAround(w, T), y._rotateAround(w, T), v._rotateAround(w, T), (d = Math.min(_.x, g.x, y.x, v.x)), (f = Math.max(_.x, g.x, y.x, v.x)), (u = Math.min(_.y, g.y, y.y, v.y)), (h = Math.max(_.y, g.y, y.y, v.y));
        }
        return e.emplaceBack(t.x, t.y, t.z, i.x, i.y, d, u, f, h, a, r, n, o), e.length - 1;
      }
      function Gp(e) {
        e.collisionPadding && ((e.top -= e.collisionPadding[1]), (e.bottom += e.collisionPadding[3]));
        const t = e.bottom - e.top;
        return t > 0 ? Math.max(10, t) : null;
      }
      function XA(e, t, i, r) {
        const n = e.compareText;
        if (t in n) {
          const o = n[t];
          for (let s = o.length - 1; s >= 0; s--) if (r.dist(o[s]) < i) return !0;
        } else n[t] = [];
        return n[t].push(r), !1;
      }
      function vv(e, t) {
        const i = e.fovAboveCenter,
          r = e.elevation ? e.elevation.getMinElevationBelowMSL() * t : 0,
          n = (e._camera.position[2] * e.worldSize - r) / Math.cos(e._pitch),
          o = (Math.sin(i) * n) / Math.sin(Math.max(Math.PI / 2 - e._pitch - i, 0.01)),
          s = Math.sin(e._pitch) * o + n;
        return Math.min(1.01 * s, n * (1 / e._horizonShift));
      }
      function Es(e, t) {
        if (!t.isReprojectedInTileSpace) return { scale: 1 << e.z, x: e.x, y: e.y, x2: e.x + 1, y2: e.y + 1, projection: t };
        const i = Math.pow(2, -e.z),
          r = e.x * i,
          n = (e.x + 1) * i,
          o = e.y * i,
          s = (e.y + 1) * i,
          a = Or(r),
          l = Or(n),
          c = Ni(o),
          u = Ni(s),
          h = t.project(a, c),
          d = t.project(l, c),
          f = t.project(l, u),
          p = t.project(a, u);
        let _ = Math.min(h.x, d.x, f.x, p.x),
          g = Math.min(h.y, d.y, f.y, p.y),
          y = Math.max(h.x, d.x, f.x, p.x),
          v = Math.max(h.y, d.y, f.y, p.y);
        const w = i / 16;
        function T(E, S, I, C, z, k) {
          const O = (I + z) / 2,
            V = (C + k) / 2,
            R = t.project(Or(O), Ni(V)),
            G = Math.max(0, _ - R.x, g - R.y, R.x - y, R.y - v);
          (_ = Math.min(_, R.x)), (y = Math.max(y, R.x)), (g = Math.min(g, R.y)), (v = Math.max(v, R.y)), G > w && (T(E, R, I, C, O, V), T(R, S, O, V, z, k));
        }
        T(h, d, r, o, n, o), T(d, f, n, o, n, s), T(f, p, n, s, r, s), T(p, h, r, s, r, o), (_ -= w), (g -= w), (y += w), (v += w);
        const b = 1 / Math.max(y - _, v - g);
        return { scale: b, x: _ * b, y: g * b, x2: y * b, y2: v * b, projection: t };
      }
      function bv(e, t, i, r, n, o, s, a, l) {
        if (l.name === 'globe') return hp(e, t, new cn(i, r, n), !1);
        const c = Es({ z: i, x: r, y: n }, l);
        return new ni([(o + c.x / c.scale) * t, t * (c.y / c.scale), s], [(o + c.x2 / c.scale) * t, t * (c.y2 / c.scale), a]);
      }
      function wv(e, { x: t, y: i }, r = 0) {
        return new H(((t - r) * e.scale - e.x) * lt, (i * e.scale - e.y) * lt);
      }
      function Tv(e, t, i = 0) {
        return N.fromValues(((t.x - i) * e.scale - e.x) * lt, (t.y * e.scale - e.y) * lt, dx(t.z, t.y));
      }
      const YA = J.identity(new Float32Array(16));
      class Zo {
        constructor(t) {
          (this.spec = t), (this.name = t.name), (this.wrap = !1), (this.requiresDraping = !1), (this.supportsWorldCopies = !1), (this.supportsTerrain = !1), (this.supportsFog = !1), (this.supportsFreeCamera = !1), (this.zAxisUnit = 'meters'), (this.isReprojectedInTileSpace = !0), (this.unsupportedLayers = ['custom']), (this.center = [0, 0]), (this.range = [3.5, 7]);
        }
        project(t, i) {
          return { x: 0, y: 0, z: 0 };
        }
        unproject(t, i) {
          return new ie(0, 0);
        }
        projectTilePoint(t, i, r) {
          return { x: t, y: i, z: 0 };
        }
        locationPoint(t, i, r = !0) {
          return t._coordinatePoint(t.locationCoordinate(i), r);
        }
        pixelsPerMeter(t, i) {
          return Je(1, t) * i;
        }
        pixelSpaceConversion(t, i, r) {
          return 1;
        }
        farthestPixelDistance(t) {
          return vv(t, t.pixelsPerMeter);
        }
        pointCoordinate(t, i, r, n) {
          const o = t.horizonLineFromTop(!1),
            s = new H(i, Math.max(o, r));
          return t.rayIntersectionCoordinate(t.pointRayIntersection(s, n));
        }
        pointCoordinate3D(t, i, r) {
          const n = new H(i, r);
          if (t.elevation) return t.elevation.pointCoordinate(n);
          {
            const o = this.pointCoordinate(t, n.x, n.y, 0);
            return [o.x, o.y, o.z];
          }
        }
        isPointAboveHorizon(t, i) {
          if (t.elevation) return !this.pointCoordinate3D(t, i.x, i.y);
          const r = t.horizonLineFromTop();
          return i.y < r;
        }
        createInversionMatrix(t, i) {
          return YA;
        }
        createTileMatrix(t, i, r) {
          let n, o, s;
          const a = r.canonical,
            l = J.identity(new Float64Array(16));
          if (this.isReprojectedInTileSpace) {
            const c = Es(a, this);
            (n = 1), (o = c.x + r.wrap * c.scale), (s = c.y), J.scale(l, l, [n / c.scale, n / c.scale, t.pixelsPerMeter / i]);
          } else (n = i / t.zoomScale(a.z)), (o = (a.x + Math.pow(2, a.z) * r.wrap) * n), (s = a.y * n);
          return J.translate(l, l, [o, s, 0]), J.scale(l, l, [n / lt, n / lt, 1]), l;
        }
        upVector(t, i, r) {
          return [0, 0, 1];
        }
        upVectorScale(t, i, r) {
          return { metersToTile: 1 };
        }
      }
      class KA extends Zo {
        constructor(t) {
          super(t), (this.range = [4, 7]), (this.center = t.center || [-96, 37.5]);
          const [i, r] = (this.parallels = t.parallels || [29.5, 45.5]),
            n = Math.sin(ne(i));
          (this.n = (n + Math.sin(ne(r))) / 2), (this.c = 1 + n * (2 * this.n - n)), (this.r0 = Math.sqrt(this.c) / this.n);
        }
        project(t, i) {
          const { n: r, c: n, r0: o } = this,
            s = ne(t - this.center[0]),
            a = ne(i),
            l = Math.sqrt(n - 2 * r * Math.sin(a)) / r;
          return { x: l * Math.sin(s * r), y: l * Math.cos(s * r) - o, z: 0 };
        }
        unproject(t, i) {
          const { n: r, c: n, r0: o } = this,
            s = o + i;
          let a = Math.atan2(t, Math.abs(s)) * Math.sign(s);
          s * r < 0 && (a -= Math.PI * Math.sign(t) * Math.sign(s));
          const l = ne(this.center[0]) * r;
          a = en(a, -Math.PI - l, Math.PI - l);
          const c = Bt(Vi(a / r) + this.center[0], -180, 180),
            u = Math.asin(Bt((n - (t * t + s * s) * r * r) / (2 * r), -1, 1)),
            h = Bt(Vi(u), -Ii, Ii);
          return new ie(c, h);
        }
      }
      const Bl = 1.340264,
        Fl = -0.081106,
        Nl = 893e-6,
        Ul = 0.003796,
        Fu = Math.sqrt(3) / 2;
      class JA extends Zo {
        project(t, i) {
          (i = (i / 180) * Math.PI), (t = (t / 180) * Math.PI);
          const r = Math.asin(Fu * Math.sin(i)),
            n = r * r,
            o = n * n * n;
          return { x: 0.5 * ((t * Math.cos(r)) / (Fu * (Bl + 3 * Fl * n + o * (7 * Nl + 9 * Ul * n))) / Math.PI + 0.5), y: 1 - 0.5 * ((r * (Bl + Fl * n + o * (Nl + Ul * n))) / Math.PI + 1), z: 0 };
        }
        unproject(t, i) {
          t = (2 * t - 0.5) * Math.PI;
          let r = (i = (2 * (1 - i) - 1) * Math.PI),
            n = r * r,
            o = n * n * n;
          for (let u, h, d, f = 0; f < 12 && ((h = r * (Bl + Fl * n + o * (Nl + Ul * n)) - i), (d = Bl + 3 * Fl * n + o * (7 * Nl + 9 * Ul * n)), (u = h / d), (r = Bt(r - u, -Math.PI / 3, Math.PI / 3)), (n = r * r), (o = n * n * n), !(Math.abs(u) < 1e-12)); ++f);
          const s = (Fu * t * (Bl + 3 * Fl * n + o * (7 * Nl + 9 * Ul * n))) / Math.cos(r),
            a = Math.asin(Math.sin(r) / Fu),
            l = Bt((180 * s) / Math.PI, -180, 180),
            c = Bt((180 * a) / Math.PI, -Ii, Ii);
          return new ie(l, c);
        }
      }
      class QA extends Zo {
        constructor(t) {
          super(t), (this.wrap = !0), (this.supportsWorldCopies = !0);
        }
        project(t, i) {
          return { x: 0.5 + t / 360, y: 0.5 - i / 360, z: 0 };
        }
        unproject(t, i) {
          const r = 360 * (t - 0.5),
            n = Bt(360 * (0.5 - i), -Ii, Ii);
          return new ie(r, n);
        }
      }
      const Pa = Math.PI / 2;
      function Nu(e) {
        return Math.tan((Pa + e) / 2);
      }
      class tI extends Zo {
        constructor(t) {
          super(t), (this.center = t.center || [0, 30]);
          const [i, r] = (this.parallels = t.parallels || [30, 30]);
          let n = ne(i),
            o = ne(r);
          (this.southernCenter = n + o < 0), this.southernCenter && ((n = -n), (o = -o));
          const s = Math.cos(n),
            a = Nu(n);
          (this.n = n === o ? Math.sin(n) : Math.log(s / Math.cos(o)) / Math.log(Nu(o) / a)), (this.f = (s * Math.pow(Nu(n), this.n)) / this.n);
        }
        project(t, i) {
          (i = ne(i)), this.southernCenter && (i = -i), (t = ne(t - this.center[0]));
          const r = 1e-6,
            { n, f: o } = this;
          o > 0 ? i < -Pa + r && (i = -Pa + r) : i > Pa - r && (i = Pa - r);
          const s = o / Math.pow(Nu(i), n);
          let a = s * Math.sin(n * t),
            l = o - s * Math.cos(n * t);
          return (a = 0.5 * (a / Math.PI + 0.5)), (l = 0.5 * (l / Math.PI + 0.5)), { x: a, y: this.southernCenter ? l : 1 - l, z: 0 };
        }
        unproject(t, i) {
          (t = (2 * t - 0.5) * Math.PI), this.southernCenter && (i = 1 - i), (i = (2 * (1 - i) - 0.5) * Math.PI);
          const { n: r, f: n } = this,
            o = n - i,
            s = Math.sign(o),
            a = Math.sign(r) * Math.sqrt(t * t + o * o);
          let l = Math.atan2(t, Math.abs(o)) * s;
          o * r < 0 && (l -= Math.PI * Math.sign(t) * s);
          const c = Bt(Vi(l / r) + this.center[0], -180, 180),
            u = Bt(Vi(2 * Math.atan(Math.pow(n / a, 1 / r)) - Pa), -Ii, Ii);
          return new ie(c, this.southernCenter ? -u : u);
        }
      }
      class Ev extends Zo {
        constructor(t) {
          super(t), (this.wrap = !0), (this.supportsWorldCopies = !0), (this.supportsTerrain = !0), (this.supportsFog = !0), (this.supportsFreeCamera = !0), (this.isReprojectedInTileSpace = !1), (this.unsupportedLayers = []), (this.range = null);
        }
        project(t, i) {
          return { x: qi(t), y: Hi(i), z: 0 };
        }
        unproject(t, i) {
          const r = Or(t),
            n = Ni(i);
          return new ie(r, n);
        }
      }
      const Mv = ne(Ii);
      class eI extends Zo {
        project(t, i) {
          const r = (i = ne(i)) * i,
            n = r * r;
          return { x: 0.5 * (((t = ne(t)) * (0.8707 - 0.131979 * r + n * (n * (0.003971 * r - 0.001529 * n) - 0.013791))) / Math.PI + 0.5), y: 1 - 0.5 * ((i * (1.007226 + r * (0.015085 + n * (0.028874 * r - 0.044475 - 0.005916 * n)))) / Math.PI + 1), z: 0 };
        }
        unproject(t, i) {
          t = (2 * t - 0.5) * Math.PI;
          let r = (i = (2 * (1 - i) - 1) * Math.PI),
            n = 25,
            o = 0,
            s = r * r;
          do {
            s = r * r;
            const c = s * s;
            (o = (r * (1.007226 + s * (0.015085 + c * (0.028874 * s - 0.044475 - 0.005916 * c))) - i) / (1.007226 + s * (0.045255 + c * (0.259866 * s - 0.311325 - 0.005916 * 11 * c)))), (r = Bt(r - o, -Mv, Mv));
          } while (Math.abs(o) > 1e-6 && --n > 0);
          s = r * r;
          const a = Bt(Vi(t / (0.8707 + s * (s * (s * s * s * (0.003971 - 0.001529 * s) - 0.013791) - 0.131979))), -180, 180),
            l = Vi(r);
          return new ie(a, l);
        }
      }
      const Sv = ne(Ii);
      class iI extends Zo {
        project(t, i) {
          (i = ne(i)), (t = ne(t));
          const r = Math.cos(i),
            n = 2 / Math.PI,
            o = Math.acos(r * Math.cos(t / 2)),
            s = Math.sin(o) / o,
            a = 0.5 * (t * n + (2 * r * Math.sin(t / 2)) / s) || 0,
            l = 0.5 * (i + Math.sin(i) / s) || 0;
          return { x: 0.5 * (a / Math.PI + 0.5), y: 1 - 0.5 * (l / Math.PI + 1), z: 0 };
        }
        unproject(t, i) {
          let r = (t = (2 * t - 0.5) * Math.PI),
            n = (i = (2 * (1 - i) - 1) * Math.PI),
            o = 25;
          const s = 1e-6;
          let a = 0,
            l = 0;
          do {
            const c = Math.cos(n),
              u = Math.sin(n),
              h = 2 * u * c,
              d = u * u,
              f = c * c,
              p = Math.cos(r / 2),
              _ = Math.sin(r / 2),
              g = 2 * p * _,
              y = _ * _,
              v = 1 - f * p * p,
              w = v ? 1 / v : 0,
              T = v ? Math.acos(c * p) * Math.sqrt(1 / v) : 0,
              b = 0.5 * (2 * T * c * _ + (2 * r) / Math.PI) - t,
              E = 0.5 * (T * u + n) - i,
              S = 0.5 * w * (f * y + T * c * p * d) + 1 / Math.PI,
              I = w * ((g * h) / 4 - T * u * _),
              C = 0.125 * w * (h * _ - T * u * f * g),
              z = 0.5 * w * (d * p + T * y * c) + 0.5,
              k = I * C - z * S;
            (a = (E * I - b * z) / k), (l = (b * C - E * S) / k), (r = Bt(r - a, -Math.PI, Math.PI)), (n = Bt(n - l, -Sv, Sv));
          } while ((Math.abs(a) > s || Math.abs(l) > s) && --o > 0);
          return new ie(Vi(r), Vi(n));
        }
      }
      class Av extends Zo {
        constructor(t) {
          super(t), (this.center = t.center || [0, 0]), (this.parallels = t.parallels || [0, 0]), (this.cosPhi = Math.max(0.01, Math.cos(ne(this.parallels[0])))), (this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi))), (this.wrap = !0), (this.supportsWorldCopies = !0);
        }
        project(t, i) {
          const { scale: r, cosPhi: n } = this;
          return { x: ne(t) * n * r + 0.5, y: (-Math.sin(ne(i)) / n) * r + 0.5, z: 0 };
        }
        unproject(t, i) {
          const { scale: r, cosPhi: n } = this,
            o = -(i - 0.5) / r,
            s = Bt(Vi((t - 0.5) / r) / n, -180, 180),
            a = Math.asin(Bt(o * n, -1, 1)),
            l = Bt(Vi(a), -Ii, Ii);
          return new ie(s, l);
        }
      }
      class rI extends Ev {
        constructor(t) {
          super(t), (this.requiresDraping = !0), (this.supportsWorldCopies = !1), (this.supportsFog = !0), (this.zAxisUnit = 'pixels'), (this.unsupportedLayers = ['debug']), (this.range = [3, 5]);
        }
        projectTilePoint(t, i, r) {
          const n = Al(t, i, r),
            o = Bo(Yr(r));
          return N.transformMat4(n, n, o), { x: n[0], y: n[1], z: n[2] };
        }
        locationPoint(t, i) {
          const r = wr(i.lat, i.lng),
            n = N.normalize([], r),
            o = t.elevation ? t.elevation.getAtPointOrZero(t.locationCoordinate(i), t._centerAltitude) : t._centerAltitude,
            s = Je(1, 0) * lt * o;
          N.scaleAndAdd(r, r, n, s);
          const a = J.identity(new Float64Array(16));
          return J.multiply(a, t.pixelMatrix, t.globeMatrix), N.transformMat4(r, r, a), new H(r[0], r[1]);
        }
        pixelsPerMeter(t, i) {
          return Je(1, 0) * i;
        }
        pixelSpaceConversion(t, i, r) {
          const n = Je(1, t) * i,
            o = ee(Je(1, 45) * i, n, r);
          return this.pixelsPerMeter(t, i) / o;
        }
        createTileMatrix(t, i, r) {
          const n = fp(Yr(r.canonical));
          return J.multiply(new Float64Array(16), t.globeMatrix, n);
        }
        createInversionMatrix(t, i) {
          const { center: r } = t,
            n = Bo(Yr(i));
          return J.rotateY(n, n, ne(r.lng)), J.rotateX(n, n, ne(r.lat)), J.scale(n, n, [t._pixelsPerMercatorPixel, t._pixelsPerMercatorPixel, 1]), Float32Array.from(n);
        }
        pointCoordinate(t, i, r, n) {
          return Q0(t, i, r, !0) || new Me(0, 0);
        }
        pointCoordinate3D(t, i, r) {
          const n = this.pointCoordinate(t, i, r, 0);
          return [n.x, n.y, n.z];
        }
        isPointAboveHorizon(t, i) {
          return !Q0(t, i.x, i.y, !1);
        }
        farthestPixelDistance(t) {
          const i = (function (n, o) {
              const s = n.cameraToCenterDistance,
                a = n._centerAltitude * o,
                l = n._camera,
                c = n._camera.forward(),
                u = N.add([], N.scale([], c, -s), [0, 0, a]),
                h = n.worldSize / (2 * Math.PI),
                d = [0, 0, -h],
                f = n.width / n.height,
                p = Math.tan(n.fovAboveCenter),
                _ = N.scale([], l.up(), p),
                g = N.scale([], l.right(), p * f),
                y = N.normalize([], N.add([], N.add([], c, _), g)),
                v = [];
              let w;
              if (new cu(u, y).closestPointOnSphere(d, h, v)) {
                const T = N.add([], v, d),
                  b = N.sub([], T, u);
                w = Math.cos(n.fovAboveCenter) * N.length(b);
              } else {
                const T = N.sub([], u, d),
                  b = N.sub([], d, u);
                N.normalize(b, b);
                const E = N.length(T) - h;
                w = Math.sqrt(E * (E + 2 * h));
                const S = Math.acos(w / (h + E)) - Math.acos(N.dot(c, b));
                w *= Math.cos(S);
              }
              return 1.01 * w;
            })(t, this.pixelsPerMeter(t.center.lat, t.worldSize)),
            r = Ji(t.zoom);
          if (r > 0) {
            const n = vv(t, Je(1, t.center.lat) * t.worldSize),
              o = t.worldSize / (2 * Math.PI),
              s = (Math.max(t.width, t.height) / t.worldSize) * Math.PI;
            return ee(i, n + o * (1 - Math.cos(s)), Math.pow(r, 10));
          }
          return i;
        }
        upVector(t, i, r) {
          return Al(i, r, t, 1);
        }
        upVectorScale(t) {
          return { metersToTile: uu(du(Yr(t))) };
        }
      }
      function Uu(e) {
        const t = e.parallels,
          i = !!t && Math.abs(t[0] + t[1]) < 0.01;
        switch (e.name) {
          case 'mercator':
            return new Ev(e);
          case 'equirectangular':
            return new QA(e);
          case 'naturalEarth':
            return new eI(e);
          case 'equalEarth':
            return new JA(e);
          case 'winkelTripel':
            return new iI(e);
          case 'albers':
            return i ? new Av(e) : new KA(e);
          case 'lambertConformalConic':
            return i ? new Av(e) : new tI(e);
          case 'globe':
            return new rI(e);
        }
        throw new Error(`Invalid projection name: ${e.name}`);
      }
      const nI = new Mi({
        'symbol-placement': new vt(Q.layout_symbol['symbol-placement']),
        'symbol-spacing': new vt(Q.layout_symbol['symbol-spacing']),
        'symbol-avoid-edges': new vt(Q.layout_symbol['symbol-avoid-edges']),
        'symbol-sort-key': new Xt(Q.layout_symbol['symbol-sort-key']),
        'symbol-z-order': new vt(Q.layout_symbol['symbol-z-order']),
        'symbol-z-elevate': new vt(Q.layout_symbol['symbol-z-elevate']),
        'icon-allow-overlap': new vt(Q.layout_symbol['icon-allow-overlap']),
        'icon-ignore-placement': new vt(Q.layout_symbol['icon-ignore-placement']),
        'icon-optional': new vt(Q.layout_symbol['icon-optional']),
        'icon-rotation-alignment': new vt(Q.layout_symbol['icon-rotation-alignment']),
        'icon-size': new Xt(Q.layout_symbol['icon-size']),
        'icon-text-fit': new Xt(Q.layout_symbol['icon-text-fit']),
        'icon-text-fit-padding': new Xt(Q.layout_symbol['icon-text-fit-padding']),
        'icon-image': new Xt(Q.layout_symbol['icon-image']),
        'icon-rotate': new Xt(Q.layout_symbol['icon-rotate']),
        'icon-padding': new vt(Q.layout_symbol['icon-padding']),
        'icon-keep-upright': new vt(Q.layout_symbol['icon-keep-upright']),
        'icon-offset': new Xt(Q.layout_symbol['icon-offset']),
        'icon-anchor': new Xt(Q.layout_symbol['icon-anchor']),
        'icon-pitch-alignment': new vt(Q.layout_symbol['icon-pitch-alignment']),
        'text-pitch-alignment': new vt(Q.layout_symbol['text-pitch-alignment']),
        'text-rotation-alignment': new vt(Q.layout_symbol['text-rotation-alignment']),
        'text-field': new Xt(Q.layout_symbol['text-field']),
        'text-font': new Xt(Q.layout_symbol['text-font']),
        'text-size': new Xt(Q.layout_symbol['text-size']),
        'text-max-width': new Xt(Q.layout_symbol['text-max-width']),
        'text-line-height': new Xt(Q.layout_symbol['text-line-height']),
        'text-letter-spacing': new Xt(Q.layout_symbol['text-letter-spacing']),
        'text-justify': new Xt(Q.layout_symbol['text-justify']),
        'text-radial-offset': new Xt(Q.layout_symbol['text-radial-offset']),
        'text-variable-anchor': new vt(Q.layout_symbol['text-variable-anchor']),
        'text-anchor': new Xt(Q.layout_symbol['text-anchor']),
        'text-max-angle': new vt(Q.layout_symbol['text-max-angle']),
        'text-writing-mode': new vt(Q.layout_symbol['text-writing-mode']),
        'text-rotate': new Xt(Q.layout_symbol['text-rotate']),
        'text-padding': new vt(Q.layout_symbol['text-padding']),
        'text-keep-upright': new vt(Q.layout_symbol['text-keep-upright']),
        'text-transform': new Xt(Q.layout_symbol['text-transform']),
        'text-offset': new Xt(Q.layout_symbol['text-offset']),
        'text-allow-overlap': new vt(Q.layout_symbol['text-allow-overlap']),
        'text-ignore-placement': new vt(Q.layout_symbol['text-ignore-placement']),
        'text-optional': new vt(Q.layout_symbol['text-optional']),
        visibility: new vt(Q.layout_symbol.visibility),
      });
      var qp = { paint: new Mi({ 'icon-opacity': new Xt(Q.paint_symbol['icon-opacity']), 'icon-emissive-strength': new Xt(Q.paint_symbol['icon-emissive-strength']), 'text-emissive-strength': new Xt(Q.paint_symbol['text-emissive-strength']), 'icon-color': new Xt(Q.paint_symbol['icon-color']), 'icon-halo-color': new Xt(Q.paint_symbol['icon-halo-color']), 'icon-halo-width': new Xt(Q.paint_symbol['icon-halo-width']), 'icon-halo-blur': new Xt(Q.paint_symbol['icon-halo-blur']), 'icon-translate': new vt(Q.paint_symbol['icon-translate']), 'icon-translate-anchor': new vt(Q.paint_symbol['icon-translate-anchor']), 'icon-image-cross-fade': new Xt(Q.paint_symbol['icon-image-cross-fade']), 'text-opacity': new Xt(Q.paint_symbol['text-opacity']), 'text-color': new Xt(Q.paint_symbol['text-color'], { runtimeType: nn, getOverride: (e) => e.textColor, hasOverride: (e) => !!e.textColor }), 'text-halo-color': new Xt(Q.paint_symbol['text-halo-color']), 'text-halo-width': new Xt(Q.paint_symbol['text-halo-width']), 'text-halo-blur': new Xt(Q.paint_symbol['text-halo-blur']), 'text-translate': new vt(Q.paint_symbol['text-translate']), 'text-translate-anchor': new vt(Q.paint_symbol['text-translate-anchor']), 'icon-color-saturation': new vt(Q.paint_symbol['icon-color-saturation']) }), layout: nI };
      class Iv {
        constructor(t) {
          (this.type = t.property.overrides ? t.property.overrides.runtimeType : Ks), (this.defaultValue = t);
        }
        evaluate(t) {
          if (t.formattedSection) {
            const i = this.defaultValue.property.overrides;
            if (i && i.hasOverride(t.formattedSection)) return i.getOverride(t.formattedSection);
          }
          return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default;
        }
        eachChild(t) {
          this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          return null;
        }
      }
      Gt(Iv, 'FormatSectionOverride', { omit: ['defaultValue'] });
      class Vu extends Hr {
        constructor(t, i) {
          super(t, qp, i);
        }
        recalculate(t, i) {
          super.recalculate(t, i), this.layout.get('icon-rotation-alignment') === 'auto' && (this.layout._values['icon-rotation-alignment'] = this.layout.get('symbol-placement') !== 'point' ? 'map' : 'viewport'), this.layout.get('text-rotation-alignment') === 'auto' && (this.layout._values['text-rotation-alignment'] = this.layout.get('symbol-placement') !== 'point' ? 'map' : 'viewport'), this.layout.get('text-pitch-alignment') === 'auto' && (this.layout._values['text-pitch-alignment'] = this.layout.get('text-rotation-alignment')), this.layout.get('icon-pitch-alignment') === 'auto' && (this.layout._values['icon-pitch-alignment'] = this.layout.get('icon-rotation-alignment'));
          const r = this.layout.get('text-writing-mode');
          if (r) {
            const n = [];
            for (const o of r) n.indexOf(o) < 0 && n.push(o);
            this.layout._values['text-writing-mode'] = n;
          } else this.layout._values['text-writing-mode'] = this.layout.get('symbol-placement') === 'point' ? ['horizontal'] : ['horizontal', 'vertical'];
          this._setPaintOverrides();
        }
        getValueAndResolveTokens(t, i, r, n) {
          const o = this.layout.get(t).evaluate(i, {}, r, n),
            s = this._unevaluatedLayout._values[t];
          return s.isDataDriven() || Nc(s.value) || !o
            ? o
            : (function (a, l) {
                return l.replace(/{([^{}]+)}/g, (c, u) => (u in a ? String(a[u]) : ''));
              })(i.properties, o);
        }
        createBucket(t) {
          return new Vl(t);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          return !1;
        }
        _setPaintOverrides() {
          for (const t of qp.paint.overridableProperties) {
            if (!Vu.hasPaintOverride(this.layout, t)) continue;
            const i = this.paint.get(t),
              r = new Iv(i),
              n = new cf(r, i.property.specification);
            let o = null;
            (o = i.value.kind === 'constant' || i.value.kind === 'source' ? new uf('source', n) : new Ao('composite', n, i.value.zoomStops, i.value._interpolationType)), (this.paint._values[t] = new da(i.property, o, i.parameters));
          }
        }
        _handleOverridablePaintPropertyUpdate(t, i, r) {
          return !(!this.layout || i.isDataDriven() || r.isDataDriven()) && Vu.hasPaintOverride(this.layout, t);
        }
        static hasPaintOverride(t, i) {
          const r = t.get('text-field'),
            n = qp.paint.properties[i];
          let o = !1;
          const s = (a) => {
            for (const l of a) if (n.overrides && n.overrides.hasOverride(l)) return void (o = !0);
          };
          if (r.value.kind === 'constant' && r.value.value instanceof zr) s(r.value.value.sections);
          else if (r.value.kind === 'source') {
            const a = (c) => {
                o || (c instanceof nl && Xi(c.value) === Qa ? s(c.value.sections) : c instanceof ol ? s(c.sections) : c.eachChild(a));
              },
              l = r.value;
            l._styleExpression && a(l._styleExpression.expression);
          }
          return o;
        }
        getProgramIds() {
          const t = this.paint.get('icon-opacity').constantOr(1) !== 0,
            i = this.paint.get('text-opacity').constantOr(1) !== 0,
            r = [];
          return t && r.push('symbolIcon'), i && r.push('symbolSDF'), r;
        }
        getDefaultProgramParams(t, i) {
          return { config: new vs(this, i), overrideFog: !1 };
        }
      }
      const oI = Su.types,
        sI = [{ name: 'a_fade_opacity', components: 1, type: 'Uint8', offset: 0 }];
      function ju(e, t, i, r, n, o, s, a, l, c, u, h, d) {
        const f = a ? Math.min(qo, Math.round(a[0])) : 0,
          p = a ? Math.min(qo, Math.round(a[1])) : 0;
        e.emplaceBack(t, i, Math.round(32 * r), Math.round(32 * n), o, s, (f << 1) + (l ? 1 : 0), p, 16 * c, 16 * u, 256 * h, 256 * d);
      }
      function Gu(e, t, i) {
        e.emplaceBack(t, i);
      }
      function qu(e, t, i, r, n, o, s) {
        e.emplaceBack(t, i, r, n, o, s);
      }
      function Zu(e, t, i, r, n) {
        const o = 5 * t + 2;
        (e.float32[o + 0] = i), (e.float32[o + 1] = r), (e.float32[o + 2] = n);
      }
      function za(e, t, i, r, n) {
        e.emplaceBack(t, i, r, n), e.emplaceBack(t, i, r, n), e.emplaceBack(t, i, r, n), e.emplaceBack(t, i, r, n);
      }
      function aI(e) {
        for (const t of e.sections) if (TM(t.text)) return !0;
        return !1;
      }
      class Zp {
        constructor(t) {
          (this.layoutVertexArray = new If()), (this.indexArray = new Fi()), (this.programConfigurations = t), (this.segments = new He()), (this.dynamicLayoutVertexArray = new ro()), (this.opacityVertexArray = new Pf()), (this.placedSymbolArray = new vy()), (this.iconTransitioningVertexArray = new zo()), (this.globeExtVertexArray = new Cf()), (this.zOffsetVertexArray = new xl());
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0 && this.iconTransitioningVertexArray.length === 0;
        }
        upload(t, i, r, n, o) {
          this.isEmpty() || (r && ((this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, TA.members)), (this.indexBuffer = t.createIndexBuffer(this.indexArray, i)), (this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, MA.members, !0)), (this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, sI, !0)), this.iconTransitioningVertexArray.length > 0 && (this.iconTransitioningVertexBuffer = t.createVertexBuffer(this.iconTransitioningVertexArray, AA.members, !0)), this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = t.createVertexBuffer(this.globeExtVertexArray, EA.members, !0)), !this.zOffsetVertexBuffer && (this.zOffsetVertexArray.length > 0 || o) && (this.zOffsetVertexBuffer = t.createVertexBuffer(this.zOffsetVertexArray, SA.members, !0)), (this.opacityVertexBuffer.itemSize = 1)), (r || n) && this.programConfigurations.upload(t));
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy(), this.iconTransitioningVertexBuffer && this.iconTransitioningVertexBuffer.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy(), this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy());
        }
      }
      Gt(Zp, 'SymbolBuffers');
      class $p {
        constructor(t, i, r) {
          (this.layoutVertexArray = new t()), (this.layoutAttributes = i), (this.indexArray = new r()), (this.segments = new He()), (this.collisionVertexArray = new Rf()), (this.collisionVertexArrayExt = new ro());
        }
        upload(t) {
          (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes)), (this.indexBuffer = t.createIndexBuffer(this.indexArray)), (this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, IA.members, !0)), (this.collisionVertexBufferExt = t.createVertexBuffer(this.collisionVertexArrayExt, CA.members, !0));
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy());
        }
      }
      Gt($p, 'CollisionBuffers');
      class $u {
        constructor(t) {
          (this.collisionBoxArray = t.collisionBoxArray), (this.zoom = t.zoom), (this.overscaling = t.overscaling), (this.layers = t.layers), (this.layerIds = this.layers.map((s) => s.fqid)), (this.index = t.index), (this.pixelRatio = t.pixelRatio), (this.sourceLayerIndex = t.sourceLayerIndex), (this.hasPattern = !1), (this.hasRTLText = !1), (this.fullyClipped = !1), (this.hasAnyIconTextFit = !1), (this.sortKeyRanges = []), (this.collisionCircleArray = []), (this.placementInvProjMatrix = J.identity([])), (this.placementViewportMatrix = J.identity([]));
          const i = this.layers[0]._unevaluatedLayout._values;
          (this.textSizeData = kp(this.zoom, i['text-size'])), (this.iconSizeData = kp(this.zoom, i['icon-size']));
          const r = this.layers[0].layout,
            n = r.get('symbol-sort-key'),
            o = r.get('symbol-z-order');
          (this.canOverlap = r.get('text-allow-overlap') || r.get('icon-allow-overlap') || r.get('text-ignore-placement') || r.get('icon-ignore-placement')), (this.sortFeaturesByKey = o !== 'viewport-y' && n.constantOr(1) !== void 0), (this.sortFeaturesByY = (o === 'viewport-y' || (o === 'auto' && !this.sortFeaturesByKey)) && this.canOverlap), (this.writingModes = r.get('text-writing-mode').map((s) => di[s])), (this.stateDependentLayerIds = this.layers.filter((s) => s.isStateDependent()).map((s) => s.id)), (this.sourceID = t.sourceID), (this.projection = t.projection), (this.hasAnyZOffset = !1), (this.zOffsetSortDirty = !1), (this.zOffsetBuffersNeedUpload = r.get('symbol-z-elevate'));
        }
        createArrays() {
          (this.text = new Zp(new Ro(this.layers, this.zoom, (t) => /^text/.test(t)))), (this.icon = new Zp(new Ro(this.layers, this.zoom, (t) => /^icon/.test(t)))), (this.glyphOffsetArray = new Ty()), (this.lineVertexArray = new Ey()), (this.symbolInstances = new wy());
        }
        calculateGlyphDependencies(t, i, r, n, o) {
          for (let s = 0; s < t.length; s++) {
            const a = t.codePointAt(s);
            if (a === void 0) break;
            if (((i[a] = !0), n && o && a <= 65535)) {
              const l = Rl[t.charAt(s)];
              l && (i[l.charCodeAt(0)] = !0);
            }
          }
        }
        populate(t, i, r, n) {
          const o = this.layers[0],
            s = o.layout,
            a = this.projection.name === 'globe',
            l = s.get('text-font'),
            c = s.get('text-field'),
            u = s.get('icon-image'),
            h = (c.value.kind !== 'constant' || (c.value.value instanceof zr && !c.value.value.isEmpty()) || c.value.value.toString().length > 0) && (l.value.kind !== 'constant' || l.value.value.length > 0),
            d = u.value.kind !== 'constant' || !!u.value.value || Object.keys(u.parameters).length > 0,
            f = s.get('symbol-sort-key');
          if (((this.features = []), !h && !d)) return;
          const p = i.iconDependencies,
            _ = i.glyphDependencies,
            g = i.availableImages,
            y = new gi(this.zoom);
          for (const { feature: v, id: w, index: T, sourceLayerIndex: b } of t) {
            const E = o._featureFilter.needGeometry,
              S = Uo(v, E);
            if (!o._featureFilter.filter(y, S, r)) continue;
            if ((E || (S.geometry = On(v, r, n)), a && v.type !== 1 && r.z <= 5)) {
              const k = S.geometry,
                O = 0.98078528056,
                V = (R, G) => {
                  const Z = Al(R.x, R.y, r, 1),
                    X = Al(G.x, G.y, r, 1);
                  return N.dot(Z, X) < O;
                };
              for (let R = 0; R < k.length; R++) k[R] = _S(k[R], V);
            }
            let I, C;
            if (h) {
              const k = o.getValueAndResolveTokens('text-field', S, r, g),
                O = zr.factory(k);
              aI(O) && (this.hasRTLText = !0), (!this.hasRTLText || Ef() === 'unavailable' || (this.hasRTLText && an.isParsed())) && (I = DA(O, o, S));
            }
            if (d) {
              const k = o.getValueAndResolveTokens('icon-image', S, r, g);
              C = k instanceof on ? k : on.fromString(k);
            }
            if (!I && !C) continue;
            const z = this.sortFeaturesByKey ? f.evaluate(S, {}, r) : void 0;
            if ((this.features.push({ id: w, text: I, icon: C, index: T, sourceLayerIndex: b, geometry: S.geometry, properties: v.properties, type: oI[v.type], sortKey: z }), C && ((p[C.namePrimary] = !0), C.nameSecondary && (p[C.nameSecondary] = !0)), I)) {
              const k = l.evaluate(S, {}, r).join(','),
                O = s.get('text-rotation-alignment') === 'map' && s.get('symbol-placement') !== 'point';
              this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(di.vertical) >= 0;
              for (const V of I.sections)
                if (V.image) p[V.image.namePrimary] = !0;
                else {
                  const R = _f(I.toString()),
                    G = V.fontStack || k,
                    Z = (_[G] = _[G] || {});
                  this.calculateGlyphDependencies(V.text, Z, O, this.allowVerticalPlacement, R);
                }
            }
          }
          s.get('symbol-placement') === 'line' &&
            (this.features = (function (v) {
              const w = {},
                T = {},
                b = [];
              let E = 0;
              function S(k) {
                b.push(v[k]), E++;
              }
              function I(k, O, V) {
                const R = T[k];
                return delete T[k], (T[O] = R), b[R].geometry[0].pop(), (b[R].geometry[0] = b[R].geometry[0].concat(V[0])), R;
              }
              function C(k, O, V) {
                const R = w[O];
                return delete w[O], (w[k] = R), b[R].geometry[0].shift(), (b[R].geometry[0] = V[0].concat(b[R].geometry[0])), R;
              }
              function z(k, O, V) {
                const R = V ? O[0][O[0].length - 1] : O[0][0];
                return `${k}:${R.x}:${R.y}`;
              }
              for (let k = 0; k < v.length; k++) {
                const O = v[k],
                  V = O.geometry,
                  R = O.text ? O.text.toString() : null;
                if (!R) {
                  S(k);
                  continue;
                }
                const G = z(R, V),
                  Z = z(R, V, !0);
                if (G in T && Z in w && T[G] !== w[Z]) {
                  const X = C(G, Z, V),
                    j = I(G, Z, b[X].geometry);
                  delete w[G], delete T[Z], (T[z(R, b[j].geometry, !0)] = j), (b[X].geometry = null);
                } else G in T ? I(G, Z, V) : Z in w ? C(G, Z, V) : (S(k), (w[G] = E - 1), (T[Z] = E - 1));
              }
              return b.filter((k) => k.geometry);
            })(this.features)),
            this.sortFeaturesByKey && this.features.sort((v, w) => v.sortKey - w.sortKey);
        }
        update(t, i, r, n, o) {
          const s = Object.keys(t).length !== 0;
          if (s && !this.stateDependentLayers.length) return;
          const a = s ? this.stateDependentLayers : this.layers;
          this.text.programConfigurations.updatePaintArrays(t, i, a, r, n, o), this.icon.programConfigurations.updatePaintArrays(t, i, a, r, n, o);
        }
        updateZOffset() {
          const t = (o, s, a) => {
              (r += s), r > o.length && o.resize(r);
              for (let l = -s; l < 0; l++) o.emplace(l + r, a);
            },
            i = (o, s, a) => {
              (n += s), n > o.length && o.resize(n);
              for (let l = -s; l < 0; l++) o.emplace(l + n, a);
            };
          if (!this.zOffsetBuffersNeedUpload) return;
          this.zOffsetBuffersNeedUpload = !1;
          let r = 0,
            n = 0;
          for (let o = 0; o < this.symbolInstances.length; o++) {
            const s = this.symbolInstances.get(o),
              { numHorizontalGlyphVertices: a, numVerticalGlyphVertices: l, numIconVertices: c } = s,
              u = s.zOffset,
              h = c > 0;
            if (((a > 0 || l > 0) && (t(this.text.zOffsetVertexArray, a, u), t(this.text.zOffsetVertexArray, l, u)), h)) {
              const { placedIconSymbolIndex: d, verticalPlacedIconSymbolIndex: f } = s;
              d >= 0 && i(this.icon.zOffsetVertexArray, c, u), f >= 0 && i(this.icon.zOffsetVertexArray, s.numVerticalIconVertices, u);
            }
          }
          this.text.zOffsetVertexBuffer && this.text.zOffsetVertexBuffer.updateData(this.text.zOffsetVertexArray), this.icon.zOffsetVertexBuffer && this.icon.zOffsetVertexBuffer.updateData(this.icon.zOffsetVertexArray);
        }
        isEmpty() {
          return this.symbolInstances.length === 0 && !this.hasRTLText;
        }
        uploadPending() {
          return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
        }
        upload(t) {
          !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t), this.iconCollisionBox.upload(t)), this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload), this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload), (this.uploaded = !0);
        }
        destroyDebugData() {
          this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
        }
        getProjection() {
          return this.projectionInstance || (this.projectionInstance = Uu(this.projection)), this.projectionInstance;
        }
        destroy() {
          this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
        }
        addToLineVertexArray(t, i) {
          const r = this.lineVertexArray.length;
          if (t.segment !== void 0) for (const { x: n, y: o } of i) this.lineVertexArray.emplaceBack(n, o);
          return { lineStartIndex: r, lineLength: this.lineVertexArray.length - r };
        }
        addSymbols(t, i, r, n, o, s, a, l, c, u, h, d, f, p, _, g) {
          const y = t.indexArray,
            v = t.layoutVertexArray,
            w = t.globeExtVertexArray,
            T = t.segments.prepareSegment(4 * i.length, v, y, this.canOverlap ? s.sortKey : void 0),
            b = this.glyphOffsetArray.length,
            E = T.vertexLength,
            S = this.allowVerticalPlacement && a === di.vertical ? Math.PI / 2 : 0,
            I = s.text && s.text.sections;
          for (let z = 0; z < i.length; z++) {
            const { tl: k, tr: O, bl: V, br: R, texPrimary: G, texSecondary: Z, pixelOffsetTL: X, pixelOffsetBR: j, minFontScaleX: q, minFontScaleY: it, glyphOffset: st, isSDF: nt, sectionIndex: ut } = i[z],
              ht = T.vertexLength,
              pt = st[1];
            if ((ju(v, c.x, c.y, k.x, pt + k.y, G.x, G.y, r, nt, X.x, X.y, q, it), ju(v, c.x, c.y, O.x, pt + O.y, G.x + G.w, G.y, r, nt, j.x, X.y, q, it), ju(v, c.x, c.y, V.x, pt + V.y, G.x, G.y + G.h, r, nt, X.x, j.y, q, it), ju(v, c.x, c.y, R.x, pt + R.y, G.x + G.w, G.y + G.h, r, nt, j.x, j.y, q, it), l)) {
              const { x: at, y: _t, z: Ct } = l.anchor,
                [Pt, Ot, Ut] = l.up;
              qu(w, at, _t, Ct, Pt, Ot, Ut), qu(w, at, _t, Ct, Pt, Ot, Ut), qu(w, at, _t, Ct, Pt, Ot, Ut), qu(w, at, _t, Ct, Pt, Ot, Ut), za(t.dynamicLayoutVertexArray, at, _t, Ct, S);
            } else za(t.dynamicLayoutVertexArray, c.x, c.y, c.z, S);
            if (g) {
              const at = Z || G;
              Gu(t.iconTransitioningVertexArray, at.x, at.y), Gu(t.iconTransitioningVertexArray, at.x + at.w, at.y), Gu(t.iconTransitioningVertexArray, at.x, at.y + at.h), Gu(t.iconTransitioningVertexArray, at.x + at.w, at.y + at.h);
            }
            y.emplaceBack(ht, ht + 1, ht + 2), y.emplaceBack(ht + 1, ht + 2, ht + 3), (T.vertexLength += 4), (T.primitiveLength += 2), this.glyphOffsetArray.emplaceBack(st[0]), (z !== i.length - 1 && ut === i[z + 1].sectionIndex) || t.programConfigurations.populatePaintArrays(v.length, s, s.index, {}, f, p, _, I && I[ut]);
          }
          const C = l ? l.anchor : c;
          t.placedSymbolArray.emplaceBack(C.x, C.y, C.z, c.x, c.y, b, this.glyphOffsetArray.length - b, E, u, h, c.segment, r ? r[0] : 0, r ? r[1] : 0, n[0], n[1], a, 0, !1, 0, d, 0);
        }
        _commitLayoutVertex(t, i, r, n, o, s, a) {
          t.emplaceBack(i, r, n, o, s, Math.round(a.x), Math.round(a.y));
        }
        _addCollisionDebugVertices(t, i, r, n, o, s, a) {
          const l = r.segments.prepareSegment(4, r.layoutVertexArray, r.indexArray),
            c = l.vertexLength,
            u = a.tileAnchorX,
            h = a.tileAnchorY;
          for (let f = 0; f < 4; f++) r.collisionVertexArray.emplaceBack(0, 0, 0, 0);
          this._commitDebugCollisionVertexUpdate(r.collisionVertexArrayExt, i, t.padding, a.zOffset), this._commitLayoutVertex(r.layoutVertexArray, n, o, s, u, h, new H(t.x1, t.y1)), this._commitLayoutVertex(r.layoutVertexArray, n, o, s, u, h, new H(t.x2, t.y1)), this._commitLayoutVertex(r.layoutVertexArray, n, o, s, u, h, new H(t.x2, t.y2)), this._commitLayoutVertex(r.layoutVertexArray, n, o, s, u, h, new H(t.x1, t.y2)), (l.vertexLength += 4);
          const d = r.indexArray;
          d.emplaceBack(c, c + 1), d.emplaceBack(c + 1, c + 2), d.emplaceBack(c + 2, c + 3), d.emplaceBack(c + 3, c), (l.primitiveLength += 4);
        }
        _addTextDebugCollisionBoxes(t, i, r, n, o, s) {
          for (let a = n; a < o; a++) {
            const l = r.get(a),
              c = this.getSymbolInstanceTextSize(t, s, i, a);
            this._addCollisionDebugVertices(l, c, this.textCollisionBox, l.projectedAnchorX, l.projectedAnchorY, l.projectedAnchorZ, s);
          }
        }
        _addIconDebugCollisionBoxes(t, i, r, n, o, s) {
          for (let a = n; a < o; a++) {
            const l = r.get(a),
              c = this.getSymbolInstanceIconSize(t, i, s.placedIconSymbolIndex);
            this._addCollisionDebugVertices(l, c, this.iconCollisionBox, l.projectedAnchorX, l.projectedAnchorY, l.projectedAnchorZ, s);
          }
        }
        generateCollisionDebugBuffers(t, i) {
          this.hasDebugData() && this.destroyDebugData(), (this.textCollisionBox = new $p(eu, Jx.members, zo)), (this.iconCollisionBox = new $p(eu, Jx.members, zo));
          const r = Bn(this.iconSizeData, t),
            n = Bn(this.textSizeData, t);
          for (let o = 0; o < this.symbolInstances.length; o++) {
            const s = this.symbolInstances.get(o);
            this._addTextDebugCollisionBoxes(n, t, i, s.textBoxStartIndex, s.textBoxEndIndex, s), this._addTextDebugCollisionBoxes(n, t, i, s.verticalTextBoxStartIndex, s.verticalTextBoxEndIndex, s), this._addIconDebugCollisionBoxes(r, t, i, s.iconBoxStartIndex, s.iconBoxEndIndex, s), this._addIconDebugCollisionBoxes(r, t, i, s.verticalIconBoxStartIndex, s.verticalIconBoxEndIndex, s);
          }
        }
        getSymbolInstanceTextSize(t, i, r, n) {
          const o = this.text.placedSymbolArray.get(i.rightJustifiedTextSymbolIndex >= 0 ? i.rightJustifiedTextSymbolIndex : i.centerJustifiedTextSymbolIndex >= 0 ? i.centerJustifiedTextSymbolIndex : i.leftJustifiedTextSymbolIndex >= 0 ? i.leftJustifiedTextSymbolIndex : i.verticalPlacedTextSymbolIndex >= 0 ? i.verticalPlacedTextSymbolIndex : n),
            s = Dl(this.textSizeData, t, o) / Qi;
          return this.tilePixelRatio * s;
        }
        getSymbolInstanceIconSize(t, i, r) {
          const n = this.icon.placedSymbolArray.get(r),
            o = Dl(this.iconSizeData, t, n);
          return this.tilePixelRatio * o;
        }
        _commitDebugCollisionVertexUpdate(t, i, r, n) {
          t.emplaceBack(i, -r, -r, n), t.emplaceBack(i, r, -r, n), t.emplaceBack(i, r, r, n), t.emplaceBack(i, -r, r, n);
        }
        _updateTextDebugCollisionBoxes(t, i, r, n, o, s) {
          for (let a = n; a < o; a++) {
            const l = r.get(a),
              c = this.getSymbolInstanceTextSize(t, s, i, a);
            this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, c, l.padding, s.zOffset);
          }
        }
        _updateIconDebugCollisionBoxes(t, i, r, n, o, s) {
          for (let a = n; a < o; a++) {
            const l = r.get(a),
              c = this.getSymbolInstanceIconSize(t, i, s.placedIconSymbolIndex);
            this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, c, l.padding, s.zOffset);
          }
        }
        updateCollisionDebugBuffers(t, i) {
          if (!this.hasDebugData()) return;
          this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();
          const r = Bn(this.iconSizeData, t),
            n = Bn(this.textSizeData, t);
          for (let o = 0; o < this.symbolInstances.length; o++) {
            const s = this.symbolInstances.get(o);
            this._updateTextDebugCollisionBoxes(n, t, i, s.textBoxStartIndex, s.textBoxEndIndex, s), this._updateTextDebugCollisionBoxes(n, t, i, s.verticalTextBoxStartIndex, s.verticalTextBoxEndIndex, s), this._updateIconDebugCollisionBoxes(r, t, i, s.iconBoxStartIndex, s.iconBoxEndIndex, s), this._updateIconDebugCollisionBoxes(r, t, i, s.verticalIconBoxStartIndex, s.verticalIconBoxEndIndex, s);
          }
          this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);
        }
        _deserializeCollisionBoxesForSymbol(t, i, r, n, o, s, a, l, c) {
          const u = {};
          if (i < r) {
            const { x1: h, y1: d, x2: f, y2: p, padding: _, projectedAnchorX: g, projectedAnchorY: y, projectedAnchorZ: v, tileAnchorX: w, tileAnchorY: T, featureIndex: b } = t.get(i);
            (u.textBox = { x1: h, y1: d, x2: f, y2: p, padding: _, projectedAnchorX: g, projectedAnchorY: y, projectedAnchorZ: v, tileAnchorX: w, tileAnchorY: T }), (u.textFeatureIndex = b);
          }
          if (n < o) {
            const { x1: h, y1: d, x2: f, y2: p, padding: _, projectedAnchorX: g, projectedAnchorY: y, projectedAnchorZ: v, tileAnchorX: w, tileAnchorY: T, featureIndex: b } = t.get(n);
            (u.verticalTextBox = { x1: h, y1: d, x2: f, y2: p, padding: _, projectedAnchorX: g, projectedAnchorY: y, projectedAnchorZ: v, tileAnchorX: w, tileAnchorY: T }), (u.verticalTextFeatureIndex = b);
          }
          if (s < a) {
            const { x1: h, y1: d, x2: f, y2: p, padding: _, projectedAnchorX: g, projectedAnchorY: y, projectedAnchorZ: v, tileAnchorX: w, tileAnchorY: T, featureIndex: b } = t.get(s);
            (u.iconBox = { x1: h, y1: d, x2: f, y2: p, padding: _, projectedAnchorX: g, projectedAnchorY: y, projectedAnchorZ: v, tileAnchorX: w, tileAnchorY: T }), (u.iconFeatureIndex = b);
          }
          if (l < c) {
            const { x1: h, y1: d, x2: f, y2: p, padding: _, projectedAnchorX: g, projectedAnchorY: y, projectedAnchorZ: v, tileAnchorX: w, tileAnchorY: T, featureIndex: b } = t.get(l);
            (u.verticalIconBox = { x1: h, y1: d, x2: f, y2: p, padding: _, projectedAnchorX: g, projectedAnchorY: y, projectedAnchorZ: v, tileAnchorX: w, tileAnchorY: T }), (u.verticalIconFeatureIndex = b);
          }
          return u;
        }
        deserializeCollisionBoxes(t) {
          this.collisionArrays = [];
          for (let i = 0; i < this.symbolInstances.length; i++) {
            const r = this.symbolInstances.get(i);
            this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, r.textBoxStartIndex, r.textBoxEndIndex, r.verticalTextBoxStartIndex, r.verticalTextBoxEndIndex, r.iconBoxStartIndex, r.iconBoxEndIndex, r.verticalIconBoxStartIndex, r.verticalIconBoxEndIndex));
          }
        }
        hasTextData() {
          return this.text.segments.get().length > 0;
        }
        hasIconData() {
          return this.icon.segments.get().length > 0;
        }
        hasDebugData() {
          return this.textCollisionBox && this.iconCollisionBox;
        }
        hasTextCollisionBoxData() {
          return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
        }
        hasIconCollisionBoxData() {
          return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
        }
        hasIconTextFit() {
          return this.hasAnyIconTextFit;
        }
        addIndicesForPlacedSymbol(t, i) {
          const r = t.placedSymbolArray.get(i),
            n = r.vertexStartIndex + 4 * r.numGlyphs;
          for (let o = r.vertexStartIndex; o < n; o += 4) t.indexArray.emplaceBack(o, o + 1, o + 2), t.indexArray.emplaceBack(o + 1, o + 2, o + 3);
        }
        getSortedSymbolIndexes(t) {
          if (this.sortedAngle === t && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
          const i = Math.sin(t),
            r = Math.cos(t),
            n = [],
            o = [],
            s = [];
          for (let a = 0; a < this.symbolInstances.length; ++a) {
            s.push(a);
            const l = this.symbolInstances.get(a);
            n.push(0 | Math.round(i * l.tileAnchorX + r * l.tileAnchorY)), o.push(l.featureIndex);
          }
          return s.sort((a, l) => n[a] - n[l] || o[l] - o[a]), s;
        }
        getSortedIndexesByZOffset() {
          if (!this.zOffsetSortDirty) return this.symbolInstanceIndexesSortedZOffset;
          if (!this.symbolInstanceIndexesSortedZOffset) {
            this.symbolInstanceIndexesSortedZOffset = [];
            for (let t = 0; t < this.symbolInstances.length; ++t) this.symbolInstanceIndexesSortedZOffset.push(t);
          }
          return (this.zOffsetSortDirty = !1), this.symbolInstanceIndexesSortedZOffset.sort((t, i) => this.symbolInstances.get(i).zOffset - this.symbolInstances.get(t).zOffset);
        }
        addToSortKeyRanges(t, i) {
          const r = this.sortKeyRanges[this.sortKeyRanges.length - 1];
          r && r.sortKey === i ? (r.symbolInstanceEnd = t + 1) : this.sortKeyRanges.push({ sortKey: i, symbolInstanceStart: t, symbolInstanceEnd: t + 1 });
        }
        sortFeatures(t) {
          if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
            (this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t)), (this.sortedAngle = t), this.text.indexArray.clear(), this.icon.indexArray.clear(), (this.featureSortOrder = []);
            for (const i of this.symbolInstanceIndexes) {
              const r = this.symbolInstances.get(i);
              this.featureSortOrder.push(r.featureIndex);
              const { rightJustifiedTextSymbolIndex: n, centerJustifiedTextSymbolIndex: o, leftJustifiedTextSymbolIndex: s, verticalPlacedTextSymbolIndex: a, placedIconSymbolIndex: l, verticalPlacedIconSymbolIndex: c } = r;
              n >= 0 && this.addIndicesForPlacedSymbol(this.text, n), o >= 0 && o !== n && this.addIndicesForPlacedSymbol(this.text, o), s >= 0 && s !== o && s !== n && this.addIndicesForPlacedSymbol(this.text, s), a >= 0 && this.addIndicesForPlacedSymbol(this.text, a), l >= 0 && this.addIndicesForPlacedSymbol(this.icon, l), c >= 0 && this.addIndicesForPlacedSymbol(this.icon, c);
            }
            this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
          }
        }
      }
      Gt($u, 'SymbolBucket', { omit: ['layers', 'collisionBoxArray', 'features', 'compareText'] }), ($u.MAX_GLYPHS = 65535), ($u.addDynamicAttributes = za);
      var Vl = $u;
      const lI = Ne(
          [
            { name: 'a_pos_normal', components: 2, type: 'Int16' },
            { name: 'a_data', components: 4, type: 'Uint8' },
            { name: 'a_linesofar', components: 1, type: 'Float32' },
          ],
          4
        ),
        { members: cI } = lI,
        uI = Ne([{ name: 'a_packed', components: 4, type: 'Float32' }]),
        { members: hI } = uI,
        dI = Su.types,
        fI = Math.cos((Math.PI / 180) * 37.5);
      class Hu {
        constructor(t) {
          (this.zoom = t.zoom),
            (this.overscaling = t.overscaling),
            (this.layers = t.layers),
            (this.layerIds = this.layers.map((i) => i.fqid)),
            (this.index = t.index),
            (this.projection = t.projection),
            (this.hasPattern = !1),
            (this.patternFeatures = []),
            (this.lineClipsArray = []),
            (this.gradients = {}),
            this.layers.forEach((i) => {
              this.gradients[i.id] = {};
            }),
            (this.layoutVertexArray = new Af()),
            (this.layoutVertexArray2 = new ro()),
            (this.indexArray = new Fi()),
            (this.programConfigurations = new Ro(t.layers, t.zoom)),
            (this.segments = new He()),
            (this.maxLineLength = 0),
            (this.stateDependentLayerIds = this.layers.filter((i) => i.isStateDependent()).map((i) => i.id));
        }
        populate(t, i, r, n) {
          this.hasPattern = Pp('line', this.layers, i);
          const o = this.layers[0].layout.get('line-sort-key'),
            s = [];
          for (const { feature: u, id: h, index: d, sourceLayerIndex: f } of t) {
            const p = this.layers[0]._featureFilter.needGeometry,
              _ = Uo(u, p);
            if (!this.layers[0]._featureFilter.filter(new gi(this.zoom), _, r)) continue;
            const g = o ? o.evaluate(_, {}, r) : void 0,
              y = { id: h, properties: u.properties, type: u.type, sourceLayerIndex: f, index: d, geometry: p ? _.geometry : On(u, r, n), patterns: {}, sortKey: g };
            s.push(y);
          }
          o && s.sort((u, h) => u.sortKey - h.sortKey);
          const { lineAtlas: a, featureIndex: l } = i,
            c = this.addConstantDashes(a);
          for (const u of s) {
            const { geometry: h, index: d, sourceLayerIndex: f } = u;
            if ((c && this.addFeatureDashes(u, a), this.hasPattern)) {
              const p = zp('line', this.layers, u, this.zoom, i);
              this.patternFeatures.push(p);
            } else this.addFeature(u, h, d, r, a.positions, i.availableImages, i.brightness);
            l.insert(t[d].feature, h, d, f, this.index);
          }
        }
        addConstantDashes(t) {
          let i = !1;
          for (const r of this.layers) {
            const n = r.paint.get('line-dasharray').value,
              o = r.layout.get('line-cap').value;
            if (n.kind !== 'constant' || o.kind !== 'constant') i = !0;
            else {
              const s = o.value,
                a = n.value;
              if (!a) continue;
              t.addDash(a, s);
            }
          }
          return i;
        }
        addFeatureDashes(t, i) {
          const r = this.zoom;
          for (const n of this.layers) {
            const o = n.paint.get('line-dasharray').value,
              s = n.layout.get('line-cap').value;
            if (o.kind === 'constant' && s.kind === 'constant') continue;
            let a, l;
            if (o.kind === 'constant') {
              if (((a = o.value), !a)) continue;
            } else a = o.evaluate({ zoom: r }, t);
            (l = s.kind === 'constant' ? s.value : s.evaluate({ zoom: r }, t)), i.addDash(a, l), (t.patterns[n.id] = i.getKey(a, l));
          }
        }
        update(t, i, r, n, o) {
          const s = Object.keys(t).length !== 0;
          (s && !this.stateDependentLayers.length) || this.programConfigurations.updatePaintArrays(t, i, s ? this.stateDependentLayers : this.layers, r, n, o);
        }
        addFeatures(t, i, r, n, o, s) {
          for (const a of this.patternFeatures) this.addFeature(a, a.geometry, a.index, i, r, n, s);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(t) {
          this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, hI)), (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, cI)), (this.indexBuffer = t.createIndexBuffer(this.indexArray))), this.programConfigurations.upload(t), (this.uploaded = !0);
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        lineFeatureClips(t) {
          if (t.properties && t.properties.hasOwnProperty('mapbox_clip_start') && t.properties.hasOwnProperty('mapbox_clip_end')) return { start: +t.properties.mapbox_clip_start, end: +t.properties.mapbox_clip_end };
        }
        addFeature(t, i, r, n, o, s, a) {
          const l = this.layers[0].layout,
            c = l.get('line-join').evaluate(t, {}),
            u = l.get('line-cap').evaluate(t, {}),
            h = l.get('line-miter-limit'),
            d = l.get('line-round-limit');
          this.lineClips = this.lineFeatureClips(t);
          for (const f of i) this.addLine(f, t, c, u, h, d);
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, o, s, n, a);
        }
        addLine(t, i, r, n, o, s) {
          if (((this.distance = 0), (this.scaledDistance = 0), (this.totalDistance = 0), (this.lineSoFar = 0), this.lineClips)) {
            this.lineClipsArray.push(this.lineClips);
            for (let y = 0; y < t.length - 1; y++) this.totalDistance += t[y].dist(t[y + 1]);
            this.updateScaledDistance(), (this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance));
          }
          const a = dI[i.type] === 'Polygon';
          let l = t.length;
          for (; l >= 2 && t[l - 1].equals(t[l - 2]); ) l--;
          let c = 0;
          for (; c < l - 1 && t[c].equals(t[c + 1]); ) c++;
          if (l < (a ? 3 : 2)) return;
          r === 'bevel' && (o = 1.05);
          const u = this.overscaling <= 16 ? (15 * lt) / (512 * this.overscaling) : 0,
            h = this.segments.prepareSegment(10 * l, this.layoutVertexArray, this.indexArray);
          let d, f, p, _, g;
          (this.e1 = this.e2 = -1), a && ((d = t[l - 2]), (g = t[c].sub(d)._unit()._perp()));
          for (let y = c; y < l; y++) {
            if (((p = y === l - 1 ? (a ? t[c + 1] : void 0) : t[y + 1]), p && t[y].equals(p))) continue;
            g && (_ = g), d && (f = d), (d = t[y]), (g = p ? p.sub(d)._unit()._perp() : _), (_ = _ || g);
            let v = _.add(g);
            (v.x === 0 && v.y === 0) || v._unit();
            const w = _.x * g.x + _.y * g.y,
              T = v.x * g.x + v.y * g.y,
              b = T !== 0 ? 1 / T : 1 / 0,
              E = 2 * Math.sqrt(2 - 2 * T),
              S = T < fI && f && p,
              I = _.x * g.y - _.y * g.x > 0;
            if (S && y > c) {
              const k = d.dist(f);
              if (k > 2 * u) {
                const O = d.sub(
                  d
                    .sub(f)
                    ._mult(u / k)
                    ._round()
                );
                this.updateDistance(f, O), this.addCurrentVertex(O, _, 0, 0, h), (f = O);
              }
            }
            const C = f && p;
            let z = C ? r : a ? 'butt' : n;
            if ((C && z === 'round' && (b < s ? (z = 'miter') : b <= 2 && (z = 'fakeround')), z === 'miter' && b > o && (z = 'bevel'), z === 'bevel' && (b > 2 && (z = 'flipbevel'), b < o && (z = 'miter')), f && this.updateDistance(f, d), z === 'miter')) v._mult(b), this.addCurrentVertex(d, v, 0, 0, h);
            else if (z === 'flipbevel') {
              if (b > 100) v = g.mult(-1);
              else {
                const k = (b * _.add(g).mag()) / _.sub(g).mag();
                v._perp()._mult(k * (I ? -1 : 1));
              }
              this.addCurrentVertex(d, v, 0, 0, h), this.addCurrentVertex(d, v.mult(-1), 0, 0, h);
            } else if (z === 'bevel' || z === 'fakeround') {
              const k = -Math.sqrt(b * b - 1),
                O = I ? k : 0,
                V = I ? 0 : k;
              if ((f && this.addCurrentVertex(d, _, O, V, h), z === 'fakeround')) {
                const R = Math.round((180 * E) / Math.PI / 20);
                for (let G = 1; G < R; G++) {
                  let Z = G / R;
                  if (Z !== 0.5) {
                    const j = Z - 0.5;
                    Z += Z * j * (Z - 1) * ((1.0904 + w * (w * (3.55645 - 1.43519 * w) - 3.2452)) * j * j + (0.848013 + w * (0.215638 * w - 1.06021)));
                  }
                  const X = g
                    .sub(_)
                    ._mult(Z)
                    ._add(_)
                    ._unit()
                    ._mult(I ? -1 : 1);
                  this.addHalfVertex(d, X.x, X.y, !1, I, 0, h);
                }
              }
              p && this.addCurrentVertex(d, g, -O, -V, h);
            } else if (z === 'butt') this.addCurrentVertex(d, v, 0, 0, h);
            else if (z === 'square') {
              const k = f ? 1 : -1;
              f || this.addCurrentVertex(d, v, k, k, h), this.addCurrentVertex(d, v, 0, 0, h), f && this.addCurrentVertex(d, v, k, k, h);
            } else z === 'round' && (f && (this.addCurrentVertex(d, _, 0, 0, h), this.addCurrentVertex(d, _, 1, 1, h, !0)), p && (this.addCurrentVertex(d, g, -1, -1, h, !0), this.addCurrentVertex(d, g, 0, 0, h)));
            if (S && y < l - 1) {
              const k = d.dist(p);
              if (k > 2 * u) {
                const O = d.add(
                  p
                    .sub(d)
                    ._mult(u / k)
                    ._round()
                );
                this.updateDistance(d, O), this.addCurrentVertex(O, g, 0, 0, h), (d = O);
              }
            }
          }
        }
        addCurrentVertex(t, i, r, n, o, s = !1) {
          const a = i.y * n - i.x,
            l = -i.y - i.x * n;
          this.addHalfVertex(t, i.x + i.y * r, i.y - i.x * r, s, !1, r, o), this.addHalfVertex(t, a, l, s, !0, -n, o);
        }
        addHalfVertex({ x: t, y: i }, r, n, o, s, a, l) {
          this.layoutVertexArray.emplaceBack((t << 1) + (o ? 1 : 0), (i << 1) + (s ? 1 : 0), Math.round(63 * r) + 128, Math.round(63 * n) + 128, 1 + (a === 0 ? 0 : a < 0 ? -1 : 1), 0, this.lineSoFar), this.lineClips && this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, this.lineClips.start, this.lineClips.end);
          const c = l.vertexLength++;
          this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, c), l.primitiveLength++), s ? (this.e2 = c) : (this.e1 = c);
        }
        updateScaledDistance() {
          if (this.lineClips) {
            const t = this.totalDistance / (this.lineClips.end - this.lineClips.start);
            (this.scaledDistance = this.distance / this.totalDistance), (this.lineSoFar = t * this.lineClips.start + this.distance);
          } else this.lineSoFar = this.distance;
        }
        updateDistance(t, i) {
          (this.distance += t.dist(i)), this.updateScaledDistance();
        }
      }
      Gt(Hu, 'LineBucket', { omit: ['layers', 'patternFeatures'] });
      class vi {
        constructor(t, i, r, n) {
          (this.context = t), (this.format = r), (this.texture = t.gl.createTexture()), this.update(i, n);
        }
        update(t, i, r) {
          const { width: n, height: o } = t,
            { context: s } = this,
            { gl: a } = s,
            { HTMLImageElement: l, HTMLCanvasElement: c, HTMLVideoElement: u, ImageData: h, ImageBitmap: d } = U;
          if ((a.bindTexture(a.TEXTURE_2D, this.texture), s.pixelStoreUnpackFlipY.set(!1), s.pixelStoreUnpack.set(1), s.pixelStoreUnpackPremultiplyAlpha.set(this.format === a.RGBA && (!i || i.premultiply !== !1)), r || (this.size && this.size[0] === n && this.size[1] === o))) {
            const { x: f, y: p } = r || { x: 0, y: 0 };
            if (t instanceof l || t instanceof c || t instanceof u || t instanceof h || (d && t instanceof d)) a.texSubImage2D(a.TEXTURE_2D, 0, f, p, a.RGBA, a.UNSIGNED_BYTE, t);
            else {
              let _ = this.format,
                g = a.UNSIGNED_BYTE;
              this.format === a.R32F && ((_ = a.RED), (g = a.FLOAT)), a.texSubImage2D(a.TEXTURE_2D, 0, f, p, n, o, _, g, t.data);
            }
          } else if (((this.size = [n, o]), t instanceof l || t instanceof c || t instanceof u || t instanceof h || (d && t instanceof d))) {
            let f = this.format;
            this.format === a.R8 && (f = a.RED), a.texImage2D(a.TEXTURE_2D, 0, this.format, f, a.UNSIGNED_BYTE, t);
          } else {
            let f = this.format,
              p = this.format,
              _ = a.UNSIGNED_BYTE;
            this.format === a.DEPTH_COMPONENT && ((f = a.DEPTH_COMPONENT16), (_ = a.UNSIGNED_SHORT)), this.format === a.R32F && ((_ = a.FLOAT), (p = a.RED)), a.texImage2D(a.TEXTURE_2D, 0, f, n, o, 0, p, _, t.data);
          }
          (this.useMipmap = !!(i && i.useMipmap)), this.useMipmap && a.generateMipmap(a.TEXTURE_2D);
        }
        bind(t, i) {
          const { context: r } = this,
            { gl: n } = r;
          n.bindTexture(n.TEXTURE_2D, this.texture), t !== this.minFilter && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, t), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, this.useMipmap ? (t === n.NEAREST ? n.NEAREST_MIPMAP_NEAREST : n.LINEAR_MIPMAP_NEAREST) : t), (this.minFilter = t)), i !== this.wrapS && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, i), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, i), (this.wrapS = i));
        }
        bindExtraParam(t, i, r, n) {
          const { context: o } = this,
            { gl: s } = o;
          s.bindTexture(s.TEXTURE_2D, this.texture), i !== this.magFilter && (s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MAG_FILTER, i), (this.magFilter = i)), t !== this.minFilter && (s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MIN_FILTER, this.useMipmap ? (t === s.NEAREST ? s.NEAREST_MIPMAP_NEAREST : s.LINEAR_MIPMAP_NEAREST) : t), (this.minFilter = t)), r !== this.wrapS && (s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_S, r), (this.wrapS = r)), n !== this.wrapT && (s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_T, n), (this.wrapT = n));
        }
        destroy() {
          const { gl: t } = this.context;
          t.deleteTexture(this.texture), (this.texture = null);
        }
      }
      class Wu {
        constructor(t, i) {
          (this.context = t), (this.texture = i);
        }
        bind(t, i) {
          const { context: r } = this,
            { gl: n } = r;
          n.bindTexture(n.TEXTURE_2D, this.texture), t !== this.minFilter && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, t), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, t), (this.minFilter = t)), i !== this.wrapS && (n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_S, i), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_WRAP_T, i), (this.wrapS = i));
        }
      }
      const dn = 32,
        Fn = 33,
        $o = new Uint16Array(8184);
      for (let e = 0; e < 2046; e++) {
        let t = e + 2,
          i = 0,
          r = 0,
          n = 0,
          o = 0,
          s = 0,
          a = 0;
        for (1 & t ? (n = o = s = dn) : (i = r = a = dn); (t >>= 1) > 1; ) {
          const c = (i + n) >> 1,
            u = (r + o) >> 1;
          1 & t ? ((n = i), (o = r), (i = s), (r = a)) : ((i = n), (r = o), (n = s), (o = a)), (s = c), (a = u);
        }
        const l = 4 * e;
        ($o[l + 0] = i), ($o[l + 1] = r), ($o[l + 2] = n), ($o[l + 3] = o);
      }
      const Nn = new Uint16Array(2178),
        Ho = new Uint8Array(1089),
        Xu = new Uint16Array(1089);
      function Cv(e) {
        return e === 0 ? -0.03125 : e === 32 ? 0.03125 : 0;
      }
      var Hp = Ne([
        { name: 'a_pos', type: 'Int16', components: 2 },
        { name: 'a_texture_pos', type: 'Int16', components: 2 },
      ]);
      const Pv = { type: 2, extent: lt, loadGeometry: () => [[new H(0, 0), new H(lt + 1, 0), new H(lt + 1, lt + 1), new H(0, lt + 1), new H(0, 0)]] };
      class jl {
        constructor(t, i, r, n, o) {
          (this.tileID = t), (this.uid = $r()), (this.uses = 0), (this.tileSize = i), (this.tileZoom = r), (this.buckets = {}), (this.expirationTime = null), (this.queryPadding = 0), (this.hasSymbolBuckets = !1), (this.hasRTLText = !1), (this.dependencies = {}), (this.isRaster = o), n && n.style && (this._lastUpdatedBrightness = n.style.getBrightness()), (this.expiredRequestCount = 0), (this.state = 'loading'), n && n.transform && (this.projection = n.transform.projection);
        }
        registerFadeDuration(t) {
          const i = t + this.timeAdded;
          i < oe.now() || (this.fadeEndTime && i < this.fadeEndTime) || (this.fadeEndTime = i);
        }
        wasRequested() {
          return this.state === 'errored' || this.state === 'loaded' || this.state === 'reloading';
        }
        get tileTransform() {
          return this._tileTransform || (this._tileTransform = Es(this.tileID.canonical, this.projection)), this._tileTransform;
        }
        loadVectorData(t, i, r) {
          if ((this.unloadVectorData(), (this.state = 'loaded'), t)) {
            t.featureIndex && ((this.latestFeatureIndex = t.featureIndex), t.rawTileData ? ((this.latestRawTileData = t.rawTileData), (this.latestFeatureIndex.rawTileData = t.rawTileData)) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)),
              (this.collisionBoxArray = t.collisionBoxArray),
              (this.buckets = (function (n, o) {
                const s = {};
                if (!o) return s;
                for (const a of n) {
                  const l = a.layerIds.map((c) => o.getLayer(c)).filter(Boolean);
                  if (l.length !== 0) {
                    (a.layers = l), a.stateDependentLayerIds && (a.stateDependentLayers = a.stateDependentLayerIds.map((c) => l.filter((u) => u.id === c)[0]));
                    for (const c of l) s[c.fqid] = a;
                  }
                }
                return s;
              })(t.buckets, i.style)),
              (this.hasSymbolBuckets = !1);
            for (const n in this.buckets) {
              const o = this.buckets[n];
              if (o instanceof Vl) {
                if (((this.hasSymbolBuckets = !0), !r)) break;
                o.justReloaded = !0;
              }
            }
            if (((this.hasRTLText = !1), this.hasSymbolBuckets))
              for (const n in this.buckets) {
                const o = this.buckets[n];
                if (o instanceof Vl && o.hasRTLText) {
                  (this.hasRTLText = !0), an.isLoading() || an.isLoaded() || Ef() !== 'deferred' || dy();
                  break;
                }
              }
            this.queryPadding = 0;
            for (const n in this.buckets) {
              const o = this.buckets[n],
                s = i.style.getOwnLayer(n);
              if (!s) continue;
              const a = s.queryRadius(o);
              this.queryPadding = Math.max(this.queryPadding, a);
            }
            t.imageAtlas && (this.imageAtlas = t.imageAtlas), t.glyphAtlasImage && (this.glyphAtlasImage = t.glyphAtlasImage), t.lineAtlas && (this.lineAtlas = t.lineAtlas), (this._lastUpdatedBrightness = t.brightness);
          } else this.collisionBoxArray = new Uf();
        }
        unloadVectorData() {
          if (this.hasData()) {
            for (const t in this.buckets) this.buckets[t].destroy();
            (this.buckets = {}), this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), (this._tileBoundsBuffer = null)), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), (this._tileDebugBuffer = null)), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), (this._tileDebugIndexBuffer = null)), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), (this._globeTileDebugBorderBuffer = null)), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), (this._tileDebugTextBuffer = null)), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), (this._globeTileDebugTextBuffer = null)), (this.latestFeatureIndex = null), (this.state = 'unloaded');
          }
        }
        getBucket(t) {
          return this.buckets[t.fqid];
        }
        upload(t) {
          for (const r in this.buckets) {
            const n = this.buckets[r];
            n.uploadPending() && n.upload(t);
          }
          const i = t.gl;
          this.imageAtlas && !this.imageAtlas.uploaded && ((this.imageAtlasTexture = new vi(t, this.imageAtlas.image, i.RGBA)), (this.imageAtlas.uploaded = !0)), this.glyphAtlasImage && ((this.glyphAtlasTexture = new vi(t, this.glyphAtlasImage, i.ALPHA)), (this.glyphAtlasImage = null)), this.lineAtlas && !this.lineAtlas.uploaded && ((this.lineAtlasTexture = new vi(t, this.lineAtlas.image, i.ALPHA)), (this.lineAtlas.uploaded = !0));
        }
        prepare(t, i, r) {
          if ((this.imageAtlas && this.imageAtlasTexture && this.imageAtlas.patchUpdatedImages(t, this.imageAtlasTexture, r), !i || !this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData)) return;
          const n = i.style.getBrightness();
          (this._lastUpdatedBrightness || n) && ((this._lastUpdatedBrightness && n && Math.abs(this._lastUpdatedBrightness - n) < 0.001) || ((this._lastUpdatedBrightness = n), this.updateBuckets(void 0, i)));
        }
        queryRenderedFeatures(t, i, r, n, o, s, a, l) {
          return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ tileResult: n, pixelPosMatrix: a, transform: s, params: o, tileTransform: this.tileTransform }, t, i, r) : {};
        }
        querySourceFeatures(t, i) {
          const r = this.latestFeatureIndex;
          if (!r || !r.rawTileData) return;
          const n = r.loadVTLayers(),
            o = i ? i.sourceLayer : '',
            s = n._geojsonTileLayer || n[o];
          if (!s) return;
          const a = Gc(i && i.filter),
            { z: l, x: c, y: u } = this.tileID.canonical,
            h = { z: l, x: c, y: u };
          for (let d = 0; d < s.length; d++) {
            const f = s.feature(d);
            if (a.needGeometry) {
              const g = Uo(f, !0);
              if (!a.filter(new gi(this.tileID.overscaledZ), g, this.tileID.canonical)) continue;
            } else if (!a.filter(new gi(this.tileID.overscaledZ), f)) continue;
            const p = r.getId(f, o),
              _ = new Gx(f, l, c, u, p);
            (_.tile = h), t.push(_);
          }
        }
        hasData() {
          return this.state === 'loaded' || this.state === 'reloading' || this.state === 'expired';
        }
        bucketsLoaded() {
          for (const t in this.buckets) if (this.buckets[t].uploadPending()) return !1;
          return !0;
        }
        patternsLoaded() {
          return !!this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
        }
        setExpiryData(t) {
          const i = this.expirationTime;
          if (t.cacheControl) {
            const r = Tt(t.cacheControl);
            r['max-age'] && (this.expirationTime = Date.now() + 1e3 * r['max-age']);
          } else t.expires && (this.expirationTime = new Date(t.expires).getTime());
          if (this.expirationTime) {
            const r = Date.now();
            let n = !1;
            if (this.expirationTime > r) n = !1;
            else if (i)
              if (this.expirationTime < i) n = !0;
              else {
                const o = this.expirationTime - i;
                o ? (this.expirationTime = r + Math.max(o, 3e4)) : (n = !0);
              }
            else n = !0;
            n ? (this.expiredRequestCount++, (this.state = 'expired')) : (this.expiredRequestCount = 0);
          }
        }
        getExpiryTimeout() {
          if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1);
        }
        setFeatureState(t, i) {
          this.latestFeatureIndex && this.latestFeatureIndex.rawTileData && Object.keys(t).length !== 0 && i && this.updateBuckets(t, i);
        }
        updateBuckets(t, i) {
          if (!this.latestFeatureIndex) return;
          const r = this.latestFeatureIndex.loadVTLayers(),
            n = i.style.listImages(),
            o = i.style.getBrightness();
          for (const s in this.buckets) {
            if (!i.style.hasLayer(s)) continue;
            const a = this.buckets[s],
              l = a.layers[0].sourceLayer || '_geojsonTileLayer',
              c = r[l];
            let u = {};
            if (t && ((u = t[l]), !c || !u || Object.keys(u).length === 0)) continue;
            if ((a.update(u, c, n, (this.imageAtlas && this.imageAtlas.patternPositions) || {}, o), a instanceof Hu || a instanceof Eu)) {
              const d = i.style.getOwnSourceCache(a.layers[0].source);
              i._terrain && i._terrain.enabled && d && a.programConfigurations.needsUpload && i._terrain._clearRenderCacheForTile(d.id, this.tileID);
            }
            const h = i && i.style && i.style.getOwnLayer(s);
            h && (this.queryPadding = Math.max(this.queryPadding, h.queryRadius(a)));
          }
        }
        holdingForFade() {
          return this.symbolFadeHoldUntil !== void 0;
        }
        symbolFadeFinished() {
          return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < oe.now();
        }
        clearFadeHold() {
          this.symbolFadeHoldUntil = void 0;
        }
        setHoldDuration(t) {
          this.symbolFadeHoldUntil = oe.now() + t;
        }
        setTexture(t, i) {
          const r = i.context,
            n = r.gl;
          (this.texture = this.texture || i.getTileTexture(t.width)), this.texture && this.texture instanceof vi ? this.texture.update(t, { useMipmap: !0 }) : ((this.texture = new vi(r, t, n.RGBA, { useMipmap: !0 })), this.texture.bind(n.LINEAR, n.CLAMP_TO_EDGE));
        }
        setDependencies(t, i) {
          const r = {};
          for (const n of i) r[n] = !0;
          this.dependencies[t] = r;
        }
        hasDependency(t, i) {
          for (const r of t) {
            const n = this.dependencies[r];
            if (n) {
              for (const o of i) if (n[o]) return !0;
            }
          }
          return !1;
        }
        clearQueryDebugViz() {}
        _makeDebugTileBoundsBuffers(t, i) {
          if (!i || i.name === 'mercator' || this._tileDebugBuffer) return;
          const r = On(Pv, this.tileID.canonical, this.tileTransform)[0],
            n = new Rr(),
            o = new vl();
          for (let s = 0; s < r.length; s++) {
            const { x: a, y: l } = r[s];
            n.emplaceBack(a, l), o.emplaceBack(s);
          }
          o.emplaceBack(0), (this._tileDebugIndexBuffer = t.createIndexBuffer(o)), (this._tileDebugBuffer = t.createVertexBuffer(n, ko.members)), (this._tileDebugSegments = He.simpleSegment(0, 0, n.length, o.length));
        }
        _makeTileBoundsBuffers(t, i) {
          if (this._tileBoundsBuffer || !i || i.name === 'mercator') return;
          const r = On(Pv, this.tileID.canonical, this.tileTransform)[0];
          let n, o;
          if (this.isRaster) {
            const s = (function (a, l) {
              const c = Es(a, l),
                u = Math.pow(2, a.z);
              for (let g = 0; g < Fn; g++)
                for (let y = 0; y < Fn; y++) {
                  const v = Or((a.x + (y + Cv(y)) / dn) / u),
                    w = Ni((a.y + (g + Cv(g)) / dn) / u),
                    T = l.project(v, w),
                    b = g * Fn + y;
                  (Nn[2 * b + 0] = Math.round((T.x * c.scale - c.x) * lt)), (Nn[2 * b + 1] = Math.round((T.y * c.scale - c.y) * lt));
                }
              Ho.fill(0), Xu.fill(0);
              for (let g = 2045; g >= 0; g--) {
                const y = 4 * g,
                  v = $o[y + 0],
                  w = $o[y + 1],
                  T = $o[y + 2],
                  b = $o[y + 3],
                  E = (v + T) >> 1,
                  S = (w + b) >> 1,
                  I = E + S - w,
                  C = S + v - E,
                  z = w * Fn + v,
                  k = b * Fn + T,
                  O = S * Fn + E,
                  V = Math.hypot((Nn[2 * z + 0] + Nn[2 * k + 0]) / 2 - Nn[2 * O + 0], (Nn[2 * z + 1] + Nn[2 * k + 1]) / 2 - Nn[2 * O + 1]) >= 16;
                (Ho[O] = Ho[O] || (V ? 1 : 0)), g < 1022 && (Ho[O] = Ho[O] || Ho[((w + C) >> 1) * Fn + ((v + I) >> 1)] || Ho[((b + C) >> 1) * Fn + ((T + I) >> 1)]);
              }
              const h = new gs(),
                d = new Fi();
              let f = 0;
              function p(g, y) {
                const v = y * Fn + g;
                return Xu[v] === 0 && (h.emplaceBack(Nn[2 * v + 0], Nn[2 * v + 1], (g * lt) / dn, (y * lt) / dn), (Xu[v] = ++f)), Xu[v] - 1;
              }
              function _(g, y, v, w, T, b) {
                const E = (g + v) >> 1,
                  S = (y + w) >> 1;
                if (Math.abs(g - T) + Math.abs(y - b) > 1 && Ho[S * Fn + E]) _(T, b, g, y, E, S), _(v, w, T, b, E, S);
                else {
                  const I = p(g, y),
                    C = p(v, w),
                    z = p(T, b);
                  d.emplaceBack(I, C, z);
                }
              }
              return _(0, 0, dn, dn, dn, 0), _(dn, dn, 0, 0, 0, dn), { vertices: h, indices: d };
            })(this.tileID.canonical, i);
            (n = s.vertices), (o = s.indices);
          } else {
            (n = new gs()), (o = new Fi());
            for (const { x: a, y: l } of r) n.emplaceBack(a, l, 0, 0);
            const s = Tu(n.int16, void 0, 4);
            for (let a = 0; a < s.length; a += 3) o.emplaceBack(s[a], s[a + 1], s[a + 2]);
          }
          (this._tileBoundsBuffer = t.createVertexBuffer(n, Hp.members)), (this._tileBoundsIndexBuffer = t.createIndexBuffer(o)), (this._tileBoundsSegments = He.simpleSegment(0, 0, n.length, o.length));
        }
        _makeGlobeTileDebugBuffers(t, i) {
          const r = i.projection;
          if (!r || r.name !== 'globe' || i.freezeTileCoverage) return;
          const n = this.tileID.canonical,
            o = Bo(tx(n, i)),
            s = Ji(i.zoom);
          let a;
          s > 0 && (a = J.invert(new Float64Array(16), i.globeMatrix)), this._makeGlobeTileDebugBorderBuffer(t, n, i, o, a, s), this._makeGlobeTileDebugTextBuffer(t, n, i, o, a, s);
        }
        _globePoint(t, i, r, n, o, s, a) {
          let l = Al(t, i, r);
          if (s) {
            const c = 1 << r.z,
              u = qi(n.center.lng),
              h = Hi(n.center.lat),
              d = (r.x + 0.5) / c - u;
            let f = 0;
            d > 0.5 ? (f = -1) : d < -0.5 && (f = 1);
            let p = (t / lt + r.x) / c + f,
              _ = (i / lt + r.y) / c;
            (p = (p - u) * n._pixelsPerMercatorPixel + u), (_ = (_ - h) * n._pixelsPerMercatorPixel + h);
            const g = [p * n.worldSize, _ * n.worldSize, 0];
            N.transformMat4(g, g, s), (l = ho(l, g, a));
          }
          return N.transformMat4(l, l, o);
        }
        _makeGlobeTileDebugBorderBuffer(t, i, r, n, o, s) {
          const a = new Rr(),
            l = new vl(),
            c = new Jc(),
            u = (d, f, p, _, g) => {
              const y = (p - d) / (g - 1),
                v = (_ - f) / (g - 1),
                w = a.length;
              for (let T = 0; T < g; T++) {
                const b = d + T * y,
                  E = f + T * v;
                a.emplaceBack(b, E);
                const S = this._globePoint(b, E, i, r, n, o, s);
                c.emplaceBack(S[0], S[1], S[2]), l.emplaceBack(w + T);
              }
            },
            h = lt;
          u(0, 0, h, 0, 16), u(h, 0, h, h, 16), u(h, h, 0, h, 16), u(0, h, 0, 0, 16), (this._tileDebugIndexBuffer = t.createIndexBuffer(l)), (this._tileDebugBuffer = t.createVertexBuffer(a, ko.members)), (this._globeTileDebugBorderBuffer = t.createVertexBuffer(c, H0.members)), (this._tileDebugSegments = He.simpleSegment(0, 0, a.length, l.length));
        }
        _makeGlobeTileDebugTextBuffer(t, i, r, n, o, s) {
          const a = lt / 4,
            l = new Rr(),
            c = new Fi(),
            u = new Jc(),
            h = 25;
          c.reserve(32), l.reserve(h), u.reserve(h);
          const d = (f, p) => h * f + p;
          for (let f = 0; f < h; f++) {
            const p = f * a;
            for (let _ = 0; _ < h; _++) {
              const g = _ * a;
              l.emplaceBack(g, p);
              const y = this._globePoint(g, p, i, r, n, o, s);
              u.emplaceBack(y[0], y[1], y[2]);
            }
          }
          for (let f = 0; f < 4; f++)
            for (let p = 0; p < 4; p++) {
              const _ = d(f, p),
                g = d(f, p + 1),
                y = d(f + 1, p),
                v = d(f + 1, p + 1);
              c.emplaceBack(_, g, y), c.emplaceBack(y, g, v);
            }
          (this._tileDebugTextIndexBuffer = t.createIndexBuffer(c)), (this._tileDebugTextBuffer = t.createVertexBuffer(l, ko.members)), (this._globeTileDebugTextBuffer = t.createVertexBuffer(u, H0.members)), (this._tileDebugTextSegments = He.simpleSegment(0, 0, h, 32));
        }
        destroy(t = !1) {
          for (const i in this.buckets) this.buckets[i].destroy();
          (this.buckets = {}), this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && (this.imageAtlasTexture.destroy(), delete this.imageAtlasTexture), this.glyphAtlasTexture && (this.glyphAtlasTexture.destroy(), delete this.glyphAtlasTexture), this.lineAtlasTexture && (this.lineAtlasTexture.destroy(), delete this.lineAtlasTexture), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), (this._tileBoundsBuffer = null)), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), (this._tileDebugBuffer = null)), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), (this._tileDebugIndexBuffer = null)), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), (this._globeTileDebugBorderBuffer = null)), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), (this._tileDebugTextBuffer = null)), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), (this._globeTileDebugTextBuffer = null)), !t && this.texture && this.texture instanceof vi && (this.texture.destroy(), delete this.texture), this.hillshadeFBO && (this.hillshadeFBO.destroy(), delete this.hillshadeFBO), this.dem && delete this.dem, this.neighboringTiles && delete this.neighboringTiles, this.demTexture && (this.demTexture.destroy(), delete this.demTexture), (this.latestFeatureIndex = null), (this.state = 'unloaded');
        }
      }
      class pI {
        constructor(t, i) {
          (this.max = t), (this.onRemove = i), this.reset();
        }
        reset() {
          for (const t in this.data) for (const i of this.data[t]) i.timeout && clearTimeout(i.timeout), this.onRemove(i.value);
          return (this.data = {}), (this.order = []), this;
        }
        add(t, i, r) {
          const n = t.wrapped().key;
          this.data[n] === void 0 && (this.data[n] = []);
          const o = { value: i, timeout: void 0 };
          if (
            (r !== void 0 &&
              (o.timeout = setTimeout(() => {
                this.remove(t, o);
              }, r)),
            this.data[n].push(o),
            this.order.push(n),
            this.order.length > this.max)
          ) {
            const s = this._getAndRemoveByKey(this.order[0]);
            s && this.onRemove(s);
          }
          return this;
        }
        has(t) {
          return t.wrapped().key in this.data;
        }
        getAndRemove(t) {
          return this.has(t) ? this._getAndRemoveByKey(t.wrapped().key) : null;
        }
        _getAndRemoveByKey(t) {
          const i = this.data[t].shift();
          return i.timeout && clearTimeout(i.timeout), this.data[t].length === 0 && delete this.data[t], this.order.splice(this.order.indexOf(t), 1), i.value;
        }
        getByKey(t) {
          const i = this.data[t];
          return i ? i[0].value : null;
        }
        get(t) {
          return this.has(t) ? this.data[t.wrapped().key][0].value : null;
        }
        remove(t, i) {
          if (!this.has(t)) return this;
          const r = t.wrapped().key,
            n = i === void 0 ? 0 : this.data[r].indexOf(i),
            o = this.data[r][n];
          return this.data[r].splice(n, 1), o.timeout && clearTimeout(o.timeout), this.data[r].length === 0 && delete this.data[r], this.onRemove(o.value), this.order.splice(this.order.indexOf(r), 1), this;
        }
        setMaxSize(t) {
          for (this.max = t; this.order.length > this.max; ) {
            const i = this._getAndRemoveByKey(this.order[0]);
            i && this.onRemove(i);
          }
          return this;
        }
        filter(t) {
          const i = [];
          for (const r in this.data) for (const n of this.data[r]) t(n.value) || i.push(n);
          for (const r of i) this.remove(r.value.tileID, r);
        }
      }
      class Wo {
        constructor(t, i, r, n) {
          (this.id = Wo.uniqueIdxCounter), Wo.uniqueIdxCounter++, (this.context = t);
          const o = t.gl;
          (this.buffer = o.createBuffer()), (this.dynamicDraw = !!r), this.context.unbindVAO(), t.bindElementBuffer.set(this.buffer), o.bufferData(o.ELEMENT_ARRAY_BUFFER, i.arrayBuffer, this.dynamicDraw ? o.DYNAMIC_DRAW : o.STATIC_DRAW), this.dynamicDraw || n || i.destroy();
        }
        bind() {
          this.context.bindElementBuffer.set(this.buffer);
        }
        updateData(t) {
          (this.id = Wo.uniqueIdxCounter), Wo.uniqueIdxCounter++;
          const i = this.context.gl;
          this.context.unbindVAO(), this.bind(), i.bufferSubData(i.ELEMENT_ARRAY_BUFFER, 0, t.arrayBuffer);
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      Wo.uniqueIdxCounter = 0;
      const mI = { Int8: 'BYTE', Uint8: 'UNSIGNED_BYTE', Int16: 'SHORT', Uint16: 'UNSIGNED_SHORT', Int32: 'INT', Uint32: 'UNSIGNED_INT', Float32: 'FLOAT' };
      class _I {
        constructor(t, i, r, n, o, s) {
          (this.length = i.length), (this.attributes = r), (this.itemSize = i.bytesPerElement), (this.dynamicDraw = n), (this.instanceCount = s), (this.context = t);
          const a = t.gl;
          (this.buffer = a.createBuffer()), t.bindVertexBuffer.set(this.buffer), a.bufferData(a.ARRAY_BUFFER, i.arrayBuffer, this.dynamicDraw ? a.DYNAMIC_DRAW : a.STATIC_DRAW), this.dynamicDraw || o || i.destroy();
        }
        bind() {
          this.context.bindVertexBuffer.set(this.buffer);
        }
        updateData(t) {
          const i = this.context.gl;
          this.bind(), i.bufferSubData(i.ARRAY_BUFFER, 0, t.arrayBuffer);
        }
        enableAttributes(t, i) {
          for (let r = 0; r < this.attributes.length; r++) {
            const n = i.attributes[this.attributes[r].name];
            n !== void 0 && t.enableVertexAttribArray(n);
          }
        }
        setVertexAttribPointers(t, i, r) {
          for (let n = 0; n < this.attributes.length; n++) {
            const o = this.attributes[n],
              s = i.attributes[o.name];
            s !== void 0 && t.vertexAttribPointer(s, o.components, t[mI[o.type]], !1, this.itemSize, o.offset + this.itemSize * (r || 0));
          }
        }
        setVertexAttribDivisor(t, i, r) {
          for (let n = 0; n < this.attributes.length; n++) {
            const o = i.attributes[this.attributes[n].name];
            o !== void 0 && this.instanceCount && this.instanceCount > 0 && t.vertexAttribDivisor(o, r);
          }
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      class li {
        constructor(t) {
          (this.gl = t.gl), (this.default = this.getDefault()), (this.current = this.default), (this.dirty = !1);
        }
        get() {
          return this.current;
        }
        set(t) {}
        getDefault() {
          return this.default;
        }
        setDefault() {
          this.set(this.default);
        }
      }
      class gI extends li {
        getDefault() {
          return pe.transparent;
        }
        set(t) {
          const i = this.current;
          (t.r !== i.r || t.g !== i.g || t.b !== i.b || t.a !== i.a || this.dirty) && (this.gl.clearColor(t.r, t.g, t.b, t.a), (this.current = t), (this.dirty = !1));
        }
      }
      class yI extends li {
        getDefault() {
          return 1;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.clearDepth(t), (this.current = t), (this.dirty = !1));
        }
      }
      class xI extends li {
        getDefault() {
          return 0;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.clearStencil(t), (this.current = t), (this.dirty = !1));
        }
      }
      class vI extends li {
        getDefault() {
          return [!0, !0, !0, !0];
        }
        set(t) {
          const i = this.current;
          (t[0] !== i[0] || t[1] !== i[1] || t[2] !== i[2] || t[3] !== i[3] || this.dirty) && (this.gl.colorMask(t[0], t[1], t[2], t[3]), (this.current = t), (this.dirty = !1));
        }
      }
      class bI extends li {
        getDefault() {
          return !0;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.depthMask(t), (this.current = t), (this.dirty = !1));
        }
      }
      class wI extends li {
        getDefault() {
          return 255;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.stencilMask(t), (this.current = t), (this.dirty = !1));
        }
      }
      class TI extends li {
        getDefault() {
          return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
        }
        set(t) {
          const i = this.current;
          (t.func !== i.func || t.ref !== i.ref || t.mask !== i.mask || this.dirty) && (this.gl.stencilFunc(t.func, t.ref, t.mask), (this.current = t), (this.dirty = !1));
        }
      }
      class EI extends li {
        getDefault() {
          const t = this.gl;
          return [t.KEEP, t.KEEP, t.KEEP];
        }
        set(t) {
          const i = this.current;
          (t[0] !== i[0] || t[1] !== i[1] || t[2] !== i[2] || this.dirty) && (this.gl.stencilOp(t[0], t[1], t[2]), (this.current = t), (this.dirty = !1));
        }
      }
      class MI extends li {
        getDefault() {
          return !1;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const i = this.gl;
          t ? i.enable(i.STENCIL_TEST) : i.disable(i.STENCIL_TEST), (this.current = t), (this.dirty = !1);
        }
      }
      class SI extends li {
        getDefault() {
          return [0, 1];
        }
        set(t) {
          const i = this.current;
          (t[0] !== i[0] || t[1] !== i[1] || this.dirty) && (this.gl.depthRange(t[0], t[1]), (this.current = t), (this.dirty = !1));
        }
      }
      class AI extends li {
        getDefault() {
          return !1;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const i = this.gl;
          t ? i.enable(i.DEPTH_TEST) : i.disable(i.DEPTH_TEST), (this.current = t), (this.dirty = !1);
        }
      }
      class II extends li {
        getDefault() {
          return this.gl.LESS;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.depthFunc(t), (this.current = t), (this.dirty = !1));
        }
      }
      class CI extends li {
        getDefault() {
          return !1;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const i = this.gl;
          t ? i.enable(i.BLEND) : i.disable(i.BLEND), (this.current = t), (this.dirty = !1);
        }
      }
      class PI extends li {
        getDefault() {
          const t = this.gl;
          return [t.ONE, t.ZERO, t.ONE, t.ZERO];
        }
        set(t) {
          const i = this.current;
          (t[0] !== i[0] || t[1] !== i[1] || t[2] !== i[2] || t[3] !== i[3] || this.dirty) && (this.gl.blendFuncSeparate(t[0], t[1], t[2], t[3]), (this.current = t), (this.dirty = !1));
        }
      }
      class zI extends li {
        getDefault() {
          return pe.transparent;
        }
        set(t) {
          const i = this.current;
          (t.r !== i.r || t.g !== i.g || t.b !== i.b || t.a !== i.a || this.dirty) && (this.gl.blendColor(t.r, t.g, t.b, t.a), (this.current = t), (this.dirty = !1));
        }
      }
      class DI extends li {
        getDefault() {
          return this.gl.FUNC_ADD;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.blendEquationSeparate(t, t), (this.current = t), (this.dirty = !1));
        }
      }
      class RI extends li {
        getDefault() {
          return !1;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const i = this.gl;
          t ? i.enable(i.CULL_FACE) : i.disable(i.CULL_FACE), (this.current = t), (this.dirty = !1);
        }
      }
      class LI extends li {
        getDefault() {
          return this.gl.BACK;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.cullFace(t), (this.current = t), (this.dirty = !1));
        }
      }
      class kI extends li {
        getDefault() {
          return this.gl.CCW;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.frontFace(t), (this.current = t), (this.dirty = !1));
        }
      }
      let OI = class extends li {
        getDefault() {
          return null;
        }
        set(e) {
          (e !== this.current || this.dirty) && (this.gl.useProgram(e), (this.current = e), (this.dirty = !1));
        }
      };
      class BI extends li {
        getDefault() {
          return this.gl.TEXTURE0;
        }
        set(t) {
          (t !== this.current || this.dirty) && (this.gl.activeTexture(t), (this.current = t), (this.dirty = !1));
        }
      }
      class FI extends li {
        getDefault() {
          const t = this.gl;
          return [0, 0, t.drawingBufferWidth, t.drawingBufferHeight];
        }
        set(t) {
          const i = this.current;
          (t[0] !== i[0] || t[1] !== i[1] || t[2] !== i[2] || t[3] !== i[3] || this.dirty) && (this.gl.viewport(t[0], t[1], t[2], t[3]), (this.current = t), (this.dirty = !1));
        }
      }
      class NI extends li {
        getDefault() {
          return null;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const i = this.gl;
          i.bindFramebuffer(i.FRAMEBUFFER, t), (this.current = t), (this.dirty = !1);
        }
      }
      class UI extends li {
        getDefault() {
          return null;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const i = this.gl;
          i.bindRenderbuffer(i.RENDERBUFFER, t), (this.current = t), (this.dirty = !1);
        }
      }
      class VI extends li {
        getDefault() {
          return null;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const i = this.gl;
          i.bindTexture(i.TEXTURE_2D, t), (this.current = t), (this.dirty = !1);
        }
      }
      class jI extends li {
        getDefault() {
          return null;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const i = this.gl;
          i.bindBuffer(i.ARRAY_BUFFER, t), (this.current = t), (this.dirty = !1);
        }
      }
      class GI extends li {
        getDefault() {
          return null;
        }
        set(t) {
          const i = this.gl;
          i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, t), (this.current = t), (this.dirty = !1);
        }
      }
      class qI extends li {
        getDefault() {
          return null;
        }
        set(t) {
          this.gl && (t !== this.current || this.dirty) && (this.gl.bindVertexArray(t), (this.current = t), (this.dirty = !1));
        }
      }
      class ZI extends li {
        getDefault() {
          return 4;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const i = this.gl;
          i.pixelStorei(i.UNPACK_ALIGNMENT, t), (this.current = t), (this.dirty = !1);
        }
      }
      class $I extends li {
        getDefault() {
          return !1;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const i = this.gl;
          i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t), (this.current = t), (this.dirty = !1);
        }
      }
      class HI extends li {
        getDefault() {
          return !1;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          const i = this.gl;
          i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, t), (this.current = t), (this.dirty = !1);
        }
      }
      class Wp extends li {
        constructor(t, i) {
          super(t), (this.context = t), (this.parent = i);
        }
        getDefault() {
          return null;
        }
      }
      class WI extends Wp {
        setDirty() {
          this.dirty = !0;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          const i = this.gl;
          i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, t, 0), (this.current = t), (this.dirty = !1);
        }
      }
      class zv extends Wp {
        attachment() {
          return this.gl.DEPTH_ATTACHMENT;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          const i = this.gl;
          i.framebufferRenderbuffer(i.FRAMEBUFFER, this.attachment(), i.RENDERBUFFER, t), (this.current = t), (this.dirty = !1);
        }
      }
      class XI extends Wp {
        attachment() {
          return this.gl.DEPTH_ATTACHMENT;
        }
        set(t) {
          if (t === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          const i = this.gl;
          i.framebufferTexture2D(i.FRAMEBUFFER, this.attachment(), i.TEXTURE_2D, t, 0), (this.current = t), (this.dirty = !1);
        }
      }
      class YI extends zv {
        attachment() {
          return this.gl.DEPTH_STENCIL_ATTACHMENT;
        }
      }
      class KI {
        constructor(t, i, r, n, o) {
          (this.context = t), (this.width = i), (this.height = r);
          const s = (this.framebuffer = t.gl.createFramebuffer());
          n && (this.colorAttachment = new WI(t, s)), o && ((this.depthAttachmentType = o), (this.depthAttachment = o === 'renderbuffer' ? new zv(t, s) : new XI(t, s)));
        }
        destroy() {
          const t = this.context.gl;
          if (this.colorAttachment) {
            const i = this.colorAttachment.get();
            i && t.deleteTexture(i);
          }
          if (this.depthAttachment && this.depthAttachmentType)
            if (this.depthAttachmentType === 'renderbuffer') {
              const i = this.depthAttachment.get();
              i && t.deleteRenderbuffer(i);
            } else {
              const i = this.depthAttachment.get();
              i && t.deleteTexture(i);
            }
          t.deleteFramebuffer(this.framebuffer);
        }
      }
      class Jt {
        constructor(t, i, r) {
          (this.func = t), (this.mask = i), (this.range = r);
        }
      }
      (Jt.ReadOnly = !1), (Jt.ReadWrite = !0), (Jt.disabled = new Jt(519, Jt.ReadOnly, [0, 1]));
      const Xp = 7680;
      class me {
        constructor(t, i, r, n, o, s) {
          (this.test = t), (this.ref = i), (this.mask = r), (this.fail = n), (this.depthFail = o), (this.pass = s);
        }
      }
      me.disabled = new me({ func: 519, mask: 0 }, 0, 0, Xp, Xp, Xp);
      const Yu = 771;
      class De {
        constructor(t, i, r, n) {
          (this.blendFunction = t), (this.blendColor = i), (this.mask = r), (this.blendEquation = n);
        }
      }
      (De.Replace = [1, 0, 1, 0]), (De.disabled = new De(De.Replace, pe.transparent, [!1, !1, !1, !1])), (De.unblended = new De(De.Replace, pe.transparent, [!0, !0, !0, !0])), (De.alphaBlended = new De([1, Yu, 1, Yu], pe.transparent, [!0, !0, !0, !0])), (De.multiply = new De([774, 0, 774, 0], pe.transparent, [!0, !0, !0, !0]));
      const Yp = 1029,
        Kp = 2305;
      class ye {
        constructor(t, i, r) {
          (this.enable = t), (this.mode = i), (this.frontFace = r);
        }
      }
      (ye.disabled = new ye(!1, Yp, Kp)), (ye.backCCW = new ye(!0, Yp, Kp)), (ye.backCW = new ye(!0, Yp, 2304)), (ye.frontCW = new ye(!0, 1028, 2304)), (ye.frontCCW = new ye(!0, 1028, Kp));
      class JI {
        constructor(t, i) {
          (this.gl = t),
            (this.clearColor = new gI(this)),
            (this.clearDepth = new yI(this)),
            (this.clearStencil = new xI(this)),
            (this.colorMask = new vI(this)),
            (this.depthMask = new bI(this)),
            (this.stencilMask = new wI(this)),
            (this.stencilFunc = new TI(this)),
            (this.stencilOp = new EI(this)),
            (this.stencilTest = new MI(this)),
            (this.depthRange = new SI(this)),
            (this.depthTest = new AI(this)),
            (this.depthFunc = new II(this)),
            (this.blend = new CI(this)),
            (this.blendFunc = new PI(this)),
            (this.blendColor = new zI(this)),
            (this.blendEquation = new DI(this)),
            (this.cullFace = new RI(this)),
            (this.cullFaceSide = new LI(this)),
            (this.frontFace = new kI(this)),
            (this.program = new OI(this)),
            (this.activeTexture = new BI(this)),
            (this.viewport = new FI(this)),
            (this.bindFramebuffer = new NI(this)),
            (this.bindRenderbuffer = new UI(this)),
            (this.bindTexture = new VI(this)),
            (this.bindVertexBuffer = new jI(this)),
            (this.bindElementBuffer = new GI(this)),
            (this.bindVertexArrayOES = new qI(this)),
            (this.pixelStoreUnpack = new ZI(this)),
            (this.pixelStoreUnpackPremultiplyAlpha = new $I(this)),
            (this.pixelStoreUnpackFlipY = new HI(this)),
            (this.options = i ? { ...i } : {}),
            this.options.extTextureFilterAnisotropicForceOff || ((this.extTextureFilterAnisotropic = t.getExtension('EXT_texture_filter_anisotropic') || t.getExtension('MOZ_EXT_texture_filter_anisotropic') || t.getExtension('WEBKIT_EXT_texture_filter_anisotropic')), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT))),
            (this.extDebugRendererInfo = t.getExtension('WEBGL_debug_renderer_info')),
            this.extDebugRendererInfo && ((this.renderer = t.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL)), (this.vendor = t.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL))),
            this.options.extTextureFloatLinearForceOff || (this.extTextureFloatLinear = t.getExtension('OES_texture_float_linear')),
            (this.extRenderToTextureHalfFloat = t.getExtension('EXT_color_buffer_half_float')),
            (this.extTimerQuery = t.getExtension('EXT_disjoint_timer_query_webgl2')),
            (this.maxTextureSize = t.getParameter(t.MAX_TEXTURE_SIZE));
        }
        setDefault() {
          this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
        }
        setDirty() {
          (this.clearColor.dirty = !0), (this.clearDepth.dirty = !0), (this.clearStencil.dirty = !0), (this.colorMask.dirty = !0), (this.depthMask.dirty = !0), (this.stencilMask.dirty = !0), (this.stencilFunc.dirty = !0), (this.stencilOp.dirty = !0), (this.stencilTest.dirty = !0), (this.depthRange.dirty = !0), (this.depthTest.dirty = !0), (this.depthFunc.dirty = !0), (this.blend.dirty = !0), (this.blendFunc.dirty = !0), (this.blendColor.dirty = !0), (this.blendEquation.dirty = !0), (this.cullFace.dirty = !0), (this.cullFaceSide.dirty = !0), (this.frontFace.dirty = !0), (this.program.dirty = !0), (this.activeTexture.dirty = !0), (this.viewport.dirty = !0), (this.bindFramebuffer.dirty = !0), (this.bindRenderbuffer.dirty = !0), (this.bindTexture.dirty = !0), (this.bindVertexBuffer.dirty = !0), (this.bindElementBuffer.dirty = !0), (this.bindVertexArrayOES.dirty = !0), (this.pixelStoreUnpack.dirty = !0), (this.pixelStoreUnpackPremultiplyAlpha.dirty = !0), (this.pixelStoreUnpackFlipY.dirty = !0);
        }
        createIndexBuffer(t, i, r) {
          return new Wo(this, t, i, r);
        }
        createVertexBuffer(t, i, r, n, o) {
          return new _I(this, t, i, r, n, o);
        }
        createRenderbuffer(t, i, r) {
          const n = this.gl,
            o = n.createRenderbuffer();
          return this.bindRenderbuffer.set(o), n.renderbufferStorage(n.RENDERBUFFER, t, i, r), this.bindRenderbuffer.set(null), o;
        }
        createFramebuffer(t, i, r, n) {
          return new KI(this, t, i, r, n);
        }
        clear({ color: t, depth: i, stencil: r, colorMask: n }) {
          const o = this.gl;
          let s = 0;
          t && ((s |= o.COLOR_BUFFER_BIT), this.clearColor.set(t), this.colorMask.set(n || [!0, !0, !0, !0])), i !== void 0 && ((s |= o.DEPTH_BUFFER_BIT), this.depthRange.set([0, 1]), this.clearDepth.set(i), this.depthMask.set(!0)), r !== void 0 && ((s |= o.STENCIL_BUFFER_BIT), this.clearStencil.set(r), this.stencilMask.set(255)), o.clear(s);
        }
        setCullFace(t) {
          t.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(t.mode), this.frontFace.set(t.frontFace));
        }
        setDepthMode(t) {
          t.func !== this.gl.ALWAYS || t.mask ? (this.depthTest.set(!0), this.depthFunc.set(t.func), this.depthMask.set(t.mask), this.depthRange.set(t.range)) : this.depthTest.set(!1);
        }
        setStencilMode(t) {
          t.test.func !== this.gl.ALWAYS || t.mask ? (this.stencilTest.set(!0), this.stencilMask.set(t.mask), this.stencilOp.set([t.fail, t.depthFail, t.pass]), this.stencilFunc.set({ func: t.test.func, ref: t.ref, mask: t.test.mask })) : this.stencilTest.set(!1);
        }
        setColorMode(t) {
          we(t.blendFunction, De.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(t.blendFunction), this.blendColor.set(t.blendColor), t.blendEquation ? this.blendEquation.set(t.blendEquation) : this.blendEquation.setDefault()), this.colorMask.set(t.mask);
        }
        unbindVAO() {
          this.bindVertexArrayOES.set(null);
        }
      }
      class wn extends Oi {
        constructor(t, i, r) {
          super(),
            (this.id = t),
            (this._onlySymbols = r),
            i.on('data', (n) => {
              n.dataType === 'source' && n.sourceDataType === 'metadata' && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && n.dataType === 'source' && n.sourceDataType === 'content' && (this.reload(), this.transform && this.update(this.transform));
            }),
            i.on('error', () => {
              this._sourceErrored = !0;
            }),
            (this._source = i),
            (this._tiles = {}),
            (this._cache = new pI(0, this._unloadTile.bind(this))),
            (this._timers = {}),
            (this._cacheTimers = {}),
            (this._minTileCacheSize = i.minTileCacheSize),
            (this._maxTileCacheSize = i.maxTileCacheSize),
            (this._loadedParentTiles = {}),
            (this.castsShadows = !1),
            (this._coveredTiles = {}),
            (this._shadowCasterTiles = {}),
            (this._state = new gA()),
            (this._isRaster = this._source.type === 'raster' || this._source.type === 'raster-dem' || (this._source.type === 'custom' && this._source._dataType === 'raster'));
        }
        onAdd(t) {
          (this.map = t), (this._minTileCacheSize = this._minTileCacheSize === void 0 && t ? t._minTileCacheSize : this._minTileCacheSize), (this._maxTileCacheSize = this._maxTileCacheSize === void 0 && t ? t._maxTileCacheSize : this._maxTileCacheSize);
        }
        loaded() {
          if (this._sourceErrored) return !0;
          if (!this._sourceLoaded || !this._source.loaded()) return !1;
          for (const t in this._tiles) {
            const i = this._tiles[t];
            if (i.state !== 'errored' && (i.state !== 'loaded' || !i.bucketsLoaded())) return !1;
          }
          return !0;
        }
        getSource() {
          return this._source;
        }
        pause() {
          this._paused = !0;
        }
        resume() {
          if (!this._paused) return;
          const t = this._shouldReloadOnResume;
          (this._paused = !1), (this._shouldReloadOnResume = !1), t && this.reload(), this.transform && this.update(this.transform);
        }
        _loadTile(t, i) {
          return (t.isSymbolTile = this._onlySymbols), (t.isExtraShadowCaster = this._shadowCasterTiles[t.tileID.key]), this._source.loadTile(t, i);
        }
        _unloadTile(t) {
          if (this._source.unloadTile) return this._source.unloadTile(t, () => {});
        }
        _abortTile(t) {
          if (this._source.abortTile) return this._source.abortTile(t, () => {});
        }
        serialize() {
          return this._source.serialize();
        }
        prepare(t) {
          this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
          for (const i in this._tiles) {
            const r = this._tiles[i];
            r.upload(t), r.prepare(this.map.style.imageManager, this.map ? this.map.painter : null, this._source.scope);
          }
        }
        getIds() {
          return hr(this._tiles)
            .map((t) => t.tileID)
            .sort(Dv)
            .map((t) => t.key);
        }
        getRenderableIds(t, i) {
          const r = [];
          for (const n in this._tiles) this._isIdRenderable(+n, t, i) && r.push(this._tiles[n]);
          return t
            ? r
                .sort((n, o) => {
                  const s = n.tileID,
                    a = o.tileID,
                    l = new H(s.canonical.x, s.canonical.y)._rotate(this.transform.angle),
                    c = new H(a.canonical.x, a.canonical.y)._rotate(this.transform.angle);
                  return s.overscaledZ - a.overscaledZ || c.y - l.y || c.x - l.x;
                })
                .map((n) => n.tileID.key)
            : r
                .map((n) => n.tileID)
                .sort(Dv)
                .map((n) => n.key);
        }
        hasRenderableParent(t) {
          const i = this.findLoadedParent(t, 0);
          return !!i && this._isIdRenderable(i.tileID.key);
        }
        _isIdRenderable(t, i, r) {
          return this._tiles[t] && this._tiles[t].hasData() && !this._coveredTiles[t] && (i || !this._tiles[t].holdingForFade()) && (r || !this._shadowCasterTiles[t]);
        }
        reload() {
          if (this._paused) this._shouldReloadOnResume = !0;
          else {
            this._cache.reset();
            for (const t in this._tiles) this._tiles[t].state !== 'errored' && this._reloadTile(+t, 'reloading');
          }
        }
        _reloadTile(t, i) {
          const r = this._tiles[t];
          r && (r.state !== 'loading' && (r.state = i), this._loadTile(r, this._tileLoaded.bind(this, r, t, i)));
        }
        _tileLoaded(t, i, r, n) {
          if (n)
            if (((t.state = 'errored'), n.status !== 404)) this._source.fire(new re(n, { tile: t }));
            else {
              if (!(t.tileID.key in this._loadedParentTiles)) return void this._source.fire(new wt('data', { dataType: 'source', sourceDataType: 'error', sourceId: this._source.id }));
              if (this._source.type === 'raster-dem' && this.usedForTerrain && this.map.painter.terrain) {
                const o = this.map.painter.terrain;
                this.update(this.transform, o.getScaledDemTileSize(), !0), o.resetTileLookupCache(this.id);
              } else this.update(this.transform);
            }
          else (t.timeAdded = oe.now()), r === 'expired' && (t.refreshedUponExpiration = !0), this._setTileReloadTimer(i, t), this._source.type === 'raster-dem' && t.dem && this._backfillDEM(t), this._state.initializeTileState(t, this.map ? this.map.painter : null), this._source.fire(new wt('data', { dataType: 'source', tile: t, coord: t.tileID, sourceCacheId: this.id }));
        }
        _backfillDEM(t) {
          const i = this.getRenderableIds();
          for (let n = 0; n < i.length; n++) {
            const o = i[n];
            if (t.neighboringTiles && t.neighboringTiles[o]) {
              const s = this.getTileByID(o);
              r(t, s), r(s, t);
            }
          }
          function r(n, o) {
            if (!n.dem || n.dem.borderReady) return;
            (n.needsHillshadePrepare = !0), (n.needsDEMTextureUpload = !0);
            let s = o.tileID.canonical.x - n.tileID.canonical.x;
            const a = o.tileID.canonical.y - n.tileID.canonical.y,
              l = Math.pow(2, n.tileID.canonical.z),
              c = o.tileID.key;
            (s === 0 && a === 0) || Math.abs(a) > 1 || (Math.abs(s) > 1 && (Math.abs(s + l) === 1 ? (s += l) : Math.abs(s - l) === 1 && (s -= l)), o.dem && n.dem && (n.dem.backfillBorder(o.dem, s, a), n.neighboringTiles && n.neighboringTiles[c] && (n.neighboringTiles[c].backfilled = !0)));
          }
        }
        getTile(t) {
          return this.getTileByID(t.key);
        }
        getTileByID(t) {
          return this._tiles[t];
        }
        _retainLoadedChildren(t, i, r, n) {
          for (const o in this._tiles) {
            let s = this._tiles[o];
            if (n[o] || !s.hasData() || s.tileID.overscaledZ <= i || s.tileID.overscaledZ > r) continue;
            let a = s.tileID;
            for (; s && s.tileID.overscaledZ > i + 1; ) {
              const c = s.tileID.scaledTo(s.tileID.overscaledZ - 1);
              (s = this._tiles[c.key]), s && s.hasData() && (a = c);
            }
            let l = a;
            for (; l.overscaledZ > i; )
              if (((l = l.scaledTo(l.overscaledZ - 1)), t[l.key])) {
                n[a.key] = a;
                break;
              }
          }
        }
        findLoadedParent(t, i) {
          if (t.key in this._loadedParentTiles) {
            const r = this._loadedParentTiles[t.key];
            return r && r.tileID.overscaledZ >= i ? r : null;
          }
          for (let r = t.overscaledZ - 1; r >= i; r--) {
            const n = t.scaledTo(r),
              o = this._getLoadedTile(n);
            if (o) return o;
          }
        }
        _getLoadedTile(t) {
          const i = this._tiles[t.key];
          return i && i.hasData() ? i : this._cache.getByKey(this._source.reparseOverscaled ? t.wrapped().key : t.canonical.key);
        }
        updateCacheSize(t, i) {
          i = i || this._source.tileSize;
          const r = Math.ceil(t.width / i) + 1,
            n = Math.ceil(t.height / i) + 1,
            o = Math.floor(r * n * 5),
            s = typeof this._minTileCacheSize == 'number' ? Math.max(this._minTileCacheSize, o) : o,
            a = typeof this._maxTileCacheSize == 'number' ? Math.min(this._maxTileCacheSize, s) : s;
          this._cache.setMaxSize(a);
        }
        handleWrapJump(t) {
          const i = Math.round((t - (this._prevLng === void 0 ? t : this._prevLng)) / 360);
          if (((this._prevLng = t), i)) {
            const r = {};
            for (const n in this._tiles) {
              const o = this._tiles[n];
              (o.tileID = o.tileID.unwrapTo(o.tileID.wrap + i)), (r[o.tileID.key] = o);
            }
            this._tiles = r;
            for (const n in this._timers) clearTimeout(this._timers[n]), delete this._timers[n];
            for (const n in this._tiles) this._setTileReloadTimer(+n, this._tiles[n]);
          }
        }
        update(t, i, r, n) {
          if (((this.transform = t), !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage || (this.usedForTerrain && !r))) return;
          let o;
          if ((this.updateCacheSize(t, i), this.transform.projection.name !== 'globe' && this.handleWrapJump(this.transform.center.lng), (this._shadowCasterTiles = {}), (this._coveredTiles = {}), this.used || this.usedForTerrain ? (this._source.tileID ? (o = t.getVisibleUnwrappedCoordinates(this._source.tileID).map((l) => new Le(l.canonical.z, l.wrap, l.canonical.z, l.canonical.x, l.canonical.y))) : ((o = t.coveringTiles({ tileSize: i || this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !r, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain })), this._source.hasTile && (o = o.filter((l) => this._source.hasTile(l))))) : (o = []), o.length > 0 && this.castsShadows && n && this.transform.projection.name !== 'globe' && !this.usedForTerrain && !Jp(this._source.type))) {
            const l = t.coveringZoomLevel({ tileSize: i || this._source.tileSize, roundZoom: this._source.roundZoom && !r }),
              c = Math.min(l, this._source.maxzoom),
              u = t.extendTileCoverForShadows(o, n, c);
            for (const h of u) (this._shadowCasterTiles[h.key] = !0), o.push(h);
          }
          const s = this._updateRetainedTiles(o);
          if (Jp(this._source.type) && o.length !== 0) {
            const l = {},
              c = {},
              u = Object.keys(s);
            for (const d of u) {
              const f = s[d],
                p = this._tiles[d];
              if (!p || (p.fadeEndTime && p.fadeEndTime <= oe.now())) continue;
              const _ = this.findLoadedParent(f, Math.max(f.overscaledZ - wn.maxOverzooming, this._source.minzoom));
              _ && (this._addTile(_.tileID), (l[_.tileID.key] = _.tileID)), (c[d] = f);
            }
            const h = o[o.length - 1].overscaledZ;
            for (const d in this._tiles) {
              const f = this._tiles[d];
              if (s[d] || !f.hasData()) continue;
              let p = f.tileID;
              for (; p.overscaledZ > h; ) {
                p = p.scaledTo(p.overscaledZ - 1);
                const _ = this._tiles[p.key];
                if (_ && _.hasData() && c[p.key]) {
                  s[d] = f.tileID;
                  break;
                }
              }
            }
            for (const d in l) s[d] || ((this._coveredTiles[d] = !0), (s[d] = l[d]));
          }
          for (const l in s) this._tiles[l].clearFadeHold();
          const a = (function (l, c) {
            const u = [];
            for (const h in l) h in c || u.push(h);
            return u;
          })(this._tiles, s);
          for (const l of a) {
            const c = this._tiles[l];
            c.hasSymbolBuckets && !c.holdingForFade() ? c.setHoldDuration(this.map._fadeDuration) : (c.hasSymbolBuckets && !c.symbolFadeFinished()) || this._removeTile(+l);
          }
          this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate();
        }
        releaseSymbolFadeTiles() {
          for (const t in this._tiles) this._tiles[t].holdingForFade() && this._removeTile(+t);
        }
        _updateRetainedTiles(t) {
          const i = {};
          if (t.length === 0) return i;
          const r = {},
            n = t.reduce((c, u) => Math.min(c, u.overscaledZ), 1 / 0),
            o = t[0].overscaledZ,
            s = Math.max(o - wn.maxOverzooming, this._source.minzoom),
            a = Math.max(o + wn.maxUnderzooming, this._source.minzoom),
            l = {};
          for (const c of t) {
            const u = this._addTile(c);
            (i[c.key] = c), u.hasData() || (n < this._source.maxzoom && (l[c.key] = c));
          }
          this._retainLoadedChildren(l, n, a, i);
          for (const c of t) {
            let u = this._tiles[c.key];
            if (u.hasData()) continue;
            if (c.canonical.z >= this._source.maxzoom) {
              const d = c.children(this._source.maxzoom)[0],
                f = this.getTile(d);
              if (f && f.hasData()) {
                i[d.key] = d;
                continue;
              }
            } else {
              const d = c.children(this._source.maxzoom);
              if (i[d[0].key] && i[d[1].key] && i[d[2].key] && i[d[3].key]) continue;
            }
            let h = u.wasRequested();
            for (let d = c.overscaledZ - 1; d >= s; --d) {
              const f = c.scaledTo(d);
              if (r[f.key] || ((r[f.key] = !0), (u = this.getTile(f)), !u && h && (u = this._addTile(f)), u && ((i[f.key] = f), (h = u.wasRequested()), u.hasData()))) break;
            }
          }
          return i;
        }
        _updateLoadedParentTileCache() {
          this._loadedParentTiles = {};
          for (const t in this._tiles) {
            const i = [];
            let r,
              n = this._tiles[t].tileID;
            for (; n.overscaledZ > 0; ) {
              if (n.key in this._loadedParentTiles) {
                r = this._loadedParentTiles[n.key];
                break;
              }
              i.push(n.key);
              const o = n.scaledTo(n.overscaledZ - 1);
              if (((r = this._getLoadedTile(o)), r)) break;
              n = o;
            }
            for (const o of i) this._loadedParentTiles[o] = r;
          }
        }
        _addTile(t) {
          let i = this._tiles[t.key];
          if (i) return i.isExtraShadowCaster !== !0 || this._shadowCasterTiles[t.key] || this._reloadTile(t.key, 'reloading'), i;
          (i = this._cache.getAndRemove(t)), i && (this._setTileReloadTimer(t.key, i), (i.tileID = t), this._state.initializeTileState(i, this.map ? this.map.painter : null), this._cacheTimers[t.key] && (clearTimeout(this._cacheTimers[t.key]), delete this._cacheTimers[t.key], this._setTileReloadTimer(t.key, i)));
          const r = !!i;
          if (!r) {
            const n = this.map ? this.map.painter : null;
            (i = new jl(t, this._source.tileSize * t.overscaleFactor(), this.transform.tileZoom, n, this._isRaster)), this._loadTile(i, this._tileLoaded.bind(this, i, t.key, i.state));
          }
          return i ? (i.uses++, (this._tiles[t.key] = i), r || this._source.fire(new wt('dataloading', { tile: i, coord: i.tileID, dataType: 'source' })), i) : null;
        }
        _setTileReloadTimer(t, i) {
          t in this._timers && (clearTimeout(this._timers[t]), delete this._timers[t]);
          const r = i.getExpiryTimeout();
          r &&
            (this._timers[t] = setTimeout(() => {
              this._reloadTile(t, 'expired'), delete this._timers[t];
            }, r));
        }
        _removeTile(t) {
          const i = this._tiles[t];
          i && (i.uses--, delete this._tiles[t], this._timers[t] && (clearTimeout(this._timers[t]), delete this._timers[t]), i.uses > 0 || (i.hasData() && i.state !== 'reloading' ? this._cache.add(i.tileID, i, i.getExpiryTimeout()) : ((i.aborted = !0), this._abortTile(i), this._unloadTile(i))));
        }
        clearTiles() {
          (this._shouldReloadOnResume = !1), (this._paused = !1);
          for (const t in this._tiles) this._removeTile(+t);
          this._source._clear && this._source._clear(), this._cache.reset(), this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id);
        }
        tilesIn(t, i, r) {
          const n = [],
            o = this.transform;
          if (!o) return n;
          const s = o.projection.name === 'globe',
            a = qi(o.center.lng);
          for (const l in this._tiles) {
            const c = this._tiles[l];
            if ((r && c.clearQueryDebugViz(), c.holdingForFade())) continue;
            let u;
            if (s) {
              const h = c.tileID.canonical;
              if (h.z === 0) {
                const d = [Math.abs(Bt(a, ...Gl(h, -1)) - a), Math.abs(Bt(a, ...Gl(h, 1)) - a)];
                u = [0, 2 * d.indexOf(Math.min(...d)) - 1];
              } else {
                const d = [Math.abs(Bt(a, ...Gl(h, -1)) - a), Math.abs(Bt(a, ...Gl(h, 0)) - a), Math.abs(Bt(a, ...Gl(h, 1)) - a)];
                u = [d.indexOf(Math.min(...d)) - 1];
              }
            } else u = [0];
            for (const h of u) {
              const d = t.containsTile(c, o, i, h);
              d && n.push(d);
            }
          }
          return n;
        }
        getShadowCasterCoordinates() {
          return this._getRenderableCoordinates(!1, !0);
        }
        getVisibleCoordinates(t) {
          return this._getRenderableCoordinates(t);
        }
        _getRenderableCoordinates(t, i) {
          const r = this.getRenderableIds(t, i).map((o) => this._tiles[o].tileID),
            n = this.transform.projection.name === 'globe';
          for (const o of r) (o.projMatrix = this.transform.calculateProjMatrix(o.toUnwrapped())), (o.expandedProjMatrix = n ? this.transform.calculateProjMatrix(o.toUnwrapped(), !1, !0) : o.projMatrix);
          return r;
        }
        sortCoordinatesByDistance(t) {
          const i = t.slice(),
            r = this.transform._camera.position,
            n = this.transform._camera.forward(),
            o = {};
          for (const s of i) {
            const a = 1 / (1 << s.canonical.z);
            o[s.key] = ((s.canonical.x + 0.5) * a + s.wrap - r[0]) * n[0] + ((s.canonical.y + 0.5) * a - r[1]) * n[1] - r[2] * n[2];
          }
          return i.sort((s, a) => o[s.key] - o[a.key]), i;
        }
        hasTransition() {
          if (this._source.hasTransition()) return !0;
          if (Jp(this._source.type))
            for (const t in this._tiles) {
              const i = this._tiles[t];
              if (i.fadeEndTime !== void 0 && i.fadeEndTime >= oe.now()) return !0;
            }
          return !1;
        }
        setFeatureState(t, i, r) {
          this._state.updateState((t = t || '_geojsonTileLayer'), i, r);
        }
        removeFeatureState(t, i, r) {
          this._state.removeFeatureState((t = t || '_geojsonTileLayer'), i, r);
        }
        getFeatureState(t, i) {
          return this._state.getState((t = t || '_geojsonTileLayer'), i);
        }
        setDependencies(t, i, r) {
          const n = this._tiles[t];
          n && n.setDependencies(i, r);
        }
        reloadTilesForDependencies(t, i) {
          for (const r in this._tiles) this._tiles[r].hasDependency(t, i) && this._reloadTile(+r, 'reloading');
          this._cache.filter((r) => !r.hasDependency(t, i));
        }
        _preloadTiles(t, i) {
          if (!this._sourceLoaded) {
            const a = () => {
              this._sourceLoaded && (this._source.off('data', a), this._preloadTiles(t, i));
            };
            return void this._source.on('data', a);
          }
          const r = new Map(),
            n = Array.isArray(t) ? t : [t],
            o = this.map.painter.terrain,
            s = this.usedForTerrain && o ? o.getScaledDemTileSize() : this._source.tileSize;
          for (const a of n) {
            const l = a.coveringTiles({ tileSize: s, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !this.usedForTerrain, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain });
            for (const c of l) r.set(c.key, c);
            this.usedForTerrain && a.updateElevation(!1);
          }
          Yn(
            Array.from(r.values()),
            (a, l) => {
              const c = new jl(a, this._source.tileSize * a.overscaleFactor(), this.transform.tileZoom, this.map.painter, this._isRaster);
              this._loadTile(c, (u) => {
                this._source.type === 'raster-dem' && c.dem && this._backfillDEM(c), l(u, c);
              });
            },
            i
          );
        }
      }
      function Dv(e, t) {
        const i = Math.abs(2 * e.wrap) - +(e.wrap < 0),
          r = Math.abs(2 * t.wrap) - +(t.wrap < 0);
        return e.overscaledZ - t.overscaledZ || r - i || t.canonical.y - e.canonical.y || t.canonical.x - e.canonical.x;
      }
      function Jp(e) {
        return e === 'raster' || e === 'image' || e === 'video' || e === 'custom';
      }
      function Gl(e, t) {
        const i = 1 << e.z;
        return [e.x / i + t, (e.x + 1) / i + t];
      }
      (wn.maxOverzooming = 10), (wn.maxUnderzooming = 3);
      const QI = Ne([{ name: 'a_pos_3f', components: 3, type: 'Float32' }]),
        tC = Ne([{ name: 'a_color_3f', components: 3, type: 'Float32' }]),
        eC = Ne([{ name: 'a_color_4f', components: 4, type: 'Float32' }]),
        iC = Ne([{ name: 'a_uv_2f', components: 2, type: 'Float32' }]),
        rC = Ne([{ name: 'a_normal_3f', components: 3, type: 'Float32' }]),
        nC = Ne([
          { name: 'a_normal_matrix0', components: 4, type: 'Float32' },
          { name: 'a_normal_matrix1', components: 4, type: 'Float32' },
          { name: 'a_normal_matrix2', components: 4, type: 'Float32' },
          { name: 'a_normal_matrix3', components: 4, type: 'Float32' },
        ]),
        oC = Ne([
          { name: 'a_pbr', components: 4, type: 'Uint16' },
          { name: 'a_heightBasedEmissiveStrength', components: 3, type: 'Float32' },
        ]);
      class Qp {
        constructor(t = 0, i = 0, r = 0, n = 0) {
          if (isNaN(t) || t < 0 || isNaN(i) || i < 0 || isNaN(r) || r < 0 || isNaN(n) || n < 0) throw new Error('Invalid value for edge-insets, top, bottom, left and right must all be numbers');
          (this.top = t), (this.bottom = i), (this.left = r), (this.right = n);
        }
        interpolate(t, i, r) {
          return i.top != null && t.top != null && (this.top = ee(t.top, i.top, r)), i.bottom != null && t.bottom != null && (this.bottom = ee(t.bottom, i.bottom, r)), i.left != null && t.left != null && (this.left = ee(t.left, i.left, r)), i.right != null && t.right != null && (this.right = ee(t.right, i.right, r)), this;
        }
        getCenter(t, i) {
          const r = Bt((this.left + t - this.right) / 2, 0, t),
            n = Bt((this.top + i - this.bottom) / 2, 0, i);
          return new H(r, n);
        }
        equals(t) {
          return this.top === t.top && this.bottom === t.bottom && this.left === t.left && this.right === t.right;
        }
        clone() {
          return new Qp(this.top, this.bottom, this.left, this.right);
        }
        toJSON() {
          return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
        }
      }
      function Rv(e, t) {
        const i = Ie(e, 3);
        J.fromQuat(e, t), ai(e, 3, i);
      }
      function tm(e, t) {
        const i = sr.identity([]);
        return sr.rotateZ(i, i, -t), sr.rotateX(i, i, -e), i;
      }
      function Lv(e, t) {
        const i = [e[0], e[1], 0],
          r = [t[0], t[1], 0];
        if (N.length(i) >= 1e-15) {
          const s = N.normalize([], i);
          N.scale(r, s, N.dot(r, s)), (t[0] = r[0]), (t[1] = r[1]);
        }
        const n = N.cross([], t, e);
        if (N.len(n) < 1e-15) return null;
        const o = Math.atan2(-n[1], n[0]);
        return tm(Math.atan2(Math.sqrt(e[0] * e[0] + e[1] * e[1]), -e[2]), o);
      }
      class kv {
        constructor(t, i) {
          (this.position = t), (this.orientation = i);
        }
        get position() {
          return this._position;
        }
        set position(t) {
          if (t) {
            const i = t instanceof Me ? t : new Me(t[0], t[1], t[2]);
            this._renderWorldCopies && (i.x = en(i.x, 0, 1)), (this._position = i);
          } else this._position = null;
        }
        lookAtPoint(t, i) {
          if (((this.orientation = null), !this.position)) return;
          const r = this.position,
            n = this._elevation ? this._elevation.getAtPointOrZero(Me.fromLngLat(t)) : 0,
            o = Me.fromLngLat(t, n),
            s = [o.x - r.x, o.y - r.y, o.z - r.z];
          i || (i = [0, 0, 1]), (i[2] = Math.abs(i[2])), (this.orientation = Lv(s, i));
        }
        setPitchBearing(t, i) {
          this.orientation = tm(ne(t), ne(-i));
        }
      }
      class Ku {
        constructor(t, i) {
          (this._transform = J.identity([])), (this.orientation = i), (this.position = t);
        }
        get mercatorPosition() {
          const t = this.position;
          return new Me(t[0], t[1], t[2]);
        }
        get position() {
          const t = Ie(this._transform, 3);
          return [t[0], t[1], t[2]];
        }
        set position(t) {
          var i;
          t && ai(this._transform, 3, [(i = t)[0], i[1], i[2], 1]);
        }
        get orientation() {
          return this._orientation;
        }
        set orientation(t) {
          (this._orientation = t || sr.identity([])), t && Rv(this._transform, this._orientation);
        }
        getPitchBearing() {
          const t = this.forward(),
            i = this.right();
          return { bearing: Math.atan2(-i[1], i[0]), pitch: Math.atan2(Math.sqrt(t[0] * t[0] + t[1] * t[1]), -t[2]) };
        }
        setPitchBearing(t, i) {
          (this._orientation = tm(t, i)), Rv(this._transform, this._orientation);
        }
        forward() {
          const t = Ie(this._transform, 2);
          return [-t[0], -t[1], -t[2]];
        }
        up() {
          const t = Ie(this._transform, 1);
          return [-t[0], -t[1], -t[2]];
        }
        right() {
          const t = Ie(this._transform, 0);
          return [t[0], t[1], t[2]];
        }
        getCameraToWorld(t, i) {
          const r = new Float64Array(16);
          return J.invert(r, this.getWorldToCamera(t, i)), r;
        }
        getCameraToWorldMercator() {
          return this._transform;
        }
        getWorldToCameraPosition(t, i, r) {
          const n = this.position;
          N.scale(n, n, -t);
          const o = new Float64Array(16);
          return J.fromScaling(o, [r, r, r]), J.translate(o, o, n), (o[10] *= i), o;
        }
        getWorldToCamera(t, i) {
          const r = new Float64Array(16),
            n = new Float64Array(4),
            o = this.position;
          return sr.conjugate(n, this._orientation), N.scale(o, o, -t), J.fromQuat(r, n), J.translate(r, r, o), (r[1] *= -1), (r[5] *= -1), (r[9] *= -1), (r[13] *= -1), (r[8] *= i), (r[9] *= i), (r[10] *= i), (r[11] *= i), r;
        }
        getCameraToClipPerspective(t, i, r, n) {
          const o = new Float64Array(16);
          return J.perspective(o, t, i, r, n), o;
        }
        getCameraToClipOrthographic(t, i, r, n, o, s) {
          const a = new Float64Array(16);
          return J.ortho(a, t, i, r, n, o, s), a;
        }
        getDistanceToElevation(t, i = !1) {
          const r = t === 0 ? 0 : Je(t, i ? Ni(this.position[1]) : this.position[1]),
            n = this.forward();
          return (r - this.position[2]) / n[2];
        }
        clone() {
          return new Ku([...this.position], [...this.orientation]);
        }
      }
      function Ov(e, t) {
        const i = ql(e.projection, e.zoom, e.width, e.height),
          r = (function (o, s, a, l, c) {
            const u = new ie(a.lng - 180 * Xo, a.lat),
              h = new ie(a.lng + 180 * Xo, a.lat),
              d = o.project(u.lng, u.lat),
              f = o.project(h.lng, h.lat),
              p = -Math.atan2(f.y - d.y, f.x - d.x),
              _ = Me.fromLngLat(a);
            _.y = Bt(_.y, -1 + Xo, 1 - Xo);
            const g = _.toLngLat(),
              y = o.project(g.lng, g.lat),
              v = Me.fromLngLat(g);
            v.x += Xo;
            const w = v.toLngLat(),
              T = o.project(w.lng, w.lat),
              b = Nv(T.x - y.x, T.y - y.y, p),
              E = Me.fromLngLat(g);
            E.y += Xo;
            const S = E.toLngLat(),
              I = o.project(S.lng, S.lat),
              C = Nv(I.x - y.x, I.y - y.y, p),
              z = Math.abs(b.x) / Math.abs(C.y),
              k = J.identity([]);
            J.rotateZ(k, k, -p * (1 - (c ? 0 : l)));
            const O = J.identity([]);
            return J.scale(O, O, [1, 1 - (1 - z) * l, 1]), (O[4] = (-C.x / C.y) * l), J.rotateZ(O, O, p), J.multiply(O, k, O), O;
          })(e.projection, 0, e.center, i, t),
          n = Bv(e);
        return J.scale(r, r, [n, n, 1]), r;
      }
      function Bv(e) {
        const t = e.projection,
          i = ql(e.projection, e.zoom, e.width, e.height),
          r = Fv(t, e.center),
          n = Fv(t, ie.convert(t.center));
        return Math.pow(2, r * i + (1 - i) * n);
      }
      function ql(e, t, i, r, n = 1 / 0) {
        const o = e.range;
        if (!o) return 0;
        const s = Math.min(n, Math.max(i, r)),
          a = Math.log(s / 1024) / Math.LN2;
        return Zr(o[0] + a, o[1] + a, t);
      }
      const Xo = 1 / 4e4;
      function Fv(e, t) {
        const i = Bt(t.lat, -Ii, Ii),
          r = new ie(t.lng - 180 * Xo, i),
          n = new ie(t.lng + 180 * Xo, i),
          o = e.project(r.lng, i),
          s = e.project(n.lng, i),
          a = Me.fromLngLat(r),
          l = Me.fromLngLat(n),
          c = s.x - o.x,
          u = s.y - o.y,
          h = l.x - a.x,
          d = l.y - a.y,
          f = Math.sqrt((h * h + d * d) / (c * c + u * u));
        return Math.log(f) / Math.LN2;
      }
      function Nv(e, t, i) {
        const r = Math.cos(i),
          n = Math.sin(i);
        return { x: e * r - t * n, y: e * n + t * r };
      }
      function Ms(e, t, i) {
        return t * (lt / (e.tileSize * Math.pow(2, i - e.tileID.overscaledZ)));
      }
      const Da = { unknown: 0, flipRequired: 1, flipNotRequired: 2 },
        sC = Math.tan((85 * Math.PI) / 180);
      function Ju(e, t, i, r, n, o, s) {
        const a = J.create();
        if (i)
          if (o.name === 'globe') {
            const l = (function (c, u) {
              const { x: h, y: d } = c.point,
                f = nx(h, d, c.worldSize / c._pixelsPerMercatorPixel, 0, 0);
              return J.multiply(f, f, fp(Yr(u)));
            })(n, t);
            J.multiply(a, a, l);
          } else {
            const l = ma.invert([], s);
            (a[0] = l[0]), (a[1] = l[1]), (a[4] = l[2]), (a[5] = l[3]), r || J.rotateZ(a, a, n.angle);
          }
        else J.multiply(a, n.labelPlaneMatrix, e);
        return a;
      }
      function Uv(e, t, i, r, n, o, s) {
        const a = Ju(e, t, i, r, n, o, s);
        return (o.name === 'globe' && i) || (a[2] = a[6] = a[10] = a[14] = 0), a;
      }
      function Vv(e, t, i, r, n, o, s) {
        if (i) {
          if (o.name === 'globe') {
            const a = Ju(e, t, i, r, n, o, s);
            return J.invert(a, a), J.multiply(a, e, a), a;
          }
          {
            const a = J.clone(e),
              l = J.identity([]);
            return (l[0] = s[0]), (l[1] = s[1]), (l[4] = s[2]), (l[5] = s[3]), J.multiply(a, a, l), r || J.rotateZ(a, a, -n.angle), a;
          }
        }
        return n.glCoordMatrix;
      }
      function Tn(e, t, i, r) {
        const n = [e, t, i, 1];
        i ? We.transformMat4(n, n, r) : Wv(n, n, r);
        const o = n[3];
        return (n[0] /= o), (n[1] /= o), (n[2] /= o), n;
      }
      function jv(e, t) {
        return Math.min(0.5 + (e / t) * 0.5, 1.5);
      }
      function aC(e, t) {
        const i = e[0] / e[3],
          r = e[1] / e[3];
        return i >= -t[0] && i <= t[0] && r >= -t[1] && r <= t[1];
      }
      function lC(e, t, i, r, n, o, s, a, l, c) {
        const u = i.transform,
          h = r ? e.textSizeData : e.iconSizeData,
          d = Bn(h, i.transform.zoom),
          f = u.projection.name === 'globe',
          p = [(256 / i.width) * 2 + 1, (256 / i.height) * 2 + 1],
          _ = r ? e.text.dynamicLayoutVertexArray : e.icon.dynamicLayoutVertexArray;
        _.clear();
        let g = null;
        f && (g = r ? e.text.globeExtVertexArray : e.icon.globeExtVertexArray);
        const y = e.lineVertexArray,
          v = r ? e.text.placedSymbolArray : e.icon.placedSymbolArray,
          w = i.transform.width / i.transform.height;
        let T,
          b = !1;
        for (let E = 0; E < v.length; E++) {
          const S = v.get(E),
            { numGlyphs: I, writingMode: C } = S;
          if ((C !== di.vertical || b || T === di.horizontal || (b = !0), (T = C), (S.hidden || C === di.vertical) && !b)) {
            Ra(I, _);
            continue;
          }
          b = !1;
          const z = new H(S.tileAnchorX, S.tileAnchorY);
          let { x: k, y: O, z: V } = u.projection.projectTilePoint(z.x, z.y, c.canonical);
          if (l) {
            const [ut, ht, pt] = l(z);
            (k += ut), (O += ht), (V += pt);
          }
          const R = [k, O, V, 1];
          if ((We.transformMat4(R, R, t), !aC(R, p))) {
            Ra(I, _);
            continue;
          }
          const G = R[3],
            Z = jv(i.transform.getCameraToCenterDistance(u.projection), G),
            X = Dl(h, d, S),
            j = s ? X / Z : X * Z,
            q = Tn(k, O, V, n);
          if (q[3] <= 0) {
            Ra(I, _);
            continue;
          }
          let it = {};
          const st = s ? null : l,
            nt = Zv(S, j, !1, a, t, n, o, e.glyphOffsetArray, y, _, g, q, z, it, w, st, u.projection, c, s);
          (b = nt.useVertical), st && nt.needsFlipping && (it = {}), (nt.notEnoughRoom || b || (nt.needsFlipping && Zv(S, j, !0, a, t, n, o, e.glyphOffsetArray, y, _, g, q, z, it, w, st, u.projection, c, s).notEnoughRoom)) && Ra(I, _);
        }
        r ? (e.text.dynamicLayoutVertexBuffer.updateData(_), g && e.text.globeExtVertexBuffer && e.text.globeExtVertexBuffer.updateData(g)) : (e.icon.dynamicLayoutVertexBuffer.updateData(_), g && e.icon.globeExtVertexBuffer && e.icon.globeExtVertexBuffer.updateData(g));
      }
      function Gv(e, t, i, r, n, o, s, a, l, c, u, h, d, f, p, _) {
        const { lineStartIndex: g, glyphStartIndex: y, segment: v } = a,
          w = y + a.numGlyphs,
          T = g + a.lineLength,
          b = t.getoffsetX(y),
          E = t.getoffsetX(w - 1),
          S = Qu(e * b, i, r, n, o, s, v, g, T, l, c, u, h, d, !0, f, p, _);
        if (!S) return null;
        const I = Qu(e * E, i, r, n, o, s, v, g, T, l, c, u, h, d, !0, f, p, _);
        return I ? { first: S, last: I } : null;
      }
      function qv(e, t, i, r) {
        return e === di.horizontal && Math.abs(r) > Math.abs(i)
          ? { useVertical: !0 }
          : e === di.vertical
          ? r > 0
            ? { needsFlipping: !0 }
            : null
          : t !== Da.unknown &&
            (function (n, o) {
              return n === 0 || Math.abs(o / n) > sC;
            })(i, r)
          ? t === Da.flipRequired
            ? { needsFlipping: !0 }
            : null
          : i < 0
          ? { needsFlipping: !0 }
          : null;
      }
      function Zv(e, t, i, r, n, o, s, a, l, c, u, h, d, f, p, _, g, y, v) {
        const w = t / 24,
          T = e.lineOffsetX * w,
          b = e.lineOffsetY * w,
          { lineStartIndex: E, glyphStartIndex: S, numGlyphs: I, segment: C, writingMode: z, flipState: k } = e,
          O = E + e.lineLength,
          V = (R) => {
            if (u) {
              const [j, q, it] = R.up,
                st = c.length;
              Zu(u, st + 0, j, q, it), Zu(u, st + 1, j, q, it), Zu(u, st + 2, j, q, it), Zu(u, st + 3, j, q, it);
            }
            const [G, Z, X] = R.point;
            za(c, G, Z, X, R.angle);
          };
        if (I > 1) {
          const R = Gv(w, a, T, b, i, h, d, e, l, o, f, _, !1, g, y, v);
          if (!R) return { notEnoughRoom: !0 };
          if (r && !i) {
            let [G, Z, X] = R.first.point,
              [j, q, it] = R.last.point;
            ([G, Z] = Tn(G, Z, X, s)), ([j, q] = Tn(j, q, it, s));
            const st = qv(z, k, (j - G) * p, q - Z);
            if (((e.flipState = st && st.needsFlipping ? Da.flipRequired : Da.flipNotRequired), st)) return st;
          }
          V(R.first);
          for (let G = S + 1; G < S + I - 1; G++) {
            const Z = Qu(w * a.getoffsetX(G), T, b, i, h, d, C, E, O, l, o, f, _, !1, !1, g, y, v);
            if (!Z) return (c.length -= 4 * (G - S)), { notEnoughRoom: !0 };
            V(Z);
          }
          V(R.last);
        } else {
          if (r && !i) {
            const G = Tn(d.x, d.y, 0, n),
              Z = E + C + 1,
              X = new H(l.getx(Z), l.gety(Z)),
              j = Tn(X.x, X.y, 0, n),
              q = j[3] > 0 ? j : Hv(d, X, G, 1, n, void 0, g, y.canonical),
              it = qv(z, k, (q[0] - G[0]) * p, q[1] - G[1]);
            if (((e.flipState = it && it.needsFlipping ? Da.flipRequired : Da.flipNotRequired), it)) return it;
          }
          const R = Qu(w * a.getoffsetX(S), T, b, i, h, d, C, E, O, l, o, f, _, !1, !1, g, y, v);
          if (!R) return { notEnoughRoom: !0 };
          V(R);
        }
        return {};
      }
      function $v(e, t, i, r, n) {
        const { x: o, y: s, z: a } = r.projectTilePoint(e.x, e.y, t);
        if (!n) return Tn(o, s, a, i);
        const [l, c, u] = n(e);
        return Tn(o + l, s + c, a + u, i);
      }
      function Hv(e, t, i, r, n, o, s, a) {
        const l = $v(e.sub(t)._unit()._add(e), a, n, s, o);
        return N.sub(l, i, l), N.normalize(l, l), N.scaleAndAdd(l, i, l, r);
      }
      function Qu(e, t, i, r, n, o, s, a, l, c, u, h, d, f, p, _, g, y) {
        const v = r ? e - t : e + t;
        let w = v > 0 ? 1 : -1,
          T = 0;
        r && ((w *= -1), (T = Math.PI)), w < 0 && (T += Math.PI);
        let b = (a + s + (w > 0 ? 0 : 1)) | 0,
          E = n,
          S = n,
          I = 0,
          C = 0;
        const z = Math.abs(v),
          k = [],
          O = [];
        let V = o,
          R = V;
        const G = () => Hv(R, V, S, z - I + 1, u, d, _, g.canonical);
        for (; I + C <= z; ) {
          if (((b += w), b < a || b >= l)) return null;
          if (((S = E), (R = V), k.push(S), f && O.push(R), (V = new H(c.getx(b), c.gety(b))), (E = h[b]), !E)) {
            const ht = $v(V, g.canonical, u, _, d);
            E = ht[3] > 0 ? (h[b] = ht) : G();
          }
          (I += C), (C = N.distance(S, E));
        }
        p && d && (h[b] && ((E = G()), (C = N.distance(S, E))), (h[b] = E));
        const Z = (z - I) / C,
          X = V.sub(R)._mult(Z)._add(R),
          j = N.sub([], E, S),
          q = N.scaleAndAdd([], S, j, Z);
        let it = [0, 0, 1],
          st = j[0],
          nt = j[1];
        if (y && ((it = _.upVector(g.canonical, X.x, X.y)), it[0] !== 0 || it[1] !== 0 || it[2] !== 1)) {
          const ht = [it[2], 0, -it[0]],
            pt = N.cross([], it, ht);
          N.normalize(ht, ht), N.normalize(pt, pt), (st = N.dot(j, ht)), (nt = N.dot(j, pt));
        }
        if (i) {
          const ht = N.cross([], it, j);
          N.normalize(ht, ht), N.scaleAndAdd(q, q, ht, i * w);
        }
        const ut = T + Math.atan2(nt, st);
        return k.push(q), f && O.push(X), { point: q, angle: ut, path: k, tilePath: O, up: it };
      }
      function Ra(e, t) {
        const i = t.length,
          r = i + 4 * e;
        t.resize(r), t.float32.fill(-1 / 0, 4 * i, 4 * r);
      }
      function Wv(e, t, i) {
        const r = t[0],
          n = t[1];
        return (e[0] = i[0] * r + i[4] * n + i[12]), (e[1] = i[1] * r + i[5] * n + i[13]), (e[3] = i[3] * r + i[7] * n + i[15]), e;
      }
      const Xv = (e, t, i) => (1 - i) * e + i * t,
        Yv = (e) => e * e * e * e * e;
      class em {
        constructor(t, i, r, n, o, s, a) {
          (this.tileSize = 512), (this._renderWorldCopies = o === void 0 || o), (this._minZoom = t || 0), (this._maxZoom = i || 22), (this._minPitch = r ?? 0), (this._maxPitch = n ?? 60), this.setProjection(s), this.setMaxBounds(a), (this.width = 0), (this.height = 0), (this._center = new ie(0, 0)), (this.zoom = 0), (this.angle = 0), (this._fov = 0.6435011087932844), (this._pitch = 0), (this._nearZ = 0), (this._farZ = 0), (this._unmodified = !0), (this._edgeInsets = new Qp()), (this._projMatrixCache = {}), (this._alignedProjMatrixCache = {}), (this._fogTileMatrixCache = {}), (this._expandedProjMatrixCache = {}), (this._distanceTileDataCache = {}), (this._camera = new Ku()), (this._centerAltitude = 0), (this._averageElevation = 0), (this.cameraElevationReference = 'ground'), (this._pixelsPerMercatorPixel = 1), (this.globeRadius = 0), (this.globeCenterInViewSpace = [0, 0, 0]), (this._horizonShift = 0.1), (this._orthographicProjectionAtLowPitch = !1);
        }
        clone() {
          const t = new em(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies, this.getProjection());
          return (t._elevation = this._elevation), (t._centerAltitude = this._centerAltitude), (t._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration), (t.tileSize = this.tileSize), (t.mercatorFromTransition = this.mercatorFromTransition), (t.width = this.width), (t.height = this.height), (t.cameraElevationReference = this.cameraElevationReference), (t._center = this._center), t._setZoom(this.zoom), (t._seaLevelZoom = this._seaLevelZoom), (t.angle = this.angle), (t._fov = this._fov), (t._pitch = this._pitch), (t._nearZ = this._nearZ), (t._farZ = this._farZ), (t._averageElevation = this._averageElevation), (t._orthographicProjectionAtLowPitch = this._orthographicProjectionAtLowPitch), (t._unmodified = this._unmodified), (t._edgeInsets = this._edgeInsets.clone()), (t._camera = this._camera.clone()), t._calcMatrices(), (t.freezeTileCoverage = this.freezeTileCoverage), (t.frustumCorners = this.frustumCorners), t;
        }
        get isOrthographic() {
          return this.projection.name !== 'globe' && this._orthographicProjectionAtLowPitch && this.pitch < 15;
        }
        get elevation() {
          return this._elevation;
        }
        set elevation(t) {
          this._elevation !== t && ((this._elevation = t), this._updateCameraOnTerrain(), this._calcMatrices());
        }
        get depthOcclusionForSymbolsAndCircles() {
          return this.projection.name !== 'globe' && !this.isOrthographic;
        }
        updateElevation(t, i = !1) {
          const r = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;
          (this._seaLevelZoom == null || r) && this._updateCameraOnTerrain(), (t || r) && this._constrainCamera(i), this._calcMatrices();
        }
        getProjection() {
          return ar(this.projection, ['name', 'center', 'parallels']);
        }
        setProjection(t) {
          this.projectionOptions = t || { name: 'mercator' };
          const i = this.projection ? this.getProjection() : void 0;
          this.projection = Uu(this.projectionOptions);
          const r = !we(i, this.getProjection());
          return r && this._calcMatrices(), (this.mercatorFromTransition = !1), r;
        }
        setOrthographicProjectionAtLowPitch(t) {
          return this._orthographicProjectionAtLowPitch !== t && ((this._orthographicProjectionAtLowPitch = t), this._calcMatrices(), !0);
        }
        setMercatorFromTransition() {
          const t = this.projection.name;
          (this.mercatorFromTransition = !0), (this.projectionOptions = { name: 'mercator' }), (this.projection = Uu({ name: 'mercator' }));
          const i = t !== this.projection.name;
          return i && this._calcMatrices(), i;
        }
        get minZoom() {
          return this._minZoom;
        }
        set minZoom(t) {
          this._minZoom !== t && ((this._minZoom = t), (this.zoom = Math.max(this.zoom, t)));
        }
        get maxZoom() {
          return this._maxZoom;
        }
        set maxZoom(t) {
          this._maxZoom !== t && ((this._maxZoom = t), (this.zoom = Math.min(this.zoom, t)));
        }
        get minPitch() {
          return this._minPitch;
        }
        set minPitch(t) {
          this._minPitch !== t && ((this._minPitch = t), (this.pitch = Math.max(this.pitch, t)));
        }
        get maxPitch() {
          return this._maxPitch;
        }
        set maxPitch(t) {
          this._maxPitch !== t && ((this._maxPitch = t), (this.pitch = Math.min(this.pitch, t)));
        }
        get renderWorldCopies() {
          return this._renderWorldCopies && this.projection.supportsWorldCopies === !0;
        }
        set renderWorldCopies(t) {
          t === void 0 ? (t = !0) : t === null && (t = !1), (this._renderWorldCopies = t);
        }
        get worldSize() {
          return this.tileSize * this.scale;
        }
        get cameraWorldSizeForFog() {
          const t = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);
          return this._worldSizeFromZoom(this._zoomFromMercatorZ(t));
        }
        get cameraWorldSize() {
          const t = Math.max(this._camera.getDistanceToElevation(this._averageElevation, !0), Number.EPSILON);
          return this._worldSizeFromZoom(this._zoomFromMercatorZ(t));
        }
        get pixelsPerMeter() {
          return this.projection.pixelsPerMeter(this.center.lat, this.worldSize);
        }
        get cameraPixelsPerMeter() {
          return Je(1, this.center.lat) * this.cameraWorldSizeForFog;
        }
        get centerOffset() {
          return this.centerPoint._sub(this.size._div(2));
        }
        get size() {
          return new H(this.width, this.height);
        }
        get bearing() {
          return en(this.rotation, -180, 180);
        }
        set bearing(t) {
          this.rotation = t;
        }
        get rotation() {
          return (-this.angle / Math.PI) * 180;
        }
        set rotation(t) {
          const i = (-t * Math.PI) / 180;
          this.angle !== i && ((this._unmodified = !1), (this.angle = i), this._calcMatrices(), (this.rotationMatrix = ma.create()), ma.rotate(this.rotationMatrix, this.rotationMatrix, this.angle));
        }
        get pitch() {
          return (this._pitch / Math.PI) * 180;
        }
        set pitch(t) {
          const i = (Bt(t, this.minPitch, this.maxPitch) / 180) * Math.PI;
          this._pitch !== i && ((this._unmodified = !1), (this._pitch = i), this._calcMatrices());
        }
        get aspect() {
          return this.width / this.height;
        }
        get fov() {
          return (this._fov / Math.PI) * 180;
        }
        get fovX() {
          return this._fov;
        }
        get fovY() {
          const t = 1 / Math.tan(0.5 * this.fovX);
          return 2 * Math.atan(1 / this.aspect / t);
        }
        set fov(t) {
          (t = Math.max(0.01, Math.min(60, t))), this._fov !== t && ((this._unmodified = !1), (this._fov = ne(t)), this._calcMatrices());
        }
        get averageElevation() {
          return this._averageElevation;
        }
        set averageElevation(t) {
          (this._averageElevation = t), this._calcFogMatrices(), (this._distanceTileDataCache = {});
        }
        get zoom() {
          return this._zoom;
        }
        set zoom(t) {
          const i = Math.min(Math.max(t, this.minZoom), this.maxZoom);
          this._zoom !== i && ((this._unmodified = !1), this._setZoom(i), this._updateSeaLevelZoom(), this._constrain(), this._calcMatrices());
        }
        _setZoom(t) {
          (this._zoom = t), (this.scale = this.zoomScale(t)), (this.tileZoom = Math.floor(t)), (this.zoomFraction = t - this.tileZoom);
        }
        _updateCameraOnTerrain() {
          const t = this.elevation ? this.elevation.getAtPoint(this.locationCoordinate(this.center), Number.NEGATIVE_INFINITY) : Number.NEGATIVE_INFINITY,
            i = this.elevation && t === Number.NEGATIVE_INFINITY && this.elevation.visibleDemTiles.length > 0 && this.elevation.exaggeration() > 0 && this._centerAltitudeValidForExaggeration;
          if (!this._elevation || (t === Number.NEGATIVE_INFINITY && (!i || !this._centerAltitude))) return (this._centerAltitude = 0), (this._seaLevelZoom = null), void (this._centerAltitudeValidForExaggeration = void 0);
          const r = this._elevation;
          i || (this._centerAltitude && this._centerAltitudeValidForExaggeration && r.exaggeration() && this._centerAltitudeValidForExaggeration !== r.exaggeration()) ? ((this._centerAltitude = (this._centerAltitude / this._centerAltitudeValidForExaggeration) * r.exaggeration()), (this._centerAltitudeValidForExaggeration = r.exaggeration())) : ((this._centerAltitude = t || 0), (this._centerAltitudeValidForExaggeration = r.exaggeration())), this._updateSeaLevelZoom();
        }
        _updateSeaLevelZoom() {
          this._centerAltitudeValidForExaggeration !== void 0 && (this._seaLevelZoom = this._zoomFromMercatorZ((this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize));
        }
        sampleAverageElevation() {
          if (!this._elevation) return 0;
          const t = this._elevation,
            i = [
              [0.5, 0.2],
              [0.3, 0.5],
              [0.5, 0.5],
              [0.7, 0.5],
              [0.5, 0.8],
            ],
            r = this.horizonLineFromTop();
          let n = 0,
            o = 0;
          for (let s = 0; s < i.length; s++) {
            const a = new H(i[s][0] * this.width, r + i[s][1] * (this.height - r)),
              l = t.pointCoordinate(a);
            if (!l) continue;
            const c = 1 / Math.hypot(l[0] - this._camera.position[0], l[1] - this._camera.position[1]);
            (n += l[3] * c), (o += c);
          }
          return o === 0 ? NaN : n / o;
        }
        get center() {
          return this._center;
        }
        set center(t) {
          (t.lat === this._center.lat && t.lng === this._center.lng) || ((this._unmodified = !1), (this._center = t), this._terrainEnabled() && (this.cameraElevationReference === 'ground' ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices());
        }
        _updateZoomFromElevation() {
          if (this._seaLevelZoom == null || !this._elevation) return;
          const t = this._seaLevelZoom,
            i = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)),
            r = (this.pixelsPerMeter / this.worldSize) * i,
            n = this._mercatorZfromZoom(t),
            o = this._mercatorZfromZoom(this._maxZoom),
            s = Math.max(n - r, o);
          this._setZoom(this._zoomFromMercatorZ(s));
        }
        get padding() {
          return this._edgeInsets.toJSON();
        }
        set padding(t) {
          this._edgeInsets.equals(t) || ((this._unmodified = !1), this._edgeInsets.interpolate(this._edgeInsets, t, 1), this._calcMatrices());
        }
        computeZoomRelativeTo(t) {
          const i = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, t.toAltitude()));
          let r;
          r = t.z < this._camera.position[2] ? [i.x, i.y, i.z] : [t.x, t.y, t.z];
          const n = N.length(N.sub([], this._camera.position, r));
          return Bt(this._zoomFromMercatorZ(n), this._minZoom, this._maxZoom);
        }
        setFreeCameraOptions(t) {
          if (!this.height || (!t.position && !t.orientation)) return;
          this._updateCameraState();
          let i = !1;
          if ((t.orientation && !sr.exactEquals(t.orientation, this._camera.orientation) && (i = this._setCameraOrientation(t.orientation)), t.position)) {
            const r = [t.position.x, t.position.y, t.position.z];
            N.exactEquals(r, this._camera.position) || (this._setCameraPosition(r), (i = !0));
          }
          i && (this._updateStateFromCamera(), this.recenterOnTerrain());
        }
        getFreeCameraOptions() {
          this._updateCameraState();
          const t = this._camera.position,
            i = new kv();
          return (i.position = new Me(t[0], t[1], t[2])), (i.orientation = this._camera.orientation), (i._elevation = this.elevation), (i._renderWorldCopies = this.renderWorldCopies), i;
        }
        _setCameraOrientation(t) {
          if (!sr.length(t)) return !1;
          sr.normalize(t, t);
          const i = N.transformQuat([], [0, 0, -1], t),
            r = N.transformQuat([], [0, -1, 0], t);
          if (r[2] < 0) return !1;
          const n = Lv(i, r);
          return !!n && ((this._camera.orientation = n), !0);
        }
        _setCameraPosition(t) {
          const i = this.zoomScale(this.minZoom) * this.tileSize,
            r = this.zoomScale(this.maxZoom) * this.tileSize,
            n = this.cameraToCenterDistance;
          (t[2] = Bt(t[2], n / r, n / i)), (this._camera.position = t);
        }
        get centerPoint() {
          return this._edgeInsets.getCenter(this.width, this.height);
        }
        get fovAboveCenter() {
          return this._fov * (0.5 + this.centerOffset.y / this.height);
        }
        isPaddingEqual(t) {
          return this._edgeInsets.equals(t);
        }
        interpolatePadding(t, i, r) {
          (this._unmodified = !1), this._edgeInsets.interpolate(t, i, r), this._constrain(), this._calcMatrices();
        }
        coveringZoomLevel(t) {
          const i = (t.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / t.tileSize));
          return Math.max(0, i);
        }
        getVisibleUnwrappedCoordinates(t) {
          const i = [new ap(0, t)];
          if (this.renderWorldCopies) {
            const r = this.pointCoordinate(new H(0, 0)),
              n = this.pointCoordinate(new H(this.width, 0)),
              o = this.pointCoordinate(new H(this.width, this.height)),
              s = this.pointCoordinate(new H(0, this.height)),
              a = Math.floor(Math.min(r.x, n.x, o.x, s.x)),
              l = Math.floor(Math.max(r.x, n.x, o.x, s.x)),
              c = 1;
            for (let u = a - c; u <= l + c; u++) u !== 0 && i.push(new ap(u, t));
          }
          return i;
        }
        isLODDisabled(t) {
          return (!t || this.pitch <= 60) && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace;
        }
        extendTileCoverForShadows(t, i, r) {
          let n = [];
          if (i[0] === 0 && i[1] === 0) return n;
          for (const s of t) {
            const a = s.canonical,
              l = s.overscaledZ,
              c = s.wrap,
              u = 1 << a.z,
              h = a.x + 1 < u,
              d = a.x > 0,
              f = a.y + 1 < u,
              p = a.y > 0,
              _ = s.wrap - (d ? 0 : 1),
              g = s.wrap + (h ? 0 : 1),
              y = d ? a.x - 1 : u - 1,
              v = h ? a.x + 1 : 0;
            i[0] < 0 ? (n.push(new Le(l, g, a.z, v, a.y)), i[1] < 0 && f && (n.push(new Le(l, c, a.z, a.x, a.y + 1)), n.push(new Le(l, g, a.z, v, a.y + 1))), i[1] > 0 && p && (n.push(new Le(l, c, a.z, a.x, a.y - 1)), n.push(new Le(l, g, a.z, v, a.y - 1)))) : i[0] > 0 ? (n.push(new Le(l, _, a.z, y, a.y)), i[1] < 0 && f && (n.push(new Le(l, c, a.z, a.x, a.y + 1)), n.push(new Le(l, _, a.z, y, a.y + 1))), i[1] > 0 && p && (n.push(new Le(l, c, a.z, a.x, a.y - 1)), n.push(new Le(l, _, a.z, y, a.y - 1)))) : i[1] < 0 && f ? n.push(new Le(l, c, a.z, a.x, a.y + 1)) : p && n.push(new Le(l, c, a.z, a.x, a.y - 1));
          }
          if (n.length > 1) {
            n.sort((l, c) => l.overscaledZ - c.overscaledZ || l.wrap - c.wrap || l.canonical.z - c.canonical.z || l.canonical.x - c.canonical.x || l.canonical.y - c.canonical.y);
            let s = 0,
              a = 0;
            for (; a < n.length; ) n[a].equals(n[s]) ? ++a : (n[++s] = n[a++]);
            n.length = s + 1;
          }
          const o = [];
          for (const s of n) n.some((a) => s.isChildOf(a)) || o.push(s);
          return (n = o.filter((s) => !t.some((a) => !!(s.overscaledZ < r && a.isChildOf(s)) || s.equals(a) || s.isChildOf(a)))), n;
        }
        coveringTiles(t) {
          let i = this.coveringZoomLevel(t);
          const r = i,
            n = this.elevation && this.elevation.exaggeration(),
            o = n && !t.isTerrainDEM,
            s = this.projection.name === 'mercator';
          if (t.minzoom !== void 0 && i < t.minzoom) return [];
          t.maxzoom !== void 0 && i > t.maxzoom && (i = t.maxzoom);
          const a = this.locationCoordinate(this.center),
            l = this.center.lat,
            c = 1 << i,
            u = [c * a.x, c * a.y, 0],
            h = this.projection.name === 'globe',
            d = !h,
            f = uo.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i, d),
            p = h ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()),
            _ = c * Je(1, this.center.lat),
            g = this._camera.position[2] / Je(1, this.center.lat),
            y = [c * p.x, c * p.y, g * (d ? 1 : _)],
            v = h || n,
            w = (this.cameraToCenterDistance / t.tileSize) * (t.roundZoom ? 1 : 0.502),
            T = this.isLODDisabled(!0) ? i : 0;
          let b;
          if (this._elevation && t.isTerrainDEM) b = 1e4 * this._elevation.exaggeration();
          else if (this._elevation) {
            const j = this._elevation.getMinMaxForVisibleTiles();
            b = j ? j.max : this._centerAltitude;
          } else b = this._centerAltitude;
          const E = t.isTerrainDEM ? -b : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0,
            S = this.projection.isReprojectedInTileSpace ? Bv(this) : 1,
            I = (j) => {
              const it = new Me(j.x + 25e-6, j.y, j.z),
                st = new Me(j.x, j.y + 25e-6, j.z),
                nt = j.toLngLat(),
                ut = it.toLngLat(),
                ht = st.toLngLat(),
                pt = this.locationCoordinate(nt),
                at = this.locationCoordinate(ut),
                _t = this.locationCoordinate(ht),
                Ct = Math.hypot(at.x - pt.x, at.y - pt.y),
                Pt = Math.hypot(_t.x - pt.x, _t.y - pt.y);
              return (Math.sqrt(Ct * Pt) * S) / 25e-6;
            },
            C = (j) => {
              const q = b,
                it = E;
              return { aabb: bv(this, c, 0, 0, 0, j, it, q, this.projection), zoom: 0, x: 0, y: 0, minZ: it, maxZ: q, wrap: j, fullyVisible: !1 };
            },
            z = [];
          let k = [];
          const O = i,
            V = t.reparseOverscaled ? r : i,
            R = (j) => j * j,
            G = R((g - this._centerAltitude) * _),
            Z = (j) => {
              if (!this._elevation || !j.tileID || !s) return;
              const q = this._elevation.getMinMaxForTile(j.tileID),
                it = j.aabb;
              q ? ((it.min[2] = q.min), (it.max[2] = q.max), (it.center[2] = (it.min[2] + it.max[2]) / 2)) : ((j.shouldSplit = X(j)), j.shouldSplit || (it.min[2] = it.max[2] = it.center[2] = this._centerAltitude));
            },
            X = (j) => {
              if (j.zoom < T) return !0;
              if (j.zoom === O) return !1;
              if (j.shouldSplit != null) return j.shouldSplit;
              const q = j.aabb.distanceX(y),
                it = j.aabb.distanceY(y);
              let st = G,
                nt = 1;
              if (h) {
                st = R(j.aabb.distanceZ(y));
                const pt = Math.pow(2, j.zoom),
                  at = Ni((j.y + 1) / pt),
                  _t = Ni(j.y / pt),
                  Ct = Math.min(Math.max(l, at), _t),
                  Pt = pu(Ct) / pu(l);
                if (((nt = Ct === l ? 1 / Math.max(1, this._mercatorScaleRatio - 0.3) : Math.min(1, Pt / this._mercatorScaleRatio)), this.zoom <= Sl && j.zoom === O - 1 && Pt >= 0.9)) return !0;
              } else if ((o && (st = R(j.aabb.distanceZ(y) * _)), this.projection.isReprojectedInTileSpace && r <= 5)) {
                const pt = Math.pow(2, j.zoom),
                  at = I(new Me((j.x + 0.5) / pt, (j.y + 0.5) / pt));
                nt = at > 0.85 ? 1 : at;
              }
              const ut = q * q + it * it + st,
                ht = R(
                  (1 << (O - j.zoom)) *
                    w *
                    nt *
                    ((pt, at) => {
                      if (at * R(0.707) < pt) return 1;
                      const _t = Math.sqrt(at / pt);
                      return _t / (1.4144271570014144 + (Math.pow(1.1, _t - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1);
                    })(Math.max(st, G), ut)
                );
              return ut < ht;
            };
          if (this.renderWorldCopies) for (let j = 1; j <= 3; j++) z.push(C(-j)), z.push(C(j));
          for (z.push(C(0)); z.length > 0; ) {
            const j = z.pop(),
              q = j.x,
              it = j.y;
            let st = j.fullyVisible;
            const nt = () => this.projection.name === 'globe' && (j.y === 0 || j.y === (1 << j.zoom) - 1);
            if (!st) {
              let ut = v ? j.aabb.intersects(f) : j.aabb.intersectsFlat(f);
              if (ut === 0 && nt()) {
                const ht = new cn(j.zoom, q, it);
                ut = hp(this, c, ht, !0).intersects(f);
              }
              if (ut === 0) continue;
              st = ut === 2;
            }
            if (j.zoom !== O && X(j))
              for (let ut = 0; ut < 4; ut++) {
                const ht = (q << 1) + (ut % 2),
                  pt = (it << 1) + (ut >> 1),
                  at = { aabb: s ? j.aabb.quadrant(ut) : bv(this, c, j.zoom + 1, ht, pt, j.wrap, j.minZ, j.maxZ, this.projection), zoom: j.zoom + 1, x: ht, y: pt, wrap: j.wrap, fullyVisible: st, tileID: void 0, shouldSplit: void 0, minZ: j.minZ, maxZ: j.maxZ };
                o && !h && ((at.tileID = new Le(j.zoom + 1 === O ? V : j.zoom + 1, j.wrap, j.zoom + 1, ht, pt)), Z(at)), z.push(at);
              }
            else {
              const ut = j.zoom === O ? V : j.zoom;
              if (t.minzoom && t.minzoom > ut) continue;
              if (!st) {
                let _t = v ? j.aabb.intersectsPrecise(f) : j.aabb.intersectsPreciseFlat(f);
                if (_t === 0 && nt()) {
                  const Ct = new cn(j.zoom, q, it);
                  _t = hp(this, c, Ct, !0).intersectsPrecise(f);
                }
                if (_t === 0) continue;
              }
              const ht = u[0] - (0.5 + q + (j.wrap << j.zoom)) * (1 << (i - j.zoom)),
                pt = u[1] - 0.5 - it,
                at = j.tileID ? j.tileID : new Le(ut, j.wrap, j.zoom, q, it);
              k.push({ tileID: at, distanceSq: ht * ht + pt * pt });
            }
          }
          if (this.fogCullDistSq) {
            const j = this.fogCullDistSq,
              q = this.horizonLineFromTop();
            k = k.filter((it) => {
              const st = [0, 0, 0, 1],
                nt = [lt, lt, 0, 1],
                ut = this.calculateFogTileMatrix(it.tileID.toUnwrapped());
              We.transformMat4(st, st, ut), We.transformMat4(nt, nt, ut);
              const ht = (function (_t, Ct, Pt) {
                let Ot = 0;
                for (let Ut = 0; Ut < 2; ++Ut) _t[Ut] > 0 && (Ot += (_t[Ut] - 0) * (_t[Ut] - 0)), Ct[Ut] < 0 && (Ot += (0 - Ct[Ut]) * (0 - Ct[Ut]));
                return Ot;
              })(We.min([], st, nt), We.max([], st, nt));
              if (ht === 0) return !0;
              let pt = !1;
              const at = this._elevation;
              if (at && ht > j && q !== 0) {
                const _t = this.calculateProjMatrix(it.tileID.toUnwrapped());
                let Ct;
                t.isTerrainDEM || (Ct = at.getMinMaxForTile(it.tileID)), Ct || (Ct = { min: E, max: b });
                const Pt = (function (Ut) {
                    const Qt = Math.round(((Ut + 45 + 360) % 360) / 90) % 4;
                    return nr[Qt];
                  })(this.rotation),
                  Ot = [Pt[0] * lt, Pt[1] * lt, Ct.max];
                N.transformMat4(Ot, Ot, _t), (pt = (1 - Ot[1]) * this.height * 0.5 < q);
              }
              return ht < j || pt;
            });
          }
          return k.sort((j, q) => j.distanceSq - q.distanceSq).map((j) => j.tileID);
        }
        resize(t, i) {
          (this.width = t), (this.height = i), (this.pixelsToGLUnits = [2 / t, -2 / i]), this._constrain(), this._calcMatrices();
        }
        get unmodified() {
          return this._unmodified;
        }
        zoomScale(t) {
          return Math.pow(2, t);
        }
        scaleZoom(t) {
          return Math.log(t) / Math.LN2;
        }
        project(t) {
          const i = Bt(t.lat, -Ii, Ii),
            r = this.projection.project(t.lng, i);
          return new H(r.x * this.worldSize, r.y * this.worldSize);
        }
        unproject(t) {
          return this.projection.unproject(t.x / this.worldSize, t.y / this.worldSize);
        }
        get point() {
          return this.project(this.center);
        }
        get pointMerc() {
          return this.point._div(this.worldSize);
        }
        get pixelsPerMeterRatio() {
          return this.pixelsPerMeter / Je(1, this.center.lat) / this.worldSize;
        }
        setLocationAtPoint(t, i) {
          let r, n;
          const o = this.centerPoint;
          if (this.projection.name === 'globe') {
            const a = this.worldSize;
            (r = (i.x - o.x) / a), (n = (i.y - o.y) / a);
          } else {
            const a = this.pointCoordinate(i),
              l = this.pointCoordinate(o);
            (r = a.x - l.x), (n = a.y - l.y);
          }
          const s = this.locationCoordinate(t);
          this.setLocation(new Me(s.x - r, s.y - n));
        }
        setLocation(t) {
          (this.center = this.coordinateLocation(t)), this.projection.wrap && (this.center = this.center.wrap());
        }
        locationPoint(t) {
          return this.projection.locationPoint(this, t);
        }
        locationPoint3D(t) {
          return this.projection.locationPoint(this, t, !0);
        }
        pointLocation(t) {
          return this.coordinateLocation(this.pointCoordinate(t));
        }
        pointLocation3D(t) {
          return this.coordinateLocation(this.pointCoordinate3D(t));
        }
        locationCoordinate(t, i) {
          const r = i ? Je(i, t.lat) : void 0,
            n = this.projection.project(t.lng, t.lat);
          return new Me(n.x, n.y, r);
        }
        coordinateLocation(t) {
          return this.projection.unproject(t.x, t.y);
        }
        pointRayIntersection(t, i) {
          const r = i ?? this._centerAltitude,
            n = [t.x, t.y, 0, 1],
            o = [t.x, t.y, 1, 1];
          We.transformMat4(n, n, this.pixelMatrixInverse), We.transformMat4(o, o, this.pixelMatrixInverse);
          const s = o[3];
          We.scale(n, n, 1 / n[3]), We.scale(o, o, 1 / s);
          const a = n[2],
            l = o[2];
          return { p0: n, p1: o, t: a === l ? 0 : (r - a) / (l - a) };
        }
        screenPointToMercatorRay(t) {
          const i = [t.x, t.y, 0, 1],
            r = [t.x, t.y, 1, 1];
          return We.transformMat4(i, i, this.pixelMatrixInverse), We.transformMat4(r, r, this.pixelMatrixInverse), We.scale(i, i, 1 / i[3]), We.scale(r, r, 1 / r[3]), (i[2] = Je(i[2], this._center.lat) * this.worldSize), (r[2] = Je(r[2], this._center.lat) * this.worldSize), We.scale(i, i, 1 / this.worldSize), We.scale(r, r, 1 / this.worldSize), new cu([i[0], i[1], i[2]], N.normalize([], N.sub([], r, i)));
        }
        rayIntersectionCoordinate(t) {
          const { p0: i, p1: r, t: n } = t,
            o = Je(i[2], this._center.lat),
            s = Je(r[2], this._center.lat);
          return new Me(ee(i[0], r[0], n) / this.worldSize, ee(i[1], r[1], n) / this.worldSize, ee(o, s, n));
        }
        pointCoordinate(t, i = this._centerAltitude) {
          return this.projection.pointCoordinate(this, t.x, t.y, i);
        }
        pointCoordinate3D(t) {
          if (!this.elevation) return this.pointCoordinate(t);
          let i = this.projection.pointCoordinate3D(this, t.x, t.y);
          if (i) return new Me(i[0], i[1], i[2]);
          let r = 0,
            n = this.horizonLineFromTop();
          if (t.y > n) return this.pointCoordinate(t);
          const o = 0.02 * n,
            s = t.clone();
          for (let a = 0; a < 10 && n - r > o; a++) {
            s.y = ee(r, n, 0.66);
            const l = this.projection.pointCoordinate3D(this, s.x, s.y);
            l ? ((n = s.y), (i = l)) : (r = s.y);
          }
          return i ? new Me(i[0], i[1], i[2]) : this.pointCoordinate(t);
        }
        isPointAboveHorizon(t) {
          return this.projection.isPointAboveHorizon(this, t);
        }
        isPointOnSurface(t) {
          if (t.y < 0 || t.y > this.height || t.x < 0 || t.x > this.width) return !1;
          if (this.elevation || this.zoom >= Oo) return !this.isPointAboveHorizon(t);
          const i = this.pointCoordinate(t);
          return i.y >= 0 && i.y <= 1;
        }
        _coordinatePoint(t, i) {
          const r = i && this.elevation ? this.elevation.getAtPointOrZero(t, this._centerAltitude) : this._centerAltitude,
            n = [t.x * this.worldSize, t.y * this.worldSize, r + t.toAltitude(), 1];
          return We.transformMat4(n, n, this.pixelMatrix), n[3] > 0 ? new H(n[0] / n[3], n[1] / n[3]) : new H(Number.MAX_VALUE, Number.MAX_VALUE);
        }
        _getBoundsNonRectangular() {
          const { top: t, left: i } = this._edgeInsets,
            r = this.height - this._edgeInsets.bottom,
            n = this.width - this._edgeInsets.right,
            o = this.pointLocation3D(new H(i, t)),
            s = this.pointLocation3D(new H(n, t)),
            a = this.pointLocation3D(new H(n, r)),
            l = this.pointLocation3D(new H(i, r));
          let c = Math.min(o.lng, s.lng, a.lng, l.lng),
            u = Math.max(o.lng, s.lng, a.lng, l.lng),
            h = Math.min(o.lat, s.lat, a.lat, l.lat),
            d = Math.max(o.lat, s.lat, a.lat, l.lat);
          const f = (Math.pow(2, -this.zoom) / 16) * 270,
            p = this.projection.name === 'globe' ? 1 : 4,
            _ = (g, y, v, w, T) => {
              const b = (g + v) / 2,
                E = (y + w) / 2,
                S = new H(b, E),
                { lng: I, lat: C } = this.pointLocation3D(S),
                z = Math.max(0, c - I, h - C, I - u, C - d);
              (c = Math.min(c, I)), (u = Math.max(u, I)), (h = Math.min(h, C)), (d = Math.max(d, C)), (T < p || z > f) && (_(g, y, b, E, T + 1), _(b, E, v, w, T + 1));
            };
          if ((_(i, t, n, t, 1), _(n, t, n, r, 1), _(n, r, i, r, 1), _(i, r, i, t, 1), this.projection.name === 'globe')) {
            const [g, y] = (function (v) {
              const w = J.identity(new Float64Array(16));
              J.multiply(w, v.pixelMatrix, v.globeMatrix);
              const T = [0, un, 0],
                b = [0, hn, 0];
              return N.transformMat4(T, T, w), N.transformMat4(b, b, w), [T[0] > 0 && T[0] <= v.width && T[1] > 0 && T[1] <= v.height && !fu(v, new ie(v.center.lat, 90)), b[0] > 0 && b[0] <= v.width && b[1] > 0 && b[1] <= v.height && !fu(v, new ie(v.center.lat, -90))];
            })(this);
            g ? ((d = 90), (u = 180), (c = -180)) : y && ((h = -90), (u = 180), (c = -180));
          }
          return new kr(new ie(c, h), new ie(u, d));
        }
        _getBoundsRectangular(t, i) {
          const { top: r, left: n } = this._edgeInsets,
            o = this.height - this._edgeInsets.bottom,
            s = this.width - this._edgeInsets.right,
            a = new H(n, r),
            l = new H(s, r),
            c = new H(s, o),
            u = new H(n, o);
          let h = this.pointCoordinate(a, t),
            d = this.pointCoordinate(l, t);
          const f = this.pointCoordinate(c, i),
            p = this.pointCoordinate(u, i),
            _ = (g, y) => (y.y - g.y) / (y.x - g.x);
          return h.y > 1 && d.y >= 0 ? (h = new Me((1 - p.y) / _(p, h) + p.x, 1)) : h.y < 0 && d.y <= 1 && (h = new Me(-p.y / _(p, h) + p.x, 0)), d.y > 1 && h.y >= 0 ? (d = new Me((1 - f.y) / _(f, d) + f.x, 1)) : d.y < 0 && h.y <= 1 && (d = new Me(-f.y / _(f, d) + f.x, 0)), new kr().extend(this.coordinateLocation(h)).extend(this.coordinateLocation(d)).extend(this.coordinateLocation(p)).extend(this.coordinateLocation(f));
        }
        _getBoundsRectangularTerrain() {
          const t = this.elevation;
          if (!t.visibleDemTiles.length || t.isUsingMockSource()) return this._getBoundsRectangular(0, 0);
          const i = t.visibleDemTiles.reduce(
            (r, n) => {
              if (n.dem) {
                const o = n.dem.tree;
                (r.min = Math.min(r.min, o.minimums[0])), (r.max = Math.max(r.max, o.maximums[0]));
              }
              return r;
            },
            { min: Number.MAX_VALUE, max: 0 }
          );
          return this._getBoundsRectangular(i.min * t.exaggeration(), i.max * t.exaggeration());
        }
        getBounds() {
          return this.projection.name === 'mercator' || this.projection.name === 'equirectangular' ? (this._terrainEnabled() ? this._getBoundsRectangularTerrain() : this._getBoundsRectangular(0, 0)) : this._getBoundsNonRectangular();
        }
        horizonLineFromTop(t = !0) {
          const i = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, 0.1)) - this.centerOffset.y,
            r = this.height / 2 - i * (1 - this._horizonShift);
          return t ? Math.max(0, r) : r;
        }
        getMaxBounds() {
          return this.maxBounds;
        }
        setMaxBounds(t) {
          (this.maxBounds = t), (this.minLat = -Ii), (this.maxLat = Ii), (this.minLng = -180), (this.maxLng = 180), t && ((this.minLat = t.getSouth()), (this.maxLat = t.getNorth()), (this.minLng = t.getWest()), (this.maxLng = t.getEast()), this.maxLng < this.minLng && (this.maxLng += 360)), (this.worldMinX = qi(this.minLng) * this.tileSize), (this.worldMaxX = qi(this.maxLng) * this.tileSize), (this.worldMinY = Hi(this.maxLat) * this.tileSize), (this.worldMaxY = Hi(this.minLat) * this.tileSize), this._constrain();
        }
        calculatePosMatrix(t, i) {
          return this.projection.createTileMatrix(this, i, t);
        }
        calculateDistanceTileData(t) {
          const i = t.key,
            r = this._distanceTileDataCache;
          if (r[i]) return r[i];
          const n = t.canonical,
            o = 1 / this.height,
            s = this.cameraWorldSize,
            a = s / this.zoomScale(n.z),
            l = (n.x + Math.pow(2, n.z) * t.wrap) * a,
            c = n.y * a,
            u = this.point;
          (u.x *= s / this.worldSize), (u.y *= s / this.worldSize);
          const h = this.angle,
            d = Math.sin(-h),
            f = -Math.cos(-h);
          return (r[i] = { bearing: [d, f], center: [(u.x - l) * o, (u.y - c) * o], scale: (a / lt) * o }), r[i];
        }
        calculateFogTileMatrix(t) {
          const i = t.key,
            r = this._fogTileMatrixCache;
          if (r[i]) return r[i];
          const n = this.projection.createTileMatrix(this, this.cameraWorldSizeForFog, t);
          return J.multiply(n, this.worldToFogMatrix, n), (r[i] = new Float32Array(n)), r[i];
        }
        calculateProjMatrix(t, i = !1, r = !1) {
          const n = t.key;
          let o;
          if (((o = r ? this._expandedProjMatrixCache : i ? this._alignedProjMatrixCache : this._projMatrixCache), o[n])) return o[n];
          const s = this.calculatePosMatrix(t, this.worldSize);
          let a;
          return (a = this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : r ? this.expandedFarZProjMatrix : i ? this.alignedProjMatrix : this.projMatrix), J.multiply(s, a, s), (o[n] = new Float32Array(s)), o[n];
        }
        calculatePixelsToTileUnitsMatrix(t) {
          const i = t.tileID.key,
            r = this._pixelsToTileUnitsCache;
          if (r[i]) return r[i];
          const n = (function (o, s) {
            const { scale: a } = o.tileTransform,
              l = (a * lt) / (o.tileSize * Math.pow(2, s.zoom - o.tileID.overscaledZ + o.tileID.canonical.z));
            return ma.scale(new Float32Array(4), s.inverseAdjustmentMatrix, [l, l]);
          })(t, this);
          return (r[i] = n), r[i];
        }
        customLayerMatrix() {
          return this.mercatorMatrix.slice();
        }
        globeToMercatorMatrix() {
          if (this.projection.name === 'globe') {
            const t = 1 / this.worldSize,
              i = J.fromScaling([], [t, t, t]);
            return J.multiply(i, i, this.globeMatrix), i;
          }
        }
        recenterOnTerrain() {
          if (!this._elevation || this.projection.name === 'globe') return;
          const t = this._elevation;
          this._updateCameraState();
          const i = Je(1, this._center.lat) * this.worldSize,
            r = this._computeCameraPosition(i),
            n = this._camera.forward(),
            o = Je(1, this._center.lat);
          (r[2] /= o), (n[2] /= o), N.normalize(n, n);
          const s = t.raycast(r, n, t.exaggeration());
          if (s) {
            const a = N.scaleAndAdd([], r, n, s),
              l = new Me(a[0], a[1], Je(a[2], Ni(a[1]))),
              c = (l.z + N.length([l.x - r[0], l.y - r[1], l.z - r[2] * o])) * this._pixelsPerMercatorPixel;
            (this._seaLevelZoom = this._zoomFromMercatorZ(c)), (this._centerAltitude = l.toAltitude()), (this._center = this.coordinateLocation(l)), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices();
          }
        }
        _constrainCamera(t = !1) {
          if (!this._elevation) return;
          const i = this._elevation,
            r = Je(1, this._center.lat) * this.worldSize,
            n = this._computeCameraPosition(r),
            o = i.getAtPointOrZero(new Me(...n)),
            s = (this.pixelsPerMeter / this.worldSize) * o,
            a = this._minimumHeightOverTerrain(),
            l = n[2] - s;
          if (l <= a)
            if (l < 0 || t) {
              const c = this.locationCoordinate(this._center, this._centerAltitude),
                u = [n[0], n[1], c.z - n[2]],
                h = N.length(u);
              u[2] -= (a - l) / this._pixelsPerMercatorPixel;
              const d = N.length(u);
              if (d === 0) return;
              N.scale(u, u, (h / d) * this._pixelsPerMercatorPixel), (this._camera.position = [n[0], n[1], c.z * this._pixelsPerMercatorPixel - u[2]]), this._updateStateFromCamera();
            } else this._isCameraConstrained = !0;
        }
        _constrain() {
          if (!this.center || !this.width || !this.height || this._constraining) return;
          this._constraining = !0;
          const t = this.projection.name === 'globe' || this.mercatorFromTransition;
          if (this.projection.isReprojectedInTileSpace || t) {
            const d = this.center;
            return (d.lat = Bt(d.lat, this.minLat, this.maxLat)), (this.maxBounds || (!this.renderWorldCopies && !t)) && (d.lng = Bt(d.lng, this.minLng, this.maxLng)), (this.center = d), void (this._constraining = !1);
          }
          const i = this._unmodified,
            { x: r, y: n } = this.point;
          let o = 0,
            s = r,
            a = n;
          const l = this.width / 2,
            c = this.height / 2,
            u = this.worldMinY * this.scale,
            h = this.worldMaxY * this.scale;
          if ((n - c < u && (a = u + c), n + c > h && (a = h - c), h - u < this.height && ((o = Math.max(o, this.height / (h - u))), (a = (h + u) / 2)), this.maxBounds || !this._renderWorldCopies || !this.projection.wrap)) {
            const d = this.worldMinX * this.scale,
              f = this.worldMaxX * this.scale,
              p = this.worldSize / 2 - (d + f) / 2;
            (s = ((r + p + this.worldSize) % this.worldSize) - p), s - l < d && (s = d + l), s + l > f && (s = f - l), f - d < this.width && ((o = Math.max(o, this.width / (f - d))), (s = (f + d) / 2));
          }
          (s === r && a === n) || (this.center = this.unproject(new H(s, a))), o && (this.zoom += this.scaleZoom(o)), this._constrainCamera(), (this._unmodified = i), (this._constraining = !1);
        }
        _minZoomForBounds() {
          let t = Math.max(0, this.scaleZoom(this.height / (this.worldMaxY - this.worldMinY)));
          return this.maxBounds && (t = Math.max(t, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))), t;
        }
        _maxCameraBoundsDistance() {
          return this._mercatorZfromZoom(this._minZoomForBounds());
        }
        _calcMatrices() {
          if (!this.height) return;
          const t = this.centerOffset,
            i = this.projection.name === 'globe',
            r = this.pixelsPerMeter;
          this.projection.name === 'globe' && (this._mercatorScaleRatio = Je(1, this.center.lat) / Je(1, 45));
          const n = ql(this.projection, this.zoom, this.width, this.height, 1024);
          (this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, n)), (this.cameraToCenterDistance = (0.5 / Math.tan(0.5 * this._fov)) * this.height * this._pixelsPerMercatorPixel), this._updateCameraState(), (this._farZ = this.projection.farthestPixelDistance(this)), (this._nearZ = this.height / 50);
          const o = this.projection.zAxisUnit === 'meters' ? r : 1,
            s = this._camera.getWorldToCamera(this.worldSize, o);
          let a;
          const l = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);
          if (((l[8] = (2 * -t.x) / this.width), (l[9] = (2 * t.y) / this.height), this.isOrthographic)) {
            let C = ((0.5 * this.height) / Math.tan(this._fov / 2)) * 1 * Math.tan(0.5 * this._fov),
              z = C * this.aspect,
              k = -z,
              O = -C;
            (z -= t.x),
              (k -= t.x),
              (C += t.y),
              (O += t.y),
              (a = this._camera.getCameraToClipOrthographic(k, z, O, C, this._nearZ, this._farZ)),
              ((V, R, G, Z) => {
                for (let X = 0; X < 16; X++) V[X] = Xv(R[X], G[X], Z);
              })(a, a, l, Yv(this.pitch >= 15 ? 1 : this.pitch / 15));
          } else a = l;
          const c = J.mul([], l, s);
          let u = J.mul([], a, s);
          if (this.projection.isReprojectedInTileSpace) {
            const C = this.locationCoordinate(this.center),
              z = J.identity([]);
            J.translate(z, z, [C.x * this.worldSize, C.y * this.worldSize, 0]),
              J.multiply(z, z, Ov(this)),
              J.translate(z, z, [-C.x * this.worldSize, -C.y * this.worldSize, 0]),
              J.multiply(u, u, z),
              J.multiply(c, c, z),
              (this.inverseAdjustmentMatrix = (function (k) {
                const O = Ov(k, !0);
                return ma.invert([], [O[0], O[1], O[4], O[5]]);
              })(this));
          } else this.inverseAdjustmentMatrix = [1, 0, 0, 1];
          if (((this.mercatorMatrix = J.scale([], u, [this.worldSize, this.worldSize, this.worldSize / o, 1])), (this.projMatrix = u), (this.invProjMatrix = J.invert(new Float64Array(16), this.projMatrix)), i)) {
            const C = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, 1 / 0);
            (C[8] = (2 * -t.x) / this.width), (C[9] = (2 * t.y) / this.height), (this.expandedFarZProjMatrix = J.mul([], C, s));
          } else this.expandedFarZProjMatrix = this.projMatrix;
          const h = J.invert([], a);
          (this.frustumCorners = lp.fromInvProjectionMatrix(h, this.horizonLineFromTop(), this.height)), (this.cameraFrustum = uo.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, 0, !i));
          const d = new Float32Array(16);
          J.identity(d), J.scale(d, d, [1, -1, 1]), J.rotateX(d, d, this._pitch), J.rotateZ(d, d, this.angle);
          const f = J.perspective(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ);
          this.starsProjMatrix = J.clone(f);
          const p = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;
          (f[8] = (2 * -t.x) / this.width), (f[9] = (2 * (t.y + p)) / this.height), (this.skyboxMatrix = J.multiply(d, f, d));
          const _ = this.point,
            g = _.x,
            y = _.y,
            v = (this.width % 2) / 2,
            w = (this.height % 2) / 2,
            T = Math.cos(this.angle),
            b = Math.sin(this.angle),
            E = g - Math.round(g) + T * v + b * w,
            S = y - Math.round(y) + T * w + b * v,
            I = new Float64Array(u);
          if ((J.translate(I, I, [E > 0.5 ? E - 1 : E, S > 0.5 ? S - 1 : S, 0]), (this.alignedProjMatrix = I), (u = J.create()), J.scale(u, u, [this.width / 2, -this.height / 2, 1]), J.translate(u, u, [1, -1, 0]), (this.labelPlaneMatrix = u), (u = J.create()), J.scale(u, u, [1, -1, 1]), J.translate(u, u, [-1, -1, 0]), J.scale(u, u, [2 / this.width, 2 / this.height, 1]), (this.glCoordMatrix = u), (this.pixelMatrix = J.multiply(new Float64Array(16), this.labelPlaneMatrix, c)), this._calcFogMatrices(), (this._distanceTileDataCache = {}), (u = J.invert(new Float64Array(16), this.pixelMatrix)), !u)) throw new Error('failed to invert matrix');
          if (((this.pixelMatrixInverse = u), this.projection.name === 'globe' || this.mercatorFromTransition)) {
            this.globeMatrix = (function (z) {
              const { x: k, y: O } = z.point,
                { lng: V, lat: R } = z._center;
              return nx(k, O, z.worldSize, V, R);
            })(this);
            const C = [this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]];
            (this.globeCenterInViewSpace = N.transformMat4(C, C, s)), (this.globeRadius = this.worldSize / 2 / Math.PI - 1);
          } else this.globeMatrix = u;
          (this._projMatrixCache = {}), (this._alignedProjMatrixCache = {}), (this._pixelsToTileUnitsCache = {}), (this._expandedProjMatrixCache = {});
        }
        _calcFogMatrices() {
          this._fogTileMatrixCache = {};
          const t = this.cameraWorldSizeForFog,
            i = this.cameraPixelsPerMeter,
            r = this._camera.position,
            n = 1 / this.height / this._pixelsPerMercatorPixel,
            o = [t, t, i];
          N.scale(o, o, n), N.scale(r, r, -1), N.multiply(r, r, o);
          const s = J.create();
          J.translate(s, s, r), J.scale(s, s, o), (this.mercatorFogMatrix = s), (this.worldToFogMatrix = this._camera.getWorldToCameraPosition(t, i, n));
        }
        _computeCameraPosition(t) {
          const i = (t = t || this.pixelsPerMeter) / this.pixelsPerMeter,
            r = this._camera.forward(),
            n = this.point,
            o = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * i - (t / this.worldSize) * this._centerAltitude;
          return [n.x / this.worldSize - r[0] * o, n.y / this.worldSize - r[1] * o, (t / this.worldSize) * this._centerAltitude - r[2] * o];
        }
        _updateCameraState() {
          this.height && (this._camera.setPitchBearing(this._pitch, this.angle), (this._camera.position = this._computeCameraPosition()));
        }
        _translateCameraConstrained(t) {
          const i = this._maxCameraBoundsDistance() * Math.cos(this._pitch),
            r = this._camera.position[2],
            n = t[2];
          let o = 1;
          this.projection.wrap && (this.center = this.center.wrap()), n > 0 && (o = Math.min((i - r) / n, 1)), (this._camera.position = N.scaleAndAdd([], this._camera.position, t, o)), this._updateStateFromCamera();
        }
        _updateStateFromCamera() {
          const t = this._camera.position,
            i = this._camera.forward(),
            { pitch: r, bearing: n } = this._camera.getPitchBearing(),
            o = Je(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel,
            s = this._mercatorZfromZoom(this._maxZoom) * Math.cos(ne(this._maxPitch)),
            a = Math.max((t[2] - o) / Math.cos(r), s),
            l = this._zoomFromMercatorZ(a);
          N.scaleAndAdd(t, t, i, a), (this._pitch = Bt(r, ne(this.minPitch), ne(this.maxPitch))), (this.angle = en(n, -Math.PI, Math.PI)), this._setZoom(Bt(l, this._minZoom, this._maxZoom)), this._updateSeaLevelZoom(), (this._center = this.coordinateLocation(new Me(t[0], t[1], t[2]))), (this._unmodified = !1), this._constrain(), this._calcMatrices();
        }
        _worldSizeFromZoom(t) {
          return Math.pow(2, t) * this.tileSize;
        }
        _mercatorZfromZoom(t) {
          return this.cameraToCenterDistance / this._worldSizeFromZoom(t);
        }
        _minimumHeightOverTerrain() {
          const t = Math.min((this._seaLevelZoom != null ? this._seaLevelZoom : this._zoom) + 4, this._maxZoom);
          return this._mercatorZfromZoom(t);
        }
        _zoomFromMercatorZ(t) {
          return this.scaleZoom(this.cameraToCenterDistance / (t * this.tileSize));
        }
        zoomFromMercatorZAdjusted(t) {
          let i = 0,
            r = Oo,
            n = 0,
            o = 1 / 0;
          for (; r - i > 1e-6 && r > i; ) {
            const s = i + 0.5 * (r - i),
              a = this.tileSize * Math.pow(2, s),
              l = this.getCameraToCenterDistance(this.projection, s, a),
              c = this.scaleZoom(l / (t * this.tileSize)),
              u = Math.abs(s - c);
            u < o && ((o = u), (n = s)), s < c ? (i = s) : (r = s);
          }
          return n;
        }
        _terrainEnabled() {
          return !(!this._elevation || (!this.projection.supportsTerrain && (B('Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain.'), 1)));
        }
        anyCornerOffEdge(t, i) {
          const r = Math.min(t.x, i.x),
            n = Math.max(t.x, i.x),
            o = Math.min(t.y, i.y),
            s = Math.max(t.y, i.y);
          if (o < this.horizonLineFromTop(!1)) return !0;
          if (this.projection.name !== 'mercator') return !1;
          const a = [new H(r, o), new H(n, s), new H(r, s), new H(n, o)],
            l = this.renderWorldCopies ? -3 : 0,
            c = this.renderWorldCopies ? 4 : 1;
          for (const u of a) {
            const h = this.pointRayIntersection(u);
            if (h.t < 0) return !0;
            const d = this.rayIntersectionCoordinate(h);
            if (d.x < l || d.y < 0 || d.x > c || d.y > 1) return !0;
          }
          return !1;
        }
        isHorizonVisible() {
          return this.pitch + Vi(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new H(0, 0), new H(this.width, this.height));
        }
        zoomDeltaToMovement(t, i) {
          const r = N.length(N.sub([], this._camera.position, t)),
            n = this._zoomFromMercatorZ(r) + i;
          return r - this._mercatorZfromZoom(n);
        }
        getCameraPoint() {
          if (this.projection.name === 'globe') {
            const t = (function ([i, r, n], o) {
              const s = [i, r, n, 1];
              We.transformMat4(s, s, o);
              const a = (s[3] = Math.max(s[3], 1e-6));
              return (s[0] /= a), (s[1] /= a), (s[2] /= a), s;
            })([this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]], this.pixelMatrix);
            return new H(t[0], t[1]);
          }
          {
            const t = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new H(0, t));
          }
        }
        getCameraToCenterDistance(t, i = this.zoom, r = this.worldSize) {
          const n = ql(t, i, this.width, this.height, 1024),
            o = t.pixelSpaceConversion(this.center.lat, r, n);
          let s = (0.5 / Math.tan(0.5 * this._fov)) * this.height * o;
          return this.isOrthographic && (s = Xv(1, s, Yv(this.pitch >= 15 ? 1 : this.pitch / 15))), s;
        }
        getWorldToCameraMatrix() {
          const t = this._camera.getWorldToCamera(this.worldSize, this.projection.zAxisUnit === 'meters' ? this.pixelsPerMeter : 1);
          return this.projection.name === 'globe' && J.multiply(t, t, this.globeMatrix), t;
        }
        getFrustum(t) {
          return uo.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, t, this.projection.zAxisUnit === 'meters');
        }
      }
      function Kv(e, t, i) {
        J.identity(e), J.rotateZ(e, e, ne(t[2])), J.rotateX(e, e, ne(t[0])), J.rotateY(e, e, ne(t[1])), J.scale(e, e, i), J.multiply(e, e, [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1]);
      }
      function th(e, t, i, r, n, o, s, a) {
        const l = [i[0] - t[0], i[1] - t[1], 0],
          c = [r[0] - t[0], r[1] - t[1], 0];
        if (N.length(l) < 1e-12 || N.length(c) < 1e-12) return sr.identity(e);
        const u = N.cross([], l, c);
        N.normalize(u, u), N.subtract(c, r, t), (l[2] = (o - n) * a), (c[2] = (s - n) * a);
        const h = l;
        return N.cross(h, l, c), N.normalize(h, h), sr.rotationTo(e, u, h);
      }
      function Jv(e, t, i = !1) {
        const r = Ji(t.zoom),
          n = (function (o, s, a) {
            const l = s.worldSize,
              c = [o[12], o[13], o[14]],
              u = Ni(c[1] / l),
              h = Or(c[0] / l),
              d = J.identity([]),
              f = Je(1, u) * l,
              p = Je(1, 0) * l * No(u, s.zoom),
              _ = 1 / pp(l);
            let g = p * _;
            if (a) {
              const T = ql(s.projection, s.zoom, s.width, s.height, 1024);
              g = _ * s.projection.pixelSpaceConversion(s.center.lat, l, T);
            }
            const y = wr(u, h);
            N.add(y, y, N.scale([], N.normalize([], y), f * g * c[2]));
            const v = (function (T) {
              const b = [T[0], T[1], T[2]];
              let E = [0, 1, 0];
              const S = N.cross([], E, b);
              return N.cross(E, b, S), N.squaredLength(E) === 0 && ((E = [0, 1, 0]), N.cross(S, b, E)), N.normalize(S, S), N.normalize(E, E), N.normalize(b, b), [S[0], S[1], S[2], 0, E[0], E[1], E[2], 0, b[0], b[1], b[2], 0, T[0], T[1], T[2], 1];
            })(y);
            J.scale(d, d, [g, g, g * f]), J.translate(d, d, [-c[0], -c[1], -c[2]]);
            const w = J.multiply([], s.globeMatrix, v);
            return J.multiply(w, w, d), J.multiply(w, w, o), w;
          })(e, t, i);
        if (r > 0) {
          const o = (function (s, a) {
            const l = a.worldSize,
              c = (Je(1, 0) * l * No(a.center.lat, a.zoom)) / pp(l),
              u = Je(1, a.center.lat) * l,
              h = J.identity([]);
            return J.rotateY(h, h, ne(a.center.lng)), J.rotateX(h, h, ne(a.center.lat)), J.translate(h, h, [0, 0, mr]), J.scale(h, h, [c, c, c * u]), J.translate(h, h, [a.point.x - 0.5 * l, a.point.y - 0.5 * l, 0]), J.multiply(h, h, s), J.multiply(h, a.globeMatrix, h);
          })(e, t);
          return (function (s, a, l) {
            const c = (p, _, g) => {
                const y = N.length(p),
                  v = N.length(_),
                  w = ho(p, _, g);
                return N.scale(w, w, (1 / N.length(w)) * ee(y, v, g));
              },
              u = c([s[0], s[1], s[2]], [a[0], a[1], a[2]], l),
              h = c([s[4], s[5], s[6]], [a[4], a[5], a[6]], l),
              d = c([s[8], s[9], s[10]], [a[8], a[9], a[10]], l),
              f = ho([s[12], s[13], s[14]], [a[12], a[13], a[14]], l);
            return [u[0], u[1], u[2], 0, h[0], h[1], h[2], 0, d[0], d[1], d[2], 0, f[0], f[1], f[2], 1];
          })(n, o, r);
        }
        return n;
      }
      const Ss = 64,
        cC = [1, 1, 1];
      class Qv {
        constructor(t, i, r, n) {
          (this.id = t), (this.position = i != null ? new ie(i[0], i[1]) : new ie(0, 0)), (this.orientation = r ?? [0, 0, 0]), (this.nodes = n), (this.uploaded = !1), (this.aabb = new ni([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0])), (this.matrix = []);
        }
        _applyTransformations(t, i) {
          if ((J.multiply(t.matrix, i, t.matrix), t.meshes))
            for (const r of t.meshes) {
              const n = ni.applyTransform(r.aabb, t.matrix);
              this.aabb.encapsulate(n);
            }
          if (t.children) for (const r of t.children) this._applyTransformations(r, t.matrix);
        }
        computeBoundsAndApplyParent() {
          const t = J.identity([]);
          for (const i of this.nodes) this._applyTransformations(i, t);
        }
        _positionModelOnTerrain(t, i) {
          const r = t.elevation;
          if (!r) return 0;
          const n = ni.projectAabbCorners(this.aabb, this.matrix),
            o = Je(1, this.position.lat) * t.worldSize,
            s = (function (y, v) {
              const w = [0, 0, 1],
                T = [
                  { corners: [0, 1, 3, 2], dotProductWithUp: 0 },
                  { corners: [1, 5, 2, 6], dotProductWithUp: 0 },
                  { corners: [0, 4, 1, 5], dotProductWithUp: 0 },
                  { corners: [2, 6, 3, 7], dotProductWithUp: 0 },
                  { corners: [4, 7, 5, 6], dotProductWithUp: 0 },
                  { corners: [0, 3, 4, 7], dotProductWithUp: 0 },
                ];
              for (const b of T) {
                const E = y[b.corners[0]],
                  S = y[b.corners[1]],
                  I = y[b.corners[2]],
                  C = [S[0] - E[0], S[1] - E[1], v * (S[2] - E[2])],
                  z = N.cross(C, C, [I[0] - E[0], I[1] - E[1], v * (I[2] - E[2])]);
                N.normalize(z, z), (b.dotProductWithUp = N.dot(z, w));
              }
              return T.sort((b, E) => b.dotProductWithUp - E.dotProductWithUp), T[0].corners;
            })(n, o),
            a = n[s[0]],
            l = n[s[1]],
            c = n[s[2]],
            u = n[s[3]],
            h = r.getAtPointOrZero(new Me(a[0] / t.worldSize, a[1] / t.worldSize), 0),
            d = r.getAtPointOrZero(new Me(l[0] / t.worldSize, l[1] / t.worldSize), 0),
            f = r.getAtPointOrZero(new Me(c[0] / t.worldSize, c[1] / t.worldSize), 0),
            p = r.getAtPointOrZero(new Me(u[0] / t.worldSize, u[1] / t.worldSize), 0),
            _ = (h + p) / 2,
            g = (d + f) / 2;
          return _ > g ? (d < f ? th(i, l, u, a, d, p, h, o) : th(i, c, a, u, f, h, p, o)) : h < p ? th(i, a, l, c, h, d, f, o) : th(i, u, c, l, p, f, d, o), Math.max(_, g);
        }
        computeModelMatrix(t, i, r, n, o, s, a = !1) {
          const l = t.transform,
            c = l.zoom,
            u = l.project(this.position),
            h = No(this.position.lat, c),
            d = 1 / h;
          J.identity(this.matrix), J.translate(this.matrix, this.matrix, [u.x + n[0] * d, u.y + n[1] * d, n[2]]);
          let f = 1,
            p = 1;
          const _ = l.worldSize;
          if (a) {
            if (l.projection.name === 'mercator') {
              let w = 0;
              l.elevation && (w = l.elevation.getAtPointOrZero(new Me(u.x / _, u.y / _), 0));
              const T = We.transformMat4([], [u.x, u.y, w, 1], l.projMatrix)[3] / l.cameraToCenterDistance;
              (f = T), (p = T * No(l.center.lat, c));
            } else if (l.projection.name === 'globe') {
              const w = Jv(this.matrix, l),
                T = J.multiply([], l.projMatrix, w),
                b = [0, 0, 0, 1];
              We.transformMat4(b, b, T);
              const E = b[3] / l.cameraToCenterDistance,
                S = Ji(c),
                I = l.projection.pixelsPerMeter(this.position.lat, _) * No(this.position.lat, c),
                C = l.projection.pixelsPerMeter(l.center.lat, _) * No(l.center.lat, c);
              (f = E / ee(I, fx(l.center.lat), S)), (p = (E * h) / I), (f *= C), (p *= C);
            }
          } else f = d;
          J.scale(this.matrix, this.matrix, [f, f, p]);
          const g = [...this.matrix],
            y = this.orientation,
            v = [];
          if ((Kv(v, [y[0] + i[0], y[1] + i[1], y[2] + i[2]], r), J.multiply(this.matrix, g, v), o && l.elevation)) {
            let w = 0;
            const T = [];
            if (s && l.elevation) {
              w = this._positionModelOnTerrain(l, T);
              const b = J.fromQuat([], T),
                E = J.multiply([], b, v);
              J.multiply(this.matrix, g, E);
            } else w = l.elevation.getAtPointOrZero(new Me(u.x / _, u.y / _), 0);
            w !== 0 && (this.matrix[14] += w);
          }
        }
        upload(t) {
          if (!this.uploaded) {
            for (const i of this.nodes) im(i, t);
            for (const i of this.nodes) eh(i);
            this.uploaded = !0;
          }
        }
        destroy() {
          for (const t of this.nodes) ih(t);
        }
      }
      function Zl(e, t, i = !1) {
        e.uploaded || ((e.gfxTexture = new vi(t, e.image, i ? t.gl.R8 : t.gl.RGBA, { useMipmap: e.sampler.minFilter >= t.gl.NEAREST_MIPMAP_NEAREST })), (e.uploaded = !0), (e.image = null));
      }
      function uC(e, t, i) {
        (e.indexBuffer = t.createIndexBuffer(e.indexArray, !1, !0)), (e.vertexBuffer = t.createVertexBuffer(e.vertexArray, QI.members, !1, !0)), e.normalArray && (e.normalBuffer = t.createVertexBuffer(e.normalArray, rC.members, !1, !0)), e.texcoordArray && (e.texcoordBuffer = t.createVertexBuffer(e.texcoordArray, iC.members, !1, !0)), e.colorArray && (e.colorBuffer = t.createVertexBuffer(e.colorArray, (e.colorArray.bytesPerElement === 12 ? tC : eC).members, !1, !0)), e.featureArray && (e.pbrBuffer = t.createVertexBuffer(e.featureArray, oC.members, !0)), (e.segments = He.simpleSegment(0, 0, e.vertexArray.length, e.indexArray.length));
        const r = e.material;
        r.pbrMetallicRoughness.baseColorTexture && Zl(r.pbrMetallicRoughness.baseColorTexture, t), r.pbrMetallicRoughness.metallicRoughnessTexture && Zl(r.pbrMetallicRoughness.metallicRoughnessTexture, t), r.normalTexture && Zl(r.normalTexture, t), r.occlusionTexture && Zl(r.occlusionTexture, t, i), r.emissionTexture && Zl(r.emissionTexture, t);
      }
      function im(e, t, i) {
        if (e.meshes) for (const r of e.meshes) uC(r, t, i);
        if (e.children) for (const r of e.children) im(r, t, i);
      }
      function eh(e) {
        if (e.meshes) for (const t of e.meshes) t.indexArray.destroy(), t.vertexArray.destroy(), t.colorArray && t.colorArray.destroy(), t.normalArray && t.normalArray.destroy(), t.texcoordArray && t.texcoordArray.destroy(), t.featureArray && t.featureArray.destroy();
        if (e.children) for (const t of e.children) eh(t);
      }
      function ih(e) {
        if (e.meshes) for (const i of e.meshes) i.vertexBuffer && (i.vertexBuffer.destroy(), i.indexBuffer.destroy(), i.normalBuffer && i.normalBuffer.destroy(), i.texcoordBuffer && i.texcoordBuffer.destroy(), i.colorBuffer && i.colorBuffer.destroy(), i.pbrBuffer && i.pbrBuffer.destroy(), i.segments.destroy(), i.material && ((t = i.material).pbrMetallicRoughness.baseColorTexture && t.pbrMetallicRoughness.baseColorTexture.gfxTexture && t.pbrMetallicRoughness.baseColorTexture.gfxTexture.destroy(), t.pbrMetallicRoughness.metallicRoughnessTexture && t.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture && t.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture.destroy(), t.normalTexture && t.normalTexture.gfxTexture && t.normalTexture.gfxTexture.destroy(), t.emissionTexture && t.emissionTexture.gfxTexture && t.emissionTexture.gfxTexture.destroy(), t.occlusionTexture && t.occlusionTexture.gfxTexture && t.occlusionTexture.gfxTexture.destroy()));
        var t;
        if (e.children) for (const i of e.children) ih(i);
      }
      class t1 {
        constructor(t, i) {
          (this.feature = t), (this.instancedDataOffset = i), (this.instancedDataCount = 0), (this.rotation = [0, 0, 0]), (this.scale = [1, 1, 1]), (this.translation = [0, 0, 0]);
        }
      }
      class e1 {
        constructor() {
          (this.instancedDataArray = new Ff()), (this.instancesEvaluatedElevation = []), (this.features = []), (this.idToFeaturesIndex = {});
        }
      }
      class i1 {
        constructor(t) {
          (this.zoom = t.zoom), (this.canonical = t.canonical), (this.layers = t.layers), (this.layerIds = this.layers.map((i) => i.fqid)), (this.projection = t.projection), (this.index = t.index), (this.hasZoomDependentProperties = this.layers[0].isZoomDependent()), (this.stateDependentLayerIds = this.layers.filter((i) => i.isStateDependent()).map((i) => i.id)), (this.hasPattern = !1), (this.instancesPerModel = {}), (this.validForExaggeration = 0), (this.maxVerticalOffset = 0), (this.maxScale = 0), (this.maxHeight = 0), (this.lookupDim = this.zoom > this.canonical.z ? 256 : this.zoom > 15 ? 75 : 100), (this.instanceCount = 0), (this.terrainElevationMin = 0), (this.terrainElevationMax = 0), (this.validForDEMTile = { id: null, timestamp: 0 });
        }
        populate(t, i, r, n) {
          this.tileToMeter = Il(r);
          const o = this.layers[0]._featureFilter.needGeometry;
          this.lookup = new Uint8Array(this.lookupDim * this.lookupDim);
          for (const { feature: s, id: a, index: l, sourceLayerIndex: c } of t) {
            const u = Uo(s, o);
            if (!this.layers[0]._featureFilter.filter(new gi(this.zoom), u, r)) continue;
            const h = { id: a, sourceLayerIndex: c, index: l, geometry: o ? u.geometry : On(s, r, n), properties: s.properties, type: s.type, patterns: {} },
              d = this.addFeature(h, h.geometry, u);
            d && i.featureIndex.insert(s, h.geometry, l, c, this.index, this.instancesPerModel[d].instancedDataArray.length);
          }
          this.lookup = null;
        }
        update(t, i, r, n) {
          for (const o in this.instancesPerModel) {
            const s = this.instancesPerModel[o];
            for (const a in t) s.idToFeaturesIndex.hasOwnProperty(a) && this.evaluate(s.features[s.idToFeaturesIndex[a]], t[a], s, !0);
          }
          this.maxHeight = 0;
        }
        updateZoomBasedPaintProperties() {
          if (!this.hasZoomDependentProperties) return !1;
          let t = !1;
          for (const i in this.instancesPerModel) {
            const r = this.instancesPerModel[i];
            for (const n of r.features) {
              const o = this.layers[0],
                s = n.feature,
                a = this.canonical,
                l = o.paint.get('model-rotation').evaluate(s, {}, a),
                c = o.paint.get('model-scale').evaluate(s, {}, a),
                u = o.paint.get('model-translation').evaluate(s, {}, a);
              (N.exactEquals(n.rotation, l) && N.exactEquals(n.scale, c) && N.exactEquals(n.translation, u)) || (this.evaluate(n, n.featureStates, r, !0), (t = !0));
            }
          }
          return t;
        }
        isEmpty() {
          for (const t in this.instancesPerModel) if (this.instancesPerModel[t].instancedDataArray.length !== 0) return !1;
          return !0;
        }
        uploadPending() {
          return !this.uploaded;
        }
        upload(t) {
          if (!this.uploaded)
            for (const i in this.instancesPerModel) {
              const r = this.instancesPerModel[i];
              r.instancedDataArray.length < 0 || r.instancedDataArray.length === 0 || (r.instancedDataBuffer ? r.instancedDataBuffer.updateData(r.instancedDataArray) : (r.instancedDataBuffer = t.createVertexBuffer(r.instancedDataArray, nC.members, !0, void 0, this.instanceCount)));
            }
          this.uploaded = !0;
        }
        destroy() {
          for (const t in this.instancesPerModel) {
            const i = this.instancesPerModel[t];
            i.instancedDataArray.length !== 0 && i.instancedDataBuffer && i.instancedDataBuffer.destroy();
          }
        }
        addFeature(t, i, r) {
          const n = this.layers[0],
            o = n.layout.get('model-id').evaluate(r, {}, this.canonical);
          if (!o) return B(`modelId is not evaluated for layer ${n.id} and it is not going to get rendered.`), o;
          this.instancesPerModel[o] || (this.instancesPerModel[o] = new e1());
          const s = this.instancesPerModel[o],
            a = s.instancedDataArray,
            l = new t1(r, a.length);
          for (const c of i)
            for (const u of c) {
              if (u.x < 0 || u.x >= lt || u.y < 0 || u.y >= lt) continue;
              const h = (this.lookupDim - 1) / lt,
                d = (this.lookupDim * ((u.y * h) | 0) + u.x * h) | 0;
              if (this.lookup) {
                if (this.lookup[d] !== 0) continue;
                this.lookup[d] = 1;
              }
              this.instanceCount++;
              const f = a.length;
              a.resize(f + 1), s.instancesEvaluatedElevation.push(0), (a.float32[16 * f] = u.x), (a.float32[16 * f + 1] = u.y);
            }
          return (l.instancedDataCount = s.instancedDataArray.length - l.instancedDataOffset), l.instancedDataCount > 0 && (t.id && (s.idToFeaturesIndex[t.id] = s.features.length), s.features.push(l), this.evaluate(l, {}, s, !1)), o;
        }
        evaluate(t, i, r, n) {
          const o = this.layers[0],
            s = t.feature,
            a = this.canonical,
            l = (t.rotation = o.paint.get('model-rotation').evaluate(s, i, a)),
            c = (t.scale = o.paint.get('model-scale').evaluate(s, i, a)),
            u = (t.translation = o.paint.get('model-translation').evaluate(s, i, a)),
            h = o.paint.get('model-color').evaluate(s, i, a);
          h.a = o.paint.get('model-color-mix-intensity').evaluate(s, i, a);
          const d = [];
          this.maxVerticalOffset < u[2] && (this.maxVerticalOffset = u[2]), (this.maxScale = Math.max(Math.max(this.maxScale, c[0]), Math.max(c[1], c[2]))), Kv(d, l, c);
          const f = Math.round(100 * h.a) + h.b / 1.05;
          for (let p = 0; p < t.instancedDataCount; ++p) {
            const _ = t.instancedDataOffset + p,
              g = 16 * _,
              y = r.instancedDataArray.float32;
            let v = 0;
            n && (v = y[g + 6] - r.instancesEvaluatedElevation[_]);
            const w = 0 | y[g + 1];
            (y[g] = (0 | y[g]) + h.r / 1.05), (y[g + 1] = w + h.g / 1.05), (y[g + 2] = f), (y[g + 3] = 1 / (a.z > 10 ? this.tileToMeter : Il(a, w))), (y[g + 4] = u[0]), (y[g + 5] = u[1]), (y[g + 6] = u[2] + v), (y[g + 7] = d[0]), (y[g + 8] = d[1]), (y[g + 9] = d[2]), (y[g + 10] = d[4]), (y[g + 11] = d[5]), (y[g + 12] = d[6]), (y[g + 13] = d[8]), (y[g + 14] = d[9]), (y[g + 15] = d[10]), (r.instancesEvaluatedElevation[_] = u[2]);
          }
        }
      }
      Gt(i1, 'ModelBucket', { omit: ['layers'] }), Gt(e1, 'PerModelAttributes'), Gt(t1, 'ModelFeature');
      const hC = new Mi({ visibility: new vt(Q.layout_model.visibility), 'model-id': new Xt(Q.layout_model['model-id']) });
      var dC = { paint: new Mi({ 'model-opacity': new vt(Q.paint_model['model-opacity']), 'model-rotation': new Xt(Q.paint_model['model-rotation']), 'model-scale': new Xt(Q.paint_model['model-scale']), 'model-translation': new Xt(Q.paint_model['model-translation']), 'model-color': new Xt(Q.paint_model['model-color']), 'model-color-mix-intensity': new Xt(Q.paint_model['model-color-mix-intensity']), 'model-type': new vt(Q.paint_model['model-type']), 'model-cast-shadows': new vt(Q.paint_model['model-cast-shadows']), 'model-receive-shadows': new vt(Q.paint_model['model-receive-shadows']), 'model-ambient-occlusion-intensity': new vt(Q.paint_model['model-ambient-occlusion-intensity']), 'model-emissive-strength': new Xt(Q.paint_model['model-emissive-strength']), 'model-roughness': new Xt(Q.paint_model['model-roughness']), 'model-height-based-emissive-strength-multiplier': new Xt(Q.paint_model['model-height-based-emissive-strength-multiplier']), 'model-cutoff-fade-range': new vt(Q.paint_model['model-cutoff-fade-range']) }), layout: hC };
      const rm = new Float32Array(262144),
        As = new Uint8Array(262144);
      function r1(e) {
        let t = 0;
        if (e.meshes) for (const i of e.meshes) t = Math.max(t, i.aabb.max[2]);
        if (e.children) for (const i of e.children) t = Math.max(t, r1(i));
        return t;
      }
      const n1 = ['', 'wall', 'door', 'roof', 'window', 'lamp', 'logo'];
      class o1 {
        constructor(t) {
          (this.node = t),
            (this.evaluatedRMEA = [
              [1, 0, 0, 1],
              [1, 0, 0, 1],
              [1, 0, 0, 1],
              [1, 0, 0, 1],
              [0.4, 1, 0, 1],
              [1, 0, 0, 1],
              [1, 0, 0, 1],
            ]),
            (this.hiddenByReplacement = !1),
            (this.evaluatedScale = [1, 1, 1]),
            (this.evaluatedColor = []),
            (this.emissionHeightBasedParams = []),
            (this.feature = { type: 'Point', id: t.id, geometry: [], properties: { height: r1(t) } });
        }
      }
      class s1 {
        constructor(t, i, r, n) {
          (this.nodes = t), (this.id = i), (this.modelTraits |= 1), (this.uploaded = !1), (this.hasPattern = !1), r && (this.modelTraits |= 4), (this.zoom = -1), (this.terrainExaggeration = 1), (this.projection = { name: 'mercator' }), (this.replacementUpdateTime = 0), (this.elevationReadFromZ = 255), (this.brightness = n), (this.dirty = !0), (this.needsUpload = !1);
        }
        update() {
          console.log('Update 3D model bucket');
        }
        populate() {
          console.log('populate 3D model bucket');
        }
        uploadPending() {
          return !this.uploaded || this.needsUpload;
        }
        upload(t) {
          if (!this.needsUpload) return;
          const i = this.getNodesInfo();
          for (const r of i) {
            const n = r.node;
            this.uploaded ? this.updatePbrBuffer(n) : im(n, t, !0);
          }
          for (const r of i) eh(r.node);
          (this.uploaded = !0), (this.needsUpload = !1);
        }
        updatePbrBuffer(t) {
          let i = !1;
          if (!t.meshes) return i;
          for (const r of t.meshes) r.pbrBuffer && (r.pbrBuffer.updateData(r.featureArray), (i = !0));
          return i;
        }
        needsReEvaluation(t, i, r) {
          const n = t.transform.projectionOptions,
            o = t.style.getBrightness(),
            s = this.brightness !== o;
          return !!(!this.uploaded || this.dirty || n.name !== this.projection.name || $l(r.paint.get('model-color').value, s) || $l(r.paint.get('model-color-mix-intensity').value, s) || $l(r.paint.get('model-roughness').value, s) || $l(r.paint.get('model-emissive-strength').value, s) || $l(r.paint.get('model-height-based-emissive-strength-multiplier').value, s)) && ((this.projection = n), (this.brightness = o), !0);
        }
        evaluateScale(t, i) {
          if (t.transform.zoom === this.zoom) return;
          this.zoom = t.transform.zoom;
          const r = this.getNodesInfo(),
            n = this.id.canonical;
          for (const o of r) {
            const s = o.feature;
            o.evaluatedScale = i.paint.get('model-scale').evaluate(s, {}, n);
          }
        }
        evaluate(t) {
          const i = this.getNodesInfo();
          for (const r of i) {
            if (!r.node.meshes) continue;
            const n = r.feature,
              o = r.node.meshes && r.node.meshes[0].featureData,
              s = r.evaluatedColor[2],
              a = r.evaluatedRMEA[2],
              l = this.id.canonical;
            if (((r.hasTranslucentParts = !1), o)) {
              for (let c = 0; c < n1.length; c++) {
                const u = n1[c];
                u.length && (n.properties.part = u);
                const h = t.paint.get('model-color').evaluate(n, {}, l),
                  d = t.paint.get('model-color-mix-intensity').evaluate(n, {}, l);
                (r.evaluatedColor[c] = [h.r, h.g, h.b, d]), (r.evaluatedRMEA[c][0] = t.paint.get('model-roughness').evaluate(n, {}, l)), (r.evaluatedRMEA[c][2] = t.paint.get('model-emissive-strength').evaluate(n, {}, l)), (r.evaluatedRMEA[c][3] = h.a), (r.emissionHeightBasedParams[c] = t.paint.get('model-height-based-emissive-strength-multiplier').evaluate(n, {}, l)), !r.hasTranslucentParts && h.a < 1 && (r.hasTranslucentParts = !0);
              }
              delete n.properties.part, pC(r, s !== r.evaluatedColor[2] || a !== r.evaluatedRMEA[2]);
            }
            (r.evaluatedScale = t.paint.get('model-scale').evaluate(n, {}, l)), this.updatePbrBuffer(r.node) || (this.needsUpload = !0);
          }
          this.dirty = !1;
        }
        elevationUpdate(t, i, r, n) {
          const o = t.findDEMTileFor(r);
          if (o && (o.tileID.canonical !== this.terrainTile || i !== this.terrainExaggeration)) {
            if (o.dem && o.tileID.overscaledZ !== this.elevationReadFromZ) {
              this.elevationReadFromZ = o.tileID.overscaledZ;
              const s = Ma.create(t, r, o);
              if (!s) return;
              4 & this.modelTraits && this.updateDEM(t, s, r, n);
              for (const a of this.getNodesInfo()) {
                const l = a.node;
                if (!l.footprint || !l.footprint.vertices || !l.footprint.vertices.length) continue;
                const c = l.footprint.vertices;
                let u = s.getElevationAt(c[0].x, c[0].y, !0, !0);
                for (let h = 1; h < c.length; h++) u = Math.min(u, s.getElevationAt(c[h].x, c[h].y, !0, !0));
                l.elevation = u;
              }
            }
            (this.terrainTile = o.tileID.canonical), (this.terrainExaggeration = i);
          }
        }
        updateDEM(t, i, r, n) {
          let o = i._dem._modifiedForSources[n];
          if ((o === void 0 && ((i._dem._modifiedForSources[n] = []), (o = i._dem._modifiedForSources[n])), o.includes(r.canonical))) return;
          const s = i._dem.dim;
          o.push(r.canonical);
          let a = !1;
          for (const l of this.getNodesInfo()) {
            const c = l.node;
            if (!c.footprint || !c.footprint.grid) continue;
            const u = c.footprint.grid,
              h = i.tileCoordToPixel(u.min.x, u.min.y),
              d = i.tileCoordToPixel(u.max.x, u.max.y),
              f = Math.min(Math.min(s - d.y, h.x), Math.min(h.y, s - d.x));
            if (f < 0) continue;
            const p = Bt(f, 2, 5);
            let _ = Math.max(0, h.x - p),
              g = Math.max(0, h.y - p),
              y = Math.min(d.x + p, s - 1),
              v = Math.min(d.y + p, s - 1);
            for (let E = g; E <= v; ++E) for (let S = _; S <= y; ++S) As[E * s + S] = 255;
            let w = 0,
              T = 0;
            for (let E = 0; E < u.cellsY; ++E)
              for (let S = 0; S < u.cellsX; ++S) {
                if (!u.cells[E * u.cellsX + S]) continue;
                const I = i.tileCoordToPixel(u.min.x + S / u.xScale, u.min.y + E / u.yScale),
                  C = i.tileCoordToPixel(u.min.x + (S + 1) / u.xScale, u.min.y + (E + 1) / u.yScale);
                for (let z = I.y; z <= Math.min(C.y + 1, s - 1); ++z) for (let k = I.x; k <= Math.min(C.x + 1, s - 1); ++k) As[z * s + k] === 255 && ((As[z * s + k] = 0), (w += i.getElevationAtPixel(k, z)), T++);
              }
            const b = w / T;
            (_ = Math.max(1, h.x - p)), (g = Math.max(1, h.y - p)), (y = Math.min(d.x + p, s - 2)), (v = Math.min(d.y + p, s - 2)), (a = !0);
            for (let E = g; E <= v; ++E) for (let S = _; S <= y; ++S) As[E * s + S] === 0 && (rm[E * s + S] = i._dem.set(S, E, b));
            for (let E = 1; E < p; ++E) {
              (_ = Math.max(1, h.x - E)), (g = Math.max(1, h.y - E)), (y = Math.min(d.x + E, s - 2)), (v = Math.min(d.y + E, s - 2));
              for (let S = g; S <= v; ++S)
                for (let I = _; I <= y; ++I) {
                  const C = S * s + I;
                  if (As[C] === 255) {
                    let z = 0,
                      k = 0,
                      O = -1,
                      V = -1;
                    for (let R = -1; R <= 1; ++R)
                      for (let G = -1; G <= 1; ++G) {
                        const Z = (S + R) * s + I + G;
                        if (As[Z] >= E) continue;
                        const X = rm[Z],
                          j = Math.abs(X);
                        j > k && ((z = X), (k = j), (O = G), (V = R));
                      }
                    if (k > 0.1) {
                      const R = 1 - (E + 0.5 * Math.abs(O * V)) / p;
                      let G = i._dem.get(I, S) + z * R;
                      const Z = i._dem.get(I + O, S + V),
                        X = i._dem.get(I - O, S - V, !0);
                      (G - Z) * (G - X) > 0 && (G = (Z + X) / 2), (rm[C] = i._dem.set(I, S, G)), (As[C] = E);
                    }
                  }
                }
            }
          }
          a && ((i._demTile.needsDEMTextureUpload = !0), (i._dem._timestamp = oe.now()));
        }
        getNodesInfo() {
          if (!this.nodesInfo) {
            this.nodesInfo = [];
            for (const t of this.nodes) this.nodesInfo.push(new o1(t));
            this.freeNodes();
          }
          return this.nodesInfo;
        }
        freeNodes() {
          if (this.nodes) {
            for (const t of this.nodes) ih(t);
            this.nodes.splice(0, this.nodes.length);
          }
        }
        destroy() {
          this.freeNodes();
          const t = this.getNodesInfo();
          for (const i of t) eh(i.node), ih(i.node);
        }
        isEmpty() {
          return !this.nodes.length;
        }
        updateReplacement(t, i) {
          if (i.updateTime === this.replacementUpdateTime) return;
          this.replacementUpdateTime = i.updateTime;
          const r = i.getReplacementRegionsForTile(t.toUnwrapped()),
            n = this.getNodesInfo();
          for (let o = 0; o < this.nodesInfo.length; o++) {
            const s = n[o].node;
            n[o].hiddenByReplacement = !!s.footprint && !r.find((a) => a.footprint === s.footprint);
          }
        }
        getHeightAtTileCoord(t, i) {
          const r = this.getNodesInfo(),
            n = [];
          for (let o = 0; o < this.nodesInfo.length; o++) {
            const s = r[o],
              a = s.node.meshes[0];
            if (t < a.aabb.min[0] || i < a.aabb.min[1] || t > a.aabb.max[0] || i > a.aabb.max[1]) continue;
            const l = (((t - a.aabb.min[0]) / (a.aabb.max[0] - a.aabb.min[0])) * Ss) | 0,
              c = Math.min(63, (((i - a.aabb.min[1]) / (a.aabb.max[1] - a.aabb.min[1])) * Ss) | 0) * Ss + Math.min(63, l);
            if (!(a.heightmap[c] < 0 && s.node.footprint)) return s.hiddenByReplacement ? void 0 : { height: a.heightmap[c], maxHeight: s.feature.properties.height, hidden: !1, verticalScale: s.evaluatedScale[2] };
            if ((s.node.footprint.grid.query(new H(t, i), new H(t, i), n), n.length > 0)) return { height: void 0, maxHeight: s.feature.properties.height, hidden: s.hiddenByReplacement, verticalScale: s.evaluatedScale[2] };
          }
        }
      }
      function $l(e, t) {
        return !e.isLightConstant && t;
      }
      function fC(e, t, i, r, n, o, s, a) {
        let l = ((61440 & t) | ((61440 & t) >> 4)) >> 8,
          c = ((3840 & t) | ((3840 & t) >> 4)) >> 4,
          u = (240 & t) | ((240 & t) >> 4);
        i[3] > 0 && ((l = ee(l, 255 * i[0], i[3])), (c = ee(c, 255 * i[1], i[3])), (u = ee(u, 255 * i[2], i[3])));
        const h = (l << 8) | c,
          d = (u << 8) | Math.floor(255 * r[3]),
          f =
            ((function (E) {
              const S = Bt(E, 0, 2);
              return Math.min(Math.round(0.5 * S * 255), 255);
            })(r[2]) <<
              8) |
            ((15 * r[0]) << 4) |
            (15 * r[1]),
          p = Bt(n[0], 0, 1),
          _ = Bt(n[1], 0, 1),
          g = Bt(n[2], 0, 1),
          y = Bt(n[3], 0, 1);
        let v, w, T, b;
        if (p !== _ && s !== o && _ !== p) {
          const E = s - o;
          (w = 1 / (E * (_ - p))), (T = -(o + E * p) / (E * (_ - p)));
          const S = Bt(n[4], -1, 1);
          (b = Math.pow(10, S)), (v = ((255 * g) << 8) | (255 * y));
        } else (v = 65535), (w = 0), (T = 1), (b = 1);
        if ((e.emplaceBack(h, d, f, v, w, T, b), a)) {
          const E = a.length;
          a.clear();
          for (let S = 0; S < E; S++) a.emplaceBack(h, d, f, v, w, T, b);
        }
      }
      function pC(e, t) {
        const i = e.node;
        let r = 0;
        for (const n of i.meshes) {
          if ((i.lights && i.lightMeshIndex === r) || !n.featureData) continue;
          (n.featureArray = new iu()), n.featureArray.reserve(n.featureData.length);
          let o = t;
          for (const s of n.featureData) {
            let a;
            const l = 65535 & s,
              c = (15 & l) < 8 ? 15 & l : 0,
              u = (s >> 16) & 65535,
              h = e.evaluatedRMEA[c],
              d = e.evaluatedColor[c],
              f = e.emissionHeightBasedParams[c];
            if ((o && c === 2 && i.lights && ((a = new iu()), a.resize(10 * i.lights.length)), fC(n.featureArray, u, d, h, f, n.aabb.min[2], n.aabb.max[2], a), a && o)) {
              o = !1;
              const p = i.meshes[i.lightMeshIndex];
              (p.featureArray = a), p.featureArray._trim();
            }
          }
          n.featureArray._trim(), r++;
        }
      }
      Gt(s1, 'Tiled3dModelBucket', { omit: ['layers'] }), Gt(o1, 'Tiled3dModelFeature');
      class mC {
        constructor() {
          (this._updateTime = 0), (this._sourceIds = []), (this._activeRegions = []), (this._prevRegions = []);
        }
        clear() {
          this._activeRegions.length > 0 && ++this._updateTime, (this._activeRegions = []), (this._prevRegions = []);
        }
        get updateTime() {
          return this._updateTime;
        }
        getReplacementRegionsForTile(t) {
          const i = c1(new H(0, 0), new H(lt, lt), t),
            r = [];
          for (const n of this._activeRegions) {
            if (n.hiddenByOverlap || !l1(i, n)) continue;
            const o = _C(n.min, n.max, t);
            r.push({ min: o.min, max: o.max, sourceId: this._sourceIds[n.priority], footprint: n.footprint, footprintTileId: n.tileId });
          }
          return r;
        }
        setSources(t) {
          this._setSources(
            t.map((i) => ({
              getSourceId: () => i.cache.id,
              getFootprints: () => {
                const r = [];
                for (const n of i.cache.getVisibleCoordinates()) {
                  const o = i.cache.getTile(n).buckets[i.layer];
                  if (o)
                    for (const s of o.getNodesInfo()) {
                      const a = s.node;
                      a.footprint && r.push({ footprint: a.footprint, id: n.toUnwrapped() });
                    }
                }
                return r;
              },
            }))
          );
        }
        _addSource(t) {
          const i = t.getFootprints();
          if (i.length !== 0) {
            for (const r of i) {
              if (!r.footprint) continue;
              const n = c1(r.footprint.min, r.footprint.max, r.id);
              this._activeRegions.push({ min: n.min, max: n.max, hiddenByOverlap: !1, priority: this._sourceIds.length, tileId: r.id, footprint: r.footprint });
            }
            this._sourceIds.push(t.getSourceId());
          }
        }
        _computeReplacement() {
          this._activeRegions.sort((i, r) => i.priority - r.priority || rh(i.min, r.min) || rh(i.max, r.max));
          let t = this._activeRegions.length !== this._prevRegions.length;
          if (!t) {
            let i = 0,
              r = 0;
            for (; !t && i !== this._activeRegions.length; ) {
              const n = this._activeRegions[i],
                o = this._prevRegions[r];
              (t = n.priority !== o.priority || !a1(n, o)), ++i, ++r;
            }
          }
          if (t) {
            ++this._updateTime;
            const i = (r) => {
              const n = this._activeRegions;
              if (r >= n.length) return r;
              const o = n[r].priority;
              for (; r < n.length && n[r].priority === o; ) ++r;
              return r;
            };
            if (this._sourceIds.length > 1) {
              let r = 0,
                n = i(r);
              for (; r !== n; ) {
                let o = r;
                const s = r;
                for (; o !== n; ) {
                  const a = this._activeRegions[o];
                  a.hiddenByOverlap = !1;
                  for (let l = 0; l < s; l++) {
                    const c = this._activeRegions[l];
                    if (!c.hiddenByOverlap && l1(a, c) && ((a.hiddenByOverlap = h1(a.footprint, a.tileId, c.footprint, c.tileId)), a.hiddenByOverlap)) break;
                  }
                  ++o;
                }
                (r = n), (n = i(r));
              }
            }
          }
        }
        _setSources(t) {
          ([this._prevRegions, this._activeRegions] = [this._activeRegions, []]), (this._sourceIds = []);
          for (let i = t.length - 1; i >= 0; i--) this._addSource(t[i]);
          this._computeReplacement();
        }
      }
      function rh(e, t) {
        return e.x - t.x || e.y - t.y;
      }
      function a1(e, t) {
        return rh(e.min, t.min) === 0 && rh(e.max, t.max) === 0;
      }
      function l1(e, t) {
        return !(e.min.x > t.max.x || e.max.x < t.min.x || e.min.y > t.max.y || e.max.y < t.min.y);
      }
      function c1(e, t, i) {
        const r = 1 / lt,
          n = 1 / (1 << i.canonical.z),
          o = (t.x * r + i.canonical.x) * n + i.wrap,
          s = (t.y * r + i.canonical.y) * n;
        return { min: new H((e.x * r + i.canonical.x) * n + i.wrap, (e.y * r + i.canonical.y) * n), max: new H(o, s) };
      }
      function _C(e, t, i) {
        const r = 1 << i.canonical.z,
          n = ((t.x - i.wrap) * r - i.canonical.x) * lt,
          o = (t.y * r - i.canonical.y) * lt;
        return { min: new H(((e.x - i.wrap) * r - i.canonical.x) * lt, (e.y * r - i.canonical.y) * lt), max: new H(n, o) };
      }
      function u1(e, t, i, r, n, o, s) {
        const a = e.indices,
          l = e.vertices,
          c = [];
        for (let u = r; u < r + n; u += 3) {
          const h = t[i[u + 0] + o],
            d = t[i[u + 1] + o],
            f = t[i[u + 2] + o],
            p = Math.min(h.x, d.x, f.x),
            _ = Math.max(h.x, d.x, f.x),
            g = Math.min(h.y, d.y, f.y),
            y = Math.max(h.y, d.y, f.y);
          (c.length = 0), e.grid.query(new H(p, g), new H(_, y), c);
          for (let v = 0; v < c.length; v++) {
            const w = c[v];
            if (Tp(l[a[3 * w + 0]], l[a[3 * w + 1]], l[a[3 * w + 2]], h, d, f, s)) return !0;
          }
        }
        return !1;
      }
      function h1(e, t, i, r) {
        if (!e || !i) return !1;
        let n = e.vertices;
        if (!t.canonical.equals(r.canonical) || t.wrap !== r.wrap) {
          if (i.vertices.length < e.vertices.length) return h1(i, r, e, t);
          const o = t.canonical,
            s = r.canonical,
            a = Math.pow(2, s.z - o.z);
          n = e.vertices.map((l) => new H(l.x * o.x * lt * a - s.x * lt, l.y * o.y * lt * a - s.y * lt));
        }
        return u1(i, n, e.indices, 0, e.indices.length, 0, 0);
      }
      const gC = Su.types,
        yC = ['fill-extrusion-base', 'fill-extrusion-height', 'fill-extrusion-color', 'fill-extrusion-pattern', 'fill-extrusion-flood-light-wall-radius'],
        xC = ['fill-extrusion-flood-light-ground-radius'],
        vC = Math.pow(2, 13),
        bC = Math.pow(2, 15) - 1,
        d1 = new H(0, 1),
        Un = 2147483648;
      function Hl(e, t, i, r, n, o, s, a) {
        e.emplaceBack((t << 1) + s, (i << 1) + o, (Math.floor(r * vC) << 1) + n, Math.round(a));
      }
      function nh(e, t, i, r, n, o) {
        e.emplaceBack(t.x, t.y, (i.x << 1) + r, (i.y << 1) + n, o);
      }
      function Wl(e, t, i) {
        e.emplaceBack(t.x, t.y, t.z, i[0] * 16384, i[1] * 16384, i[2] * 16384);
      }
      class f1 {
        constructor() {
          (this.vertexOffset = 0), (this.vertexCount = 0), (this.indexOffset = 0), (this.indexCount = 0);
        }
      }
      class p1 {
        constructor() {
          (this.centroidXY = new H(0, 0)), (this.vertexArrayOffset = 0), (this.vertexCount = 0), (this.groundVertexArrayOffset = 0), (this.groundVertexCount = 0), (this.flags = 0), (this.footprintSegIdx = -1), (this.footprintSegLen = 0), (this.polygonSegIdx = -1), (this.polygonSegLen = 0), (this.min = new H(Number.MAX_VALUE, Number.MAX_VALUE)), (this.max = new H(-Number.MAX_VALUE, -Number.MAX_VALUE)), (this.height = 0);
        }
        span() {
          return new H(this.max.x - this.min.x, this.max.y - this.min.y);
        }
      }
      class m1 {
        constructor() {
          (this.acc = new H(0, 0)), (this.accCount = 0), (this.centroidDataIndex = 0);
        }
        startRing(t, i) {
          t.min.x === Number.MAX_VALUE && ((t.min.x = t.max.x = i.x), (t.min.y = t.max.y = i.y));
        }
        appendEdge(t, i, r) {
          this.accCount++, this.acc._add(i);
          let n = !!this.borders;
          i.x < t.min.x ? ((t.min.x = i.x), (n = !0)) : i.x > t.max.x && ((t.max.x = i.x), (n = !0)), i.y < t.min.y ? ((t.min.y = i.y), (n = !0)) : i.y > t.max.y && ((t.max.y = i.y), (n = !0)), ((i.x === 0 || i.x === lt) && i.x === r.x) != ((i.y === 0 || i.y === lt) && i.y === r.y) && this.processBorderOverlap(i, r), n && this.checkBorderIntersection(i, r);
        }
        checkBorderIntersection(t, i) {
          i.x < 0 != t.x < 0 && this.addBorderIntersection(0, ee(i.y, t.y, (0 - i.x) / (t.x - i.x))), i.x > lt != t.x > lt && this.addBorderIntersection(1, ee(i.y, t.y, (lt - i.x) / (t.x - i.x))), i.y < 0 != t.y < 0 && this.addBorderIntersection(2, ee(i.x, t.x, (0 - i.y) / (t.y - i.y))), i.y > lt != t.y > lt && this.addBorderIntersection(3, ee(i.x, t.x, (lt - i.y) / (t.y - i.y)));
        }
        addBorderIntersection(t, i) {
          this.borders ||
            (this.borders = [
              [Number.MAX_VALUE, -Number.MAX_VALUE],
              [Number.MAX_VALUE, -Number.MAX_VALUE],
              [Number.MAX_VALUE, -Number.MAX_VALUE],
              [Number.MAX_VALUE, -Number.MAX_VALUE],
            ]);
          const r = this.borders[t];
          i < r[0] && (r[0] = i), i > r[1] && (r[1] = i);
        }
        processBorderOverlap(t, i) {
          if (t.x === i.x) {
            if (t.y === i.y) return;
            const r = t.x === 0 ? 0 : 1;
            this.addBorderIntersection(r, i.y), this.addBorderIntersection(r, t.y);
          } else {
            const r = t.y === 0 ? 2 : 3;
            this.addBorderIntersection(r, i.x), this.addBorderIntersection(r, t.x);
          }
        }
        centroid() {
          return this.accCount === 0 ? new H(0, 0) : new H(Math.floor(Math.max(0, this.acc.x) / this.accCount), Math.floor(Math.max(0, this.acc.y) / this.accCount));
        }
        intersectsCount() {
          return this.borders ? this.borders.reduce((t, i) => t + +(i[0] !== Number.MAX_VALUE), 0) : 0;
        }
      }
      function _1(e, t) {
        const i = e.add(t)._unit(),
          r = Bt(e.x * i.x + e.y * i.y, -1, 1);
        var n, o, s;
        return (n = Math.acos(r)), (Math.min(4, Math.max(-4, Math.tan(n))) / 4) * bC * ((o = e).x * (s = t).y - o.y * s.x < 0 ? -1 : 1);
      }
      const wC = [(e) => e.x < 0, (e) => e.x > lt, (e) => e.y < 0, (e) => e.y > lt];
      function TC(e, t, i, r) {
        const n = [4];
        if (r === 0) return n;
        i._mult(r);
        const o = e.sub(i),
          s = t.sub(i),
          a = [e, t, o, s];
        for (let l = 0; l < 4; l++)
          for (const c of a)
            if (wC[l](c)) {
              n.push(l);
              break;
            }
        return n;
      }
      class g1 {
        constructor(t) {
          (this.vertexArray = new Sf()), (this.indexArray = new Fi()), (this.programConfigurations = new Ro(t.layers, t.zoom, (i) => xC.includes(i))), (this._segments = new He()), (this.hiddenByLandmarkVertexArray = new Nf()), (this._segmentToGroundQuads = {}), (this._segmentToGroundQuads[0] = []), (this._segmentToRegionTriCounts = {}), (this._segmentToRegionTriCounts[0] = [0, 0, 0, 0, 0]), (this.regionSegments = {}), (this.regionSegments[4] = new He());
        }
        getDefaultSegment() {
          return this.regionSegments[4];
        }
        hasData() {
          return this.vertexArray.length !== 0;
        }
        addData(t, i, r, n = !1) {
          const o = t.length;
          if (o > 2) {
            let s = Math.max(0, this._segments.get().length - 1);
            const a = this._segments._prepareSegment(4 * o, this.vertexArray.length, 2 * this._segmentToGroundQuads[s].length);
            let l;
            s !== this._segments.get().length - 1 && (s++, (this._segmentToGroundQuads[s] = []), (this._segmentToRegionTriCounts[s] = [0, 0, 0, 0, 0]));
            {
              const c = t[0],
                u = t[1];
              l = _1(
                c
                  .sub(t[o - 1])
                  ._perp()
                  ._unit(),
                u.sub(c)._perp()._unit()
              );
            }
            for (let c = 0; c < o; c++) {
              const u = c === o - 1 ? 0 : c + 1,
                h = t[c],
                d = t[u],
                f = t[u === o - 1 ? 0 : u + 1],
                p = d.sub(h)._perp()._unit(),
                _ = _1(p, f.sub(d)._perp()._unit()),
                g = l,
                y = _;
              if (nm(h, d, i) || (n && v1(h, i) && v1(d, i))) {
                l = _;
                continue;
              }
              const v = a.vertexLength;
              nh(this.vertexArray, h, d, 1, 1, g), nh(this.vertexArray, h, d, 1, 0, g), nh(this.vertexArray, h, d, 0, 1, y), nh(this.vertexArray, h, d, 0, 0, y), (a.vertexLength += 4);
              const w = TC(h, d, p, r);
              for (const T of w) this._segmentToGroundQuads[s].push({ id: v, region: T }), (this._segmentToRegionTriCounts[s][T] += 2), (a.primitiveLength += 2);
              l = _;
            }
          }
        }
        prepareBorderSegments() {
          if (!this.hasData()) return;
          const t = this._segments.get(),
            i = t.length;
          for (let r = 0; r < i; r++) this._segmentToGroundQuads[r].sort((n, o) => n.region - o.region);
          for (let r = 0; r < i; r++) {
            const n = this._segmentToGroundQuads[r],
              o = t[r],
              s = this._segmentToRegionTriCounts[r];
            s.reduce((l, c) => l + c, 0);
            let a = 0;
            for (let l = 0; l <= 4; l++) {
              const c = s[l];
              if (c !== 0) {
                let u = this.regionSegments[l];
                u || (u = this.regionSegments[l] = new He());
                const h = { vertexOffset: o.vertexOffset, primitiveOffset: o.primitiveOffset + a, vertexLength: o.vertexLength, primitiveLength: c };
                u.get().push(h);
              }
              a += c;
            }
            for (let l = 0; l < n.length; l++) {
              const c = n[l].id;
              this.indexArray.emplaceBack(c, c + 1, c + 3), this.indexArray.emplaceBack(c, c + 3, c + 2);
            }
          }
          (this._segmentToGroundQuads = null), (this._segmentToRegionTriCounts = null), this._segments.destroy(), (this._segments = null);
        }
        addPaintPropertiesData(t, i, r, n, o, s) {
          this.hasData() && this.programConfigurations.populatePaintArrays(this.vertexArray.length, t, i, r, n, o, s);
        }
        upload(t) {
          this.hasData() && ((this.vertexBuffer = t.createVertexBuffer(this.vertexArray, WS.members)), (this.indexBuffer = t.createIndexBuffer(this.indexArray)));
        }
        uploadPaintProperties(t) {
          this.hasData() && this.programConfigurations.upload(t);
        }
        update(t, i, r, n, o, s) {
          this.hasData() && this.programConfigurations.updatePaintArrays(t, i, r, n, o, s);
        }
        updateHiddenByLandmark(t) {
          if (!this.hasData()) return;
          const i = t.groundVertexCount + t.groundVertexArrayOffset;
          if (t.groundVertexCount === 0) return;
          const r = t.flags & Un ? 1 : 0;
          for (let n = t.groundVertexArrayOffset; n < i; ++n) this.hiddenByLandmarkVertexArray.emplace(n, r);
          this._needsHiddenByLandmarkUpdate = !0;
        }
        uploadHiddenByLandmark(t) {
          this.hasData() && this._needsHiddenByLandmarkUpdate && (!this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexArray.length > 0 ? (this.hiddenByLandmarkVertexBuffer = t.createVertexBuffer(this.hiddenByLandmarkVertexArray, YS.members, !0)) : this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.updateData(this.hiddenByLandmarkVertexArray), (this._needsHiddenByLandmarkUpdate = !1));
        }
        destroy() {
          if (this.vertexBuffer) {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.destroy(), this._segments && this._segments.destroy(), this.programConfigurations.destroy();
            for (let t = 0; t <= 4; t++) {
              const i = this.regionSegments[t];
              i && i.destroy();
            }
          }
        }
      }
      class Xl {
        constructor(t) {
          (this.zoom = t.zoom), (this.canonical = t.canonical), (this.overscaling = t.overscaling), (this.layers = t.layers), (this.layerIds = this.layers.map((i) => i.fqid)), (this.index = t.index), (this.hasPattern = !1), (this.edgeRadius = 0), (this.projection = t.projection), (this.activeReplacements = []), (this.replacementUpdateTime = 0), (this.centroidData = []), (this.footprintIndices = new Fi()), (this.footprintVertices = new Rr()), (this.footprintSegments = []), (this.layoutVertexArray = new gs()), (this.centroidVertexArray = new Ay()), (this.indexArray = new Fi()), (this.programConfigurations = new Ro(t.layers, t.zoom, (i) => yC.includes(i))), (this.segments = new He()), (this.stateDependentLayerIds = this.layers.filter((i) => i.isStateDependent()).map((i) => i.id)), (this.groundEffect = new g1(t)), (this.maxHeight = 0), (this.partLookup = {}), (this.triangleSubSegments = []), (this.polygonSegments = []);
        }
        populate(t, i, r, n) {
          (this.features = []), (this.hasPattern = Pp('fill-extrusion', this.layers, i)), (this.featuresOnBorder = []), (this.borderFeatureIndices = [[], [], [], []]), (this.borderDoneWithNeighborZ = [-1, -1, -1, -1]), (this.tileToMeter = Il(r)), (this.edgeRadius = this.layers[0].layout.get('fill-extrusion-edge-radius') / this.tileToMeter);
          for (const { feature: o, id: s, index: a, sourceLayerIndex: l } of t) {
            const c = this.layers[0]._featureFilter.needGeometry,
              u = Uo(o, c);
            if (!this.layers[0]._featureFilter.filter(new gi(this.zoom), u, r)) continue;
            const h = { id: s, sourceLayerIndex: l, index: a, geometry: c ? u.geometry : On(o, r, n), properties: o.properties, type: o.type, patterns: {} },
              d = this.layoutVertexArray.length;
            this.hasPattern ? this.features.push(zp('fill-extrusion', this.layers, h, this.zoom, i)) : this.addFeature(h, h.geometry, a, r, {}, i.availableImages, n, i.brightness), i.featureIndex.insert(o, h.geometry, a, l, this.index, d);
          }
          this.sortBorders(), this.projection.name === 'mercator' && this.splitToSubtiles(), this.groundEffect.prepareBorderSegments(), (this.polygonSegments.length = 0);
        }
        addFeatures(t, i, r, n, o, s) {
          for (const a of this.features) {
            const { geometry: l } = a;
            this.addFeature(a, l, a.index, i, r, n, o, s);
          }
          this.sortBorders(), this.projection.name === 'mercator' && this.splitToSubtiles();
        }
        update(t, i, r, n, o) {
          const s = Object.keys(t).length !== 0;
          if (s && !this.stateDependentLayers.length) return;
          const a = s ? this.stateDependentLayers : this.layers;
          this.programConfigurations.updatePaintArrays(t, i, a, r, n, o), this.groundEffect.update(t, i, a, r, n, o);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload || this.groundEffect.programConfigurations.needsUpload;
        }
        upload(t) {
          this.uploaded || ((this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, JS)), (this.indexBuffer = t.createIndexBuffer(this.indexArray)), this.layoutVertexExtArray && (this.layoutVertexExtBuffer = t.createVertexBuffer(this.layoutVertexExtArray, KS.members, !0)), this.groundEffect.upload(t)), this.groundEffect.uploadPaintProperties(t), this.programConfigurations.upload(t), (this.uploaded = !0);
        }
        uploadCentroid(t) {
          this.groundEffect.uploadHiddenByLandmark(t), this.needsCentroidUpdate && (!this.centroidVertexBuffer && this.centroidVertexArray.length > 0 ? (this.centroidVertexBuffer = t.createVertexBuffer(this.centroidVertexArray, XS.members, !0)) : this.centroidVertexBuffer && this.centroidVertexBuffer.updateData(this.centroidVertexArray), (this.needsCentroidUpdate = !1));
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(), this.groundEffect.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        addFeature(t, i, r, n, o, s, a, l) {
          const c = this.layers[0].paint.get('fill-extrusion-flood-light-ground-radius').evaluate(t, {}) / this.tileToMeter,
            u = [new H(0, 0), new H(lt, lt)],
            h = a.projection,
            d = h.name === 'globe',
            f = gC[t.type] === 'Polygon',
            p = new m1();
          p.centroidDataIndex = this.centroidData.length;
          const _ = new p1(),
            g = this.layers[0].paint.get('fill-extrusion-base').evaluate(t, {}, n) <= 0,
            y = this.layers[0].paint.get('fill-extrusion-height').evaluate(t, {}, n);
          (_.height = y), (_.vertexArrayOffset = this.layoutVertexArray.length), (_.groundVertexArrayOffset = this.groundEffect.vertexArray.length), d && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new tu());
          const v = Cp(i, 500);
          for (let I = v.length - 1; I >= 0; I--) {
            const C = v[I];
            (C.length === 0 || (w = C[0]).every((z) => z.x <= 0) || w.every((z) => z.x >= lt) || w.every((z) => z.y <= 0) || w.every((z) => z.y >= lt)) && v.splice(I, 1);
          }
          var w;
          let T;
          if (d) T = E1(v, u, n);
          else {
            T = [];
            for (const I of v) T.push({ polygon: I, bounds: u });
          }
          const b = f ? this.edgeRadius : 0,
            E = b > 0 && this.zoom < 17,
            S = (I, C) => {
              if (I.length === 0) return !1;
              const z = I[I.length - 1];
              return C.x === z.x && C.y === z.y;
            };
          for (const { polygon: I, bounds: C } of T) {
            let z = 0,
              k = 0;
            for (const G of I) f && !G[0].equals(G[G.length - 1]) && G.push(G[0]), (k += f ? G.length - 1 : G.length);
            const O = this.segments.prepareSegment((f ? 5 : 4) * k, this.layoutVertexArray, this.indexArray);
            _.footprintSegIdx < 0 && (_.footprintSegIdx = this.footprintSegments.length), _.polygonSegIdx < 0 && (_.polygonSegIdx = this.polygonSegments.length);
            const V = { triangleArrayOffset: this.indexArray.length, triangleCount: 0, triangleSegIdx: this.segments.segments.length - 1 },
              R = new f1();
            if (((R.vertexOffset = this.footprintVertices.length), (R.indexOffset = 3 * this.footprintIndices.length), (R.ringIndices = []), f)) {
              const G = [],
                Z = [];
              z = O.vertexLength;
              for (let j = 0; j < I.length; j++) {
                const q = I[j];
                q.length && j !== 0 && Z.push(G.length / 2);
                const it = [];
                let st, nt;
                (st = q[1].sub(q[0])._perp()._unit()), R.ringIndices.push(q.length - 1);
                for (let ut = 1; ut < q.length; ut++) {
                  const ht = q[ut],
                    pt = q[ut === q.length - 1 ? 1 : ut + 1],
                    at = ht.clone();
                  if (b) {
                    nt = pt.sub(ht)._perp()._unit();
                    const _t = st.add(nt)._unit(),
                      Ct = b * Math.min(4, 1 / (st.x * _t.x + st.y * _t.y));
                    (at.x += Ct * _t.x), (at.y += Ct * _t.y), (at.x = Math.round(at.x)), (at.y = Math.round(at.y)), (st = nt);
                  }
                  !g || (b !== 0 && !E) || S(it, at) || it.push(at), Hl(this.layoutVertexArray, at.x, at.y, 0, 0, 1, 1, 0), O.vertexLength++, this.footprintVertices.emplaceBack(ht.x, ht.y), G.push(ht.x, ht.y), d && Wl(this.layoutVertexExtArray, h.projectTilePoint(at.x, at.y, n), h.upVector(n, at.x, at.y));
                }
                g && (b === 0 || E) && (it.length !== 0 && S(it, it[0]) && it.pop(), this.groundEffect.addData(it, C, c));
              }
              const X = Tu(G, Z);
              for (let j = 0; j < X.length; j += 3) this.footprintIndices.emplaceBack(R.vertexOffset + X[j + 0], R.vertexOffset + X[j + 1], R.vertexOffset + X[j + 2]), this.indexArray.emplaceBack(z + X[j], z + X[j + 2], z + X[j + 1]), O.primitiveLength++;
              (R.indexCount += X.length), (R.vertexCount += this.footprintVertices.length - R.vertexOffset);
            }
            for (let G = 0; G < I.length; G++) {
              const Z = I[G];
              p.startRing(_, Z[0]);
              let X = Z.length > 4 && b1(Z[Z.length - 2], Z[0], Z[1]),
                j = b ? EC(Z[Z.length - 2], Z[0], Z[1], b) : 0;
              const q = [];
              let it, st, nt;
              st = Z[1].sub(Z[0])._perp()._unit();
              let ut = !0;
              for (let ht = 1, pt = 0; ht < Z.length; ht++) {
                let at = Z[ht - 1],
                  _t = Z[ht];
                const Ct = Z[ht === Z.length - 1 ? 1 : ht + 1];
                if ((p.appendEdge(_, _t, at), nm(_t, at, C))) {
                  b && ((st = Ct.sub(_t)._perp()._unit()), (ut = !ut));
                  continue;
                }
                const Pt = _t.sub(at)._perp(),
                  Ot = Pt.x / (Math.abs(Pt.x) + Math.abs(Pt.y)),
                  Ut = Pt.y > 0 ? 1 : 0,
                  Qt = at.dist(_t);
                if ((pt + Qt > 32768 && (pt = 0), b)) {
                  nt = Ct.sub(_t)._perp()._unit();
                  let te = x1(at, _t, Ct, y1(st, nt), b);
                  isNaN(te) && (te = 0);
                  const Kt = _t.sub(at)._unit();
                  (at = at.add(Kt.mult(j))._round()), (_t = _t.add(Kt.mult(-te))._round()), (j = te), (st = nt), g && this.zoom >= 17 && (S(q, at) || q.push(at), S(q, _t) || q.push(_t));
                }
                const Ht = O.vertexLength,
                  Ce = Z.length > 4 && b1(at, _t, Ct);
                let be = w1(pt, X, ut);
                if ((Hl(this.layoutVertexArray, at.x, at.y, Ot, Ut, 0, 0, be), Hl(this.layoutVertexArray, at.x, at.y, Ot, Ut, 0, 1, be), (pt += Qt), (be = w1(pt, Ce, !ut)), (X = Ce), Hl(this.layoutVertexArray, _t.x, _t.y, Ot, Ut, 0, 0, be), Hl(this.layoutVertexArray, _t.x, _t.y, Ot, Ut, 0, 1, be), (O.vertexLength += 4), this.indexArray.emplaceBack(Ht + 0, Ht + 1, Ht + 2), this.indexArray.emplaceBack(Ht + 1, Ht + 3, Ht + 2), (O.primitiveLength += 2), b)) {
                  const te = z + (ht === 1 ? Z.length - 2 : ht - 2),
                    Kt = ht === 1 ? z : te + 1;
                  if ((this.indexArray.emplaceBack(Ht + 1, te, Ht + 3), this.indexArray.emplaceBack(te, Kt, Ht + 3), (O.primitiveLength += 2), it === void 0 && (it = Ht), !nm(Ct, Z[ht], C))) {
                    const Wt = ht === Z.length - 1 ? it : O.vertexLength;
                    this.indexArray.emplaceBack(Ht + 2, Ht + 3, Wt), this.indexArray.emplaceBack(Ht + 3, Wt + 1, Wt), this.indexArray.emplaceBack(Ht + 3, Kt, Wt + 1), (O.primitiveLength += 3);
                  }
                  ut = !ut;
                }
                if (d) {
                  const te = this.layoutVertexExtArray,
                    Kt = h.projectTilePoint(at.x, at.y, n),
                    Wt = h.projectTilePoint(_t.x, _t.y, n),
                    Ee = h.upVector(n, at.x, at.y),
                    Ae = h.upVector(n, _t.x, _t.y);
                  Wl(te, Kt, Ee), Wl(te, Kt, Ee), Wl(te, Wt, Ae), Wl(te, Wt, Ae);
                }
              }
              f && (z += Z.length - 1), g && b && this.zoom >= 17 && (q.length !== 0 && S(q, q[0]) && q.pop(), this.groundEffect.addData(q, C, c, b > 0));
            }
            this.footprintSegments.push(R), (V.triangleCount = this.indexArray.length - V.triangleArrayOffset), this.polygonSegments.push(V), ++_.footprintSegLen, ++_.polygonSegLen;
          }
          if (((_.vertexCount = this.layoutVertexArray.length - _.vertexArrayOffset), (_.groundVertexCount = this.groundEffect.vertexArray.length - _.groundVertexArrayOffset), _.vertexCount !== 0)) {
            if (((_.centroidXY = p.borders ? d1 : this.encodeCentroid(p, _)), this.centroidData.push(_), p.borders)) {
              this.featuresOnBorder.push(p);
              const I = this.featuresOnBorder.length - 1;
              for (let C = 0; C < p.borders.length; C++) p.borders[C][0] !== Number.MAX_VALUE && this.borderFeatureIndices[C].push(I);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, r, o, s, n, l), this.groundEffect.addPaintPropertiesData(t, r, o, s, n, l), (this.maxHeight = Math.max(this.maxHeight, y));
          }
        }
        sortBorders() {
          for (let t = 0; t < this.borderFeatureIndices.length; t++) this.borderFeatureIndices[t].sort((i, r) => this.featuresOnBorder[i].borders[t][0] - this.featuresOnBorder[r].borders[t][0]);
        }
        splitToSubtiles() {
          const t = [];
          for (let a = 0; a < this.centroidData.length; a++) {
            const l = this.centroidData[a],
              c = +(l.min.y + l.max.y > lt),
              u = 2 * c + (+(l.min.x + l.max.x > lt) ^ c);
            for (let h = 0; h < l.polygonSegLen; h++) {
              const d = l.polygonSegIdx + h;
              t.push({ centroidIdx: a, subtile: u, polygonSegmentIdx: d, triangleSegmentIdx: this.polygonSegments[d].triangleSegIdx });
            }
          }
          const i = new Fi();
          t.sort((a, l) => (a.triangleSegmentIdx === l.triangleSegmentIdx ? a.subtile - l.subtile : a.triangleSegmentIdx - l.triangleSegmentIdx));
          let r = 0,
            n = 0,
            o = 0;
          for (const a of t) {
            if (a.triangleSegmentIdx !== r) break;
            o++;
          }
          const s = t.length;
          for (; n !== t.length; ) {
            r = t[n].triangleSegmentIdx;
            let a = 0,
              l = n,
              c = n;
            for (let u = l; u < o && t[u].subtile === a; u++) c++;
            for (; l !== o; ) {
              const u = t[l];
              a = u.subtile;
              const h = this.centroidData[u.centroidIdx].min.clone(),
                d = this.centroidData[u.centroidIdx].max.clone(),
                f = { vertexOffset: this.segments.segments[r].vertexOffset, primitiveOffset: i.length, vertexLength: this.segments.segments[r].vertexLength, primitiveLength: 0, sortKey: void 0, vaos: {} };
              for (let p = l; p < c; p++) {
                const _ = t[p],
                  g = this.polygonSegments[_.polygonSegmentIdx],
                  y = this.centroidData[_.centroidIdx].min,
                  v = this.centroidData[_.centroidIdx].max,
                  w = this.indexArray.uint16;
                for (let T = g.triangleArrayOffset; T < g.triangleArrayOffset + g.triangleCount; T++) i.emplaceBack(w[3 * T], w[3 * T + 1], w[3 * T + 2]);
                (f.primitiveLength += g.triangleCount), (h.x = Math.min(h.x, y.x)), (h.y = Math.min(h.y, y.y)), (d.x = Math.max(d.x, v.x)), (d.y = Math.max(d.y, v.y));
              }
              f.primitiveLength > 0 && this.triangleSubSegments.push({ segment: f, min: h, max: d }), (l = c);
              for (let p = l; p < o && t[p].subtile === t[l].subtile; p++) c++;
            }
            n = o;
            for (let u = n; u < s && t[u].triangleSegmentIdx === t[n].triangleSegmentIdx; u++) o++;
          }
          i._trim(), (this.indexArray = i);
        }
        getVisibleSegments(t, i, r) {
          let n = 0,
            o = 0;
          const s = 1 << t.canonical.z;
          if (i) {
            const _ = i.getMinMaxForTile(t);
            _ && ((n = _.min), (o = _.max));
          }
          o += this.maxHeight;
          const a = t.toUnwrapped();
          let l;
          const c = [a.canonical.x / s + a.wrap, a.canonical.y / s],
            u = [(a.canonical.x + 1) / s + a.wrap, (a.canonical.y + 1) / s],
            h = new He(),
            d = (_, g, y) => [_[0] * (1 - y[0]) + g[0] * y[0], _[1] * (1 - y[1]) + g[1] * y[1]],
            f = [],
            p = [];
          for (const _ of this.triangleSubSegments) {
            (f[0] = _.min.x / lt), (f[1] = _.min.y / lt), (p[0] = _.max.x / lt), (p[1] = _.max.y / lt);
            const g = d(c, u, f),
              y = d(c, u, p);
            if (new ni([g[0], g[1], n], [y[0], y[1], o]).intersectsPrecise(r) === 0) {
              l && (h.segments.push(l), (l = void 0));
              continue;
            }
            const v = _.segment;
            l && l.vertexOffset !== v.vertexOffset && (h.segments.push(l), (l = void 0)), l ? ((l.vertexLength += v.vertexLength), (l.primitiveLength += v.primitiveLength)) : (l = { vertexOffset: v.vertexOffset, primitiveLength: v.primitiveLength, vertexLength: v.vertexLength, primitiveOffset: v.primitiveOffset, sortKey: void 0, vaos: {} });
          }
          return l && h.segments.push(l), h;
        }
        encodeCentroid(t, i) {
          const r = t.centroid(),
            n = i.span(),
            o = Math.min(7, Math.round((n.x * this.tileToMeter) / 10)),
            s = Math.min(7, Math.round((n.y * this.tileToMeter) / 10));
          return new H((Bt(r.x, 1, lt - 1) << 3) | o, (Bt(r.y, 1, lt - 1) << 3) | s);
        }
        showCentroid(t) {
          const i = this.centroidData[t.centroidDataIndex];
          (i.flags &= Un), (i.centroidXY.x = 0), (i.centroidXY.y = 0), this.writeCentroidToBuffer(i);
        }
        writeCentroidToBuffer(t) {
          this.groundEffect.updateHiddenByLandmark(t);
          const i = t.vertexArrayOffset,
            r = t.vertexCount + t.vertexArrayOffset,
            n = t.flags & Un ? d1 : t.centroidXY,
            o = this.centroidVertexArray.geta_centroid_pos0(i);
          if (this.centroidVertexArray.geta_centroid_pos1(i) !== n.y || o !== n.x) {
            for (let s = i; s < r; ++s) this.centroidVertexArray.emplace(s, n.x, n.y);
            this.needsCentroidUpdate = !0;
          }
        }
        createCentroidsBuffer() {
          this.centroidVertexArray.resize(this.layoutVertexArray.length), this.groundEffect.hiddenByLandmarkVertexArray.resize(this.groundEffect.vertexArray.length);
          for (const t of this.centroidData) this.writeCentroidToBuffer(t);
        }
        updateReplacement(t, i) {
          if (i.updateTime === this.replacementUpdateTime) return;
          this.replacementUpdateTime = i.updateTime;
          const r = i.getReplacementRegionsForTile(t.toUnwrapped());
          if (
            (function (o, s) {
              if (o.length !== s.length) return !1;
              for (let a = 0; a < o.length; a++) if (o[a].sourceId !== s[a].sourceId || !a1(o[a], s[a])) return !1;
              return !0;
            })(this.activeReplacements, r)
          )
            return;
          if (((this.activeReplacements = r), this.centroidVertexArray.length === 0)) this.createCentroidsBuffer();
          else for (const o of this.centroidData) o.flags &= 2147483647;
          const n = [];
          for (const o of this.activeReplacements) {
            const s = Math.pow(2, o.footprintTileId.canonical.z - t.canonical.z);
            for (const a of this.centroidData)
              if (!(a.flags & Un || o.min.x > a.max.x || a.min.x > o.max.x || o.min.y > a.max.y || a.min.y > o.max.y))
                for (let l = 0; l < a.footprintSegLen; l++) {
                  const c = this.footprintSegments[a.footprintSegIdx + l];
                  if (((n.length = 0), MC(this.footprintVertices, c.vertexOffset, c.vertexCount, o.footprintTileId.canonical, t.canonical, n), u1(o.footprint, n, this.footprintIndices.uint16, c.indexOffset, c.indexCount, -c.vertexOffset, -s))) {
                    a.flags |= Un;
                    break;
                  }
                }
          }
          for (const o of this.centroidData) this.writeCentroidToBuffer(o);
          this.borderDoneWithNeighborZ = [-1, -1, -1, -1];
        }
        footprintContainsPoint(t, i, r) {
          let n = !1;
          for (let o = 0; o < r.footprintSegLen; o++) {
            const s = this.footprintSegments[r.footprintSegIdx + o];
            let a = 0;
            for (const l of s.ringIndices) {
              for (let c = a, u = l + a - 1; c < l + a; u = c++) {
                const h = this.footprintVertices.int16[2 * (c + s.vertexOffset) + 0],
                  d = this.footprintVertices.int16[2 * (c + s.vertexOffset) + 1],
                  f = this.footprintVertices.int16[2 * (u + s.vertexOffset) + 1];
                d > i != f > i && t < ((this.footprintVertices.int16[2 * (u + s.vertexOffset) + 0] - h) * (i - d)) / (f - d) + h && (n = !n);
              }
              a = l;
            }
          }
          return n;
        }
        getHeightAtTileCoord(t, i) {
          let r = Number.NEGATIVE_INFINITY,
            n = !0;
          const o = 4 * (t + lt) * lt + (i + lt);
          if (this.partLookup.hasOwnProperty(o)) {
            const s = this.partLookup[o];
            return s ? { height: s.height, hidden: !!(s.flags & Un) } : void 0;
          }
          for (const s of this.centroidData) t > s.max.x || s.min.x > t || i > s.max.y || s.min.y > i || (this.footprintContainsPoint(t, i, s) && s && s.height > r && ((r = s.height), (this.partLookup[o] = s), (n = !!(s.flags & Un))));
          if (r !== Number.NEGATIVE_INFINITY) return { height: r, hidden: n };
          this.partLookup[o] = void 0;
        }
      }
      function y1(e, t) {
        const i = e.add(t)._unit();
        return e.x * i.x + e.y * i.y;
      }
      function EC(e, t, i, r) {
        const n = t.sub(e)._perp()._unit(),
          o = i.sub(t)._perp()._unit();
        return x1(e, t, i, y1(n, o), r);
      }
      function x1(e, t, i, r, n) {
        const o = Math.sqrt(1 - r * r);
        return Math.min(e.dist(t) / 3, t.dist(i) / 3, (n * o) / r);
      }
      function nm(e, t, i) {
        return (e.x < i[0].x && t.x < i[0].x) || (e.x > i[1].x && t.x > i[1].x) || (e.y < i[0].y && t.y < i[0].y) || (e.y > i[1].y && t.y > i[1].y);
      }
      function v1(e, t) {
        return e.x < t[0].x || e.x > t[1].x || e.y < t[0].y || e.y > t[1].y;
      }
      function b1(e, t, i) {
        if (e.x < 0 || e.x >= lt || t.x < 0 || t.x >= lt || i.x < 0 || i.x >= lt) return !1;
        const r = i.sub(t),
          n = r.perp(),
          o = e.sub(t);
        return (r.x * o.x + r.y * o.y) / Math.sqrt((r.x * r.x + r.y * r.y) * (o.x * o.x + o.y * o.y)) > -0.866 && n.x * o.x + n.y * o.y < 0;
      }
      function w1(e, t, i) {
        const r = t ? 2 | e : -3 & e;
        return i ? 1 | r : -2 & r;
      }
      function T1() {
        const e = Math.PI / 32,
          t = Math.tan(e),
          i = ya;
        return i * Math.sqrt(1 + 2 * t * t) - i;
      }
      function E1(e, t, i) {
        const r = 1 << i.z,
          n = Or(i.x / r),
          o = Or((i.x + 1) / r),
          s = Ni(i.y / r),
          a = Ni((i.y + 1) / r);
        return (function (l, c, u, h, d = 0, f) {
          const p = [];
          if (!l.length || !u || !h) return p;
          const _ = (E, S) => {
              for (const I of E) p.push({ polygon: I, bounds: S });
            },
            g = Math.ceil(Math.log2(u)),
            y = Math.ceil(Math.log2(h)),
            v = g - y,
            w = [];
          for (let E = 0; E < Math.abs(v); E++) w.push(v > 0 ? 0 : 1);
          for (let E = 0; E < Math.min(g, y); E++) w.push(0), w.push(1);
          let T = l;
          if (((T = Au(T, c[0].y - d, c[1].y + d, 1)), (T = Au(T, c[0].x - d, c[1].x + d, 0)), !T.length)) return p;
          const b = [];
          for (w.length ? b.push({ polygons: T, bounds: c, depth: 0 }) : _(T, c); b.length; ) {
            const E = b.pop(),
              S = E.depth,
              I = w[S],
              C = E.bounds[0],
              z = E.bounds[1],
              k = I === 0 ? C.x : C.y,
              O = I === 0 ? z.x : z.y,
              V = f ? f(I, k, O) : 0.5 * (k + O),
              R = Au(E.polygons, k - d, V + d, I),
              G = Au(E.polygons, V - d, O + d, I);
            if (R.length) {
              const Z = [C, new H(I === 0 ? V : z.x, I === 1 ? V : z.y)];
              w.length > S + 1 ? b.push({ polygons: R, bounds: Z, depth: S + 1 }) : _(R, Z);
            }
            if (G.length) {
              const Z = [new H(I === 0 ? V : C.x, I === 1 ? V : C.y), z];
              w.length > S + 1 ? b.push({ polygons: G, bounds: Z, depth: S + 1 }) : _(G, Z);
            }
          }
          return p;
        })(e, t, Math.ceil((o - n) / 11.25), Math.ceil((s - a) / 11.25), 1, (l, c, u) => {
          if (l === 0) return 0.5 * (c + u);
          {
            const h = Ni((i.y + c / lt) / r);
            return (Hi(0.5 * (Ni((i.y + u / lt) / r) + h)) * r - i.y) * lt;
          }
        });
      }
      function MC(e, t, i, r, n, o) {
        const s = Math.pow(2, r.z - n.z);
        for (let a = 0; a < i; a++) {
          let l = e.int16[2 * (a + t) + 0],
            c = e.int16[2 * (a + t) + 1];
          (l = (l + n.x * lt) * s - r.x * lt), (c = (c + n.y * lt) * s - r.y * lt), o.push(new H(l, c));
        }
      }
      Gt(Xl, 'FillExtrusionBucket', { omit: ['layers', 'features'] }), Gt(p1, 'PartData'), Gt(f1, 'FootprintSegment'), Gt(m1, 'BorderCentroidData'), Gt(g1, 'GroundEffect');
      const SC = new Mi({ visibility: new vt(Q['layout_fill-extrusion'].visibility), 'fill-extrusion-edge-radius': new vt(Q['layout_fill-extrusion']['fill-extrusion-edge-radius']) });
      var AC = {
        paint: new Mi({
          'fill-extrusion-opacity': new vt(Q['paint_fill-extrusion']['fill-extrusion-opacity']),
          'fill-extrusion-color': new Xt(Q['paint_fill-extrusion']['fill-extrusion-color']),
          'fill-extrusion-translate': new vt(Q['paint_fill-extrusion']['fill-extrusion-translate']),
          'fill-extrusion-translate-anchor': new vt(Q['paint_fill-extrusion']['fill-extrusion-translate-anchor']),
          'fill-extrusion-pattern': new Xt(Q['paint_fill-extrusion']['fill-extrusion-pattern']),
          'fill-extrusion-height': new Xt(Q['paint_fill-extrusion']['fill-extrusion-height']),
          'fill-extrusion-base': new Xt(Q['paint_fill-extrusion']['fill-extrusion-base']),
          'fill-extrusion-vertical-gradient': new vt(Q['paint_fill-extrusion']['fill-extrusion-vertical-gradient']),
          'fill-extrusion-ambient-occlusion-intensity': new vt(Q['paint_fill-extrusion']['fill-extrusion-ambient-occlusion-intensity']),
          'fill-extrusion-ambient-occlusion-radius': new vt(Q['paint_fill-extrusion']['fill-extrusion-ambient-occlusion-radius']),
          'fill-extrusion-ambient-occlusion-wall-radius': new vt(Q['paint_fill-extrusion']['fill-extrusion-ambient-occlusion-wall-radius']),
          'fill-extrusion-ambient-occlusion-ground-radius': new vt(Q['paint_fill-extrusion']['fill-extrusion-ambient-occlusion-ground-radius']),
          'fill-extrusion-ambient-occlusion-ground-attenuation': new vt(Q['paint_fill-extrusion']['fill-extrusion-ambient-occlusion-ground-attenuation']),
          'fill-extrusion-flood-light-color': new vt(Q['paint_fill-extrusion']['fill-extrusion-flood-light-color']),
          'fill-extrusion-flood-light-intensity': new vt(Q['paint_fill-extrusion']['fill-extrusion-flood-light-intensity']),
          'fill-extrusion-flood-light-wall-radius': new Xt(Q['paint_fill-extrusion']['fill-extrusion-flood-light-wall-radius']),
          'fill-extrusion-flood-light-ground-radius': new Xt(Q['paint_fill-extrusion']['fill-extrusion-flood-light-ground-radius']),
          'fill-extrusion-flood-light-ground-attenuation': new vt(Q['paint_fill-extrusion']['fill-extrusion-flood-light-ground-attenuation']),
          'fill-extrusion-vertical-scale': new vt(Q['paint_fill-extrusion']['fill-extrusion-vertical-scale']),
          'fill-extrusion-rounded-roof': new vt(Q['paint_fill-extrusion']['fill-extrusion-rounded-roof']),
          'fill-extrusion-cutoff-fade-range': new vt(Q['paint_fill-extrusion']['fill-extrusion-cutoff-fade-range']),
          'fill-extrusion-emissive-strength': new vt(Q['paint_fill-extrusion']['fill-extrusion-emissive-strength']),
        }),
        layout: SC,
      };
      class La extends H {
        constructor(t, i, r) {
          super(t, i), (this.z = r);
        }
      }
      function Yl(e, t) {
        return e.x * t.x + e.y * t.y;
      }
      function M1(e, t) {
        if (e.length === 1) {
          let i = 0;
          const r = t[i++];
          let n;
          for (; !n || r.equals(n); ) if (((n = t[i++]), !n)) return 1 / 0;
          for (; i < t.length; i++) {
            const o = t[i],
              s = e[0],
              a = n.sub(r),
              l = o.sub(r),
              c = s.sub(r),
              u = Yl(a, a),
              h = Yl(a, l),
              d = Yl(l, l),
              f = Yl(c, a),
              p = Yl(c, l),
              _ = u * d - h * h,
              g = (d * f - h * p) / _,
              y = (u * p - h * f) / _,
              v = r.z * (1 - g - y) + n.z * g + o.z * y;
            if (isFinite(v)) return v;
          }
          return 1 / 0;
        }
        {
          let i = 1 / 0;
          for (const r of t) i = Math.min(i, r.z);
          return i;
        }
      }
      function S1(e, t, i, r, n, o, s, a) {
        const l = s * n.getElevationAt(e, t, !0, !0),
          c = o[0] !== 0,
          u = c
            ? o[1] === 0
              ? s * (o[0] / 7 - 450)
              : s *
                (function (h, d, f) {
                  const p = Math.floor(d[0] / 8),
                    _ = Math.floor(d[1] / 8),
                    g = 10 * (d[0] - 8 * p),
                    y = 10 * (d[1] - 8 * _),
                    v = h.getElevationAt(p, _, !0, !0),
                    w = h.getMeterToDEM(f),
                    T = Math.floor(0.5 * (g * w - 1)),
                    b = Math.floor(0.5 * (y * w - 1)),
                    E = h.tileCoordToPixel(p, _),
                    S = 2 * T + 1,
                    I = 2 * b + 1,
                    C = (function (G, Z, X, j, q) {
                      return [G.getElevationAtPixel(Z, X, !0), G.getElevationAtPixel(Z + q, X, !0), G.getElevationAtPixel(Z, X + q, !0), G.getElevationAtPixel(Z + j, X + q, !0)];
                    })(h, E.x - T, E.y - b, S, I),
                    z = Math.abs(C[0] - C[1]),
                    k = Math.abs(C[2] - C[3]),
                    O = Math.abs(C[0] - C[2]) + Math.abs(C[1] - C[3]),
                    V = Math.min(0.25, (0.5 * w * (z + k)) / S),
                    R = Math.min(0.25, (0.5 * w * O) / I);
                  return v + Math.max(V * g, R * y);
                })(n, o, a)
            : l;
        return { base: l + (i === 0) ? -1 : i, top: c ? Math.max(u + r, l + i + 2) : l + r };
      }
      const IC = new Mi({ 'line-cap': new Xt(Q.layout_line['line-cap']), 'line-join': new Xt(Q.layout_line['line-join']), 'line-miter-limit': new vt(Q.layout_line['line-miter-limit']), 'line-round-limit': new vt(Q.layout_line['line-round-limit']), 'line-sort-key': new Xt(Q.layout_line['line-sort-key']), visibility: new vt(Q.layout_line.visibility) });
      var A1 = { paint: new Mi({ 'line-opacity': new Xt(Q.paint_line['line-opacity']), 'line-color': new Xt(Q.paint_line['line-color']), 'line-translate': new vt(Q.paint_line['line-translate']), 'line-translate-anchor': new vt(Q.paint_line['line-translate-anchor']), 'line-width': new Xt(Q.paint_line['line-width']), 'line-gap-width': new Xt(Q.paint_line['line-gap-width']), 'line-offset': new Xt(Q.paint_line['line-offset']), 'line-blur': new Xt(Q.paint_line['line-blur']), 'line-dasharray': new Xt(Q.paint_line['line-dasharray']), 'line-pattern': new Xt(Q.paint_line['line-pattern']), 'line-gradient': new yl(Q.paint_line['line-gradient']), 'line-trim-offset': new vt(Q.paint_line['line-trim-offset']), 'line-emissive-strength': new vt(Q.paint_line['line-emissive-strength']), 'line-border-width': new Xt(Q.paint_line['line-border-width']), 'line-border-color': new Xt(Q.paint_line['line-border-color']) }), layout: IC };
      const CC = (e, t, i, r, n, o, s) => {
          const a = e.transform,
            l = a.calculatePixelsToTileUnitsMatrix(t);
          return { u_matrix: C1(e, t, i, r), u_pixels_to_tile_units: l, u_device_pixel_ratio: o, u_units_to_pixels: [1 / a.pixelsToGLUnits[0], 1 / a.pixelsToGLUnits[1]], u_dash_image: 0, u_gradient_image: 1, u_image_height: n, u_texsize: z1(i) && t.lineAtlasTexture ? t.lineAtlasTexture.size : [0, 0], u_tile_units_to_pixels: I1(t, e.transform), u_alpha_discard_threshold: 0, u_trim_offset: s, u_emissive_strength: i.paint.get('line-emissive-strength') };
        },
        PC = (e, t, i, r, n) => {
          const o = e.transform;
          return { u_matrix: C1(e, t, i, r), u_texsize: t.imageAtlasTexture ? t.imageAtlasTexture.size : [0, 0], u_pixels_to_tile_units: o.calculatePixelsToTileUnitsMatrix(t), u_device_pixel_ratio: n, u_image: 0, u_tile_units_to_pixels: I1(t, o), u_units_to_pixels: [1 / o.pixelsToGLUnits[0], 1 / o.pixelsToGLUnits[1]], u_alpha_discard_threshold: 0 };
        };
      function I1(e, t) {
        return 1 / Ms(e, 1, t.tileZoom);
      }
      function C1(e, t, i, r) {
        return e.translatePosMatrix(r || t.tileID.projMatrix, t, i.paint.get('line-translate'), i.paint.get('line-translate-anchor'));
      }
      const P1 = (e) => {
        const t = [];
        z1(e) && t.push('RENDER_LINE_DASH'), e.paint.get('line-gradient') && t.push('RENDER_LINE_GRADIENT');
        const i = e.paint.get('line-trim-offset');
        return (i[0] === 0 && i[1] === 0) || t.push('RENDER_LINE_TRIM_OFFSET'), e.paint.get('line-border-width').constantOr(1) !== 0 && t.push('RENDER_LINE_BORDER'), t;
      };
      function z1(e) {
        const t = e.paint.get('line-dasharray').value;
        return t.value || t.kind !== 'constant';
      }
      const D1 = new (class extends Xt {
        possiblyEvaluate(e, t) {
          return (t = new gi(Math.floor(t.zoom), { now: t.now, fadeDuration: t.fadeDuration, transition: t.transition })), super.possiblyEvaluate(e, t);
        }
        evaluate(e, t, i, r) {
          return (t = Ft({}, t, { zoom: Math.floor(t.zoom) })), super.evaluate(e, t, i, r);
        }
      })(A1.paint.properties['line-width'].specification);
      function R1(e, t) {
        return t > 0 ? t + 2 * e : e;
      }
      D1.useIntegerZoom = !0;
      const zC = new Mi({ visibility: new vt(Q.layout_background.visibility) });
      var DC = { paint: new Mi({ 'background-color': new vt(Q.paint_background['background-color']), 'background-pattern': new vt(Q.paint_background['background-pattern']), 'background-opacity': new vt(Q.paint_background['background-opacity']), 'background-emissive-strength': new vt(Q.paint_background['background-emissive-strength']) }), layout: zC };
      const RC = new Mi({ visibility: new vt(Q.layout_raster.visibility) });
      var LC = { paint: new Mi({ 'raster-opacity': new vt(Q.paint_raster['raster-opacity']), 'raster-color': new yl(Q.paint_raster['raster-color']), 'raster-color-mix': new vt(Q.paint_raster['raster-color-mix']), 'raster-color-range': new vt(Q.paint_raster['raster-color-range']), 'raster-hue-rotate': new vt(Q.paint_raster['raster-hue-rotate']), 'raster-brightness-min': new vt(Q.paint_raster['raster-brightness-min']), 'raster-brightness-max': new vt(Q.paint_raster['raster-brightness-max']), 'raster-saturation': new vt(Q.paint_raster['raster-saturation']), 'raster-contrast': new vt(Q.paint_raster['raster-contrast']), 'raster-resampling': new vt(Q.paint_raster['raster-resampling']), 'raster-fade-duration': new vt(Q.paint_raster['raster-fade-duration']), 'raster-emissive-strength': new vt(Q.paint_raster['raster-emissive-strength']), 'raster-array-band': new vt(Q.paint_raster['raster-array-band']), 'raster-elevation': new vt(Q.paint_raster['raster-elevation']) }), layout: RC };
      function L1(e, t, i, r, n, o, s, a) {
        const l = [e, i, n, t, r, o, 1, 1, 1],
          c = [s, a, 1],
          u = br.adjoint([], l),
          [h, d, f] = N.transformMat3(c, c, br.transpose(u, u));
        return br.multiply(l, [h, 0, 0, 0, d, 0, 0, 0, f], l);
      }
      class fn extends Oi {
        constructor(t, i, r, n) {
          super(), (this.id = t), (this.dispatcher = r), (this.coordinates = i.coordinates), (this.type = 'image'), (this.minzoom = 0), (this.maxzoom = 22), (this.tileSize = 512), (this.tiles = {}), (this._loaded = !1), (this.onNorthPole = !1), (this.onSouthPole = !1), this.setEventedParent(n), (this.options = i), (this._dirty = !1);
        }
        load(t, i) {
          if (((this._loaded = i || !1), this.fire(new wt('dataloading', { dataType: 'source' })), (this.url = this.options.url), !this.url)) return t && (this.coordinates = t), (this._loaded = !0), void this._finishLoading();
          this._imageRequest = de(this.map._requestManager.transformRequest(this.url, dt.Image), (r, n) => {
            if (((this._imageRequest = null), (this._loaded = !0), r)) this.fire(new re(r));
            else if (n) {
              const { HTMLImageElement: o } = U;
              (this.image = n instanceof o ? oe.getImageData(n) : n), (this._dirty = !0), (this.width = this.image.width), (this.height = this.image.height), t && (this.coordinates = t), this._finishLoading();
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        updateImage(t) {
          return t.url ? (this._imageRequest && t.url !== this.options.url && (this._imageRequest.cancel(), (this._imageRequest = null)), (this.options.url = t.url), this.load(t.coordinates, this._loaded), this) : this;
        }
        setTexture(t) {
          if (!(t.handle instanceof WebGLTexture)) throw new Error('The provided handle is not a WebGLTexture instance');
          return (this.texture = new Wu(this.map.painter.context, t.handle)), (this.width = t.dimensions[0]), (this.height = t.dimensions[1]), (this._dirty = !1), (this._loaded = !0), this._finishLoading(), this;
        }
        _finishLoading() {
          this.map && (this.setCoordinates(this.coordinates), this.fire(new wt('data', { dataType: 'source', sourceDataType: 'metadata' })));
        }
        onAdd(t) {
          (this.map = t), this.load();
        }
        onRemove() {
          this._imageRequest && (this._imageRequest.cancel(), (this._imageRequest = null)), !this.texture || this.texture instanceof Wu || this.texture.destroy();
        }
        setCoordinates(t) {
          if (((this.coordinates = t), (this._boundsArray = void 0), !t.length)) return this;
          (this.onNorthPole = !1), (this.onSouthPole = !1);
          let i = t[0][1],
            r = t[0][1];
          for (const o of t) o[1] > r && (r = o[1]), o[1] < i && (i = o[1]);
          const n = (r + i) / 2;
          if ((n > Ii ? (this.onNorthPole = !0) : n < -Ii && (this.onSouthPole = !0), !this.onNorthPole && !this.onSouthPole)) {
            const o = t.map(Me.fromLngLat);
            (this.tileID = (function (s) {
              let a = 1 / 0,
                l = 1 / 0,
                c = -1 / 0,
                u = -1 / 0;
              for (const p of s) (a = Math.min(a, p.x)), (l = Math.min(l, p.y)), (c = Math.max(c, p.x)), (u = Math.max(u, p.y));
              const h = Math.max(c - a, u - l),
                d = Math.max(0, Math.floor(-Math.log(h) / Math.LN2)),
                f = Math.pow(2, d);
              return new cn(d, Math.floor(((a + c) / 2) * f), Math.floor(((l + u) / 2) * f));
            })(o)),
              (this.minzoom = this.maxzoom = this.tileID.z);
          }
          return this.fire(new wt('data', { dataType: 'source', sourceDataType: 'content' })), this;
        }
        _clear() {
          this._boundsArray = void 0;
        }
        _prepareData(t) {
          for (const l in this.tiles) {
            const c = this.tiles[l];
            c.state !== 'loaded' && ((c.state = 'loaded'), (c.texture = this.texture));
          }
          if (this._boundsArray) return;
          const i = Es(this.tileID, this.map.transform.projection),
            [r, n, o, s] = this.coordinates.map((l) => {
              const c = i.projection.project(l[0], l[1]);
              return wv(i, c)._round();
            });
          this.perspectiveTransform = (function (l, c, u, h, d, f, p, _, g, y) {
            const v = L1(0, 0, l, 0, 0, c, l, c),
              w = L1(u, h, d, f, p, _, g, y);
            return br.multiply(w, br.adjoint(v, v), w), [((w[6] / w[8]) * l) / lt, ((w[7] / w[8]) * c) / lt];
          })(this.width, this.height, r.x, r.y, n.x, n.y, s.x, s.y, o.x, o.y);
          const a = (this._boundsArray = new gs());
          a.emplaceBack(r.x, r.y, 0, 0), a.emplaceBack(n.x, n.y, lt, 0), a.emplaceBack(s.x, s.y, 0, lt), a.emplaceBack(o.x, o.y, lt, lt), this.boundsBuffer && this.boundsBuffer.destroy(), (this.boundsBuffer = t.createVertexBuffer(a, Hp.members)), (this.boundsSegments = He.simpleSegment(0, 0, 4, 2));
        }
        prepare() {
          const t = Object.keys(this.tiles).length !== 0;
          if (this.tileID && !t) return;
          const i = this.map.painter.context,
            r = i.gl;
          !this._dirty || this.texture instanceof Wu || (this.texture ? this.texture.update(this.image) : ((this.texture = new vi(i, this.image, r.RGBA)), this.texture.bind(r.LINEAR, r.CLAMP_TO_EDGE)), (this._dirty = !1)), t && this._prepareData(i);
        }
        loadTile(t, i) {
          this.tileID && this.tileID.equals(t.tileID.canonical) ? ((this.tiles[String(t.tileID.wrap)] = t), (t.buckets = {}), i(null)) : ((t.state = 'errored'), i(null));
        }
        serialize() {
          return { type: 'image', url: this.options.url, coordinates: this.coordinates };
        }
        hasTransition() {
          return !1;
        }
      }
      class kC extends Hr {
        constructor(t) {
          super(t, {}), (this.implementation = t), t.slot && (this.slot = t.slot);
        }
        is3D() {
          return this.implementation.renderingMode === '3d';
        }
        hasOffscreenPass() {
          return this.implementation.prerender !== void 0;
        }
        isLayerDraped(t) {
          return this.implementation.renderToTile !== void 0;
        }
        shouldRedrape() {
          return !!this.implementation.shouldRerenderTiles && this.implementation.shouldRerenderTiles();
        }
        recalculate() {}
        updateTransitions() {}
        hasTransition() {
          return !1;
        }
        serialize() {}
        onAdd(t) {
          this.implementation.onAdd && this.implementation.onAdd(t, t.painter.context.gl);
        }
        onRemove(t) {
          this.implementation.onRemove && this.implementation.onRemove(t, t.painter.context.gl);
        }
      }
      const OC = new Mi({ visibility: new vt(Q.layout_sky.visibility) });
      var BC = { paint: new Mi({ 'sky-type': new vt(Q.paint_sky['sky-type']), 'sky-atmosphere-sun': new vt(Q.paint_sky['sky-atmosphere-sun']), 'sky-atmosphere-sun-intensity': new vt(Q.paint_sky['sky-atmosphere-sun-intensity']), 'sky-gradient-center': new vt(Q.paint_sky['sky-gradient-center']), 'sky-gradient-radius': new vt(Q.paint_sky['sky-gradient-radius']), 'sky-gradient': new yl(Q.paint_sky['sky-gradient']), 'sky-atmosphere-halo-color': new vt(Q.paint_sky['sky-atmosphere-halo-color']), 'sky-atmosphere-color': new vt(Q.paint_sky['sky-atmosphere-color']), 'sky-opacity': new vt(Q.paint_sky['sky-opacity']) }), layout: OC };
      function om(e, t, i) {
        const r = [0, 0, 1],
          n = sr.identity([]);
        return sr.rotateY(n, n, i ? -ne(e) + Math.PI : ne(e)), sr.rotateX(n, n, -ne(t)), N.transformQuat(r, r, n), N.normalize(r, r);
      }
      var FC = { paint: new Mi({}) };
      const NC = {
        circle: class extends Hr {
          constructor(e, t) {
            super(e, TS, t);
          }
          createBucket(e) {
            return new vp(e);
          }
          queryRadius(e) {
            const t = e;
            return va('circle-radius', this, t) + va('circle-stroke-width', this, t) + gu(this.paint.get('circle-translate'));
          }
          queryIntersectsFeature(e, t, i, r, n, o, s, a) {
            const l = wx(this.paint.get('circle-translate'), this.paint.get('circle-translate-anchor'), o.angle, e.pixelToTileUnitsFactor),
              c = this.paint.get('circle-radius').evaluate(t, i) + this.paint.get('circle-stroke-width').evaluate(t, i);
            return Ex(e, r, o, s, a, this.paint.get('circle-pitch-alignment') === 'map', this.paint.get('circle-pitch-scale') === 'map', l, c);
          }
          getProgramIds() {
            return ['circle'];
          }
          getDefaultProgramParams(e, t) {
            const i = Tx(this);
            return { config: new vs(this, t), defines: i, overrideFog: !1 };
          }
        },
        heatmap: class extends Hr {
          createBucket(e) {
            return new Sx(e);
          }
          constructor(e, t) {
            super(e, PS, t), this._updateColorRamp();
          }
          _handleSpecialPaintPropertyUpdate(e) {
            e === 'heatmap-color' && this._updateColorRamp();
          }
          _updateColorRamp() {
            (this.colorRamp = yu({ expression: this._transitionablePaint._values['heatmap-color'].value.expression, evaluationKey: 'heatmapDensity', image: this.colorRamp })), (this.colorRampTexture = null);
          }
          resize() {
            this.heatmapFbo && (this.heatmapFbo.destroy(), (this.heatmapFbo = null));
          }
          queryRadius(e) {
            return va('heatmap-radius', this, e);
          }
          queryIntersectsFeature(e, t, i, r, n, o, s, a) {
            const l = this.paint.get('heatmap-radius').evaluate(t, i);
            return Ex(e, r, o, s, a, !0, !0, new H(0, 0), l);
          }
          hasOffscreenPass() {
            return this.paint.get('heatmap-opacity') !== 0 && this.visibility !== 'none';
          }
          getProgramIds() {
            return ['heatmap', 'heatmapTexture'];
          }
          getDefaultProgramParams(e, t) {
            return e === 'heatmap' ? { config: new vs(this, t), overrideFog: !1 } : {};
          }
        },
        hillshade: class extends Hr {
          constructor(e, t) {
            super(e, DS, t);
          }
          hasOffscreenPass() {
            return this.paint.get('hillshade-exaggeration') !== 0 && this.visibility !== 'none';
          }
          getProgramIds() {
            return ['hillshade', 'hillshadePrepare'];
          }
          getDefaultProgramParams(e, t) {
            return { overrideFog: !1 };
          }
        },
        fill: class extends Hr {
          constructor(e, t) {
            super(e, $S, t);
          }
          getProgramIds() {
            const e = this.paint.get('fill-pattern'),
              t = e && e.constantOr(1),
              i = [t ? 'fillPattern' : 'fill'];
            return this.paint.get('fill-antialias') && i.push(t && !this.getPaintProperty('fill-outline-color') ? 'fillOutlinePattern' : 'fillOutline'), i;
          }
          getDefaultProgramParams(e, t) {
            return { config: new vs(this, t), overrideFog: !1 };
          }
          recalculate(e, t) {
            super.recalculate(e, t);
            const i = this.paint._values['fill-outline-color'];
            i.value.kind === 'constant' && i.value.value === void 0 && (this.paint._values['fill-outline-color'] = this.paint._values['fill-color']);
          }
          createBucket(e) {
            return new Eu(e);
          }
          queryRadius() {
            return gu(this.paint.get('fill-translate'));
          }
          queryIntersectsFeature(e, t, i, r, n, o) {
            return !e.queryGeometry.isAboveHorizon && gx(bx(e.tilespaceGeometry, this.paint.get('fill-translate'), this.paint.get('fill-translate-anchor'), o.angle, e.pixelToTileUnitsFactor), r);
          }
          isTileClipped() {
            return !0;
          }
        },
        'fill-extrusion': class extends Hr {
          constructor(e, t) {
            super(e, AC, t), (this._stats = { numRenderedVerticesInShadowPass: 0, numRenderedVerticesInTransparentPass: 0 });
          }
          createBucket(e) {
            return new Xl(e);
          }
          queryRadius() {
            return gu(this.paint.get('fill-extrusion-translate'));
          }
          is3D() {
            return !0;
          }
          hasShadowPass() {
            return !0;
          }
          cutoffRange() {
            return this.paint.get('fill-extrusion-cutoff-fade-range');
          }
          canCastShadows() {
            return !0;
          }
          getProgramIds() {
            return [this.paint.get('fill-extrusion-pattern').constantOr(1) ? 'fillExtrusionPattern' : 'fillExtrusion'];
          }
          queryIntersectsFeature(e, t, i, r, n, o, s, a, l) {
            const c = wx(this.paint.get('fill-extrusion-translate'), this.paint.get('fill-extrusion-translate-anchor'), o.angle, e.pixelToTileUnitsFactor),
              u = this.paint.get('fill-extrusion-height').evaluate(t, i),
              h = this.paint.get('fill-extrusion-base').evaluate(t, i),
              d = [0, 0],
              f = a && o.elevation,
              p = o.elevation ? o.elevation.exaggeration() : 1,
              _ = e.tile.getBucket(this);
            if (f && _ instanceof Xl) {
              const T = _.centroidVertexArray,
                b = l + 1;
              b < T.length && ((d[0] = T.geta_centroid_pos0(b)), (d[1] = T.geta_centroid_pos1(b)));
            }
            if (d[0] === 0 && d[1] === 1) return !1;
            o.projection.name === 'globe' &&
              (r = E1([r], [new H(0, 0), new H(lt, lt)], e.tileID.canonical)
                .map((T) => T.polygon)
                .flat());
            const g = f ? a : null,
              [y, v] = (function (T, b, E, S, I, C, z, k, O, V, R) {
                return T.projection.name === 'globe'
                  ? (function (G, Z, X, j, q, it, st, nt, ut, ht, pt) {
                      const at = [],
                        _t = [],
                        Ct = G.projection.upVectorScale(pt, G.center.lat, G.worldSize).metersToTile,
                        Pt = [0, 0, 0, 1],
                        Ot = [0, 0, 0, 1],
                        Ut = (Ht, Ce, be, te) => {
                          (Ht[0] = Ce), (Ht[1] = be), (Ht[2] = te), (Ht[3] = 1);
                        },
                        Qt = T1();
                      X > 0 && (X += Qt), (j += Qt);
                      for (const Ht of Z) {
                        const Ce = [],
                          be = [];
                        for (const te of Ht) {
                          const Kt = te.x + q.x,
                            Wt = te.y + q.y,
                            Ee = G.projection.projectTilePoint(Kt, Wt, pt),
                            Ae = G.projection.upVector(pt, te.x, te.y);
                          let fe = X,
                            Qe = j;
                          if (st) {
                            const Ci = S1(Kt, Wt, X, j, st, nt, ut, ht);
                            (fe += Ci.base), (Qe += Ci.top);
                          }
                          X !== 0 ? Ut(Pt, Ee.x + Ae[0] * Ct * fe, Ee.y + Ae[1] * Ct * fe, Ee.z + Ae[2] * Ct * fe) : Ut(Pt, Ee.x, Ee.y, Ee.z), Ut(Ot, Ee.x + Ae[0] * Ct * Qe, Ee.y + Ae[1] * Ct * Qe, Ee.z + Ae[2] * Ct * Qe), N.transformMat4(Pt, Pt, it), N.transformMat4(Ot, Ot, it), Ce.push(new La(Pt[0], Pt[1], Pt[2])), be.push(new La(Ot[0], Ot[1], Ot[2]));
                        }
                        at.push(Ce), _t.push(be);
                      }
                      return [at, _t];
                    })(T, b, E, S, I, C, z, k, O, V, R)
                  : z
                  ? (function (G, Z, X, j, q, it, st, nt, ut) {
                      const ht = [],
                        pt = [],
                        at = [0, 0, 0, 1];
                      for (const _t of G) {
                        const Ct = [],
                          Pt = [];
                        for (const Ot of _t) {
                          const Ut = Ot.x + j.x,
                            Qt = Ot.y + j.y,
                            Ht = S1(Ut, Qt, Z, X, it, st, nt, ut);
                          (at[0] = Ut), (at[1] = Qt), (at[2] = Ht.base), (at[3] = 1), We.transformMat4(at, at, q), (at[3] = Math.max(at[3], 1e-5));
                          const Ce = new La(at[0] / at[3], at[1] / at[3], at[2] / at[3]);
                          (at[0] = Ut), (at[1] = Qt), (at[2] = Ht.top), (at[3] = 1), We.transformMat4(at, at, q), (at[3] = Math.max(at[3], 1e-5));
                          const be = new La(at[0] / at[3], at[1] / at[3], at[2] / at[3]);
                          Ct.push(Ce), Pt.push(be);
                        }
                        ht.push(Ct), pt.push(Pt);
                      }
                      return [ht, pt];
                    })(b, E, S, I, C, z, k, O, V)
                  : (function (G, Z, X, j, q) {
                      const it = [],
                        st = [],
                        nt = q[8] * Z,
                        ut = q[9] * Z,
                        ht = q[10] * Z,
                        pt = q[11] * Z,
                        at = q[8] * X,
                        _t = q[9] * X,
                        Ct = q[10] * X,
                        Pt = q[11] * X;
                      for (const Ot of G) {
                        const Ut = [],
                          Qt = [];
                        for (const Ht of Ot) {
                          const Ce = Ht.x + j.x,
                            be = Ht.y + j.y,
                            te = q[0] * Ce + q[4] * be + q[12],
                            Kt = q[1] * Ce + q[5] * be + q[13],
                            Wt = q[2] * Ce + q[6] * be + q[14],
                            Ee = q[3] * Ce + q[7] * be + q[15],
                            Ae = te + nt,
                            fe = Kt + ut,
                            Qe = Wt + ht,
                            Ci = Math.max(Ee + pt, 1e-5),
                            Xe = te + at,
                            oi = Kt + _t,
                            Ri = Wt + Ct,
                            Pi = Math.max(Ee + Pt, 1e-5);
                          Ut.push(new La(Ae / Ci, fe / Ci, Qe / Ci)), Qt.push(new La(Xe / Pi, oi / Pi, Ri / Pi));
                        }
                        it.push(Ut), st.push(Qt);
                      }
                      return [it, st];
                    })(b, E, S, I, C);
              })(o, r, h, u, c, s, g, d, p, o.center.lat, e.tileID.canonical),
              w = e.queryGeometry;
            return (function (T, b, E) {
              let S = 1 / 0;
              gx(E, b) && (S = M1(E, b[0]));
              for (let I = 0; I < b.length; I++) {
                const C = b[I],
                  z = T[I];
                for (let k = 0; k < C.length - 1; k++) {
                  const O = C[k],
                    V = [O, C[k + 1], z[k + 1], z[k], O];
                  _x(E, V) && (S = Math.min(S, M1(E, V)));
                }
              }
              return S !== 1 / 0 && S;
            })(y, v, w.isPointQuery() ? w.screenBounds : w.screenGeometry);
          }
        },
        line: class extends Hr {
          constructor(e, t) {
            super(e, A1, t), (this.gradientVersion = 0);
          }
          _handleSpecialPaintPropertyUpdate(e) {
            if (e === 'line-gradient') {
              const t = this._transitionablePaint._values['line-gradient'].value.expression;
              (this.stepInterpolant = t._styleExpression && t._styleExpression.expression instanceof qd), (this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER);
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values['line-gradient'].value.expression;
          }
          widthExpression() {
            return this._transitionablePaint._values['line-width'].value.expression;
          }
          recalculate(e, t) {
            super.recalculate(e, t), (this.paint._values['line-floorwidth'] = D1.possiblyEvaluate(this._transitioningPaint._values['line-width'].value, e));
          }
          createBucket(e) {
            return new Hu(e);
          }
          getProgramIds() {
            return [this.paint.get('line-pattern').constantOr(1) ? 'linePattern' : 'line'];
          }
          getDefaultProgramParams(e, t) {
            const i = P1(this);
            return { config: new vs(this, t), defines: i, overrideFog: !1 };
          }
          queryRadius(e) {
            const t = e,
              i = R1(va('line-width', this, t), va('line-gap-width', this, t)),
              r = va('line-offset', this, t);
            return i / 2 + Math.abs(r) + gu(this.paint.get('line-translate'));
          }
          queryIntersectsFeature(e, t, i, r, n, o) {
            if (e.queryGeometry.isAboveHorizon) return !1;
            const s = bx(e.tilespaceGeometry, this.paint.get('line-translate'), this.paint.get('line-translate-anchor'), o.angle, e.pixelToTileUnitsFactor),
              a = (e.pixelToTileUnitsFactor / 2) * R1(this.paint.get('line-width').evaluate(t, i), this.paint.get('line-gap-width').evaluate(t, i)),
              l = this.paint.get('line-offset').evaluate(t, i);
            return (
              l &&
                (r = (function (c, u) {
                  const h = [],
                    d = new H(0, 0);
                  for (let f = 0; f < c.length; f++) {
                    const p = c[f],
                      _ = [];
                    for (let g = 0; g < p.length; g++) {
                      const y = p[g],
                        v = p[g + 1],
                        w =
                          g === 0
                            ? d
                            : y
                                .sub(p[g - 1])
                                ._unit()
                                ._perp(),
                        T = g === p.length - 1 ? d : v.sub(y)._unit()._perp(),
                        b = w._add(T)._unit();
                      b._mult(1 / (b.x * T.x + b.y * T.y)), _.push(b._mult(u)._add(y));
                    }
                    h.push(_);
                  }
                  return h;
                })(r, l * e.pixelToTileUnitsFactor)),
              (function (c, u, h) {
                for (let d = 0; d < u.length; d++) {
                  const f = u[d];
                  if (c.length >= 3) {
                    for (let p = 0; p < f.length; p++) if (Vo(c, f[p])) return !0;
                  }
                  if (xS(c, f, h)) return !0;
                }
                return !1;
              })(s, r, a)
            );
          }
          isTileClipped() {
            return !0;
          }
        },
        symbol: Vu,
        background: class extends Hr {
          constructor(e, t) {
            super(e, DC, t);
          }
          getProgramIds() {
            return [this.paint.get('background-pattern') ? 'backgroundPattern' : 'background'];
          }
          getDefaultProgramParams(e, t) {
            return { overrideFog: !1 };
          }
        },
        raster: class extends Hr {
          constructor(e, t) {
            super(e, LC, t), this._updateColorRamp();
          }
          getProgramIds() {
            return ['raster'];
          }
          hasColorMap() {
            return !!this._transitionablePaint._values['raster-color'].value.value;
          }
          isLayerDraped(e) {
            return !(e && e._source instanceof fn) || (!e._source.onNorthPole && !e._source.onSouthPole && this.paint.get('raster-elevation') === 0);
          }
          _handleSpecialPaintPropertyUpdate(e) {
            (e !== 'raster-color' && e !== 'raster-color-range') || this._updateColorRamp();
          }
          _updateColorRamp() {
            if (!this.hasColorMap()) return;
            const e = this._transitionablePaint._values['raster-color'].value.expression,
              [t, i] = this._transitionablePaint._values['raster-color-range'].value.expression.evaluate({ zoom: 0 });
            (this.colorRamp = yu({ expression: e, evaluationKey: 'rasterValue', image: this.colorRamp, clips: [{ start: t, end: i }], resolution: 256 })), (this.colorRampTexture = null);
          }
        },
        sky: class extends Hr {
          constructor(e, t) {
            super(e, BC, t), this._updateColorRamp();
          }
          _handleSpecialPaintPropertyUpdate(e) {
            e === 'sky-gradient' ? this._updateColorRamp() : (e !== 'sky-atmosphere-sun' && e !== 'sky-atmosphere-halo-color' && e !== 'sky-atmosphere-color' && e !== 'sky-atmosphere-sun-intensity') || (this._skyboxInvalidated = !0);
          }
          _updateColorRamp() {
            (this.colorRamp = yu({ expression: this._transitionablePaint._values['sky-gradient'].value.expression, evaluationKey: 'skyRadialProgress' })), this.colorRampTexture && (this.colorRampTexture.destroy(), (this.colorRampTexture = null));
          }
          needsSkyboxCapture(e) {
            if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry) return !0;
            if (!this.paint.get('sky-atmosphere-sun')) {
              const t = e.style.light.properties.get('position');
              return this._lightPosition.azimuthal !== t.azimuthal || this._lightPosition.polar !== t.polar;
            }
            return !1;
          }
          getCenter(e, t) {
            if (this.paint.get('sky-type') === 'atmosphere') {
              const r = this.paint.get('sky-atmosphere-sun'),
                n = !r,
                o = e.style.light,
                s = o.properties.get('position');
              return n && o.properties.get('anchor') === 'viewport' && B('The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly.'), n ? om(s.azimuthal, 90 - s.polar, t) : om(r[0], 90 - r[1], t);
            }
            const i = this.paint.get('sky-gradient-center');
            return om(i[0], 90 - i[1], t);
          }
          isSky() {
            return !0;
          }
          markSkyboxValid(e) {
            (this._skyboxInvalidated = !1), (this._lightPosition = e.style.light.properties.get('position'));
          }
          hasOffscreenPass() {
            return !0;
          }
          getProgramIds() {
            const e = this.paint.get('sky-type');
            return e === 'atmosphere' ? ['skyboxCapture', 'skybox'] : e === 'gradient' ? ['skyboxGradient'] : null;
          }
        },
        slot: class extends Hr {
          constructor(e, t) {
            super(e, FC);
          }
        },
        model: class extends Hr {
          constructor(e, t) {
            super(e, dC, t);
          }
          createBucket(e) {
            return new i1(e);
          }
          getProgramIds() {
            return ['model'];
          }
          is3D() {
            return !0;
          }
          hasShadowPass() {
            return !0;
          }
          canCastShadows() {
            return !0;
          }
          hasLightBeamPass() {
            return !0;
          }
          cutoffRange() {
            return this.paint.get('model-cutoff-fade-range');
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            return !1;
          }
          _handleOverridablePaintPropertyUpdate(e, t, i) {
            return !(!this.layout || t.isDataDriven() || i.isDataDriven() || (e !== 'model-color' && e !== 'model-color-mix-intensity' && e !== 'model-rotation' && e !== 'model-scale' && e !== 'model-translation' && e !== 'model-emissive-strength'));
          }
          _isPropertyZoomDependent(e) {
            const t = this._transitionablePaint._values[e];
            return t != null && t.value != null && t.value.expression != null && t.value.expression instanceof Ao;
          }
          isZoomDependent() {
            return this._isPropertyZoomDependent('model-scale') || this._isPropertyZoomDependent('model-rotation') || this._isPropertyZoomDependent('model-translation');
          }
        },
      };
      function oh(e, t) {
        return e.type === 'custom' ? new kC(e) : new NC[e.type](e, t);
      }
      function UC(e) {
        const { userImage: t } = e;
        return !!(t && t.render && t.render()) && (e.data.replace(new Uint8Array(t.data.buffer)), !0);
      }
      class VC extends Oi {
        constructor() {
          super(), (this.images = {}), (this.updatedImages = {}), (this.callbackDispatchedThisFrame = {}), (this.loaded = {}), (this.requestors = []), (this.patterns = {}), (this.atlasImage = {}), (this.atlasTexture = {}), (this.dirty = !0);
        }
        createScope(t) {
          (this.images[t] = {}), (this.loaded[t] = !1), (this.updatedImages[t] = {}), (this.patterns[t] = {}), (this.callbackDispatchedThisFrame[t] = {}), (this.atlasImage[t] = new Li({ width: 1, height: 1 }));
        }
        isLoaded() {
          for (const t in this.loaded) if (!this.loaded[t]) return !1;
          return !0;
        }
        setLoaded(t, i) {
          if (this.loaded[i] !== t && ((this.loaded[i] = t), t)) {
            for (const { ids: r, callback: n } of this.requestors) this._notify(r, i, n);
            this.requestors = [];
          }
        }
        hasImage(t, i) {
          return !!this.getImage(t, i);
        }
        getImage(t, i) {
          return this.images[i][t];
        }
        addImage(t, i, r) {
          this._validate(t, r) && (this.images[i][t] = r);
        }
        _validate(t, i) {
          let r = !0;
          return this._validateStretch(i.stretchX, i.data && i.data.width) || (this.fire(new re(new Error(`Image "${t}" has invalid "stretchX" value`))), (r = !1)), this._validateStretch(i.stretchY, i.data && i.data.height) || (this.fire(new re(new Error(`Image "${t}" has invalid "stretchY" value`))), (r = !1)), this._validateContent(i.content, i) || (this.fire(new re(new Error(`Image "${t}" has invalid "content" value`))), (r = !1)), r;
        }
        _validateStretch(t, i) {
          if (!t) return !0;
          let r = 0;
          for (const n of t) {
            if (n[0] < r || n[1] < n[0] || i < n[1]) return !1;
            r = n[1];
          }
          return !0;
        }
        _validateContent(t, i) {
          return !(t && (t.length !== 4 || t[0] < 0 || i.data.width < t[0] || t[1] < 0 || i.data.height < t[1] || t[2] < 0 || i.data.width < t[2] || t[3] < 0 || i.data.height < t[3] || t[2] < t[0] || t[3] < t[1]));
        }
        updateImage(t, i, r) {
          (r.version = this.images[i][t].version + 1), (this.images[i][t] = r), (this.updatedImages[i][t] = !0);
        }
        removeImage(t, i) {
          const r = this.images[i][t];
          delete this.images[i][t], delete this.patterns[i][t], r.userImage && r.userImage.onRemove && r.userImage.onRemove();
        }
        listImages(t) {
          return Object.keys(this.images[t]);
        }
        getImages(t, i, r) {
          let n = !0;
          const o = !!this.loaded[i];
          if (!o) for (const s of t) this.images[i][s] || (n = !1);
          o || n ? this._notify(t, i, r) : this.requestors.push({ ids: t, scope: i, callback: r });
        }
        getUpdatedImages(t) {
          return this.updatedImages[t];
        }
        _notify(t, i, r) {
          const n = {};
          for (const o of t) {
            this.images[i][o] || this.fire(new wt('styleimagemissing', { id: o }));
            const s = this.images[i][o];
            s ? (n[o] = { data: s.data.clone(), pixelRatio: s.pixelRatio, sdf: s.sdf, version: s.version, stretchX: s.stretchX, stretchY: s.stretchY, content: s.content, hasRenderCallback: !!(s.userImage && s.userImage.render) }) : B(`Image "${o}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
          }
          r(null, n);
        }
        getPixelSize(t) {
          const { width: i, height: r } = this.atlasImage[t];
          return { width: i, height: r };
        }
        getPattern(t, i) {
          const r = this.patterns[i][t],
            n = this.getImage(t, i);
          if (!n) return null;
          if (r && r.position.version === n.version) return r.position;
          if (r) r.position.version = n.version;
          else {
            const o = { w: n.data.width + 2, h: n.data.height + 2, x: 0, y: 0 },
              s = new Np(o, n);
            this.patterns[i][t] = { bin: o, position: s };
          }
          return this._updatePatternAtlas(i), this.patterns[i][t].position;
        }
        bind(t, i) {
          const r = t.gl;
          let n = this.atlasTexture[i];
          n ? this.dirty && (n.update(this.atlasImage[i]), (this.dirty = !1)) : ((n = new vi(t, this.atlasImage[i], r.RGBA)), (this.atlasTexture[i] = n)), n.bind(r.LINEAR, r.CLAMP_TO_EDGE);
        }
        _updatePatternAtlas(t) {
          const i = [];
          for (const s in this.patterns[t]) i.push(this.patterns[t][s].bin);
          const { w: r, h: n } = Fp(i),
            o = this.atlasImage[t];
          o.resize({ width: r || 1, height: n || 1 });
          for (const s in this.patterns[t]) {
            const { bin: a } = this.patterns[t][s],
              l = a.x + 1,
              c = a.y + 1,
              u = this.images[t][s].data,
              h = u.width,
              d = u.height;
            Li.copy(u, o, { x: 0, y: 0 }, { x: l, y: c }, { width: h, height: d }), Li.copy(u, o, { x: 0, y: d - 1 }, { x: l, y: c - 1 }, { width: h, height: 1 }), Li.copy(u, o, { x: 0, y: 0 }, { x: l, y: c + d }, { width: h, height: 1 }), Li.copy(u, o, { x: h - 1, y: 0 }, { x: l - 1, y: c }, { width: 1, height: d }), Li.copy(u, o, { x: 0, y: 0 }, { x: l + h, y: c }, { width: 1, height: d });
          }
          this.dirty = !0;
        }
        beginFrame() {
          for (const t in this.images) this.callbackDispatchedThisFrame[t] = {};
        }
        dispatchRenderCallbacks(t, i) {
          for (const r of t) {
            if (this.callbackDispatchedThisFrame[i][r]) continue;
            this.callbackDispatchedThisFrame[i][r] = !0;
            const n = this.images[i][r];
            UC(n) && this.updateImage(r, i, n);
          }
        }
      }
      const jC = new Mi({
        anchor: new vt(Q.light.anchor),
        position: new (class {
          constructor(e) {
            this.specification = e;
          }
          possiblyEvaluate(e, t) {
            return ft(e.expression.evaluate(t));
          }
          interpolate(e, t, i) {
            return { x: ee(e.x, t.x, i), y: ee(e.y, t.y, i), z: ee(e.z, t.z, i), azimuthal: ee(e.azimuthal, t.azimuthal, i), polar: ee(e.polar, t.polar, i) };
          }
        })(Q.light.position),
        color: new vt(Q.light.color),
        intensity: new vt(Q.light.intensity),
      });
      class k1 extends Oi {
        constructor(t, i = 'flat') {
          super(), (this._transitionable = new _l(jC)), this.setLight(t, i), (this._transitioning = this._transitionable.untransitioned());
        }
        getLight() {
          return this._transitionable.serialize();
        }
        setLight(t, i, r = {}) {
          this._validate(hM, t, r) || (this._transitionable.setTransitionOrValue(t), (this.id = i));
        }
        updateTransitions(t) {
          this._transitioning = this._transitionable.transitioned(t, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(t) {
          this.properties = this._transitioning.possiblyEvaluate(t);
        }
        _validate(t, i, r) {
          return (!r || r.validate !== !1) && $c(this, t.call(la, Ft({ value: i, style: { glyphs: !0, sprite: !0 }, styleSpec: Q })));
        }
      }
      const GC = new Mi({ source: new vt(Q.terrain.source), exaggeration: new vt(Q.terrain.exaggeration) });
      let qC = class extends Oi {
        constructor(e, t, i, r) {
          super(), (this.scope = i), (this._transitionable = new _l(GC, r)), this._transitionable.setTransitionOrValue(e, r), (this._transitioning = this._transitionable.untransitioned()), (this.drapeRenderMode = t);
        }
        get() {
          return this._transitionable.serialize();
        }
        set(e, t) {
          this._transitionable.setTransitionOrValue(e, t);
        }
        updateTransitions(e) {
          this._transitioning = this._transitionable.transitioned(e, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(e) {
          this.properties = this._transitioning.possiblyEvaluate(e);
        }
        getExaggeration(e) {
          return this._transitioning.possiblyEvaluate(new gi(e)).get('exaggeration');
        }
        isZoomDependent() {
          const e = this._transitionable._values.exaggeration;
          return e != null && e.value != null && e.value.expression != null && e.value.expression instanceof Ao;
        }
      };
      const O1 = 45,
        B1 = 65,
        Is = 0.05;
      function sh(e, t, i, r) {
        const n = Zr(O1, B1, i),
          [o, s] = F1(e, r);
        let a = 1 - Math.min(1, Math.exp(((t - o) / (s - o)) * -6));
        return (a *= a * a), (a = Math.min(1, 1.00747 * a)), a * n * e.alpha;
      }
      function F1(e, t) {
        const i = 0.5 / Math.tan(0.5 * t);
        return [e.range[0] + i, e.range[1] + i];
      }
      function N1(e, t, i, r, n) {
        const o = N.transformMat4([], [t, i, r], n.mercatorFogMatrix);
        return sh(e, N.length(o), n.pitch, n._fov);
      }
      function U1(e, t, i, r, n, o, s) {
        const a = [
          [i, r, 0],
          [n, r, 0],
          [n, o, 0],
          [i, o, 0],
        ];
        let l = Number.MAX_VALUE,
          c = -Number.MAX_VALUE;
        for (const u of a) {
          const h = N.transformMat4([], u, t),
            d = N.length(h);
          (l = Math.min(l, d)), (c = Math.max(c, d));
        }
        return [sh(e, l, s.pitch, s._fov), sh(e, c, s.pitch, s._fov)];
      }
      const ZC = new Mi({ range: new vt(Q.fog.range), color: new vt(Q.fog.color), 'high-color': new vt(Q.fog['high-color']), 'space-color': new vt(Q.fog['space-color']), 'horizon-blend': new vt(Q.fog['horizon-blend']), 'star-intensity': new vt(Q.fog['star-intensity']), 'vertical-range': new vt(Q.fog['vertical-range']) });
      class $C extends Oi {
        constructor(t, i) {
          super(), (this._transitionable = new _l(ZC)), this.set(t), (this._transitioning = this._transitionable.untransitioned()), (this._transform = i);
        }
        get state() {
          const t = this._transform,
            i = t.projection.name === 'globe',
            r = Ji(t.zoom),
            n = this.properties.get('range'),
            o = [0.5, 3];
          return { range: i ? [ee(o[0], n[0], r), ee(o[1], n[1], r)] : n, horizonBlend: this.properties.get('horizon-blend'), alpha: this.properties.get('color').a };
        }
        get() {
          return this._transitionable.serialize();
        }
        set(t, i = {}) {
          if (this._validate(pM, t, i)) return;
          const r = Ft({}, t);
          for (const n of Object.keys(Q.fog)) r[n] === void 0 && (r[n] = Q.fog[n].default);
          this._transitionable.setTransitionOrValue(r);
        }
        getOpacity(t) {
          if (!this._transform.projection.supportsFog) return 0;
          const i = (this.properties && this.properties.get('color')) || 1;
          return (this._transform.projection.name === 'globe' ? 1 : Zr(O1, B1, t)) * i.a;
        }
        getOpacityAtLatLng(t, i) {
          return this._transform.projection.supportsFog
            ? (function (r, n, o) {
                const s = Me.fromLngLat(n),
                  a = o.elevation ? o.elevation.getAtPointOrZero(s) : 0;
                return N1(r, s.x, s.y, a, o);
              })(this.state, t, i)
            : 0;
        }
        getOpacityForTile(t) {
          if (!this._transform.projection.supportsFog) return [1, 1];
          const i = this._transform.calculateFogTileMatrix(t.toUnwrapped());
          return U1(this.state, i, 0, 0, lt, lt, this._transform);
        }
        getOpacityForBounds(t, i, r, n, o) {
          return this._transform.projection.supportsFog ? U1(this.state, t, i, r, n, o, this._transform) : [1, 1];
        }
        getFovAdjustedRange(t) {
          return this._transform.projection.supportsFog ? F1(this.state, t) : [0, 1];
        }
        isVisibleOnFrustum(t) {
          if (!this._transform.projection.supportsFog) return !1;
          const i = [4, 5, 6, 7];
          for (const r of i) {
            const n = t.points[r];
            let o;
            if (n[2] >= 0) o = n;
            else {
              const s = t.points[r - 4];
              o = pg(s, n, s[2] / (s[2] - n[2]));
            }
            if (N1(this.state, o[0], o[1], 0, this._transform) >= Is) return !0;
          }
          return !1;
        }
        updateTransitions(t) {
          this._transitioning = this._transitionable.transitioned(t, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(t) {
          this.properties = this._transitioning.possiblyEvaluate(t);
        }
        _validate(t, i, r) {
          return (!r || r.validate !== !1) && $c(this, t.call(la, Ft({ value: i, style: { glyphs: !0, sprite: !0 }, styleSpec: Q })));
        }
      }
      class HC {
        constructor(t) {
          (this._callback = t),
            (this._triggered = !1),
            typeof MessageChannel < 'u' &&
              ((this._channel = new MessageChannel()),
              (this._channel.port2.onmessage = () => {
                (this._triggered = !1), this._callback();
              }));
        }
        trigger() {
          this._triggered ||
            ((this._triggered = !0),
            this._channel
              ? this._channel.port1.postMessage(!0)
              : setTimeout(() => {
                  (this._triggered = !1), this._callback();
                }, 0));
        }
        remove() {
          (this._channel = void 0), (this._callback = () => {});
        }
      }
      class WC {
        constructor() {
          (this.tasks = {}), (this.taskQueue = []), ot(['process'], this), (this.invoker = new HC(this.process)), (this.nextId = 0);
        }
        add(t, i) {
          const r = this.nextId++,
            n = (function ({ type: o, isSymbolTile: s, zoom: a }) {
              return (a = a || 0), o === 'message' ? 0 : o !== 'maybePrepare' || s ? (o !== 'parseTile' || s ? (o === 'parseTile' && s ? 300 - a : o === 'maybePrepare' && s ? 400 - a : 500) : 200 - a) : 100 - a;
            })(i);
          if (n === 0) {
            ct();
            try {
              t();
            } finally {
            }
            return { cancel: () => {} };
          }
          return (
            (this.tasks[r] = { fn: t, metadata: i, priority: n, id: r }),
            this.taskQueue.push(r),
            this.invoker.trigger(),
            {
              cancel: () => {
                delete this.tasks[r];
              },
            }
          );
        }
        process() {
          ct();
          try {
            if (((this.taskQueue = this.taskQueue.filter((r) => !!this.tasks[r])), !this.taskQueue.length)) return;
            const t = this.pick();
            if (t === null) return;
            const i = this.tasks[t];
            if ((delete this.tasks[t], this.taskQueue.length && this.invoker.trigger(), !i)) return;
            i.fn();
          } finally {
          }
        }
        pick() {
          let t = null,
            i = 1 / 0;
          for (let n = 0; n < this.taskQueue.length; n++) {
            const o = this.tasks[this.taskQueue[n]];
            o.priority < i && ((i = o.priority), (t = n));
          }
          if (t === null) return null;
          const r = this.taskQueue[t];
          return this.taskQueue.splice(t, 1), r;
        }
        remove() {
          this.invoker.remove();
        }
      }
      class V1 {
        constructor(t, i, r) {
          (this.target = t), (this.parent = i), (this.mapId = r), (this.callbacks = {}), (this.cancelCallbacks = {}), ot(['receive'], this), this.target.addEventListener('message', this.receive, !1), (this.scheduler = new WC());
        }
        send(t, i, r, n, o = !1, s) {
          const a = Math.round(1e18 * Math.random())
            .toString(36)
            .substring(0, 10);
          r && ((r.metadata = s), (this.callbacks[a] = r));
          const l = new Set();
          return (
            this.target.postMessage({ id: a, type: t, hasCallback: !!r, targetMapId: n, mustQueue: o, sourceMapId: this.mapId, data: ua(i, l) }, l),
            {
              cancel: () => {
                r && delete this.callbacks[a], this.target.postMessage({ id: a, type: '<cancel>', targetMapId: n, sourceMapId: this.mapId });
              },
            }
          );
        }
        receive(t) {
          const i = t.data,
            r = i.id;
          if (r && (!i.targetMapId || this.mapId === i.targetMapId))
            if (i.type === '<cancel>') {
              const n = this.cancelCallbacks[r];
              delete this.cancelCallbacks[r], n && n.cancel();
            } else if (i.mustQueue || ct()) {
              const n = this.callbacks[r];
              this.cancelCallbacks[r] = this.scheduler.add(() => this.processTask(r, i), (n && n.metadata) || { type: 'message' });
            } else this.processTask(r, i);
        }
        processTask(t, i) {
          if (i.type === '<response>') {
            const r = this.callbacks[t];
            delete this.callbacks[t], r && (i.error ? r(ha(i.error)) : r(null, ha(i.data)));
          } else {
            const r = new Set(),
              n = i.hasCallback
                ? (s, a) => {
                    delete this.cancelCallbacks[t], this.target.postMessage({ id: t, type: '<response>', sourceMapId: this.mapId, error: s ? ua(s) : null, data: ua(a, r) }, r);
                  }
                : (s) => {},
              o = ha(i.data);
            if (this.parent[i.type]) this.parent[i.type](i.sourceMapId, o, n);
            else if (this.parent.getWorkerSource) {
              const s = i.type.split('.');
              this.parent.getWorkerSource(i.sourceMapId, s[0], o.source, o.scope)[s[1]](o, n);
            } else n(new Error(`Could not find function ${i.type}`));
          }
        }
        remove() {
          this.scheduler.remove(), this.target.removeEventListener('message', this.receive, !1);
        }
      }
      class Cs {
        constructor(t, i) {
          (this.workerPool = t), (this.actors = []), (this.currentActor = 0), (this.id = $r());
          const r = this.workerPool.acquire(this.id);
          for (let n = 0; n < r.length; n++) {
            const o = new Cs.Actor(r[n], i, this.id);
            (o.name = `Worker ${n}`), this.actors.push(o);
          }
          (this.ready = !1),
            this.broadcast('checkIfReady', null, () => {
              this.ready = !0;
            });
        }
        broadcast(t, i, r) {
          Yn(
            this.actors,
            (n, o) => {
              n.send(t, i, o);
            },
            (r = r || function () {})
          );
        }
        getActor() {
          return (this.currentActor = (this.currentActor + 1) % this.actors.length), this.actors[this.currentActor];
        }
        remove() {
          this.actors.forEach((t) => {
            t.remove();
          }),
            (this.actors = []),
            this.workerPool.release(this.id);
        }
      }
      Cs.Actor = V1;
      class j1 extends Oi {
        constructor(t, i, r, n) {
          super(), (this.scope = r), (this._options = t), (this.properties = new gl(i)), (this._transitionable = new _l(i, new Map(n))), this._transitionable.setTransitionOrValue(t.properties), (this._transitioning = this._transitionable.untransitioned());
        }
        updateConfig(t) {
          this._transitionable.setTransitionOrValue(this._options.properties, new Map(t));
        }
        updateTransitions(t) {
          this._transitioning = this._transitionable.transitioned(t, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(t) {
          this.properties = this._transitioning.possiblyEvaluate(t);
        }
        get() {
          return (this._options.properties = this._transitionable.serialize()), this._options;
        }
        set(t, i) {
          (this._options = t), this._transitionable.setTransitionOrValue(t.properties, i);
        }
        shadowsEnabled() {
          return !!this.properties && this.properties.get('cast-shadows') === !0;
        }
      }
      const XC = new Mi({ color: new vt(Q.properties_light_ambient.color), intensity: new vt(Q.properties_light_ambient.intensity) }),
        YC = new Mi({
          direction: new (class {
            constructor(e) {
              this.specification = e;
            }
            possiblyEvaluate(e, t) {
              return (function ([i, r]) {
                const n = ft([1, i, r]);
                return { x: n.x, y: n.y, z: n.z };
              })(e.expression.evaluate(t));
            }
            interpolate(e, t, i) {
              return { x: ee(e.x, t.x, i), y: ee(e.y, t.y, i), z: ee(e.z, t.z, i) };
            }
          })(Q.properties_light_directional.direction),
          color: new vt(Q.properties_light_directional.color),
          intensity: new vt(Q.properties_light_directional.intensity),
          'cast-shadows': new vt(Q.properties_light_directional['cast-shadows']),
          'shadow-intensity': new vt(Q.properties_light_directional['shadow-intensity']),
        });
      class sm {
        constructor(t, i, r, n) {
          (this.screenBounds = t), (this.cameraPoint = i), (this._screenRaycastCache = {}), (this._cameraRaycastCache = {}), (this.isAboveHorizon = r), (this.screenGeometry = this.bufferedScreenGeometry(0)), (this.screenGeometryMercator = this._bufferedScreenMercator(0, n));
        }
        static createFromScreenPoints(t, i) {
          let r, n;
          if (t instanceof H || typeof t[0] == 'number') {
            const o = H.convert(t);
            (r = [o]), (n = i.isPointAboveHorizon(o));
          } else {
            const o = H.convert(t[0]),
              s = H.convert(t[1]);
            (r = [o, s]), (n = yr(o, s).every((a) => i.isPointAboveHorizon(a)));
          }
          return new sm(r, i.getCameraPoint(), n, i);
        }
        isPointQuery() {
          return this.screenBounds.length === 1;
        }
        bufferedScreenGeometry(t) {
          return yr(this.screenBounds[0], this.screenBounds.length === 1 ? this.screenBounds[0] : this.screenBounds[1], t);
        }
        bufferedCameraGeometry(t) {
          const i = this.screenBounds[0],
            r = this.screenBounds.length === 1 ? this.screenBounds[0].add(new H(1, 1)) : this.screenBounds[1],
            n = yr(i, r, 0, !1);
          return (
            this.cameraPoint.y > r.y && (this.cameraPoint.x > i.x && this.cameraPoint.x < r.x ? n.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= r.x ? (n[2] = this.cameraPoint) : this.cameraPoint.x <= i.x && (n[3] = this.cameraPoint)),
            (function (o, s) {
              const a = [];
              for (let l = 0; l < o.length; l++) {
                const c = en(l - 1, -1, o.length - 1),
                  u = en(l + 1, -1, o.length - 1),
                  h = o[l],
                  d = o[u],
                  f = o[c].sub(h).unit(),
                  p = d.sub(h).unit(),
                  _ = p.angleWithSep(f.x, f.y),
                  g = f
                    .add(p)
                    .unit()
                    .mult((-1 * s) / Math.sin(_ / 2));
                a.push(h.add(g));
              }
              return a;
            })(n, t)
          );
        }
        bufferedCameraGeometryGlobe(t) {
          const i = this.screenBounds[0],
            r = this.screenBounds.length === 1 ? this.screenBounds[0].add(new H(1, 1)) : this.screenBounds[1],
            n = yr(i, r, t),
            o = this.cameraPoint.clone();
          switch (3 * ((o.y > i.y) + (o.y > r.y)) + ((o.x > i.x) + (o.x > r.x))) {
            case 0:
              (n[0] = o), (n[4] = o.clone());
              break;
            case 1:
              n.splice(1, 0, o);
              break;
            case 2:
              n[1] = o;
              break;
            case 3:
              n.splice(4, 0, o);
              break;
            case 5:
              n.splice(2, 0, o);
              break;
            case 6:
              n[3] = o;
              break;
            case 7:
              n.splice(3, 0, o);
              break;
            case 8:
              n[2] = o;
          }
          return n;
        }
        containsTile(t, i, r, n = 0) {
          const o = t.queryPadding / i._pixelsPerMercatorPixel + 1,
            s = r ? this._bufferedCameraMercator(o, i) : this._bufferedScreenMercator(o, i);
          let a = t.tileID.wrap + (s.unwrapped ? n : 0);
          const l = s.polygon.map((g) => wv(t.tileTransform, g, a));
          if (!vx(l, 0, 0, lt, lt)) return;
          a = t.tileID.wrap + (this.screenGeometryMercator.unwrapped ? n : 0);
          const c = this.screenGeometryMercator.polygon.map((g) => Tv(t.tileTransform, g, a)),
            u = c.map((g) => new H(g[0], g[1])),
            h = i.getFreeCameraOptions().position || new Me(0, 0, 0),
            d = Tv(t.tileTransform, h, a),
            f = c.map((g) => {
              const y = N.sub(g, g, d);
              return N.normalize(y, y), new cu(d, y);
            }),
            p = Ms(t, 1, i.zoom) * i._pixelsPerMercatorPixel;
          return { queryGeometry: this, tilespaceGeometry: u, tilespaceRays: f, bufferedTilespaceGeometry: l, bufferedTilespaceBounds: ((_ = _i(l)), (_.min.x = Bt(_.min.x, 0, lt)), (_.min.y = Bt(_.min.y, 0, lt)), (_.max.x = Bt(_.max.x, 0, lt)), (_.max.y = Bt(_.max.y, 0, lt)), _), tile: t, tileID: t.tileID, pixelToTileUnitsFactor: p };
          var _;
        }
        _bufferedScreenMercator(t, i) {
          const r = G1(t);
          if (this._screenRaycastCache[r]) return this._screenRaycastCache[r];
          {
            let n;
            return (n = i.projection.name === 'globe' ? this._projectAndResample(this.bufferedScreenGeometry(t), i) : { polygon: this.bufferedScreenGeometry(t).map((o) => i.pointCoordinate3D(o)), unwrapped: !0 }), (this._screenRaycastCache[r] = n), n;
          }
        }
        _bufferedCameraMercator(t, i) {
          const r = G1(t);
          if (this._cameraRaycastCache[r]) return this._cameraRaycastCache[r];
          {
            let n;
            return (n = i.projection.name === 'globe' ? this._projectAndResample(this.bufferedCameraGeometryGlobe(t), i) : { polygon: this.bufferedCameraGeometry(t).map((o) => i.pointCoordinate3D(o)), unwrapped: !0 }), (this._cameraRaycastCache[r] = n), n;
          }
        }
        _projectAndResample(t, i) {
          const r = (function (o, s) {
            const a = J.multiply([], s.pixelMatrix, s.globeMatrix),
              l = [0, -mr, 0, 1],
              c = [0, mr, 0, 1],
              u = [0, 0, 0, 1];
            We.transformMat4(l, l, a), We.transformMat4(c, c, a), We.transformMat4(u, u, a);
            const h = new H(l[0] / l[3], l[1] / l[3]),
              d = new H(c[0] / c[3], c[1] / c[3]),
              f = Vo(o, h) && l[3] < u[3],
              p = Vo(o, d) && c[3] < u[3];
            if (!f && !p) return null;
            const _ = (function (S, I, C) {
              for (let z = 1; z < S.length; z++) {
                const k = Kl(I.pointCoordinate3D(S[z - 1]).x),
                  O = Kl(I.pointCoordinate3D(S[z]).x);
                if (C < 0) {
                  if (k < O) return { idx: z, t: -k / (O - 1 - k) };
                } else if (O < k) return { idx: z, t: (1 - k) / (O + 1 - k) };
              }
              return null;
            })(o, s, f ? -1 : 1);
            if (!_) return null;
            const { idx: g, t: y } = _;
            let v = g > 1 ? am(o.slice(0, g), s) : [],
              w = g < o.length ? am(o.slice(g), s) : [];
            (v = v.map((S) => new H(Kl(S.x), S.y))), (w = w.map((S) => new H(Kl(S.x), S.y)));
            const T = [...v];
            T.length === 0 && T.push(w[w.length - 1]);
            const b = ee(T[T.length - 1].y, (w.length === 0 ? v[0] : w[0]).y, y);
            let E;
            return (E = f ? [new H(0, b), new H(0, 0), new H(1, 0), new H(1, b)] : [new H(1, b), new H(1, 1), new H(0, 1), new H(0, b)]), T.push(...E), w.length === 0 ? T.push(v[0]) : T.push(...w), { polygon: T.map((S) => new Me(S.x, S.y)), unwrapped: !1 };
          })(t, i);
          if (r) return r;
          const n = (function (o, s) {
            let a = !1,
              l = -1 / 0,
              c = 0;
            for (let h = 0; h < o.length - 1; h++) o[h].x > l && ((l = o[h].x), (c = h));
            for (let h = 0; h < o.length - 1; h++) {
              const d = (c + h) % (o.length - 1),
                f = o[d],
                p = o[d + 1];
              Math.abs(f.x - p.x) > 0.5 && (f.x < p.x ? ((f.x += 1), d === 0 && (o[o.length - 1].x += 1)) : ((p.x += 1), d + 1 === o.length - 1 && (o[0].x += 1)), (a = !0));
            }
            const u = qi(s.center.lng);
            return (
              a &&
                u < Math.abs(u - 1) &&
                o.forEach((h) => {
                  h.x -= 1;
                }),
              { polygon: o, unwrapped: a }
            );
          })(
            am(t, i).map((o) => new H(Kl(o.x), o.y)),
            i
          );
          return { polygon: n.polygon.map((o) => new Me(o.x, o.y)), unwrapped: n.unwrapped };
        }
      }
      function am(e, t) {
        return px(
          e,
          (i) => {
            const r = t.pointCoordinate3D(i);
            (i.x = r.x), (i.y = r.y);
          },
          1 / 256
        );
      }
      function Kl(e) {
        return e < 0 ? 1 + (e % 1) : e % 1;
      }
      function G1(e) {
        return (100 * e) | 0;
      }
      function lm(e, t, i, r, n) {
        const o = function (s, a) {
          if (s) return n(s);
          if (a) {
            e.url && a.tiles && e.tiles && delete e.tiles;
            const l = ar(Ft(a, e), ['tiles', 'minzoom', 'maxzoom', 'attribution', 'mapbox_logo', 'bounds', 'scheme', 'tileSize', 'encoding']);
            a.vector_layers && ((l.vectorLayers = a.vector_layers), (l.vectorLayerIds = l.vectorLayers.map((c) => c.id))), (l.tiles = t.canonicalizeTileset(l, e.url)), n(null, l);
          }
        };
        return e.url ? At(t.transformRequest(t.normalizeSourceURL(e.url, null, i, r), dt.Source), o) : oe.frame(() => o(null, e));
      }
      class ah {
        constructor(t, i, r) {
          (this.bounds = kr.convert(this.validateBounds(t))), (this.minzoom = i || 0), (this.maxzoom = r || 24);
        }
        validateBounds(t) {
          return Array.isArray(t) && t.length === 4 ? [Math.max(-180, t[0]), Math.max(-90, t[1]), Math.min(180, t[2]), Math.min(90, t[3])] : [-180, -90, 180, 90];
        }
        contains(t) {
          const i = Math.pow(2, t.z),
            r = Math.floor(qi(this.bounds.getWest()) * i),
            n = Math.floor(Hi(this.bounds.getNorth()) * i),
            o = Math.ceil(qi(this.bounds.getEast()) * i),
            s = Math.ceil(Hi(this.bounds.getSouth()) * i);
          return t.x >= r && t.x < o && t.y >= n && t.y < s;
        }
      }
      class q1 {
        constructor(t, i) {
          (this.width = t), (this.height = i), (this.nextRow = 0), (this.image = new fo({ width: t, height: i })), (this.positions = {}), (this.uploaded = !1);
        }
        getDash(t, i) {
          const r = this.getKey(t, i);
          return this.positions[r];
        }
        trim() {
          const t = this.width,
            i = (this.height = wo(this.nextRow));
          this.image.resize({ width: t, height: i });
        }
        getKey(t, i) {
          return t.join(',') + i;
        }
        getDashRanges(t, i, r) {
          const n = [];
          let o = t.length % 2 == 1 ? -t[t.length - 1] * r : 0,
            s = t[0] * r,
            a = !0;
          n.push({ left: o, right: s, isDash: a, zeroLength: t[0] === 0 });
          let l = t[0];
          for (let c = 1; c < t.length; c++) {
            a = !a;
            const u = t[c];
            (o = l * r), (l += u), (s = l * r), n.push({ left: o, right: s, isDash: a, zeroLength: u === 0 });
          }
          return n;
        }
        addRoundDash(t, i, r) {
          const n = i / 2;
          for (let o = -r; o <= r; o++) {
            const s = this.width * (this.nextRow + r + o);
            let a = 0,
              l = t[a];
            for (let c = 0; c < this.width; c++) {
              c / l.right > 1 && (l = t[++a]);
              const u = Math.abs(c - l.left),
                h = Math.abs(c - l.right),
                d = Math.min(u, h);
              let f;
              const p = (o / r) * (n + 1);
              if (l.isDash) {
                const _ = n - Math.abs(p);
                f = Math.sqrt(d * d + _ * _);
              } else f = n - Math.sqrt(d * d + p * p);
              this.image.data[s + c] = Math.max(0, Math.min(255, f + 128));
            }
          }
        }
        addRegularDash(t, i) {
          for (let l = t.length - 1; l >= 0; --l) {
            const c = t[l],
              u = t[l + 1];
            c.zeroLength ? t.splice(l, 1) : u && u.isDash === c.isDash && ((u.left = c.left), t.splice(l, 1));
          }
          const r = t[0],
            n = t[t.length - 1];
          r.isDash === n.isDash && ((r.left = n.left - this.width), (n.right = r.right + this.width));
          const o = this.width * this.nextRow;
          let s = 0,
            a = t[s];
          for (let l = 0; l < this.width; l++) {
            l / a.right > 1 && (a = t[++s]);
            const c = Math.abs(l - a.left),
              u = Math.abs(l - a.right),
              h = Math.min(c, u);
            this.image.data[o + l] = Math.max(0, Math.min(255, (a.isDash ? h : -h) + i + 128));
          }
        }
        addDash(t, i) {
          const r = this.getKey(t, i);
          if (this.positions[r]) return this.positions[r];
          const n = i === 'round',
            o = n ? 7 : 0,
            s = 2 * o + 1;
          if (this.nextRow + s > this.height) return B('LineAtlas out of space'), null;
          t.length === 0 && t.push(1);
          let a = 0;
          for (let u = 0; u < t.length; u++) t[u] < 0 && (B('Negative value is found in line dasharray, replacing values with 0'), (t[u] = 0)), (a += t[u]);
          if (a !== 0) {
            const u = this.width / a,
              h = this.getDashRanges(t, this.width, u);
            n ? this.addRoundDash(h, u, o) : this.addRegularDash(h, i === 'square' ? 0.5 * u : 0);
          }
          const l = this.nextRow + o;
          this.nextRow += s;
          const c = { tl: [l, o], br: [a, 0] };
          return (this.positions[r] = c), c;
        }
      }
      Gt(q1, 'LineAtlas');
      const Z1 = 1 * bn;
      class $1 {
        constructor(t) {
          const i = {},
            r = [];
          for (const a in t) {
            const l = t[a],
              c = (i[a] = {});
            for (const u in l.glyphs) {
              const h = l.glyphs[+u];
              if (!h || h.bitmap.width === 0 || h.bitmap.height === 0) continue;
              const d = h.metrics.localGlyph ? Z1 : 1,
                f = { x: 0, y: 0, w: h.bitmap.width + 2 * d, h: h.bitmap.height + 2 * d };
              r.push(f), (c[u] = f);
            }
          }
          const { w: n, h: o } = Fp(r),
            s = new fo({ width: n || 1, height: o || 1 });
          for (const a in t) {
            const l = t[a];
            for (const c in l.glyphs) {
              const u = l.glyphs[+c];
              if (!u || u.bitmap.width === 0 || u.bitmap.height === 0) continue;
              const h = i[a][c],
                d = u.metrics.localGlyph ? Z1 : 1;
              fo.copy(u.bitmap, s, { x: 0, y: 0 }, { x: h.x + d, y: h.y + d }, u.bitmap);
            }
          }
          (this.image = s), (this.positions = i);
        }
      }
      Gt($1, 'GlyphAtlas');
      class KC {
        constructor(t) {
          (this.tileID = new Le(t.tileID.overscaledZ, t.tileID.wrap, t.tileID.canonical.z, t.tileID.canonical.x, t.tileID.canonical.y)), (this.tileZoom = t.tileZoom), (this.uid = t.uid), (this.zoom = t.zoom), (this.canonical = t.tileID.canonical), (this.pixelRatio = t.pixelRatio), (this.tileSize = t.tileSize), (this.source = t.source), (this.scope = t.scope), (this.overscaling = this.tileID.overscaleFactor()), (this.showCollisionBoxes = t.showCollisionBoxes), (this.collectResourceTiming = !!t.collectResourceTiming), (this.promoteId = t.promoteId), (this.isSymbolTile = t.isSymbolTile), (this.tileTransform = Es(t.tileID.canonical, t.projection)), (this.projection = t.projection), (this.brightness = t.brightness), (this.extraShadowCaster = !!t.extraShadowCaster);
        }
        parse(t, i, r, n, o) {
          (this.status = 'parsing'), (this.data = t), (this.collisionBoxArray = new Uf());
          const s = new Bx(Object.keys(t.layers).sort()),
            a = new Lp(this.tileID, this.promoteId);
          a.bucketLayerIDs = [];
          const l = {},
            c = new q1(256, 256),
            u = { featureIndex: a, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, lineAtlas: c, availableImages: r, brightness: this.brightness },
            h = i.familiesBySource[this.source];
          for (const v in h) {
            const w = t.layers[v];
            if (!w) continue;
            let T = !1,
              b = !1,
              E = !1;
            for (const C of h[v]) C[0].type === 'symbol' ? (T = !0) : (b = !0), C[0].is3D() && C[0].type !== 'model' && (E = !0);
            if ((this.extraShadowCaster && !E) || (this.isSymbolTile === !0 && !T) || (this.isSymbolTile === !1 && !b)) continue;
            w.version === 1 && B(`Vector tile source "${this.source}" layer "${v}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
            const S = s.encode(v),
              I = [];
            for (let C = 0; C < w.length; C++) {
              const z = w.feature(C),
                k = a.getId(z, v);
              I.push({ feature: z, id: k, index: C, sourceLayerIndex: S });
            }
            for (const C of h[v]) {
              const z = C[0];
              (!this.extraShadowCaster || (z.is3D() && z.type !== 'model')) && ((this.isSymbolTile !== void 0 && (z.type === 'symbol') !== this.isSymbolTile) || (z.minzoom && this.zoom < Math.floor(z.minzoom)) || (z.maxzoom && this.zoom >= z.maxzoom) || (z.visibility !== 'none' && (cm(C, this.zoom, u.brightness, r), (l[z.id] = z.createBucket({ index: a.bucketLayerIDs.length, layers: C, zoom: this.zoom, canonical: this.canonical, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: S, sourceID: this.source, projection: this.projection.spec })).populate(I, u, this.tileID.canonical, this.tileTransform), a.bucketLayerIDs.push(C.map((k) => k.id)))));
            }
          }
          let d, f, p, _;
          c.trim();
          const g = { type: 'maybePrepare', isSymbolTile: this.isSymbolTile, zoom: this.zoom },
            y = () => {
              if (d) return (this.status = 'done'), o(d);
              if (this.extraShadowCaster) (this.status = 'done'), o(null, { buckets: hr(l).filter((v) => !v.isEmpty()), featureIndex: a, collisionBoxArray: null, glyphAtlasImage: null, lineAtlas: null, imageAtlas: null, brightness: u.brightness, glyphMap: null, iconMap: null, glyphPositions: null });
              else if (f && p && _) {
                const v = new $1(f),
                  w = new fv(p, _);
                for (const T in l) {
                  const b = l[T];
                  b instanceof Vl ? (cm(b.layers, this.zoom, u.brightness, r), HA(b, f, v.positions, p, w.iconPositions, this.showCollisionBoxes, r, this.tileID.canonical, this.tileZoom, this.projection, this.brightness)) : b.hasPattern && (b instanceof Hu || b instanceof Eu || b instanceof Xl) && (cm(b.layers, this.zoom, u.brightness, r), b.addFeatures(u, this.tileID.canonical, w.patternPositions, r, this.tileTransform, this.brightness));
                }
                (this.status = 'done'), o(null, { buckets: hr(l).filter((T) => !T.isEmpty()), featureIndex: a, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: v.image, lineAtlas: c, imageAtlas: w, brightness: u.brightness });
              }
            };
          if (!this.extraShadowCaster) {
            const v = zt(u.glyphDependencies, (b) => Object.keys(b).map(Number));
            Object.keys(v).length
              ? n.send(
                  'getGlyphs',
                  { uid: this.uid, stacks: v, scope: this.scope },
                  (b, E) => {
                    d || ((d = b), (f = E), y());
                  },
                  void 0,
                  !1,
                  g
                )
              : (f = {});
            const w = Object.keys(u.iconDependencies);
            w.length
              ? n.send(
                  'getImages',
                  { icons: w, source: this.source, scope: this.scope, tileID: this.tileID, type: 'icons' },
                  (b, E) => {
                    d || ((d = b), (p = E), y());
                  },
                  void 0,
                  !1,
                  g
                )
              : (p = {});
            const T = Object.keys(u.patternDependencies);
            T.length
              ? n.send(
                  'getImages',
                  { icons: T, source: this.source, scope: this.scope, tileID: this.tileID, type: 'patterns' },
                  (b, E) => {
                    d || ((d = b), (_ = E), y());
                  },
                  void 0,
                  !1,
                  g
                )
              : (_ = {});
          }
          y();
        }
      }
      function cm(e, t, i, r) {
        const n = new gi(t, { brightness: i });
        for (const o of e) o.recalculate(n, r);
      }
      class H1 {
        constructor(t) {
          (this.entries = {}), (this.scheduler = t);
        }
        request(t, i, r, n) {
          const o = (this.entries[t] = this.entries[t] || { callbacks: [] });
          if (o.result) {
            const [s, a] = o.result;
            return (
              this.scheduler
                ? this.scheduler.add(() => {
                    n(s, a);
                  }, i)
                : n(s, a),
              () => {}
            );
          }
          return (
            o.callbacks.push(n),
            o.cancel ||
              (o.cancel = r((s, a) => {
                o.result = [s, a];
                for (const l of o.callbacks)
                  this.scheduler
                    ? this.scheduler.add(() => {
                        l(s, a);
                      }, i)
                    : l(s, a);
                setTimeout(() => delete this.entries[t], 3e3);
              })),
            () => {
              o.result || ((o.callbacks = o.callbacks.filter((s) => s !== n)), o.callbacks.length || (o.cancel(), delete this.entries[t]));
            }
          );
        }
      }
      function W1(e, t, i) {
        const r = JSON.stringify(e.request);
        return (
          e.data && (this.deduped.entries[r] = { result: [null, e.data] }),
          this.deduped.request(
            r,
            { type: 'parseTile', isSymbolTile: e.isSymbolTile, zoom: e.tileZoom },
            (n) => {
              const o = Dt(e.request, (s, a, l, c) => {
                s ? n(s) : a && n(null, { vectorTile: i ? void 0 : new Dp(new Pu(a)), rawData: a, cacheControl: l, expires: c });
              });
              return () => {
                o.cancel(), n();
              };
            },
            t
          )
        );
      }
      class X1 extends Oi {
        constructor(t, i, r, n) {
          if ((super(), (this.id = t), (this.dispatcher = r), (this.type = 'vector'), (this.minzoom = 0), (this.maxzoom = 22), (this.scheme = 'xyz'), (this.tileSize = 512), (this.reparseOverscaled = !0), (this.isTileClipped = !0), (this._loaded = !1), Ft(this, ar(i, ['url', 'scheme', 'tileSize', 'promoteId'])), (this._options = Ft({ type: 'vector' }, i)), (this._collectResourceTiming = !!i.collectResourceTiming), this.tileSize !== 512)) throw new Error('vector tile sources must have a tileSize of 512');
          this.setEventedParent(n), (this._tileWorkers = {}), (this._deduped = new H1());
        }
        load(t) {
          (this._loaded = !1), this.fire(new wt('dataloading', { dataType: 'source' }));
          const i = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language,
            r = this.map._worldview;
          this._tileJSONRequest = lm(this._options, this.map._requestManager, i, r, (n, o) => {
            (this._tileJSONRequest = null), (this._loaded = !0), n ? (i && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i}`), r && r.length !== 2 && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${r}`), this.fire(new re(n))) : o && (Ft(this, o), o.bounds && (this.tileBounds = new ah(o.bounds, this.minzoom, this.maxzoom)), ld(o.tiles, this.map._requestManager._customAccessToken), this.fire(new wt('data', { dataType: 'source', sourceDataType: 'metadata' })), this.fire(new wt('data', { dataType: 'source', sourceDataType: 'content' }))), t && t(n);
          });
        }
        loaded() {
          return this._loaded;
        }
        hasTile(t) {
          return !this.tileBounds || this.tileBounds.contains(t.canonical);
        }
        onAdd(t) {
          (this.map = t), this.load();
        }
        reload() {
          this.cancelTileJSONRequest();
          const t = pr(this.id, this.scope);
          this.load(() => this.map.style.clearSource(t));
        }
        setTiles(t) {
          return (this._options.tiles = t), this.reload(), this;
        }
        setUrl(t) {
          return (this.url = t), (this._options.url = t), this.reload(), this;
        }
        onRemove() {
          this.cancelTileJSONRequest();
        }
        serialize() {
          return Ft({}, this._options);
        }
        loadTile(t, i) {
          const r = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme)),
            n = { request: this.map._requestManager.transformRequest(r, dt.Tile), data: void 0, uid: t.uid, tileID: t.tileID, tileZoom: t.tileZoom, zoom: t.tileID.overscaledZ, tileSize: this.tileSize * t.tileID.overscaleFactor(), type: this.type, source: this.id, scope: this.scope, pixelRatio: oe.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, isSymbolTile: t.isSymbolTile, brightness: (this.map.style && this.map.style.getBrightness()) || 0, extraShadowCaster: t.isExtraShadowCaster };
          if (((n.request.collectResourceTiming = this._collectResourceTiming), t.actor && t.state !== 'expired')) t.state === 'loading' ? (t.reloadCallback = i) : (t.request = t.actor.send('reloadTile', n, o.bind(this)));
          else if (((t.actor = this._tileWorkers[r] = this._tileWorkers[r] || this.dispatcher.getActor()), this.dispatcher.ready)) t.request = t.actor.send('loadTile', n, o.bind(this), void 0, !0);
          else {
            const s = W1.call(
              { deduped: this._deduped },
              n,
              (a, l) => {
                a || !l ? o.call(this, a) : ((n.data = { cacheControl: l.cacheControl, expires: l.expires, rawData: l.rawData.slice(0) }), t.actor && t.actor.send('loadTile', n, o.bind(this), void 0, !0));
              },
              !0
            );
            t.request = { cancel: s };
          }
          function o(s, a) {
            return delete t.request, t.aborted ? i(null) : s && s.status !== 404 ? i(s) : (a && a.resourceTiming && (t.resourceTiming = a.resourceTiming), this.map._refreshExpiredTiles && a && t.setExpiryData(a), t.loadVectorData(a, this.map.painter), Ws(this.dispatcher), i(null), void (t.reloadCallback && (this.loadTile(t, t.reloadCallback), (t.reloadCallback = null))));
          }
        }
        abortTile(t) {
          t.request && (t.request.cancel(), delete t.request), t.actor && t.actor.send('abortTile', { uid: t.uid, type: this.type, source: this.id, scope: this.scope });
        }
        unloadTile(t) {
          t.actor && t.actor.send('removeTile', { uid: t.uid, type: this.type, source: this.id, scope: this.scope }), t.destroy();
        }
        hasTransition() {
          return !1;
        }
        afterUpdate() {
          this._tileWorkers = {};
        }
        cancelTileJSONRequest() {
          this._tileJSONRequest && (this._tileJSONRequest.cancel(), (this._tileJSONRequest = null));
        }
      }
      class um extends Oi {
        constructor(t, i, r, n) {
          super(), (this.id = t), (this.dispatcher = r), this.setEventedParent(n), (this.type = 'raster'), (this.minzoom = 0), (this.maxzoom = 22), (this.roundZoom = !0), (this.scheme = 'xyz'), (this.tileSize = 512), (this._loaded = !1), (this._options = Ft({ type: 'raster' }, i)), Ft(this, ar(i, ['url', 'scheme', 'tileSize']));
        }
        load(t) {
          (this._loaded = !1),
            this.fire(new wt('dataloading', { dataType: 'source' })),
            (this._tileJSONRequest = lm(this._options, this.map._requestManager, null, null, (i, r) => {
              (this._tileJSONRequest = null), (this._loaded = !0), i ? this.fire(new re(i)) : r && (Ft(this, r), r.bounds && (this.tileBounds = new ah(r.bounds, this.minzoom, this.maxzoom)), ld(r.tiles), this.fire(new wt('data', { dataType: 'source', sourceDataType: 'metadata' })), this.fire(new wt('data', { dataType: 'source', sourceDataType: 'content' }))), t && t(i);
            }));
        }
        loaded() {
          return this._loaded;
        }
        onAdd(t) {
          (this.map = t), this.load();
        }
        reload() {
          this.cancelTileJSONRequest();
          const t = pr(this.id, this.scope);
          this.load(() => this.map.style.clearSource(t));
        }
        setTiles(t) {
          return (this._options.tiles = t), this.reload(), this;
        }
        setUrl(t) {
          return (this.url = t), (this._options.url = t), this.reload(), this;
        }
        onRemove() {
          this.cancelTileJSONRequest();
        }
        serialize() {
          return Ft({}, this._options);
        }
        hasTile(t) {
          return !this.tileBounds || this.tileBounds.contains(t.canonical);
        }
        loadTile(t, i) {
          const r = oe.devicePixelRatio >= 2,
            n = this.map._requestManager.normalizeTileURL(t.tileID.canonical.url(this.tiles, this.scheme), r, this.tileSize);
          t.request = de(this.map._requestManager.transformRequest(n, dt.Tile), (o, s, a, l) => (delete t.request, t.aborted ? ((t.state = 'unloaded'), i(null)) : o ? ((t.state = 'errored'), i(o)) : s ? (this.map._refreshExpiredTiles && t.setExpiryData({ cacheControl: a, expires: l }), t.setTexture(s, this.map.painter), (t.state = 'loaded'), Ws(this.dispatcher), void i(null)) : i(null)));
        }
        abortTile(t, i) {
          t.request && (t.request.cancel(), delete t.request), i();
        }
        unloadTile(t, i) {
          t.texture && t.texture instanceof vi ? (t.destroy(!0), t.texture && t.texture instanceof vi && this.map.painter.saveTileTexture(t.texture)) : t.destroy(), i();
        }
        hasTransition() {
          return !1;
        }
        cancelTileJSONRequest() {
          this._tileJSONRequest && (this._tileJSONRequest.cancel(), (this._tileJSONRequest = null));
        }
      }
      function JC() {
        return Ph.workerClass != null ? new Ph.workerClass() : new U.Worker(Ph.workerUrl);
      }
      const hm = 'mapboxgl_preloaded_worker_pool';
      class ka {
        constructor() {
          this.active = {};
        }
        acquire(t) {
          if (!this.workers) for (this.workers = []; this.workers.length < ka.workerCount; ) this.workers.push(new JC());
          return (this.active[t] = !0), this.workers.slice();
        }
        release(t) {
          delete this.active[t],
            this.workers &&
              this.numActive() === 0 &&
              (this.workers.forEach((i) => {
                i.terminate();
              }),
              (this.workers = null));
        }
        isPreloaded() {
          return !!this.active[hm];
        }
        numActive() {
          return Object.keys(this.active).length;
        }
      }
      let Jl;
      function Ql() {
        return Jl || (Jl = new ka()), Jl;
      }
      ka.workerCount = 2;
      let lh,
        dm,
        En,
        fm = null;
      function Y1() {
        return ct() && self.worker && self.worker.dracoUrl ? self.worker.dracoUrl : dm || Mt.DRACO_URL;
      }
      const pm = 5123,
        mm = 5126,
        _m = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, [pm]: Uint16Array, 5125: Uint32Array, [mm]: Float32Array },
        QC = { 5120: 'DT_INT8', 5121: 'DT_UINT8', 5122: 'DT_INT16', [pm]: 'DT_UINT16', 5125: 'DT_UINT32', [mm]: 'DT_FLOAT32' },
        gm = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 };
      function K1(e, t, i) {
        const r = i.json.bufferViews.length,
          n = i.buffers.length;
        (t.bufferView = r), (i.json.bufferViews[r] = { buffer: n, byteLength: e.byteLength }), (i.buffers[n] = e);
      }
      const ym = 'KHR_draco_mesh_compression';
      function tP(e, t) {
        const i = e.extensions && e.extensions[ym];
        if (!i) return;
        const r = new En.Decoder(),
          n = eb(t, i.bufferView),
          o = new En.Mesh();
        if (!r.DecodeArrayToMesh(n, n.byteLength, o)) throw new Error('Failed to decode Draco mesh');
        const s = t.json.accessors[e.indices],
          a = _m[s.componentType],
          l = s.count * a.BYTES_PER_ELEMENT,
          c = En._malloc(l);
        a === Uint16Array ? r.GetTrianglesUInt16Array(o, l, c) : r.GetTrianglesUInt32Array(o, l, c), K1(En.memory.buffer.slice(c, c + l), s, t), En._free(c);
        for (const u of Object.keys(i.attributes)) {
          const h = r.GetAttributeByUniqueId(o, i.attributes[u]),
            d = t.json.accessors[e.attributes[u]],
            f = QC[d.componentType],
            p = d.count * gm[d.type] * _m[d.componentType].BYTES_PER_ELEMENT,
            _ = En._malloc(p);
          r.GetAttributeDataArrayForAllPoints(o, h, En[f], p, _), K1(En.memory.buffer.slice(_, _ + p), d, t), En._free(_);
        }
        r.destroy(), o.destroy(), delete e.extensions[ym];
      }
      const J1 = 1179937895,
        Q1 = new TextDecoder('utf8');
      function tb(e, t) {
        return new URL(e, t).href;
      }
      function eP(e, t, i, r) {
        return fetch(tb(e.uri, r))
          .then((n) => n.arrayBuffer())
          .then((n) => {
            t.buffers[i] = n;
          });
      }
      function eb(e, t) {
        const i = e.json.bufferViews[t];
        return new Uint8Array(e.buffers[i.buffer], i.byteOffset || 0, i.byteLength);
      }
      function iP(e, t, i, r) {
        if (e.uri) {
          const n = tb(e.uri, r);
          return fetch(n)
            .then((o) => o.blob())
            .then((o) => U.createImageBitmap(o))
            .then((o) => {
              t.images[i] = o;
            });
        }
        if (e.bufferView !== void 0) {
          const n = eb(t, e.bufferView),
            o = new U.Blob([n], { type: e.mimeType });
          return U.createImageBitmap(o).then((s) => {
            t.images[i] = s;
          });
        }
      }
      function ib(e, t = 0, i) {
        const r = { json: null, images: [], buffers: [] };
        if (new Uint32Array(e, t, 1)[0] === J1) {
          const c = new Uint32Array(e, t);
          let u = 2;
          const h = (c[u++] >> 2) - 3,
            d = c[u++] >> 2;
          if ((u++, (r.json = JSON.parse(Q1.decode(c.subarray(u, u + d)))), (u += d), u < h)) {
            const f = c[u++];
            u++;
            const p = t + (u << 2);
            r.buffers[0] = e.slice(p, p + f);
          }
        } else r.json = JSON.parse(Q1.decode(new Uint8Array(e, t)));
        const { buffers: n, images: o, meshes: s, extensionsUsed: a } = r.json;
        let l = Promise.resolve();
        if (n) {
          const c = [];
          for (let u = 0; u < n.length; u++) {
            const h = n[u];
            h.uri ? c.push(eP(h, r, u, i)) : r.buffers[u] || (r.buffers[u] = null);
          }
          l = Promise.all(c);
        }
        return l.then(() => {
          const c = [],
            u = a && a.includes(ym);
          if (
            (u &&
              c.push(
                (function () {
                  if (!En)
                    return (
                      lh ||
                      ((lh = (function (h) {
                        let d,
                          f = null;
                        function p() {
                          d = new Uint8Array(f.buffer);
                        }
                        function _() {
                          throw new Error('Unexpected Draco error.');
                        }
                        const g = {
                          a: {
                            a: _,
                            d: function (y, v, w) {
                              return d.copyWithin(y, v, v + w);
                            },
                            c: function (y) {
                              const v = d.length,
                                w = Math.max(y >>> 0, Math.ceil(1.2 * v)),
                                T = Math.ceil((w - v) / 65536);
                              try {
                                return f.grow(T), p(), !0;
                              } catch {
                                return !1;
                              }
                            },
                            b: _,
                          },
                        };
                        return (WebAssembly.instantiateStreaming ? WebAssembly.instantiateStreaming(h, g) : h.then((y) => y.arrayBuffer()).then((y) => WebAssembly.instantiate(y, g))).then((y) => {
                          const { Rb: v, Qb: w, P: T, T: b, X: E, Ja: S, La: I, Qa: C, Va: z, Wa: k, eb: O, jb: V, f: R, e: G, yb: Z, zb: X, Ab: j, Bb: q, Db: it, Gb: st } = y.instance.exports;
                          f = G;
                          const nt = (() => {
                            let ut = 0,
                              ht = 0,
                              pt = 0,
                              at = 0;
                            return (_t) => {
                              pt && (v(at), v(ut), (ht += pt), (pt = ut = 0)), ut || ((ht += 128), (ut = w(ht)));
                              const Ct = (_t.length + 7) & -8;
                              let Pt = ut;
                              Ct >= ht && ((pt = Ct), (Pt = at = w(Ct)));
                              for (let Ot = 0; Ot < _t.length; Ot++) d[Pt + Ot] = _t[Ot];
                              return Pt;
                            };
                          })();
                          return (
                            p(),
                            R(),
                            {
                              memory: G,
                              _free: v,
                              _malloc: w,
                              Mesh: class {
                                constructor() {
                                  this.ptr = T();
                                }
                                destroy() {
                                  b(this.ptr);
                                }
                              },
                              Decoder: class {
                                constructor() {
                                  this.ptr = S();
                                }
                                destroy() {
                                  V(this.ptr);
                                }
                                DecodeArrayToMesh(ut, ht, pt) {
                                  const at = nt(ut),
                                    _t = I(this.ptr, at, ht, pt.ptr);
                                  return !!E(_t);
                                }
                                GetAttributeByUniqueId(ut, ht) {
                                  return { ptr: C(this.ptr, ut.ptr, ht) };
                                }
                                GetTrianglesUInt16Array(ut, ht, pt) {
                                  z(this.ptr, ut.ptr, ht, pt);
                                }
                                GetTrianglesUInt32Array(ut, ht, pt) {
                                  k(this.ptr, ut.ptr, ht, pt);
                                }
                                GetAttributeDataArrayForAllPoints(ut, ht, pt, at, _t) {
                                  O(this.ptr, ut.ptr, ht.ptr, pt, at, _t);
                                }
                              },
                              DT_INT8: Z(),
                              DT_UINT8: X(),
                              DT_INT16: j(),
                              DT_UINT16: q(),
                              DT_UINT32: it(),
                              DT_FLOAT32: st(),
                            }
                          );
                        });
                      })(fetch(Y1()))),
                      lh.then((h) => {
                        (En = h), (lh = void 0);
                      }))
                    );
                })()
              ),
            o)
          )
            for (let h = 0; h < o.length; h++) c.push(iP(o[h], r, h, i));
          return (c.length ? Promise.all(c) : Promise.resolve()).then(() => {
            if (u && s) for (const { primitives: h } of s) for (const d of h) tP(d, r);
            return r;
          });
        });
      }
      function rb(e) {
        return fetch(e)
          .then((t) => t.arrayBuffer())
          .then((t) => ib(t, 0, e));
      }
      class nb {
        constructor(t, i, r) {
          if (((this.triangleCount = i.length / 3), (this.min = new H(0, 0)), (this.max = new H(0, 0)), (this.xScale = 0), (this.yScale = 0), (this.cellsX = 0), (this.cellsY = 0), (this.cells = []), (this.payload = []), this.triangleCount === 0 || t.length === 0 || r === 0)) return;
          const n = t.map((u) => u.x),
            o = t.map((u) => u.y);
          (this.min = new H(Math.min(...n), Math.min(...o))), (this.max = new H(Math.max(...n), Math.max(...o)));
          const s = this.max.sub(this.min);
          (s.x = Math.max(s.x, 1)), (s.y = Math.max(s.y, 1));
          const a = Math.max(s.x, s.y) / r;
          (this.cellsX = Math.max(1, Math.ceil(s.x / a))), (this.cellsY = Math.max(1, Math.ceil(s.y / a))), (this.xScale = 1 / a), (this.yScale = 1 / a);
          const l = [];
          for (let u = 0; u < this.triangleCount; u++) {
            const h = t[i[3 * u + 0]].sub(this.min),
              d = t[i[3 * u + 1]].sub(this.min),
              f = t[i[3 * u + 2]].sub(this.min),
              p = Yo(Math.floor(Math.min(h.x, d.x, f.x)), this.xScale, this.cellsX),
              _ = Yo(Math.floor(Math.max(h.x, d.x, f.x)), this.xScale, this.cellsX),
              g = Yo(Math.floor(Math.min(h.y, d.y, f.y)), this.yScale, this.cellsY),
              y = Yo(Math.floor(Math.max(h.y, d.y, f.y)), this.yScale, this.cellsY),
              v = new H(0, 0),
              w = new H(0, 0),
              T = new H(0, 0),
              b = new H(0, 0);
            for (let E = g; E <= y; ++E) {
              (v.y = w.y = E * a), (T.y = b.y = (E + 1) * a);
              for (let S = p; S <= _; ++S) (v.x = T.x = S * a), (w.x = b.x = (S + 1) * a), (Tp(h, d, f, v, w, b) || Tp(h, d, f, v, b, T)) && l.push({ cellIdx: E * this.cellsX + S, triIdx: u });
            }
          }
          if (l.length === 0) return;
          l.sort((u, h) => u.cellIdx - h.cellIdx || u.triIdx - h.triIdx);
          let c = 0;
          for (; c < l.length; ) {
            const u = l[c].cellIdx,
              h = { start: this.payload.length, len: 0 };
            for (; c < l.length && l[c].cellIdx === u; ) ++h.len, this.payload.push(l[c++].triIdx);
            this.cells[u] = h;
          }
        }
        query(t, i, r) {
          if (this.triangleCount === 0 || this.cells.length === 0 || t.x > this.max.x || this.min.x > i.x || t.y > this.max.y || this.min.y > i.y) return;
          this.lookup || (this.lookup = new Uint8Array(Math.ceil(this.triangleCount / 8)));
          for (let l = 0; l < this.lookup.length; l++) this.lookup[l] = 0;
          const n = Yo(t.x - this.min.x, this.xScale, this.cellsX),
            o = Yo(i.x - this.min.x, this.xScale, this.cellsX),
            s = Yo(t.y - this.min.y, this.yScale, this.cellsY),
            a = Yo(i.y - this.min.y, this.yScale, this.cellsY);
          for (let l = s; l <= a; l++)
            for (let c = n; c <= o; c++) {
              const u = this.cells[l * this.cellsX + c];
              if (u)
                for (let h = 0; h < u.len; h++) {
                  const d = this.payload[u.start + h],
                    f = Math.floor(d / 8),
                    p = 1 << d % 8;
                  if (!(this.lookup[f] & p) && ((this.lookup[f] |= p), r.push(d), r.length === this.triangleCount)) return;
                }
            }
        }
      }
      function Yo(e, t, i) {
        return Math.max(0, Math.min(i - 1, Math.floor(e * t)));
      }
      function Ps(e, t) {
        const i = e.json.bufferViews[t.bufferView];
        return new _m[t.componentType](e.buffers[i.buffer], (t.byteOffset || 0) + (i.byteOffset || 0), t.count * gm[t.type]);
      }
      function rP(e, t, i) {
        const r = e.indices,
          n = e.attributes,
          o = {};
        o.indexArray = new Fi();
        const s = t.json.accessors[r],
          a = s.count / 3;
        o.indexArray.reserve(a);
        const l = Ps(t, s);
        for (let d = 0; d < a; d++) o.indexArray.emplaceBack(l[3 * d], l[3 * d + 1], l[3 * d + 2]);
        o.indexArray._trim(), (o.vertexArray = new xs());
        const c = t.json.accessors[n.POSITION];
        o.vertexArray.reserve(c.count);
        const u = Ps(t, c);
        for (let d = 0; d < c.count; d++) o.vertexArray.emplaceBack(u[3 * d], u[3 * d + 1], u[3 * d + 2]);
        if (
          (o.vertexArray._trim(),
          (o.aabb = new ni(c.min, c.max)),
          (o.centroid = (function (d, f) {
            const p = [0, 0, 0],
              _ = d.length;
            if (_ > 0) {
              for (let g = 0; g < _; g++) {
                const y = 3 * d[g];
                (p[0] += f[y]), (p[1] += f[y + 1]), (p[2] += f[y + 2]);
              }
              (p[0] /= _), (p[1] /= _), (p[2] /= _);
            }
            return p;
          })(l, u)),
          n.COLOR_0 !== void 0)
        ) {
          const d = t.json.accessors[n.COLOR_0],
            f = gm[d.type];
          if (d.componentType === mm) {
            (o.colorArray = f === 3 ? new xs() : new ro()), o.colorArray.reserve(d.count);
            const p = Ps(t, d);
            if (f === 3) for (let _ = 0; _ < d.count; _++) o.colorArray.emplaceBack(p[3 * _], p[3 * _ + 1], p[3 * _ + 2]);
            else for (let _ = 0; _ < d.count; _++) o.colorArray.emplaceBack(p[4 * _], p[4 * _ + 1], p[4 * _ + 2], p[4 * _ + 3]);
            o.colorArray._trim();
          } else if (d.componentType === pm && f === 4) {
            (o.colorArray = new ro()), o.colorArray.resize(d.count);
            const p = Ps(t, d),
              _ = 1 / 65535,
              g = o.colorArray.float32;
            for (let y = 0; y < 4 * p.length; ++y) g[y] = p[y] * _;
          } else B(`glTF color buffer parsing for accessor ${JSON.stringify(d)} is not supported`);
        }
        if (n.NORMAL !== void 0) {
          o.normalArray = new xs();
          const d = t.json.accessors[n.NORMAL];
          o.normalArray.reserve(d.count);
          const f = Ps(t, d);
          for (let p = 0; p < d.count; p++) o.normalArray.emplaceBack(f[3 * p], f[3 * p + 1], f[3 * p + 2]);
          o.normalArray._trim();
        }
        if (n.TEXCOORD_0 !== void 0 && i.length > 0) {
          o.texcoordArray = new bl();
          const d = t.json.accessors[n.TEXCOORD_0];
          o.texcoordArray.reserve(d.count);
          const f = Ps(t, d);
          for (let p = 0; p < d.count; p++) o.texcoordArray.emplaceBack(f[2 * p], f[2 * p + 1]);
          o.texcoordArray._trim();
        }
        const h = e.material;
        return (
          (o.material = (function (d, f) {
            const { emissiveFactor: p = [0, 0, 0], alphaMode: _ = 'OPAQUE', alphaCutoff: g = 0.5, normalTexture: y, occlusionTexture: v, emissiveTexture: w, doubleSided: T } = d,
              { baseColorFactor: b = [1, 1, 1, 1], metallicFactor: E = 1, roughnessFactor: S = 1, baseColorTexture: I, metallicRoughnessTexture: C } = d.pbrMetallicRoughness || {};
            return { pbrMetallicRoughness: { baseColorFactor: new pe(...b), metallicFactor: E, roughnessFactor: S, baseColorTexture: I ? f[I.index] : void 0, metallicRoughnessTexture: C ? f[C.index] : void 0 }, doubleSided: T, emissiveFactor: p, alphaMode: _, alphaCutoff: g, normalTexture: y ? f[y.index] : void 0, occlusionTexture: v ? f[v.index] : void 0, emissionTexture: w ? f[w.index] : void 0, defined: d.defined === void 0 };
          })(h !== void 0 ? t.json.materials[h] : { defined: !1 }, i)),
          n._FEATURE_RGBA4444 !== void 0 && (o.featureData = new Uint32Array(Ps(t, t.json.accessors[n._FEATURE_RGBA4444]).buffer)),
          o
        );
      }
      function ob(e, t, i) {
        const { matrix: r, rotation: n, translation: o, scale: s, mesh: a, extras: l, children: c } = e,
          u = {};
        if (((u.matrix = r || J.fromRotationTranslationScale([], n || [0, 0, 0, 1], o || [0, 0, 0], s || [1, 1, 1])), a !== void 0)) {
          u.meshes = i[a];
          const h = (u.anchor = [0, 0]);
          for (const d of u.meshes) {
            const { min: f, max: p } = d.aabb;
            (h[0] += f[0] + p[0]), (h[1] += f[1] + p[1]);
          }
          (h[0] = Math.floor(h[0] / u.meshes.length / 2)), (h[1] = Math.floor(h[1] / u.meshes.length / 2));
        }
        if (
          (l &&
            (l.id && (u.id = l.id),
            l.lights &&
              (u.lights = (function (h) {
                if (!h.length) return [];
                const d = (function (y) {
                    const v = atob(y),
                      w = new Uint8Array(v.length);
                    for (let T = 0; T < v.length; T++) w[T] = v.codePointAt(T);
                    return w;
                  })(h),
                  f = [],
                  p = d.length / 24,
                  _ = new Uint16Array(d.buffer),
                  g = new Float32Array(d.buffer);
                for (let y = 0; y < p; y++) {
                  const v = _[2 * y * 6] / 30,
                    w = _[2 * y * 6 + 1] / 30,
                    T = _[2 * y * 6 + 10] / 100,
                    b = g[6 * y + 1],
                    E = g[6 * y + 2],
                    S = g[6 * y + 3],
                    I = g[6 * y + 4],
                    C = S - b,
                    z = I - E,
                    k = Math.hypot(C, z);
                  f.push({ pos: [b + 0.5 * C, E + 0.5 * z, w], normal: [z / k, -C / k, 0], width: k, height: v, depth: T, points: [b, E, S, I] });
                }
                return f;
              })(l.lights))),
          c)
        ) {
          const h = [];
          for (const d of c) h.push(ob(t.json.nodes[d], t, i));
          u.children = h;
        }
        return u;
      }
      function nP(e) {
        if (e.vertices.length === 0 || e.indices.length === 0) return null;
        const [t, i] = [e.vertices[0].clone(), e.vertices[0].clone()];
        for (let s = 1; s < e.vertices.length; ++s) {
          const a = e.vertices[s];
          (t.x = Math.min(t.x, a.x)), (t.y = Math.min(t.y, a.y)), (i.x = Math.max(i.x, a.x)), (i.y = Math.max(i.y, a.y));
        }
        const r = Math.ceil(Math.max(i.x - t.x, i.y - t.y) / 256),
          n = Math.max(8, r),
          o = new nb(e.vertices, e.indices, n);
        return { vertices: e.vertices, indices: e.indices, grid: o, min: t, max: i };
      }
      function oP(e) {
        if (!e.extras || !e.extras.ground) return null;
        const t = e.extras.ground;
        if (!t || !Array.isArray(t) || t.length === 0) return null;
        const i = t[0];
        if (!i || !Array.isArray(i) || i.length === 0) return null;
        const r = [];
        for (const s of i) {
          if (!Array.isArray(s) || s.length !== 2) continue;
          const a = s[0],
            l = s[1];
          typeof a == 'number' && typeof l == 'number' && r.push(new H(a, l));
        }
        if (r.length < 3) return null;
        r.length > 1 && r[r.length - 1].equals(r[0]) && r.pop();
        let n = 0;
        for (let s = 0; s < r.length; s++) {
          const a = r[s],
            l = r[(s + 1) % r.length],
            c = r[(s + 2) % r.length];
          n += (a.x - l.x) * (c.y - l.y) - (c.x - l.x) * (a.y - l.y);
        }
        n > 0 && r.reverse();
        const o = Tu(
          r.flatMap((s) => [s.x, s.y]),
          []
        );
        return o.length === 0 ? null : { vertices: r, indices: o };
      }
      function sP(e) {
        const t = [],
          i = [];
        let r = 0;
        for (const n of e) {
          r = t.length;
          const o = n.vertexArray.float32,
            s = n.indexArray.uint16;
          for (let a = 0; a < n.vertexArray.length; a++) t.push(new H(o[3 * a + 0], o[3 * a + 1]));
          for (let a = 0; a < 3 * n.indexArray.length; a++) i.push(s[a] + r);
        }
        if (i.length % 3 != 0) return null;
        for (let n = 0; n < i.length; n += 3) {
          const o = t[i[n + 0]],
            s = t[i[n + 1]],
            a = t[i[n + 2]];
          (o.x - s.x) * (a.y - s.y) - (a.x - s.x) * (o.y - s.y) > 0 && ([i[n + 1], i[n + 2]] = [i[n + 2], i[n + 1]]);
        }
        return { vertices: t, indices: i };
      }
      function xm(e) {
        const t = (function (l, c) {
            const u = [],
              h = U.WebGL2RenderingContext;
            if (l.json.textures)
              for (const d of l.json.textures) {
                const f = { magFilter: h.LINEAR, minFilter: h.NEAREST, wrapS: h.REPEAT, wrapT: h.REPEAT };
                d.sampler !== void 0 && Object.assign(f, l.json.samplers[d.sampler]), u.push({ image: c[d.source], sampler: f, uploaded: !1 });
              }
            return u;
          })(e, e.images),
          i = (function (l, c) {
            const u = [];
            for (const h of l.json.meshes) {
              const d = [];
              for (const f of h.primitives) d.push(rP(f, l, c));
              u.push(d);
            }
            return u;
          })(e, t),
          { scenes: r, scene: n, nodes: o } = e.json,
          s = r ? r[n || 0].nodes : o,
          a = [];
        for (const l of s) a.push(ob(o[l], e, i));
        return (
          (function (l, c, u) {
            const h = {},
              d = new Set();
            for (let f = 0; f < l.length; f++) {
              const p = u[c[f]];
              if (!p.extras) continue;
              const _ = p.extras['mapbox:footprint:version'],
                g = p.extras['mapbox:footprint:id'];
              (_ || g) && d.add(f), _ === '1.0.0' && g && (h[g] = f);
            }
            for (let f = 0; f < l.length; f++) {
              if (d.has(f)) continue;
              const p = l[f],
                _ = u[c[f]];
              if (!_.extras) continue;
              let g = null;
              p.id in h && (g = sP(l[h[p.id]].meshes)), g || (g = oP(_)), g && (p.footprint = nP(g));
            }
            if (d.size > 0) {
              const f = Array.from(d.values()).sort((p, _) => p - _);
              for (let p = f.length - 1; p >= 0; p--) l.splice(f[p], 1);
            }
          })(a, s, e.json.nodes),
          a
        );
      }
      function aP(e) {
        (e.heightmap = new Float32Array(4096)), e.heightmap.fill(-1);
        const t = e.vertexArray.float32,
          i = e.aabb.min[0] - 1,
          r = e.aabb.min[1] - 1,
          n = Ss / (e.aabb.max[0] - i + 2),
          o = Ss / (e.aabb.max[1] - r + 2);
        for (let s = 0; s < t.length; s += 3) {
          const a = t[s + 2],
            l = ((t[s + 0] - i) * n) | 0,
            c = ((t[s + 1] - r) * o) | 0;
          a > e.heightmap[c * Ss + l] && (e.heightmap[c * Ss + l] = a);
        }
      }
      function lP(e, t) {
        const i = {};
        (i.indexArray = new Fi()), i.indexArray.reserve(4 * e.length), (i.vertexArray = new xs()), i.vertexArray.reserve(10 * e.length), (i.colorArray = new ro()), i.vertexArray.reserve(10 * e.length);
        let r = 0;
        for (const s of e) {
          const a = Math.min(10, Math.max(4, 1.3 * s.height)) * t,
            l = [-s.normal[1], s.normal[0], 0],
            c = Math.min(0.29, (0.1 * s.width) / s.depth),
            u = s.width - 2 * s.depth * t * (c + 0.01),
            h = N.scaleAndAdd([], s.pos, l, u / 2),
            d = N.scaleAndAdd([], s.pos, l, -u / 2),
            f = [h[0], h[1], h[2] + s.height],
            p = [d[0], d[1], d[2] + s.height],
            _ = N.scaleAndAdd([], s.normal, l, c);
          N.scale(_, _, a);
          const g = N.scaleAndAdd([], s.normal, l, -c);
          N.scale(g, g, a), N.add(_, h, _), N.add(g, d, g), (h[2] += 0.1), (d[2] += 0.1), i.vertexArray.emplaceBack(_[0], _[1], _[2]), i.vertexArray.emplaceBack(g[0], g[1], g[2]), i.vertexArray.emplaceBack(h[0], h[1], h[2]), i.vertexArray.emplaceBack(d[0], d[1], d[2]), i.vertexArray.emplaceBack(f[0], f[1], f[2]), i.vertexArray.emplaceBack(p[0], p[1], p[2]), i.vertexArray.emplaceBack(h[0], h[1], h[2]), i.vertexArray.emplaceBack(d[0], d[1], d[2]), i.vertexArray.emplaceBack(_[0], _[1], _[2]), i.vertexArray.emplaceBack(g[0], g[1], g[2]);
          const y = u / a / 2;
          i.colorArray.emplaceBack(-y - c, -1, y, 0.8), i.colorArray.emplaceBack(y + c, -1, y, 0.8), i.colorArray.emplaceBack(-y, 0, y, 1.3), i.colorArray.emplaceBack(y, 0, y, 1.3), i.colorArray.emplaceBack(y + c, -0.8, y, 0.7), i.colorArray.emplaceBack(y + c, -0.8, y, 0.7), i.colorArray.emplaceBack(0, 0, y, 1.3), i.colorArray.emplaceBack(0, 0, y, 1.3), i.colorArray.emplaceBack(y + c, -1.2, y, 0.8), i.colorArray.emplaceBack(y + c, -1.2, y, 0.8), i.indexArray.emplaceBack(6 + r, 4 + r, 8 + r), i.indexArray.emplaceBack(7 + r, 9 + r, 5 + r), i.indexArray.emplaceBack(0 + r, 1 + r, 2 + r), i.indexArray.emplaceBack(1 + r, 3 + r, 2 + r), (r += 10);
        }
        const n = { defined: !0, emissiveFactor: [0, 0, 0] },
          o = {};
        return (o.baseColorFactor = pe.white), (n.pbrMetallicRoughness = o), (i.material = n), (i.aabb = new ni([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0])), i;
      }
      Gt(nb, 'TriangleGridIndex');
      const vm = {
          vector: X1,
          raster: um,
          'raster-dem': class extends um {
            constructor(e, t, i, r) {
              super(e, t, i, r), (this.type = 'raster-dem'), (this.maxzoom = 22), (this._options = Ft({ type: 'raster-dem' }, t)), (this.encoding = t.encoding || 'mapbox');
            }
            loadTile(e, t) {
              const i = this.map._requestManager.normalizeTileURL(e.tileID.canonical.url(this.tiles, this.scheme), !1, this.tileSize);
              function r(n, o) {
                n && ((e.state = 'errored'), t(n)), o && ((e.dem = o), e.dem.onDeserialize(), (e.needsHillshadePrepare = !0), (e.needsDEMTextureUpload = !0), (e.state = 'loaded'), t(null));
              }
              e.request = de(
                this.map._requestManager.transformRequest(i, dt.Tile),
                function (n, o, s, a) {
                  if ((delete e.request, e.aborted)) (e.state = 'unloaded'), t(null);
                  else if (n) (e.state = 'errored'), t(n);
                  else if (o) {
                    this.map._refreshExpiredTiles && e.setExpiryData({ cacheControl: s, expires: a });
                    const c = U.ImageBitmap && o instanceof U.ImageBitmap && V_(),
                      u = 1 - (o.width - ((l = o.width) <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(l) / Math.LN2)))) / 2;
                    u < 1 || e.neighboringTiles || (e.neighboringTiles = this._getNeighboringTiles(e.tileID));
                    const h = c ? o : oe.getImageData(o, u),
                      d = { uid: e.uid, coord: e.tileID, source: this.id, scope: this.scope, rawImageData: h, encoding: this.encoding, padding: u };
                    (e.actor && e.state !== 'expired') || ((e.actor = this.dispatcher.getActor()), e.actor.send('loadDEMTile', d, r.bind(this), void 0, !0));
                  }
                  var l;
                }.bind(this)
              );
            }
            _getNeighboringTiles(e) {
              const t = e.canonical,
                i = Math.pow(2, t.z),
                r = (t.x - 1 + i) % i,
                n = t.x === 0 ? e.wrap - 1 : e.wrap,
                o = (t.x + 1 + i) % i,
                s = t.x + 1 === i ? e.wrap + 1 : e.wrap,
                a = {};
              return (a[new Le(e.overscaledZ, n, t.z, r, t.y).key] = { backfilled: !1 }), (a[new Le(e.overscaledZ, s, t.z, o, t.y).key] = { backfilled: !1 }), t.y > 0 && ((a[new Le(e.overscaledZ, n, t.z, r, t.y - 1).key] = { backfilled: !1 }), (a[new Le(e.overscaledZ, e.wrap, t.z, t.x, t.y - 1).key] = { backfilled: !1 }), (a[new Le(e.overscaledZ, s, t.z, o, t.y - 1).key] = { backfilled: !1 })), t.y + 1 < i && ((a[new Le(e.overscaledZ, n, t.z, r, t.y + 1).key] = { backfilled: !1 }), (a[new Le(e.overscaledZ, e.wrap, t.z, t.x, t.y + 1).key] = { backfilled: !1 }), (a[new Le(e.overscaledZ, s, t.z, o, t.y + 1).key] = { backfilled: !1 })), a;
            }
          },
          geojson: class extends Oi {
            constructor(e, t, i, r) {
              super(), (this.id = e), (this.type = 'geojson'), (this.minzoom = 0), (this.maxzoom = 18), (this.tileSize = 512), (this.isTileClipped = !0), (this.reparseOverscaled = !0), (this._loaded = !1), (this.actor = i.getActor()), this.setEventedParent(r), (this._data = t.data), (this._options = Ft({}, t)), (this._collectResourceTiming = t.collectResourceTiming), t.maxzoom !== void 0 && (this.maxzoom = t.maxzoom), t.type && (this.type = t.type), t.attribution && (this.attribution = t.attribution), (this.promoteId = t.promoteId);
              const n = lt / this.tileSize;
              this.workerOptions = Ft({ source: this.id, scope: this.scope, cluster: t.cluster || !1, geojsonVtOptions: { buffer: (t.buffer !== void 0 ? t.buffer : 128) * n, tolerance: (t.tolerance !== void 0 ? t.tolerance : 0.375) * n, extent: lt, maxZoom: this.maxzoom, lineMetrics: t.lineMetrics || !1, generateId: t.generateId || !1 }, superclusterOptions: { maxZoom: t.clusterMaxZoom !== void 0 ? t.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, t.clusterMinPoints || 2), extent: lt, radius: (t.clusterRadius !== void 0 ? t.clusterRadius : 50) * n, log: !1, generateId: t.generateId || !1 }, clusterProperties: t.clusterProperties, filter: t.filter }, t.workerOptions);
            }
            onAdd(e) {
              (this.map = e), this.setData(this._data);
            }
            setData(e) {
              return (this._data = e), this._updateWorkerData(), this;
            }
            getClusterExpansionZoom(e, t) {
              return this.actor.send('geojson.getClusterExpansionZoom', { clusterId: e, source: this.id, scope: this.scope }, t), this;
            }
            getClusterChildren(e, t) {
              return this.actor.send('geojson.getClusterChildren', { clusterId: e, source: this.id, scope: this.scope }, t), this;
            }
            getClusterLeaves(e, t, i, r) {
              return this.actor.send('geojson.getClusterLeaves', { source: this.id, scope: this.scope, clusterId: e, limit: t, offset: i }, r), this;
            }
            _updateWorkerData() {
              if (this._pendingLoad) return void (this._coalesce = !0);
              this.fire(new wt('dataloading', { dataType: 'source' })), (this._loaded = !1);
              const e = Ft({}, this.workerOptions);
              e.scope = this.scope;
              const t = this._data;
              typeof t == 'string' ? ((e.request = this.map._requestManager.transformRequest(oe.resolveURL(t), dt.Source)), (e.request.collectResourceTiming = this._collectResourceTiming)) : (e.data = JSON.stringify(t)),
                (this._pendingLoad = this.actor.send(`${this.type}.loadData`, e, (i, r) => {
                  if (((this._loaded = !0), (this._pendingLoad = null), i)) this.fire(new re(i));
                  else {
                    const n = { dataType: 'source', sourceDataType: this._metadataFired ? 'content' : 'metadata' };
                    this._collectResourceTiming && r && r.resourceTiming && r.resourceTiming[this.id] && (n.resourceTiming = r.resourceTiming[this.id]), this.fire(new wt('data', n)), (this._metadataFired = !0);
                  }
                  this._coalesce && (this._updateWorkerData(), (this._coalesce = !1));
                }));
            }
            loaded() {
              return this._loaded;
            }
            loadTile(e, t) {
              const i = e.actor ? 'reloadTile' : 'loadTile';
              e.actor = this.actor;
              const r = { type: this.type, uid: e.uid, tileID: e.tileID, tileZoom: e.tileZoom, zoom: e.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, scope: this.scope, pixelRatio: oe.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, brightness: (this.map.style && this.map.style.getBrightness()) || 0 };
              e.request = this.actor.send(i, r, (n, o) => (delete e.request, e.destroy(), e.aborted ? t(null) : n ? t(n) : (e.loadVectorData(o, this.map.painter, i === 'reloadTile'), t(null))), void 0, i === 'loadTile');
            }
            abortTile(e) {
              e.request && (e.request.cancel(), delete e.request), (e.aborted = !0);
            }
            unloadTile(e) {
              this.actor.send('removeTile', { uid: e.uid, type: this.type, source: this.id, scope: this.scope }), e.destroy();
            }
            onRemove() {
              this._pendingLoad && this._pendingLoad.cancel();
            }
            serialize() {
              return Ft({}, this._options, { type: this.type, data: this._data });
            }
            hasTransition() {
              return !1;
            }
          },
          video: class extends fn {
            constructor(e, t, i, r) {
              super(e, t, i, r), (this.roundZoom = !0), (this.type = 'video'), (this.options = t);
            }
            load() {
              this._loaded = !1;
              const e = this.options;
              this.urls = [];
              for (const t of e.urls) this.urls.push(this.map._requestManager.transformRequest(t, dt.Source).url);
              (function (t, i) {
                const r = U.document.createElement('video');
                (r.muted = !0),
                  (r.onloadstart = function () {
                    i(null, r);
                  });
                for (let n = 0; n < t.length; n++) {
                  const o = U.document.createElement('source');
                  kt(t[n]) || (r.crossOrigin = 'Anonymous'), (o.src = t[n]), r.appendChild(o);
                }
              })(this.urls, (t, i) => {
                (this._loaded = !0),
                  t
                    ? this.fire(new re(t))
                    : i &&
                      ((this.video = i),
                      (this.video.loop = !0),
                      this.video.setAttribute('playsinline', ''),
                      this.video.addEventListener('playing', () => {
                        this.map.triggerRepaint();
                      }),
                      this.map && this.video.play(),
                      this._finishLoading());
              });
            }
            pause() {
              this.video && this.video.pause();
            }
            play() {
              this.video && this.video.play();
            }
            seek(e) {
              if (this.video) {
                const t = this.video.seekable;
                e < t.start(0) || e > t.end(0) ? this.fire(new re(new Vt(`sources.${this.id}`, null, `Playback for this video can be set only between the ${t.start(0)} and ${t.end(0)}-second mark.`))) : (this.video.currentTime = e);
              }
            }
            getVideo() {
              return this.video;
            }
            onAdd(e) {
              this.map || ((this.map = e), this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
            }
            prepare() {
              if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
              const e = this.map.painter.context,
                t = e.gl;
              this.texture ? this.video.paused || (this.texture.bind(t.LINEAR, t.CLAMP_TO_EDGE), t.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, t.RGBA, t.UNSIGNED_BYTE, this.video)) : ((this.texture = new vi(e, this.video, t.RGBA)), this.texture.bind(t.LINEAR, t.CLAMP_TO_EDGE), (this.width = this.video.videoWidth), (this.height = this.video.videoHeight)), this._prepareData(e);
            }
            serialize() {
              return { type: 'video', urls: this.urls, coordinates: this.coordinates };
            }
            hasTransition() {
              return this.video && !this.video.paused;
            }
          },
          image: fn,
          model: class extends Oi {
            constructor(e, t, i, r) {
              super(), (this.id = e), (this.type = 'model'), (this.models = []), (this._loaded = !1), (this._options = t);
            }
            load() {
              const e = [];
              for (const t in this._options.models) {
                const i = this._options.models[t],
                  r = rb(this.map._requestManager.transformRequest(i.uri, dt.Model).url)
                    .then((n) => {
                      if (!n) return;
                      const o = xm(n),
                        s = new Qv(t, i.position, i.orientation, o);
                      s.computeBoundsAndApplyParent(), this.models.push(s);
                    })
                    .catch((n) => {
                      this.fire(new re(new Error(`Could not load model ${t} from ${i.uri}: ${n.message}`)));
                    });
                e.push(r);
              }
              return Promise.allSettled(e)
                .then(() => {
                  (this._loaded = !0), this.fire(new wt('data', { dataType: 'source', sourceDataType: 'metadata' }));
                })
                .catch((t) => {
                  this.fire(new re(new Error(`Could not load models: ${t.message}`)));
                });
            }
            onAdd(e) {
              (this.map = e), this.load();
            }
            hasTransition() {
              return !1;
            }
            loaded() {
              return this._loaded;
            }
            getModels() {
              return this.models;
            }
            loadTile(e, t) {}
            serialize() {
              return { type: 'model' };
            }
          },
          'batched-model': class extends Oi {
            constructor(e, t, i, r) {
              super(), (this.type = 'batched-model'), (this.id = e), (this.tileSize = 512), (this._options = t), (this.tiles = this._options.tiles), (this.maxzoom = t.maxzoom || 19), (this.minzoom = t.minzoom || 0), (this.roundZoom = !0), (this.usedInConflation = !0), (this.dispatcher = i), (this.reparseOverscaled = !1), (this.scheme = 'xyz'), (this._loaded = !1), this.setEventedParent(r);
            }
            onAdd(e) {
              (this.map = e), this.load();
            }
            load(e) {
              (this._loaded = !1), this.fire(new wt('dataloading', { dataType: 'source' }));
              const t = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language,
                i = this.map._worldview;
              this._tileJSONRequest = lm(this._options, this.map._requestManager, t, i, (r, n) => {
                (this._tileJSONRequest = null), (this._loaded = !0), r ? (t && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${t}`), i && i.length !== 2 && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${i}`), this.fire(new re(r))) : n && (Ft(this, n), n.bounds && (this.tileBounds = new ah(n.bounds, this.minzoom, this.maxzoom)), ld(n.tiles, this.map._requestManager._customAccessToken), this.fire(new wt('data', { dataType: 'source', sourceDataType: 'metadata' })), this.fire(new wt('data', { dataType: 'source', sourceDataType: 'content' }))), e && e(r);
              });
            }
            hasTransition() {
              return !1;
            }
            hasTile(e) {
              return !this.tileBounds || this.tileBounds.contains(e.canonical);
            }
            loaded() {
              return this._loaded;
            }
            loadTile(e, t) {
              const i = this.map._requestManager.normalizeTileURL(e.tileID.canonical.url(this.tiles, this.scheme)),
                r = { request: this.map._requestManager.transformRequest(i, dt.Tile), data: void 0, uid: e.uid, tileID: e.tileID, tileZoom: e.tileZoom, zoom: e.tileID.overscaledZ, tileSize: this.tileSize * e.tileID.overscaleFactor(), type: this.type, source: this.id, scope: this.scope, showCollisionBoxes: this.map.showCollisionBoxes, isSymbolTile: e.isSymbolTile, brightness: (this.map.style && this.map.style.getBrightness()) || 0 };
              if (e.actor && e.state !== 'expired')
                if (e.state === 'loading') e.reloadCallback = t;
                else {
                  if (e.buckets) {
                    const o = Object.values(e.buckets);
                    for (const s of o) s.dirty = !0;
                    return void (e.state = 'loaded');
                  }
                  e.request = e.actor.send('reloadTile', r, n.bind(this));
                }
              else (e.actor = this.dispatcher.getActor()), (e.request = e.actor.send('loadTile', r, n.bind(this), void 0, !0));
              function n(o, s) {
                return e.aborted ? t(null) : o && o.status !== 404 ? t(o) : (s && (s.resourceTiming && (e.resourceTiming = s.resourceTiming), this.map._refreshExpiredTiles && e.setExpiryData(s), (e.buckets = { ...e.buckets, ...s.buckets })), (e.state = 'loaded'), void t(null));
              }
            }
            serialize() {
              return Ft({}, this._options);
            }
          },
          canvas: class extends fn {
            constructor(e, t, i, r) {
              super(e, t, i, r), t.coordinates ? (Array.isArray(t.coordinates) && t.coordinates.length === 4 && !t.coordinates.some((n) => !Array.isArray(n) || n.length !== 2 || n.some((o) => typeof o != 'number'))) || this.fire(new re(new Vt(`sources.${e}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new re(new Vt(`sources.${e}`, null, 'missing required property "coordinates"'))), t.animate && typeof t.animate != 'boolean' && this.fire(new re(new Vt(`sources.${e}`, null, 'optional "animate" property must be a boolean value'))), t.canvas ? typeof t.canvas == 'string' || t.canvas instanceof U.HTMLCanvasElement || this.fire(new re(new Vt(`sources.${e}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new re(new Vt(`sources.${e}`, null, 'missing required property "canvas"'))), (this.options = t), (this.animate = t.animate === void 0 || t.animate);
            }
            load() {
              (this._loaded = !0),
                this.canvas || (this.canvas = this.options.canvas instanceof U.HTMLCanvasElement ? this.options.canvas : U.document.getElementById(this.options.canvas)),
                (this.width = this.canvas.width),
                (this.height = this.canvas.height),
                this._hasInvalidDimensions()
                  ? this.fire(new re(new Error('Canvas dimensions cannot be less than or equal to zero.')))
                  : ((this.play = function () {
                      (this._playing = !0), this.map.triggerRepaint();
                    }),
                    (this.pause = function () {
                      this._playing && (this.prepare(), (this._playing = !1));
                    }),
                    this._finishLoading());
            }
            getCanvas() {
              return this.canvas;
            }
            onAdd(e) {
              (this.map = e), this.load(), this.canvas && this.animate && this.play();
            }
            onRemove() {
              this.pause();
            }
            prepare() {
              let e = !1;
              if ((this.canvas.width !== this.width && ((this.width = this.canvas.width), (e = !0)), this.canvas.height !== this.height && ((this.height = this.canvas.height), (e = !0)), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0)) return;
              const t = this.map.painter.context;
              this.texture ? (!e && !this._playing) || this.texture instanceof Wu || this.texture.update(this.canvas, { premultiply: !0 }) : (this.texture = new vi(t, this.canvas, t.gl.RGBA, { premultiply: !0 })), this._prepareData(t);
            }
            serialize() {
              return { type: 'canvas', coordinates: this.coordinates };
            }
            hasTransition() {
              return this._playing;
            }
            _hasInvalidDimensions() {
              for (const e of [this.canvas.width, this.canvas.height]) if (isNaN(e) || e <= 0) return !0;
              return !1;
            }
          },
          custom: class extends Oi {
            constructor(e, t, i, r) {
              super(), (this.id = e), (this.type = 'custom'), (this._dataType = 'raster'), (this._dispatcher = i), (this._implementation = t), this.setEventedParent(r), (this.scheme = 'xyz'), (this.minzoom = 0), (this.maxzoom = 22), (this.tileSize = 512), (this._loaded = !1), (this.roundZoom = !0), this._implementation || this.fire(new re(new Error(`Missing implementation for ${this.id} custom source`))), this._implementation.loadTile || this.fire(new re(new Error(`Missing loadTile implementation for ${this.id} custom source`))), this._implementation.bounds && (this.tileBounds = new ah(this._implementation.bounds, this.minzoom, this.maxzoom)), (t.update = this._update.bind(this)), (t.clearTiles = this._clearTiles.bind(this)), (t.coveringTiles = this._coveringTiles.bind(this)), Ft(this, ar(t, ['dataType', 'scheme', 'minzoom', 'maxzoom', 'tileSize', 'attribution', 'minTileCacheSize', 'maxTileCacheSize']));
            }
            serialize() {
              return ar(this, ['type', 'scheme', 'minzoom', 'maxzoom', 'tileSize', 'attribution']);
            }
            load() {
              (this._loaded = !0), this.fire(new wt('data', { dataType: 'source', sourceDataType: 'metadata' })), this.fire(new wt('data', { dataType: 'source', sourceDataType: 'content' }));
            }
            loaded() {
              return this._loaded;
            }
            onAdd(e) {
              (this._map = e), (this._loaded = !1), this.fire(new wt('dataloading', { dataType: 'source' })), this._implementation.onAdd && this._implementation.onAdd(e), this.load();
            }
            onRemove(e) {
              this._implementation.onRemove && this._implementation.onRemove(e);
            }
            hasTile(e) {
              if (this._implementation.hasTile) {
                const { x: t, y: i, z: r } = e.canonical;
                return this._implementation.hasTile({ x: t, y: i, z: r });
              }
              return !this.tileBounds || this.tileBounds.contains(e.canonical);
            }
            loadTile(e, t) {
              const { x: i, y: r, z: n } = e.tileID.canonical,
                o = new U.AbortController();
              (e.request = Promise.resolve(this._implementation.loadTile({ x: i, y: r, z: n }, { signal: o.signal }))
                .then(
                  function (s) {
                    return (
                      delete e.request,
                      e.aborted
                        ? ((e.state = 'unloaded'), t(null))
                        : s === void 0
                        ? ((e.state = 'errored'), t(null))
                        : s === null
                        ? (this.loadTileData(e, { width: this.tileSize, height: this.tileSize, data: null }), (e.state = 'loaded'), t(null))
                        : (function (a) {
                            return a instanceof U.ImageData || a instanceof U.HTMLCanvasElement || a instanceof U.ImageBitmap || a instanceof U.HTMLImageElement;
                          })(s)
                        ? (this.loadTileData(e, s), (e.state = 'loaded'), void t(null))
                        : ((e.state = 'errored'), t(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`)))
                    );
                  }.bind(this)
                )
                .catch((s) => {
                  s.code !== 20 && ((e.state = 'errored'), t(s));
                })),
                (e.request.cancel = () => o.abort());
            }
            loadTileData(e, t) {
              e.setTexture(t, this._map.painter);
            }
            unloadTile(e, t) {
              if ((e.texture && e.texture instanceof vi ? (e.destroy(!0), e.texture && e.texture instanceof vi && this._map.painter.saveTileTexture(e.texture)) : e.destroy(), this._implementation.unloadTile)) {
                const { x: i, y: r, z: n } = e.tileID.canonical;
                this._implementation.unloadTile({ x: i, y: r, z: n });
              }
              t();
            }
            abortTile(e, t) {
              e.request && e.request.cancel && (e.request.cancel(), delete e.request), t();
            }
            hasTransition() {
              return !1;
            }
            _coveringTiles() {
              return this._map.transform.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, roundZoom: this.roundZoom }).map((e) => ({ x: e.canonical.x, y: e.canonical.y, z: e.canonical.z }));
            }
            _clearTiles() {
              const e = pr(this.id, this.scope);
              this._map.style.clearSource(e);
            }
            _update() {
              this.fire(new wt('data', { dataType: 'source', sourceDataType: 'content' }));
            }
          },
        },
        bm = function (e, t, i, r) {
          const n = new vm[t.type](e, t, i, r);
          if (n.id !== e) throw new Error(`Expected Source id to be ${e} instead of ${n.id}`);
          return ot(['load', 'abort', 'unload', 'serialize', 'prepare'], n), n;
        };
      function cP(e, t) {
        const i = J.identity([]);
        return J.scale(i, i, [0.5 * e.width, 0.5 * -e.height, 1]), J.translate(i, i, [1, -1, 0]), J.multiply(i, i, e.calculateProjMatrix(t.toUnwrapped())), Float32Array.from(i);
      }
      function uP(e, t, i, r, n, o, s, a = !1) {
        const l = e.tilesIn(r, s, a);
        l.sort(sb);
        const c = [];
        for (const h of l) c.push({ wrappedTileID: h.tile.tileID.wrapped().key, queryResults: h.tile.queryRenderedFeatures(t, i, e._state, h, n, o, cP(e.transform, h.tile.tileID), a) });
        const u = (function (h) {
          const d = {},
            f = {};
          for (const p of h) {
            const _ = p.queryResults,
              g = p.wrappedTileID,
              y = (f[g] = f[g] || {});
            for (const v in _) {
              const w = _[v],
                T = (y[v] = y[v] || {}),
                b = (d[v] = d[v] || []);
              for (const E of w) T[E.featureIndex] || ((T[E.featureIndex] = !0), b.push(E));
            }
          }
          return d;
        })(c);
        for (const h in u)
          u[h].forEach((d) => {
            const f = d.feature,
              p = f.layer;
            p && p.type !== 'background' && p.type !== 'sky' && p.type !== 'slot' && ((f.source = p.source), p['source-layer'] && (f.sourceLayer = p['source-layer']), (f.state = f.id !== void 0 ? e.getFeatureState(p['source-layer'], f.id) : {}));
          });
        return u;
      }
      function hP(e, t) {
        const i = e.getRenderableIds().map((o) => e.getTileByID(o)),
          r = [],
          n = {};
        for (let o = 0; o < i.length; o++) {
          const s = i[o],
            a = s.tileID.canonical.key;
          n[a] || ((n[a] = !0), s.querySourceFeatures(r, t));
        }
        return r;
      }
      function sb(e, t) {
        const i = e.tileID,
          r = t.tileID;
        return i.overscaledZ - r.overscaledZ || i.canonical.y - r.canonical.y || i.wrap - r.wrap || i.canonical.x - r.canonical.x;
      }
      class dP {
        constructor(t) {
          this.style = t;
        }
        processLayersChanged() {
          this.layers = [];
          for (const t in this.style._mergedLayers) {
            const i = this.style._mergedLayers[t];
            if (i.type === 'fill-extrusion') this.layers.push(i);
            else if (i.type === 'model') {
              const r = this.style.getLayerSource(i);
              r && r.type === 'batched-model' && this.layers.push(i);
            }
          }
        }
        updateZOffset(t, i) {
          this.currentBuildingBuckets = [];
          for (let n = 0; n < this.layers.length; ++n) {
            const o = this.layers[n],
              s = this.style.getLayerSourceCache(o);
            let a = 1;
            o.type === 'fill-extrusion' && (a = o.paint.get('fill-extrusion-opacity') > 0 ? o.paint.get('fill-extrusion-vertical-scale') : 0);
            let l = s ? s.getTile(i) : null;
            if (!l && s && i.canonical.z > s.getSource().minzoom) {
              let c = i.scaledTo(Math.min(s.getSource().maxzoom, i.overscaledZ - 1));
              for (; c.overscaledZ >= s.getSource().minzoom && ((l = s.getTile(c)), !l && c.overscaledZ !== 0); ) c = c.scaledTo(c.overscaledZ - 1);
            }
            this.currentBuildingBuckets.push({ bucket: l ? l.getBucket(o) : null, tileID: l ? l.tileID : i, verticalScale: a });
          }
          t.hasAnyZOffset = !1;
          let r = !1;
          for (let n = 0; n < t.symbolInstances.length; n++) {
            const o = t.symbolInstances.get(n),
              s = o.zOffset,
              a = this._getHeightAtTileOffset(i, o.tileAnchorX, o.tileAnchorY);
            (o.zOffset = a !== -1 ? a : s), r || s === o.zOffset || (r = !0), t.hasAnyZOffset || o.zOffset === 0 || (t.hasAnyZOffset = !0);
          }
          r && ((t.zOffsetBuffersNeedUpload = !0), (t.zOffsetSortDirty = !0));
        }
        _mapCoordToOverlappingTile(t, i, r, n) {
          let o = i,
            s = r;
          if (t.canonical.z !== n.canonical.z) {
            const a = n.canonical,
              l = 1 / (1 << (t.canonical.z - a.z));
            (o = ((i + t.canonical.x * lt) * l - a.x * lt) | 0), (s = ((r + t.canonical.y * lt) * l - a.y * lt) | 0);
          }
          return { tileX: o, tileY: s };
        }
        _getHeightAtTileOffset(t, i, r) {
          let n;
          for (let o = 0; o < this.layers.length; ++o) {
            if (this.layers[o].type !== 'fill-extrusion') continue;
            const { bucket: s, tileID: a, verticalScale: l } = this.currentBuildingBuckets[o];
            if (!s) continue;
            const { tileX: c, tileY: u } = this._mapCoordToOverlappingTile(t, i, r, a),
              h = s.getHeightAtTileCoord(c, u);
            if (h && h.height !== void 0) {
              if (!h.hidden) return h.height * l;
              n = h.height;
            }
          }
          for (let o = 0; o < this.layers.length; ++o) {
            if (this.layers[o].type !== 'model') continue;
            const { bucket: s, tileID: a } = this.currentBuildingBuckets[o];
            if (!s) continue;
            const { tileX: l, tileY: c } = this._mapCoordToOverlappingTile(t, i, r, a),
              u = s.getHeightAtTileCoord(l, c);
            if (u && !u.hidden) return u.height === void 0 && n !== void 0 ? Math.min(u.maxHeight, n) * u.verticalScale : (u.height || 0) * u.verticalScale;
          }
          return -1;
        }
      }
      var ab = ['type', 'source', 'source-layer', 'minzoom', 'maxzoom', 'filter', 'layout'];
      function fP(e, t) {
        const i = {};
        for (const r in e) r !== 'ref' && (i[r] = e[r]);
        return (
          ab.forEach((r) => {
            r in t && (i[r] = t[r]);
          }),
          i
        );
      }
      function lb(e) {
        e = e.slice();
        const t = Object.create(null);
        for (let i = 0; i < e.length; i++) t[e[i].id] = e[i];
        for (let i = 0; i < e.length; i++) 'ref' in e[i] && (e[i] = fP(e[i], t[e[i].ref]));
        return e;
      }
      const Be = { setStyle: 'setStyle', addLayer: 'addLayer', removeLayer: 'removeLayer', setPaintProperty: 'setPaintProperty', setLayoutProperty: 'setLayoutProperty', setSlot: 'setSlot', setFilter: 'setFilter', addSource: 'addSource', removeSource: 'removeSource', setGeoJSONSourceData: 'setGeoJSONSourceData', setLayerZoomRange: 'setLayerZoomRange', setLayerProperty: 'setLayerProperty', setCenter: 'setCenter', setZoom: 'setZoom', setBearing: 'setBearing', setPitch: 'setPitch', setSprite: 'setSprite', setGlyphs: 'setGlyphs', setTransition: 'setTransition', setLight: 'setLight', setTerrain: 'setTerrain', setFog: 'setFog', setCamera: 'setCamera', setLights: 'setLights', setProjection: 'setProjection', addImport: 'addImport', removeImport: 'removeImport', setImportUrl: 'setImportUrl', setImportData: 'setImportData', setImportConfig: 'setImportConfig' };
      function cb(e, t, i) {
        i.push({ command: Be.addSource, args: [e, t[e]] });
      }
      function ub(e, t, i) {
        t.push({ command: Be.removeSource, args: [e] }), (i[e] = !0);
      }
      function pP(e, t, i, r) {
        ub(e, i, r), cb(e, t, i);
      }
      function mP(e, t, i) {
        let r;
        for (r in e[i]) if (e[i].hasOwnProperty(r) && r !== 'data' && !we(e[i][r], t[i][r])) return !1;
        for (r in t[i]) if (t[i].hasOwnProperty(r) && r !== 'data' && !we(e[i][r], t[i][r])) return !1;
        return !0;
      }
      function ch(e, t, i, r, n, o) {
        let s;
        for (s in ((t = t || {}), (e = e || {}))) e.hasOwnProperty(s) && (we(e[s], t[s]) || i.push({ command: o, args: [r, s, t[s], n] }));
        for (s in t) t.hasOwnProperty(s) && !e.hasOwnProperty(s) && (we(e[s], t[s]) || i.push({ command: o, args: [r, s, t[s], n] }));
      }
      function uh(e) {
        return e.id;
      }
      function hh(e, t) {
        return (e[t.id] = t), e;
      }
      class _P {
        constructor(t, i) {
          this.reset(t, i);
        }
        reset(t, i) {
          (this.points = t || []), (this._distances = [0]);
          for (let r = 1; r < this.points.length; r++) this._distances[r] = this._distances[r - 1] + this.points[r].dist(this.points[r - 1]);
          (this.length = this._distances[this._distances.length - 1]), (this.padding = Math.min(i || 0, 0.5 * this.length)), (this.paddedLength = this.length - 2 * this.padding);
        }
        lerp(t) {
          if (this.points.length === 1) return this.points[0];
          t = Bt(t, 0, 1);
          let i = 1,
            r = this._distances[i];
          const n = t * this.paddedLength + this.padding;
          for (; r < n && i < this._distances.length; ) r = this._distances[++i];
          const o = i - 1,
            s = this._distances[o],
            a = r - s,
            l = a > 0 ? (n - s) / a : 0;
          return this.points[o].mult(1 - l).add(this.points[i].mult(l));
        }
      }
      class hb {
        constructor(t, i, r) {
          const n = (this.boxCells = []),
            o = (this.circleCells = []);
          (this.xCellCount = Math.ceil(t / r)), (this.yCellCount = Math.ceil(i / r));
          for (let s = 0; s < this.xCellCount * this.yCellCount; s++) n.push([]), o.push([]);
          (this.circleKeys = []), (this.boxKeys = []), (this.bboxes = []), (this.circles = []), (this.width = t), (this.height = i), (this.xScale = this.xCellCount / t), (this.yScale = this.yCellCount / i), (this.boxUid = 0), (this.circleUid = 0);
        }
        keysLength() {
          return this.boxKeys.length + this.circleKeys.length;
        }
        insert(t, i, r, n, o) {
          this._forEachCell(i, r, n, o, this._insertBoxCell, this.boxUid++), this.boxKeys.push(t), this.bboxes.push(i), this.bboxes.push(r), this.bboxes.push(n), this.bboxes.push(o);
        }
        insertCircle(t, i, r, n) {
          this._forEachCell(i - n, r - n, i + n, r + n, this._insertCircleCell, this.circleUid++), this.circleKeys.push(t), this.circles.push(i), this.circles.push(r), this.circles.push(n);
        }
        _insertBoxCell(t, i, r, n, o, s) {
          this.boxCells[o].push(s);
        }
        _insertCircleCell(t, i, r, n, o, s) {
          this.circleCells[o].push(s);
        }
        _query(t, i, r, n, o, s) {
          if (r < 0 || t > this.width || n < 0 || i > this.height) return !o && [];
          const a = [];
          if (t <= 0 && i <= 0 && this.width <= r && this.height <= n) {
            if (o) return !0;
            for (let l = 0; l < this.boxKeys.length; l++) a.push({ key: this.boxKeys[l], x1: this.bboxes[4 * l], y1: this.bboxes[4 * l + 1], x2: this.bboxes[4 * l + 2], y2: this.bboxes[4 * l + 3] });
            for (let l = 0; l < this.circleKeys.length; l++) {
              const c = this.circles[3 * l],
                u = this.circles[3 * l + 1],
                h = this.circles[3 * l + 2];
              a.push({ key: this.circleKeys[l], x1: c - h, y1: u - h, x2: c + h, y2: u + h });
            }
            return s ? a.filter(s) : a;
          }
          return this._forEachCell(t, i, r, n, this._queryCell, a, { hitTest: o, seenUids: { box: {}, circle: {} } }, s), o ? a.length > 0 : a;
        }
        _queryCircle(t, i, r, n, o) {
          const s = t - r,
            a = t + r,
            l = i - r,
            c = i + r;
          if (a < 0 || s > this.width || c < 0 || l > this.height) return !n && [];
          const u = [];
          return this._forEachCell(s, l, a, c, this._queryCellCircle, u, { hitTest: n, circle: { x: t, y: i, radius: r }, seenUids: { box: {}, circle: {} } }, o), n ? u.length > 0 : u;
        }
        query(t, i, r, n, o) {
          return this._query(t, i, r, n, !1, o);
        }
        hitTest(t, i, r, n, o) {
          return this._query(t, i, r, n, !0, o);
        }
        hitTestCircle(t, i, r, n) {
          return this._queryCircle(t, i, r, !0, n);
        }
        _queryCell(t, i, r, n, o, s, a, l) {
          const c = a.seenUids,
            u = this.boxCells[o];
          if (u !== null) {
            const d = this.bboxes;
            for (const f of u)
              if (!c.box[f]) {
                c.box[f] = !0;
                const p = 4 * f;
                if (t <= d[p + 2] && i <= d[p + 3] && r >= d[p + 0] && n >= d[p + 1] && (!l || l(this.boxKeys[f]))) {
                  if (a.hitTest) return s.push(!0), !0;
                  s.push({ key: this.boxKeys[f], x1: d[p], y1: d[p + 1], x2: d[p + 2], y2: d[p + 3] });
                }
              }
          }
          const h = this.circleCells[o];
          if (h !== null) {
            const d = this.circles;
            for (const f of h)
              if (!c.circle[f]) {
                c.circle[f] = !0;
                const p = 3 * f;
                if (this._circleAndRectCollide(d[p], d[p + 1], d[p + 2], t, i, r, n) && (!l || l(this.circleKeys[f]))) {
                  if (a.hitTest) return s.push(!0), !0;
                  {
                    const _ = d[p],
                      g = d[p + 1],
                      y = d[p + 2];
                    s.push({ key: this.circleKeys[f], x1: _ - y, y1: g - y, x2: _ + y, y2: g + y });
                  }
                }
              }
          }
        }
        _queryCellCircle(t, i, r, n, o, s, a, l) {
          const c = a.circle,
            u = a.seenUids,
            h = this.boxCells[o];
          if (h !== null) {
            const f = this.bboxes;
            for (const p of h)
              if (!u.box[p]) {
                u.box[p] = !0;
                const _ = 4 * p;
                if (this._circleAndRectCollide(c.x, c.y, c.radius, f[_ + 0], f[_ + 1], f[_ + 2], f[_ + 3]) && (!l || l(this.boxKeys[p]))) return s.push(!0), !0;
              }
          }
          const d = this.circleCells[o];
          if (d !== null) {
            const f = this.circles;
            for (const p of d)
              if (!u.circle[p]) {
                u.circle[p] = !0;
                const _ = 3 * p;
                if (this._circlesCollide(f[_], f[_ + 1], f[_ + 2], c.x, c.y, c.radius) && (!l || l(this.circleKeys[p]))) return s.push(!0), !0;
              }
          }
        }
        _forEachCell(t, i, r, n, o, s, a, l) {
          const c = this._convertToXCellCoord(t),
            u = this._convertToYCellCoord(i),
            h = this._convertToXCellCoord(r),
            d = this._convertToYCellCoord(n);
          for (let f = c; f <= h; f++) for (let p = u; p <= d; p++) if (o.call(this, t, i, r, n, this.xCellCount * p + f, s, a, l)) return;
        }
        _convertToXCellCoord(t) {
          return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t * this.xScale)));
        }
        _convertToYCellCoord(t) {
          return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t * this.yScale)));
        }
        _circlesCollide(t, i, r, n, o, s) {
          const a = n - t,
            l = o - i,
            c = r + s;
          return c * c > a * a + l * l;
        }
        _circleAndRectCollide(t, i, r, n, o, s, a) {
          const l = (s - n) / 2,
            c = Math.abs(t - (n + l));
          if (c > l + r) return !1;
          const u = (a - o) / 2,
            h = Math.abs(i - (o + u));
          if (h > u + r) return !1;
          if (c <= l || h <= u) return !0;
          const d = c - l,
            f = h - u;
          return d * d + f * f <= r * r;
        }
      }
      const Vn = 100;
      class gP {
        constructor(t, i, r = new hb(t.width + 200, t.height + 200, 25), n = new hb(t.width + 200, t.height + 200, 25)) {
          (this.transform = t), (this.grid = r), (this.ignoredGrid = n), (this.pitchfactor = Math.cos(t._pitch) * t.cameraToCenterDistance), (this.screenRightBoundary = t.width + Vn), (this.screenBottomBoundary = t.height + Vn), (this.gridRightBoundary = t.width + 200), (this.gridBottomBoundary = t.height + 200), (this.fogState = i);
        }
        placeCollisionBox(t, i, r, n, o, s, a, l) {
          let c = r.projectedAnchorX,
            u = r.projectedAnchorY,
            h = r.projectedAnchorZ;
          const d = r.elevation,
            f = r.tileID,
            p = t.getProjection();
          if (d && f) {
            const [E, S, I] = p.upVector(f.canonical, r.tileAnchorX, r.tileAnchorY),
              C = p.upVectorScale(f.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;
            (c += E * d * C), (u += S * d * C), (h += I * d * C);
          }
          const _ = this.projectAndGetPerspectiveRatio(a, c, u, h, r.tileID, p.name === 'globe' || !!d || this.transform.pitch > 0, p),
            g = s * _.perspectiveRatio,
            y = (r.x1 * i + n.x - r.padding) * g + _.point.x,
            v = (r.y1 * i + n.y - r.padding) * g + _.point.y,
            w = (r.x2 * i + n.x + r.padding) * g + _.point.x,
            T = (r.y2 * i + n.y + r.padding) * g + _.point.y,
            b = _.perspectiveRatio <= 0.55 || _.occluded;
          return !this.isInsideGrid(y, v, w, T) || (!o && this.grid.hitTest(y, v, w, T, l)) || b ? { box: [], offscreen: !1, occluded: _.occluded } : { box: [y, v, w, T], offscreen: this.isOffscreen(y, v, w, T), occluded: !1 };
        }
        placeCollisionCircles(t, i, r, n, o, s, a, l, c, u, h, d, f, p, _) {
          const g = [],
            y = this.transform.elevation,
            v = t.getProjection(),
            w = y ? y.getAtTileOffsetFunc(_, this.transform.center.lat, this.transform.worldSize, v) : null,
            T = new H(r.tileAnchorX, r.tileAnchorY);
          let { x: b, y: E, z: S } = v.projectTilePoint(T.x, T.y, _.canonical);
          if (w) {
            const [X, j, q] = w(T);
            (b += X), (E += j), (S += q);
          }
          const I = v.name === 'globe',
            C = this.projectAndGetPerspectiveRatio(a, b, E, S, _, I || !!y || this.transform.pitch > 0, v),
            { perspectiveRatio: z } = C,
            k = (h ? s / z : s * z) / Qi,
            O = Tn(b, E, S, l),
            V = C.signedDistanceFromCamera > 0 ? Gv(k, o, r.lineOffsetX * k, r.lineOffsetY * k, !1, O, T, r, n, l, {}, y && !h ? w : null, h && !!y, v, _, h) : null;
          let R = !1,
            G = !1,
            Z = !0;
          if (V && !C.occluded) {
            const X = 0.5 * f * z + p,
              j = new H(-100, -100),
              q = new H(this.screenRightBoundary, this.screenBottomBoundary),
              it = new _P(),
              { first: st, last: nt } = V,
              ut = st.path.length;
            let ht = [];
            for (let _t = ut - 1; _t >= 1; _t--) ht.push(st.path[_t]);
            for (let _t = 1; _t < nt.path.length; _t++) ht.push(nt.path[_t]);
            const pt = 2.5 * X;
            c && ((ht = ht.map(([_t, Ct, Pt], Ot) => (w && !I && (Pt = w(Ot < ut - 1 ? st.tilePath[ut - 1 - Ot] : nt.tilePath[Ot - ut + 2])[2]), Tn(_t, Ct, Pt, c)))), ht.some((_t) => _t[3] <= 0) && (ht = []));
            let at = [];
            if (ht.length > 0) {
              let _t = 1 / 0,
                Ct = -1 / 0,
                Pt = 1 / 0,
                Ot = -1 / 0;
              for (const Ut of ht) (_t = Math.min(_t, Ut[0])), (Pt = Math.min(Pt, Ut[1])), (Ct = Math.max(Ct, Ut[0])), (Ot = Math.max(Ot, Ut[1]));
              Ct >= j.x && _t <= q.x && Ot >= j.y && Pt <= q.y && ((at = [ht.map((Ut) => new H(Ut[0], Ut[1]))]), (_t < j.x || Ct > q.x || Pt < j.y || Ot > q.y) && (at = dv(at, j.x, j.y, q.x, q.y)));
            }
            for (const _t of at) {
              it.reset(_t, 0.25 * X);
              let Ct = 0;
              Ct = it.length <= 0.5 * X ? 1 : Math.ceil(it.paddedLength / pt) + 1;
              for (let Pt = 0; Pt < Ct; Pt++) {
                const Ot = Pt / Math.max(Ct - 1, 1),
                  Ut = it.lerp(Ot),
                  Qt = Ut.x + Vn,
                  Ht = Ut.y + Vn;
                g.push(Qt, Ht, X, 0);
                const Ce = Qt - X,
                  be = Ht - X,
                  te = Qt + X,
                  Kt = Ht + X;
                if (((Z = Z && this.isOffscreen(Ce, be, te, Kt)), (G = G || this.isInsideGrid(Ce, be, te, Kt)), !i && this.grid.hitTestCircle(Qt, Ht, X, d) && ((R = !0), !u))) return { circles: [], offscreen: !1, collisionDetected: R, occluded: !1 };
              }
            }
          }
          return { circles: (!u && R) || !G ? [] : g, offscreen: Z, collisionDetected: R, occluded: C.occluded };
        }
        queryRenderedSymbols(t) {
          if (t.length === 0 || (this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0)) return {};
          const i = [];
          let r = 1 / 0,
            n = 1 / 0,
            o = -1 / 0,
            s = -1 / 0;
          for (const u of t) {
            const h = new H(u.x + Vn, u.y + Vn);
            (r = Math.min(r, h.x)), (n = Math.min(n, h.y)), (o = Math.max(o, h.x)), (s = Math.max(s, h.y)), i.push(h);
          }
          const a = this.grid.query(r, n, o, s).concat(this.ignoredGrid.query(r, n, o, s)),
            l = {},
            c = {};
          for (const u of a) {
            const h = u.key;
            l[h.bucketInstanceId] === void 0 && (l[h.bucketInstanceId] = {}), l[h.bucketInstanceId][h.featureIndex] || (_x(i, [new H(u.x1, u.y1), new H(u.x2, u.y1), new H(u.x2, u.y2), new H(u.x1, u.y2)]) && ((l[h.bucketInstanceId][h.featureIndex] = !0), c[h.bucketInstanceId] === void 0 && (c[h.bucketInstanceId] = []), c[h.bucketInstanceId].push(h.featureIndex)));
          }
          return c;
        }
        insertCollisionBox(t, i, r, n, o) {
          (i ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: r, featureIndex: n, collisionGroupID: o }, t[0], t[1], t[2], t[3]);
        }
        insertCollisionCircles(t, i, r, n, o) {
          const s = i ? this.ignoredGrid : this.grid,
            a = { bucketInstanceId: r, featureIndex: n, collisionGroupID: o };
          for (let l = 0; l < t.length; l += 4) s.insertCircle(a, t[l], t[l + 1], t[l + 2]);
        }
        projectAndGetPerspectiveRatio(t, i, r, n, o, s, a) {
          const l = [i, r, n, 1];
          let c = !1;
          n || this.transform.pitch > 0
            ? (We.transformMat4(l, l, t),
              this.fogState &&
                o &&
                a.name !== 'globe' &&
                (c =
                  (function (d, f, p, _, g, y) {
                    const v = y.calculateFogTileMatrix(g),
                      w = [f, p, _];
                    return N.transformMat4(w, w, v), sh(d, N.length(w), y.pitch, y._fov);
                  })(this.fogState, i, r, n, o.toUnwrapped(), this.transform) > 0.9))
            : Wv(l, l, t);
          const u = l[3];
          return { point: new H(((l[0] / u + 1) / 2) * this.transform.width + Vn, ((-l[1] / u + 1) / 2) * this.transform.height + Vn), perspectiveRatio: Math.min(0.5 + (this.transform.getCameraToCenterDistance(a) / u) * 0.5, 1.5), signedDistanceFromCamera: u, occluded: (s && l[2] > u) || c };
        }
        isOffscreen(t, i, r, n) {
          return r < Vn || t >= this.screenRightBoundary || n < Vn || i > this.screenBottomBoundary;
        }
        isInsideGrid(t, i, r, n) {
          return r >= 0 && t < this.gridRightBoundary && n >= 0 && i < this.gridBottomBoundary;
        }
        getViewportMatrix() {
          const t = J.identity([]);
          return J.translate(t, t, [-100, -100, 0]), t;
        }
      }
      function wm(e, t, i) {
        const r = t.createTileMatrix(e, e.worldSize, i.toUnwrapped());
        return J.multiply(new Float32Array(16), e.projMatrix, r);
      }
      function yP(e, t, i) {
        if (t.projection.name === i.projection.name) return e.projMatrix;
        const r = i.clone();
        return r.setProjection(t.projection), wm(r, t.getProjection(), e);
      }
      function Tm(e, t, i) {
        return t.name === i.projection.name ? e.projMatrix : wm(i, t, e);
      }
      class db {
        constructor(t, i, r, n) {
          (this.opacity = t ? Math.max(0, Math.min(1, t.opacity + (t.placed ? i : -i))) : n && r ? 1 : 0), (this.placed = r);
        }
        isHidden() {
          return this.opacity === 0 && !this.placed;
        }
      }
      class tc {
        constructor(t, i, r, n, o, s = !1) {
          (this.text = new db(t ? t.text : null, i, r, o)), (this.icon = new db(t ? t.icon : null, i, n, o)), (this.clipped = s);
        }
        isHidden() {
          return this.text.isHidden() && this.icon.isHidden();
        }
      }
      class Em {
        constructor(t, i, r, n = !1) {
          (this.text = t), (this.icon = i), (this.skipFade = r), (this.clipped = n);
        }
      }
      class xP {
        constructor() {
          (this.invProjMatrix = J.create()), (this.viewportMatrix = J.create()), (this.circles = []);
        }
      }
      class vP {
        constructor(t, i, r, n, o) {
          (this.bucketInstanceId = t), (this.featureIndex = i), (this.sourceLayerIndex = r), (this.bucketIndex = n), (this.tileID = o);
        }
      }
      class bP {
        constructor(t) {
          (this.crossSourceCollisions = t), (this.maxGroupID = 0), (this.collisionGroups = {});
        }
        get(t) {
          if (this.crossSourceCollisions) return { ID: 0, predicate: null };
          if (!this.collisionGroups[t]) {
            const i = ++this.maxGroupID;
            this.collisionGroups[t] = { ID: i, predicate: (r) => r.collisionGroupID === i };
          }
          return this.collisionGroups[t];
        }
      }
      function fb(e, t, i, r, n) {
        const { horizontalAlign: o, verticalAlign: s } = Ru(e),
          a = -(o - 0.5) * t,
          l = -(s - 0.5) * i,
          c = Vp(e, r);
        return new H(a + c[0] * n, l + c[1] * n);
      }
      function Mm(e, t, i, r, n) {
        const o = new H(e, t);
        return i && o._rotate(r ? n : -n), o;
      }
      class wP {
        constructor(t, i, r, n, o, s) {
          (this.transform = t.clone()), (this.projection = t.projection.name), (this.collisionIndex = new gP(this.transform, o)), (this.buildingIndex = s), (this.placements = {}), (this.opacities = {}), (this.variableOffsets = {}), (this.stale = !1), (this.commitTime = 0), (this.fadeDuration = i), (this.retainedQueryData = {}), (this.collisionGroups = new bP(r)), (this.collisionCircleArrays = {}), (this.prevPlacement = n), n && (n.prevPlacement = void 0), (this.placedOrientations = {});
        }
        getBucketParts(t, i, r, n) {
          const o = r.getBucket(i),
            s = r.latestFeatureIndex;
          if (!o || !s || i.fqid !== o.layerIds[0]) return;
          const a = o.layers[0].layout,
            l = r.collisionBoxArray,
            c = Math.pow(2, this.transform.zoom - r.tileID.overscaledZ),
            u = r.tileSize / lt,
            h = r.tileID.toUnwrapped();
          this.transform.setProjection(o.projection);
          const d = ((f = r.tileID), (p = o.getProjection()), (_ = this.transform), p.name === this.projection ? _.calculateProjMatrix(f.toUnwrapped()) : wm(_, p, f));
          var f, p, _;
          const g = a.get('text-pitch-alignment') === 'map',
            y = a.get('text-rotation-alignment') === 'map';
          i.compileFilter();
          const v = i.dynamicFilter(),
            w = i.dynamicFilterNeedsFeature(),
            T = this.transform.calculatePixelsToTileUnitsMatrix(r),
            b = Uv(d, r.tileID.canonical, g, y, this.transform, o.getProjection(), T);
          let E = null;
          if (g) {
            const C = Vv(d, r.tileID.canonical, g, y, this.transform, o.getProjection(), T);
            E = J.multiply([], this.transform.labelPlaneMatrix, C);
          }
          let S = null;
          v && r.latestFeatureIndex && (S = { unwrappedTileID: h, dynamicFilter: v, dynamicFilterNeedsFeature: w, featureIndex: r.latestFeatureIndex }), (this.retainedQueryData[o.bucketInstanceId] = new vP(o.bucketInstanceId, s, o.sourceLayerIndex, o.index, r.tileID));
          const I = { bucket: o, layout: a, posMatrix: d, textLabelPlaneMatrix: b, labelToScreenMatrix: E, clippingData: S, scale: c, textPixelRatio: u, holdingForFade: r.holdingForFade(), collisionBoxArray: l, partiallyEvaluatedTextSize: Bn(o.textSizeData, this.transform.zoom), partiallyEvaluatedIconSize: Bn(o.iconSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(o.sourceID) };
          if (n)
            for (const C of o.sortKeyRanges) {
              const { sortKey: z, symbolInstanceStart: k, symbolInstanceEnd: O } = C;
              t.push({ sortKey: z, symbolInstanceStart: k, symbolInstanceEnd: O, parameters: I });
            }
          else t.push({ symbolInstanceStart: 0, symbolInstanceEnd: o.symbolInstances.length, parameters: I });
        }
        attemptAnchorPlacement(t, i, r, n, o, s, a, l, c, u, h, d, f, p, _, g, y, v) {
          const { textOffset0: w, textOffset1: T, crossTileID: b } = d,
            E = [w, T],
            S = fb(t, r, n, E, o),
            I = this.collisionIndex.placeCollisionBox(p, o, i, Mm(S.x, S.y, s, a, this.transform.angle), h, l, c, u.predicate);
          if (g) {
            const C = p.getSymbolInstanceIconSize(v, this.transform.zoom, d.placedIconSymbolIndex);
            if (this.collisionIndex.placeCollisionBox(p, C, g, Mm(S.x, S.y, s, a, this.transform.angle), h, l, c, u.predicate).box.length === 0) return;
          }
          if (I.box.length > 0) {
            let C;
            return this.prevPlacement && this.prevPlacement.variableOffsets[b] && this.prevPlacement.placements[b] && this.prevPlacement.placements[b].text && (C = this.prevPlacement.variableOffsets[b].anchor), (this.variableOffsets[b] = { textOffset: E, width: r, height: n, anchor: t, textScale: o, prevAnchor: C }), this.markUsedJustification(p, t, d, _), p.allowVerticalPlacement && (this.markUsedOrientation(p, _, d), (this.placedOrientations[b] = _)), { shift: S, placedGlyphBoxes: I };
          }
        }
        placeLayerBucketPart(t, i, r, n) {
          const { bucket: o, layout: s, posMatrix: a, textLabelPlaneMatrix: l, labelToScreenMatrix: c, clippingData: u, textPixelRatio: h, holdingForFade: d, collisionBoxArray: f, partiallyEvaluatedTextSize: p, partiallyEvaluatedIconSize: _, collisionGroup: g } = t.parameters,
            y = s.get('text-optional'),
            v = s.get('icon-optional'),
            w = s.get('text-allow-overlap'),
            T = s.get('icon-allow-overlap'),
            b = s.get('text-rotation-alignment') === 'map',
            E = s.get('text-pitch-alignment') === 'map',
            S = s.get('symbol-z-order') === 'viewport-y',
            I = s.get('symbol-z-elevate');
          this.transform.setProjection(o.projection);
          let C = w && (T || !o.hasIconData() || v),
            z = T && (w || !o.hasTextData() || y);
          !o.collisionArrays && f && o.deserializeCollisionBoxes(f), r && n && o.updateCollisionDebugBuffers(this.transform.zoom, f);
          const k = (O, V, R) => {
            const { crossTileID: G, numVerticalGlyphVertices: Z } = O;
            if (u) {
              const te = { zoom: this.transform.zoom, pitch: this.transform.pitch };
              let Kt = null;
              if (u.dynamicFilterNeedsFeature) {
                const Wt = this.retainedQueryData[o.bucketInstanceId];
                Kt = u.featureIndex.loadFeature({ featureIndex: O.featureIndex, bucketIndex: Wt.bucketIndex, sourceLayerIndex: Wt.sourceLayerIndex, layoutVertexArrayOffset: 0 });
              }
              if (!(0, u.dynamicFilter)(te, Kt, this.retainedQueryData[o.bucketInstanceId].tileID.canonical, new H(O.tileAnchorX, O.tileAnchorY), this.transform.calculateDistanceTileData(u.unwrappedTileID))) return (this.placements[G] = new Em(!1, !1, !1, !0)), void i.add(G);
            }
            if (i.has(G)) return;
            if (d) return void (this.placements[G] = new Em(!1, !1, !1));
            let X = !1,
              j = !1,
              q = !0,
              it = !1,
              st = !1,
              nt = null,
              ut = { box: null, offscreen: null, occluded: null },
              ht = { box: null, offscreen: null, occluded: null },
              pt = null,
              at = null,
              _t = null,
              Ct = 0,
              Pt = 0,
              Ot = 0;
            R.textFeatureIndex ? (Ct = R.textFeatureIndex) : O.useRuntimeCollisionCircles && (Ct = O.featureIndex), R.verticalTextFeatureIndex && (Pt = R.verticalTextFeatureIndex);
            const Ut = (te) => {
                te.tileID = this.retainedQueryData[o.bucketInstanceId].tileID;
                const Kt = this.transform.elevation;
                te.elevation = O.zOffset + (Kt ? Kt.getAtTileOffset(te.tileID, te.tileAnchorX, te.tileAnchorY) : 0);
              },
              Qt = R.textBox;
            if (Qt) {
              Ut(Qt);
              const te = (Wt) => {
                  let Ee = di.horizontal;
                  if (o.allowVerticalPlacement && !Wt && this.prevPlacement) {
                    const Ae = this.prevPlacement.placedOrientations[G];
                    Ae && ((this.placedOrientations[G] = Ae), (Ee = Ae), this.markUsedOrientation(o, Ee, O));
                  }
                  return Ee;
                },
                Kt = (Wt, Ee) => {
                  if (o.allowVerticalPlacement && Z > 0 && R.verticalTextBox) {
                    for (const Ae of o.writingModes) if ((Ae === di.vertical ? ((ut = Ee()), (ht = ut)) : (ut = Wt()), ut && ut.box && ut.box.length)) break;
                  } else ut = Wt();
                };
              if (s.get('text-variable-anchor')) {
                let Wt = s.get('text-variable-anchor');
                if (this.prevPlacement && this.prevPlacement.variableOffsets[G]) {
                  const fe = this.prevPlacement.variableOffsets[G];
                  Wt.indexOf(fe.anchor) > 0 && ((Wt = Wt.filter((Qe) => Qe !== fe.anchor)), Wt.unshift(fe.anchor));
                }
                const Ee = (fe, Qe, Ci) => {
                  const Xe = o.getSymbolInstanceTextSize(p, O, this.transform.zoom, V),
                    oi = (fe.x2 - fe.x1) * Xe + 2 * fe.padding,
                    Ri = (fe.y2 - fe.y1) * Xe + 2 * fe.padding,
                    Pi = O.hasIconTextFit && !T ? Qe : null;
                  Pi && Ut(Pi);
                  let ci = { box: [], offscreen: !1, occluded: !1 };
                  const je = w ? 2 * Wt.length : Wt.length;
                  for (let rr = 0; rr < je; ++rr) {
                    const Gn = this.attemptAnchorPlacement(Wt[rr % Wt.length], fe, oi, Ri, Xe, b, E, h, a, g, rr >= Wt.length, O, V, o, Ci, Pi, p, _);
                    if (Gn && ((ci = Gn.placedGlyphBoxes), ci && ci.box && ci.box.length)) {
                      (X = !0), (nt = Gn.shift);
                      break;
                    }
                  }
                  return ci;
                };
                Kt(
                  () => Ee(Qt, R.iconBox, di.horizontal),
                  () => {
                    const fe = R.verticalTextBox;
                    return fe && Ut(fe), o.allowVerticalPlacement && !(ut && ut.box && ut.box.length) && Z > 0 && fe ? Ee(fe, R.verticalIconBox, di.vertical) : { box: null, offscreen: null, occluded: null };
                  }
                ),
                  ut && ((X = ut.box), (q = ut.offscreen), (it = ut.occluded));
                const Ae = te(!(!ut || !ut.box));
                if (!X && this.prevPlacement) {
                  const fe = this.prevPlacement.variableOffsets[G];
                  fe && ((this.variableOffsets[G] = fe), this.markUsedJustification(o, fe.anchor, O, Ae));
                }
              } else {
                const Wt = (Ee, Ae) => {
                  const fe = o.getSymbolInstanceTextSize(p, O, this.transform.zoom, V),
                    Qe = this.collisionIndex.placeCollisionBox(o, fe, Ee, new H(0, 0), w, h, a, g.predicate);
                  return Qe && Qe.box && Qe.box.length && (this.markUsedOrientation(o, Ae, O), (this.placedOrientations[G] = Ae)), Qe;
                };
                Kt(
                  () => Wt(Qt, di.horizontal),
                  () => {
                    const Ee = R.verticalTextBox;
                    return o.allowVerticalPlacement && Z > 0 && Ee ? (Ut(Ee), Wt(Ee, di.vertical)) : { box: null, offscreen: null, occluded: null };
                  }
                ),
                  te(!!(ut && ut.box && ut.box.length));
              }
            }
            if (((pt = ut), (X = pt && pt.box && pt.box.length > 0), (q = pt && pt.offscreen), (it = pt && pt.occluded), O.useRuntimeCollisionCircles)) {
              const te = o.text.placedSymbolArray.get(O.centerJustifiedTextSymbolIndex >= 0 ? O.centerJustifiedTextSymbolIndex : O.verticalPlacedTextSymbolIndex),
                Kt = Dl(o.textSizeData, p, te),
                Wt = s.get('text-padding');
              (at = this.collisionIndex.placeCollisionCircles(o, w, te, o.lineVertexArray, o.glyphOffsetArray, Kt, a, l, c, r, E, g.predicate, (O.collisionCircleDiameter * Kt) / Qi, Wt, this.retainedQueryData[o.bucketInstanceId].tileID)), (X = w || (at.circles.length > 0 && !at.collisionDetected)), (q = q && at.offscreen), (it = at.occluded);
            }
            if ((R.iconFeatureIndex && (Ot = R.iconFeatureIndex), R.iconBox)) {
              const te = (Kt) => {
                Ut(Kt);
                const Wt = O.hasIconTextFit && nt ? Mm(nt.x, nt.y, b, E, this.transform.angle) : new H(0, 0),
                  Ee = o.getSymbolInstanceIconSize(_, this.transform.zoom, O.placedIconSymbolIndex);
                return this.collisionIndex.placeCollisionBox(o, Ee, Kt, Wt, T, h, a, g.predicate);
              };
              ht && ht.box && ht.box.length && R.verticalIconBox ? ((_t = te(R.verticalIconBox)), (j = _t.box.length > 0)) : ((_t = te(R.iconBox)), (j = _t.box.length > 0)), (q = q && _t.offscreen), (st = _t.occluded);
            }
            const Ht = y || (O.numHorizontalGlyphVertices === 0 && Z === 0),
              Ce = v || O.numIconVertices === 0;
            if ((Ht || Ce ? (Ce ? Ht || (j = j && X) : (X = j && X)) : (j = X = j && X), X && pt && pt.box && this.collisionIndex.insertCollisionBox(pt.box, s.get('text-ignore-placement'), o.bucketInstanceId, ht && ht.box && Pt ? Pt : Ct, g.ID), j && _t && this.collisionIndex.insertCollisionBox(_t.box, s.get('icon-ignore-placement'), o.bucketInstanceId, Ot, g.ID), at && (X && this.collisionIndex.insertCollisionCircles(at.circles, s.get('text-ignore-placement'), o.bucketInstanceId, Ct, g.ID), r))) {
              const te = o.bucketInstanceId;
              let Kt = this.collisionCircleArrays[te];
              Kt === void 0 && (Kt = this.collisionCircleArrays[te] = new xP());
              for (let Wt = 0; Wt < at.circles.length; Wt += 4) Kt.circles.push(at.circles[Wt + 0]), Kt.circles.push(at.circles[Wt + 1]), Kt.circles.push(at.circles[Wt + 2]), Kt.circles.push(at.collisionDetected ? 1 : 0);
            }
            const be = o.projection.name !== 'globe';
            (C = C && (be || !it)), (z = z && (be || !st)), (this.placements[G] = new Em(X || C, j || z, q || o.justReloaded)), i.add(G);
          };
          if ((I && this.buildingIndex && (this.buildingIndex.updateZOffset(o, this.retainedQueryData[o.bucketInstanceId].tileID), o.updateZOffset()), S)) {
            const O = o.getSortedSymbolIndexes(this.transform.angle);
            for (let V = O.length - 1; V >= 0; --V) {
              const R = O[V];
              k(o.symbolInstances.get(R), R, o.collisionArrays[R]);
            }
            o.hasAnyZOffset && B(`${o.layerIds[0]} layer symbol-z-elevate: symbols are not sorted by elevation if symbol-z-order is evaluated to viewport-y`);
          } else if (o.hasAnyZOffset) {
            const O = o.getSortedIndexesByZOffset();
            for (let V = 0; V < O.length; ++V) {
              const R = O[V];
              k(o.symbolInstances.get(R), R, o.collisionArrays[R]);
            }
          } else for (let O = t.symbolInstanceStart; O < t.symbolInstanceEnd; O++) k(o.symbolInstances.get(O), O, o.collisionArrays[O]);
          if (r && o.bucketInstanceId in this.collisionCircleArrays) {
            const O = this.collisionCircleArrays[o.bucketInstanceId];
            J.invert(O.invProjMatrix, a), (O.viewportMatrix = this.collisionIndex.getViewportMatrix());
          }
          o.justReloaded = !1;
        }
        markUsedJustification(t, i, r, n) {
          const { leftJustifiedTextSymbolIndex: o, centerJustifiedTextSymbolIndex: s, rightJustifiedTextSymbolIndex: a, verticalPlacedTextSymbolIndex: l, crossTileID: c } = r,
            u = jp(i),
            h = n === di.vertical ? l : u === 'left' ? o : u === 'center' ? s : u === 'right' ? a : -1;
          o >= 0 && (t.text.placedSymbolArray.get(o).crossTileID = h >= 0 && o !== h ? 0 : c), s >= 0 && (t.text.placedSymbolArray.get(s).crossTileID = h >= 0 && s !== h ? 0 : c), a >= 0 && (t.text.placedSymbolArray.get(a).crossTileID = h >= 0 && a !== h ? 0 : c), l >= 0 && (t.text.placedSymbolArray.get(l).crossTileID = h >= 0 && l !== h ? 0 : c);
        }
        markUsedOrientation(t, i, r) {
          const n = i === di.horizontal || i === di.horizontalOnly ? i : 0,
            o = i === di.vertical ? i : 0,
            { leftJustifiedTextSymbolIndex: s, centerJustifiedTextSymbolIndex: a, rightJustifiedTextSymbolIndex: l, verticalPlacedTextSymbolIndex: c } = r,
            u = t.text.placedSymbolArray;
          s >= 0 && (u.get(s).placedOrientation = n), a >= 0 && (u.get(a).placedOrientation = n), l >= 0 && (u.get(l).placedOrientation = n), c >= 0 && (u.get(c).placedOrientation = o);
        }
        commit(t) {
          (this.commitTime = t), (this.zoomAtLastRecencyCheck = this.transform.zoom);
          const i = this.prevPlacement;
          let r = !1;
          this.prevZoomAdjustment = i ? i.zoomAdjustment(this.transform.zoom) : 0;
          const n = i ? i.symbolFadeChange(t) : 1,
            o = i ? i.opacities : {},
            s = i ? i.variableOffsets : {},
            a = i ? i.placedOrientations : {};
          for (const l in this.placements) {
            const c = this.placements[l],
              u = o[l];
            u ? ((this.opacities[l] = new tc(u, n, c.text, c.icon, null, c.clipped)), (r = r || c.text !== u.text.placed || c.icon !== u.icon.placed)) : ((this.opacities[l] = new tc(null, n, c.text, c.icon, c.skipFade, c.clipped)), (r = r || c.text || c.icon));
          }
          for (const l in o) {
            const c = o[l];
            if (!this.opacities[l]) {
              const u = new tc(c, n, !1, !1);
              u.isHidden() || ((this.opacities[l] = u), (r = r || c.text.placed || c.icon.placed));
            }
          }
          for (const l in s) this.variableOffsets[l] || !this.opacities[l] || this.opacities[l].isHidden() || (this.variableOffsets[l] = s[l]);
          for (const l in a) this.placedOrientations[l] || !this.opacities[l] || this.opacities[l].isHidden() || (this.placedOrientations[l] = a[l]);
          r ? (this.lastPlacementChangeTime = t) : typeof this.lastPlacementChangeTime != 'number' && (this.lastPlacementChangeTime = i ? i.lastPlacementChangeTime : t);
        }
        updateLayerOpacities(t, i) {
          const r = new Set();
          for (const n of i) {
            const o = n.getBucket(t);
            o && n.latestFeatureIndex && t.fqid === o.layerIds[0] && (this.updateBucketOpacities(o, r, n.collisionBoxArray), o.layers[0].layout.get('symbol-z-elevate') && this.buildingIndex && (this.buildingIndex.updateZOffset(o, n.tileID), o.updateZOffset()));
          }
        }
        updateBucketOpacities(t, i, r) {
          t.hasTextData() && t.text.opacityVertexArray.clear(), t.hasIconData() && t.icon.opacityVertexArray.clear(), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexArray.clear(), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexArray.clear();
          const n = t.layers[0].layout,
            o = !!t.layers[0].dynamicFilter(),
            s = new tc(null, 0, !1, !1, !0),
            a = n.get('text-allow-overlap'),
            l = n.get('icon-allow-overlap'),
            c = n.get('text-variable-anchor'),
            u = n.get('text-rotation-alignment') === 'map',
            h = n.get('text-pitch-alignment') === 'map',
            d = new tc(null, 0, a && (l || !t.hasIconData() || n.get('icon-optional')), l && (a || !t.hasTextData() || n.get('text-optional')), !0);
          !t.collisionArrays && r && (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) && t.deserializeCollisionBoxes(r);
          const f = (_, g, y) => {
            for (let v = 0; v < g / 4; v++) _.opacityVertexArray.emplaceBack(y);
          };
          let p = 0;
          for (let _ = 0; _ < t.symbolInstances.length; _++) {
            const g = t.symbolInstances.get(_),
              { numHorizontalGlyphVertices: y, numVerticalGlyphVertices: v, crossTileID: w, numIconVertices: T } = g,
              b = i.has(w);
            let E = this.opacities[w];
            b ? (E = s) : E || ((E = d), (this.opacities[w] = E)), i.add(w);
            const S = y > 0 || v > 0,
              I = T > 0,
              C = this.placedOrientations[w],
              z = C === di.vertical,
              k = C === di.horizontal || C === di.horizontalOnly;
            if (((!S && !I) || E.isHidden() || p++, S)) {
              const O = pb(E.text);
              f(t.text, y, z ? fh : O), f(t.text, v, k ? fh : O);
              const V = E.text.isHidden(),
                { leftJustifiedTextSymbolIndex: R, centerJustifiedTextSymbolIndex: G, rightJustifiedTextSymbolIndex: Z, verticalPlacedTextSymbolIndex: X } = g,
                j = t.text.placedSymbolArray,
                q = V || z ? 1 : 0;
              R >= 0 && (j.get(R).hidden = q), G >= 0 && (j.get(G).hidden = q), Z >= 0 && (j.get(Z).hidden = q), X >= 0 && (j.get(X).hidden = V || k ? 1 : 0);
              const it = this.variableOffsets[w];
              it && this.markUsedJustification(t, it.anchor, g, C);
              const st = this.placedOrientations[w];
              st && (this.markUsedJustification(t, 'left', g, st), this.markUsedOrientation(t, st, g));
            }
            if (I) {
              const O = pb(E.icon),
                { placedIconSymbolIndex: V, verticalPlacedIconSymbolIndex: R } = g,
                G = t.icon.placedSymbolArray,
                Z = E.icon.isHidden() ? 1 : 0;
              V >= 0 && (f(t.icon, T, z ? fh : O), (G.get(V).hidden = Z)), R >= 0 && (f(t.icon, g.numVerticalIconVertices, k ? fh : O), (G.get(R).hidden = Z));
            }
            if (t.hasIconCollisionBoxData() || t.hasTextCollisionBoxData()) {
              const O = t.collisionArrays[_];
              if (O) {
                let V = new H(0, 0),
                  R = !0;
                if (O.textBox || O.verticalTextBox) {
                  if (c) {
                    const Z = this.variableOffsets[w];
                    Z ? ((V = fb(Z.anchor, Z.width, Z.height, Z.textOffset, Z.textScale)), u && V._rotate(h ? this.transform.angle : -this.transform.angle)) : (R = !1);
                  }
                  o && (R = !E.clipped), O.textBox && dh(t.textCollisionBox.collisionVertexArray, E.text.placed, !R || z, V.x, V.y), O.verticalTextBox && dh(t.textCollisionBox.collisionVertexArray, E.text.placed, !R || k, V.x, V.y);
                }
                const G = R && !!(!k && O.verticalIconBox);
                O.iconBox && dh(t.iconCollisionBox.collisionVertexArray, E.icon.placed, G, g.hasIconTextFit ? V.x : 0, g.hasIconTextFit ? V.y : 0), O.verticalIconBox && dh(t.iconCollisionBox.collisionVertexArray, E.icon.placed, !G, g.hasIconTextFit ? V.x : 0, g.hasIconTextFit ? V.y : 0);
              }
            }
          }
          if (((t.fullyClipped = p === 0), t.sortFeatures(this.transform.angle), this.retainedQueryData[t.bucketInstanceId] && (this.retainedQueryData[t.bucketInstanceId].featureSortOrder = t.featureSortOrder), t.hasTextData() && t.text.opacityVertexBuffer && t.text.opacityVertexBuffer.updateData(t.text.opacityVertexArray), t.hasIconData() && t.icon.opacityVertexBuffer && t.icon.opacityVertexBuffer.updateData(t.icon.opacityVertexArray), t.hasIconCollisionBoxData() && t.iconCollisionBox.collisionVertexBuffer && t.iconCollisionBox.collisionVertexBuffer.updateData(t.iconCollisionBox.collisionVertexArray), t.hasTextCollisionBoxData() && t.textCollisionBox.collisionVertexBuffer && t.textCollisionBox.collisionVertexBuffer.updateData(t.textCollisionBox.collisionVertexArray), t.bucketInstanceId in this.collisionCircleArrays)) {
            const _ = this.collisionCircleArrays[t.bucketInstanceId];
            (t.placementInvProjMatrix = _.invProjMatrix), (t.placementViewportMatrix = _.viewportMatrix), (t.collisionCircleArray = _.circles), delete this.collisionCircleArrays[t.bucketInstanceId];
          }
        }
        symbolFadeChange(t) {
          return this.fadeDuration === 0 ? 1 : (t - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
        }
        zoomAdjustment(t) {
          return Math.max(0, (this.transform.zoom - t) / 1.5);
        }
        hasTransitions(t) {
          return this.stale || t - this.lastPlacementChangeTime < this.fadeDuration;
        }
        stillRecent(t, i) {
          const r = this.zoomAtLastRecencyCheck === i ? 1 - this.zoomAdjustment(i) : 1;
          return (this.zoomAtLastRecencyCheck = i), this.commitTime + this.fadeDuration * r > t;
        }
        setStale() {
          this.stale = !0;
        }
      }
      function dh(e, t, i, r, n) {
        e.emplaceBack(t ? 1 : 0, i ? 1 : 0, r || 0, n || 0), e.emplaceBack(t ? 1 : 0, i ? 1 : 0, r || 0, n || 0), e.emplaceBack(t ? 1 : 0, i ? 1 : 0, r || 0, n || 0), e.emplaceBack(t ? 1 : 0, i ? 1 : 0, r || 0, n || 0);
      }
      const TP = Math.pow(2, 25),
        EP = Math.pow(2, 24),
        MP = Math.pow(2, 17),
        SP = Math.pow(2, 16),
        AP = Math.pow(2, 9),
        IP = Math.pow(2, 8),
        CP = Math.pow(2, 1);
      function pb(e) {
        if (e.opacity === 0 && !e.placed) return 0;
        if (e.opacity === 1 && e.placed) return 4294967295;
        const t = e.placed ? 1 : 0,
          i = Math.floor(127 * e.opacity);
        return i * TP + t * EP + i * MP + t * SP + i * AP + t * IP + i * CP + t;
      }
      const fh = 0;
      class PP {
        constructor(t) {
          (this._sortAcrossTiles = t.layout.get('symbol-z-order') !== 'viewport-y' && t.layout.get('symbol-sort-key').constantOr(1) !== void 0), (this._currentTileIndex = 0), (this._currentPartIndex = 0), (this._seenCrossTileIDs = new Set()), (this._bucketParts = []);
        }
        continuePlacement(t, i, r, n, o) {
          const s = this._bucketParts;
          for (; this._currentTileIndex < t.length; ) if ((i.getBucketParts(s, n, t[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, o())) return !0;
          for (this._sortAcrossTiles && ((this._sortAcrossTiles = !1), s.sort((a, l) => a.sortKey - l.sortKey)); this._currentPartIndex < s.length; ) {
            const a = s[this._currentPartIndex];
            if ((i.placeLayerBucketPart(a, this._seenCrossTileIDs, r, a.symbolInstanceStart === 0), this._currentPartIndex++, o())) return !0;
          }
          return !1;
        }
      }
      class zP {
        constructor(t, i, r, n, o, s, a, l, c) {
          (this.placement = new wP(t, o, s, a, l, c)), (this._currentPlacementIndex = i.length - 1), (this._forceFullPlacement = r), (this._showCollisionBoxes = n), (this._done = !1);
        }
        isDone() {
          return this._done;
        }
        continuePlacement(t, i, r, n) {
          const o = oe.now(),
            s = () => {
              const a = oe.now() - o;
              return !this._forceFullPlacement && a > 2;
            };
          for (; this._currentPlacementIndex >= 0; ) {
            const a = i[t[this._currentPlacementIndex]],
              l = this.placement.collisionIndex.transform.zoom;
            if (a.type === 'symbol' && (!a.minzoom || a.minzoom <= l) && (!a.maxzoom || a.maxzoom > l)) {
              const c = a,
                u = c.layout.get('symbol-z-elevate'),
                h = (this._inProgressLayer = this._inProgressLayer || new PP(c)),
                d = pr(a.source, a.scope);
              if (h.continuePlacement(u ? n[d] : r[d], this.placement, this._showCollisionBoxes, a, s)) return;
              delete this._inProgressLayer;
            }
            this._currentPlacementIndex--;
          }
          this._done = !0;
        }
        commit(t) {
          return this.placement.commit(t), this.placement;
        }
      }
      const mb = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
      class ph {
        static from(t) {
          if (!(t instanceof ArrayBuffer)) throw new Error('Data must be an instance of ArrayBuffer.');
          const [i, r] = new Uint8Array(t, 0, 2);
          if (i !== 219) throw new Error('Data does not appear to be in a KDBush format.');
          const n = r >> 4;
          if (n !== 1) throw new Error(`Got v${n} data when expected v1.`);
          const o = mb[15 & r];
          if (!o) throw new Error('Unrecognized array type.');
          const [s] = new Uint16Array(t, 2, 1),
            [a] = new Uint32Array(t, 4, 1);
          return new ph(a, s, o, t);
        }
        constructor(t, i = 64, r = Float64Array, n) {
          if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);
          (this.numItems = +t), (this.nodeSize = Math.min(Math.max(+i, 2), 65535)), (this.ArrayType = r), (this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array);
          const o = mb.indexOf(this.ArrayType),
            s = 2 * t * this.ArrayType.BYTES_PER_ELEMENT,
            a = t * this.IndexArrayType.BYTES_PER_ELEMENT,
            l = (8 - (a % 8)) % 8;
          if (o < 0) throw new Error(`Unexpected typed array class: ${r}.`);
          n && n instanceof ArrayBuffer ? ((this.data = n), (this.ids = new this.IndexArrayType(this.data, 8, t)), (this.coords = new this.ArrayType(this.data, 8 + a + l, 2 * t)), (this._pos = 2 * t), (this._finished = !0)) : ((this.data = new ArrayBuffer(8 + s + a + l)), (this.ids = new this.IndexArrayType(this.data, 8, t)), (this.coords = new this.ArrayType(this.data, 8 + a + l, 2 * t)), (this._pos = 0), (this._finished = !1), new Uint8Array(this.data, 0, 2).set([219, 16 + o]), (new Uint16Array(this.data, 2, 1)[0] = i), (new Uint32Array(this.data, 4, 1)[0] = t));
        }
        add(t, i) {
          const r = this._pos >> 1;
          return (this.ids[r] = r), (this.coords[this._pos++] = t), (this.coords[this._pos++] = i), r;
        }
        finish() {
          const t = this._pos >> 1;
          if (t !== this.numItems) throw new Error(`Added ${t} items when expected ${this.numItems}.`);
          return Sm(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), (this._finished = !0), this;
        }
        range(t, i, r, n) {
          if (!this._finished) throw new Error('Data not yet indexed - call index.finish().');
          const { ids: o, coords: s, nodeSize: a } = this,
            l = [0, o.length - 1, 0],
            c = [];
          for (; l.length; ) {
            const u = l.pop() || 0,
              h = l.pop() || 0,
              d = l.pop() || 0;
            if (h - d <= a) {
              for (let g = d; g <= h; g++) {
                const y = s[2 * g],
                  v = s[2 * g + 1];
                y >= t && y <= r && v >= i && v <= n && c.push(o[g]);
              }
              continue;
            }
            const f = (d + h) >> 1,
              p = s[2 * f],
              _ = s[2 * f + 1];
            p >= t && p <= r && _ >= i && _ <= n && c.push(o[f]), (u === 0 ? t <= p : i <= _) && (l.push(d), l.push(f - 1), l.push(1 - u)), (u === 0 ? r >= p : n >= _) && (l.push(f + 1), l.push(h), l.push(1 - u));
          }
          return c;
        }
        within(t, i, r) {
          if (!this._finished) throw new Error('Data not yet indexed - call index.finish().');
          const { ids: n, coords: o, nodeSize: s } = this,
            a = [0, n.length - 1, 0],
            l = [],
            c = r * r;
          for (; a.length; ) {
            const u = a.pop() || 0,
              h = a.pop() || 0,
              d = a.pop() || 0;
            if (h - d <= s) {
              for (let g = d; g <= h; g++) gb(o[2 * g], o[2 * g + 1], t, i) <= c && l.push(n[g]);
              continue;
            }
            const f = (d + h) >> 1,
              p = o[2 * f],
              _ = o[2 * f + 1];
            gb(p, _, t, i) <= c && l.push(n[f]), (u === 0 ? t - r <= p : i - r <= _) && (a.push(d), a.push(f - 1), a.push(1 - u)), (u === 0 ? t + r >= p : i + r >= _) && (a.push(f + 1), a.push(h), a.push(1 - u));
          }
          return l;
        }
      }
      function Sm(e, t, i, r, n, o) {
        if (n - r <= i) return;
        const s = (r + n) >> 1;
        _b(e, t, s, r, n, o), Sm(e, t, i, r, s - 1, 1 - o), Sm(e, t, i, s + 1, n, 1 - o);
      }
      function _b(e, t, i, r, n, o) {
        for (; n > r; ) {
          if (n - r > 600) {
            const c = n - r + 1,
              u = i - r + 1,
              h = Math.log(c),
              d = 0.5 * Math.exp((2 * h) / 3),
              f = 0.5 * Math.sqrt((h * d * (c - d)) / c) * (u - c / 2 < 0 ? -1 : 1);
            _b(e, t, i, Math.max(r, Math.floor(i - (u * d) / c + f)), Math.min(n, Math.floor(i + ((c - u) * d) / c + f)), o);
          }
          const s = t[2 * i + o];
          let a = r,
            l = n;
          for (ec(e, t, r, i), t[2 * n + o] > s && ec(e, t, r, n); a < l; ) {
            for (ec(e, t, a, l), a++, l--; t[2 * a + o] < s; ) a++;
            for (; t[2 * l + o] > s; ) l--;
          }
          t[2 * r + o] === s ? ec(e, t, r, l) : (l++, ec(e, t, l, n)), l <= i && (r = l + 1), i <= l && (n = l - 1);
        }
      }
      function ec(e, t, i, r) {
        Am(e, i, r), Am(t, 2 * i, 2 * r), Am(t, 2 * i + 1, 2 * r + 1);
      }
      function Am(e, t, i) {
        const r = e[t];
        (e[t] = e[i]), (e[i] = r);
      }
      function gb(e, t, i, r) {
        const n = e - i,
          o = t - r;
        return n * n + o * o;
      }
      const Im = 512 / lt / 2;
      class DP {
        constructor(t, i, r) {
          (this.tileID = t), (this.bucketInstanceId = r), (this.index = new ph(i.length, 16, Int32Array)), (this.keys = []), (this.crossTileIDs = []);
          const n = t.canonical.x * lt,
            o = t.canonical.y * lt;
          for (let s = 0; s < i.length; s++) {
            const { key: a, crossTileID: l, tileAnchorX: c, tileAnchorY: u } = i.get(s),
              h = Math.floor((n + c) * Im),
              d = Math.floor((o + u) * Im);
            this.index.add(h, d), this.keys.push(a), this.crossTileIDs.push(l);
          }
          this.index.finish();
        }
        findMatches(t, i, r) {
          const n = this.tileID.canonical.z < i.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - i.canonical.z),
            o = Im / Math.pow(2, i.canonical.z - this.tileID.canonical.z),
            s = i.canonical.x * lt,
            a = i.canonical.y * lt;
          for (let l = 0; l < t.length; l++) {
            const c = t.get(l);
            if (c.crossTileID) continue;
            const { key: u, tileAnchorX: h, tileAnchorY: d } = c,
              f = Math.floor((s + h) * o),
              p = Math.floor((a + d) * o),
              _ = this.index.range(f - n, p - n, f + n, p + n);
            for (const g of _) {
              const y = this.crossTileIDs[g];
              if (this.keys[g] === u && !r.has(y)) {
                r.add(y), (c.crossTileID = y);
                break;
              }
            }
          }
        }
      }
      class RP {
        constructor() {
          this.maxCrossTileID = 0;
        }
        generate() {
          return ++this.maxCrossTileID;
        }
      }
      class LP {
        constructor() {
          (this.indexes = {}), (this.usedCrossTileIDs = {}), (this.lng = 0);
        }
        handleWrapJump(t) {
          const i = Math.round((t - this.lng) / 360);
          if (i !== 0)
            for (const r in this.indexes) {
              const n = this.indexes[r],
                o = {};
              for (const s in n) {
                const a = n[s];
                (a.tileID = a.tileID.unwrapTo(a.tileID.wrap + i)), (o[a.tileID.key] = a);
              }
              this.indexes[r] = o;
            }
          this.lng = t;
        }
        addBucket(t, i, r) {
          if (this.indexes[t.overscaledZ] && this.indexes[t.overscaledZ][t.key]) {
            if (this.indexes[t.overscaledZ][t.key].bucketInstanceId === i.bucketInstanceId) return !1;
            this.removeBucketCrossTileIDs(t.overscaledZ, this.indexes[t.overscaledZ][t.key]);
          }
          for (let o = 0; o < i.symbolInstances.length; o++) i.symbolInstances.get(o).crossTileID = 0;
          this.usedCrossTileIDs[t.overscaledZ] || (this.usedCrossTileIDs[t.overscaledZ] = new Set());
          const n = this.usedCrossTileIDs[t.overscaledZ];
          for (const o in this.indexes) {
            const s = this.indexes[o];
            if (Number(o) > t.overscaledZ)
              for (const a in s) {
                const l = s[a];
                l.tileID.isChildOf(t) && l.findMatches(i.symbolInstances, t, n);
              }
            else {
              const a = s[t.scaledTo(Number(o)).key];
              a && a.findMatches(i.symbolInstances, t, n);
            }
          }
          for (let o = 0; o < i.symbolInstances.length; o++) {
            const s = i.symbolInstances.get(o);
            s.crossTileID || ((s.crossTileID = r.generate()), n.add(s.crossTileID));
          }
          return this.indexes[t.overscaledZ] === void 0 && (this.indexes[t.overscaledZ] = {}), (this.indexes[t.overscaledZ][t.key] = new DP(t, i.symbolInstances, i.bucketInstanceId)), !0;
        }
        removeBucketCrossTileIDs(t, i) {
          for (const r of i.crossTileIDs) this.usedCrossTileIDs[t].delete(r);
        }
        removeStaleBuckets(t) {
          let i = !1;
          for (const r in this.indexes) {
            const n = this.indexes[r];
            for (const o in n) t[n[o].bucketInstanceId] || (this.removeBucketCrossTileIDs(r, n[o]), delete n[o], (i = !0));
          }
          return i;
        }
      }
      class kP {
        constructor() {
          (this.layerIndexes = {}), (this.crossTileIDs = new RP()), (this.maxBucketInstanceId = 0), (this.bucketsInCurrentPlacement = {});
        }
        addLayer(t, i, r, n) {
          let o = this.layerIndexes[t.fqid];
          o === void 0 && (o = this.layerIndexes[t.fqid] = new LP());
          let s = !1;
          const a = {};
          n.name !== 'globe' && o.handleWrapJump(r);
          for (const l of i) {
            const c = l.getBucket(t);
            c && t.fqid === c.layerIds[0] && (c.bucketInstanceId || (c.bucketInstanceId = ++this.maxBucketInstanceId), o.addBucket(l.tileID, c, this.crossTileIDs) && (s = !0), (a[c.bucketInstanceId] = !0));
          }
          return o.removeStaleBuckets(a) && (s = !0), s;
        }
        pruneUnusedLayers(t) {
          const i = {};
          t.forEach((r) => {
            i[r] = !0;
          });
          for (const r in this.layerIndexes) i[r] || delete this.layerIndexes[r];
        }
      }
      var yb = `
#define EPSILON 0.0000001
#define PI 3.141592653589793
#ifdef RENDER_CUTOFF
float cutoff_opacity(vec4 cutoff_params,float depth) {float near=cutoff_params.x;float far=cutoff_params.y;float cutoffStart=cutoff_params.z;float cutoffEnd=cutoff_params.w-0.0001;float linearDepth=(depth-near)/(far-near);return clamp((linearDepth-cutoffStart)/(cutoffEnd-cutoffStart),0.0,1.0);}
#endif`,
        xb = 'in highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;out highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}',
        vb = `
#define ELEVATION_SCALE 7.0
#define ELEVATION_OFFSET 450.0
#ifdef PROJECTION_GLOBE_VIEW
uniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(
mix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}
#else
vec3 elevationVector(vec2 pos) { return vec3(0,0,1); }
#endif
#ifdef TERRAIN
uniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;uniform sampler2D u_depth;uniform vec2 u_depth_size_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float currentElevation(vec2 apos) {
#ifdef TERRAIN_DEM_FLOAT_FORMAT
vec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem,pos).r;
#else
float dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(dd,0)).r;float bl=texture(u_dem,pos+vec2(0,dd)).r;float br=texture(u_dem,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);
#endif
}float prevElevation(vec2 apos) {
#ifdef TERRAIN_DEM_FLOAT_FORMAT
vec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem_prev,pos).r;
#else
float dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem_prev,pos).r;float tr=texture(u_dem_prev,pos+vec2(dd,0)).r;float bl=texture(u_dem_prev,pos+vec2(0,dd)).r;float br=texture(u_dem_prev,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);
#endif
}
#ifdef TERRAIN_VERTEX_MORPHING
float elevation(vec2 apos) {
#ifdef ZERO_EXAGGERATION
return 0.0;
#endif
float nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}
#else
float elevation(vec2 apos) {
#ifdef ZERO_EXAGGERATION
return 0.0;
#endif
return currentElevation(apos);}
#endif
highp float unpack_depth(highp vec4 rgba_depth)
{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}bool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;float depth=unpack_depth(texture(u_depth,(coord.xy+1.0)*0.5));return coord.z > depth+0.0005;}float occlusionFade(vec4 frag) {vec3 coord=frag.xyz/frag.w;vec3 df=vec3(5.0*u_depth_size_inv,0.0);vec2 uv=0.5*coord.xy+0.5;vec4 depth=vec4(
unpack_depth(texture(u_depth,uv-df.xz)),unpack_depth(texture(u_depth,uv+df.xz)),unpack_depth(texture(u_depth,uv-df.zy)),unpack_depth(texture(u_depth,uv+df.zy))
);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z-0.001)-depth),0.0,1.0));}vec4 fourSample(vec2 pos,vec2 off) {float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(off.x,0.0)).r;float bl=texture(u_dem,pos+vec2(0.0,off.y)).r;float br=texture(u_dem,pos+off).r;return vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}
#else
float elevation(vec2 pos) { return 0.0; }bool isOccluded(vec4 frag) { return false; }float occlusionFade(vec4 frag) { return 1.0; }
#endif`,
        bb = `#ifdef FOG
uniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;out vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}
#endif`,
        wb = `highp vec3 hash(highp vec2 p) {highp vec3 p3=fract(p.xyx*vec3(443.8975,397.2973,491.1871));p3+=dot(p3,p3.yxz+19.19);return fract((p3.xxy+p3.yzz)*p3.zyx);}vec3 dither(vec3 color,highp vec2 seed) {vec3 rnd=hash(seed)+hash(seed+0.59374)-0.5;return color+rnd/255.0;}
#ifdef FOG
uniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump vec2 u_fog_vertical_limit;uniform mediump float u_fog_temporal_offset;in vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(
mix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos,float opacity_limit) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,min(opacity,opacity_limit));}vec3 fog_apply(vec3 color,vec3 pos) {return fog_apply(color,pos,1.0);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec4 fog_apply_premultiplied(vec4 color,vec3 pos,float heightMeters) {float verticalProgress=(u_fog_vertical_limit.x > 0.0 || u_fog_vertical_limit.y > 0.0) ? smoothstep(u_fog_vertical_limit.x,u_fog_vertical_limit.y,heightMeters) : 0.0;float opacityLimit=1.0-smoothstep(0.9,1.0,fog_opacity(pos));return mix(fog_apply_premultiplied(color,pos),color,min(verticalProgress,opacityLimit));}vec3 fog_dither(vec3 color) {
#ifdef FOG_DITHERING
vec2 dither_seed=gl_FragCoord.xy+u_fog_temporal_offset;return dither(color,dither_seed);
#else
return color;
#endif
}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}
#endif`,
        Tb = `#ifdef RASTER_ARRAY
uniform sampler2D u_image0;uniform sampler2D u_image1;const vec4 NODATA=vec4(1);vec4 _raTexLinearCoord(vec2 texCoord,vec2 texResolution,out vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return (texCoord.xxyy+vec2(1.5,0.5).xyxy)/texResolution.xxyy;}vec2 _raTexLinearMix(vec2 fxy,vec4 colorMix,float colorOffset,vec4 t00,vec4 t10,vec4 t01,vec4 t11) {vec2 c00=t00==NODATA ? vec2(0) : vec2(colorOffset+dot(t00,colorMix),1);vec2 c10=t10==NODATA ? vec2(0) : vec2(colorOffset+dot(t10,colorMix),1);vec2 c01=t01==NODATA ? vec2(0) : vec2(colorOffset+dot(t01,colorMix),1);vec2 c11=t11==NODATA ? vec2(0) : vec2(colorOffset+dot(t11,colorMix),1);return mix(mix(c01,c11,fxy.x),mix(c00,c10,fxy.x),fxy.y);}vec2 raTexture2D_image0_linear(vec2 texCoord,vec2 texResolution,vec4 colorMix,float colorOffset) {vec2 fxy;vec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texture(u_image0,c.yz),texture(u_image0,c.xz),texture(u_image0,c.yw),texture(u_image0,c.xw)
);}vec2 raTexture2D_image1_linear(vec2 texCoord,vec2 texResolution,vec4 colorMix,float colorOffset) {vec2 fxy;vec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texture(u_image1,c.yz),texture(u_image1,c.xz),texture(u_image1,c.yw),texture(u_image1,c.xw)
);}vec2 raTexture2D_image0_nearest(vec2 texCoord,vec2 texResolution,vec4 colorMix,float colorOffset) {vec4 t=texture(u_image0,texCoord);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}vec2 raTexture2D_image1_nearest(vec2 texCoord,vec2 texResolution,vec4 colorMix,float colorOffset) {vec4 t=texture(u_image1,texCoord);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}
#endif`,
        Eb = `#ifdef RENDER_SHADOWS
uniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_normal_offset;vec3 shadow_normal_offset(vec3 normal) {float tileInMeters=u_shadow_normal_offset[0];vec3 n=vec3(-normal.xy,tileInMeters*normal.z);float dotScale=min(1.0-dot(normal,u_shadow_direction),1.0)*0.5+0.5;return n*dotScale;}vec3 shadow_normal_offset_model(vec3 normal) {float dotScale=min(1.0-dot(normal,u_shadow_direction),1.0)*0.5+0.5;return normal*dotScale;}float shadow_normal_offset_multiplier0() {return u_shadow_normal_offset[1];}float shadow_normal_offset_multiplier1() {return u_shadow_normal_offset[2];}
#endif//RENDER_SHADOWS`,
        Mb = `#ifdef RENDER_SHADOWS
#ifdef DEPTH_TEXTURE
uniform highp sampler2D u_shadowmap_0;uniform highp sampler2D u_shadowmap_1;
#else
uniform sampler2D u_shadowmap_0;uniform sampler2D u_shadowmap_1;
#endif
uniform float u_shadow_intensity;uniform float u_shadow_map_resolution;uniform float u_shadow_texel_size;uniform highp vec3 u_shadow_normal_offset;uniform vec2 u_fade_range;uniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_bias;highp float shadow_sample_1(highp vec2 uv,highp float compare) {highp float shadow_depth;
#ifdef DEPTH_TEXTURE
shadow_depth=texture(u_shadowmap_1,uv).r;
#else
shadow_depth=unpack_depth(texture(u_shadowmap_1,uv))*0.5+0.5;
#endif
return step(shadow_depth,compare);}highp float shadow_sample_0(highp vec2 uv,highp float compare) {highp float shadow_depth;
#ifdef DEPTH_TEXTURE
shadow_depth=texture(u_shadowmap_0,uv).r;
#else
shadow_depth=unpack_depth(texture(u_shadowmap_0,uv))*0.5+0.5;
#endif
return step(shadow_depth,compare);}float shadow_occlusion_1(highp vec4 pos,highp float bias) {highp vec2 uv=pos.xy;return shadow_sample_1(uv,pos.z-bias);}float shadow_occlusion_0(highp vec4 pos,highp float bias) {highp float compare0=pos.z-bias;
#ifdef NATIVE
highp vec2 uv=pos.xy;highp vec4 samples=textureGather(u_shadowmap_0,uv,0);lowp vec4 stepSamples=step(samples,vec4(compare0));
#else
highp vec2 uv00=pos.xy-vec2(0.5*u_shadow_texel_size);highp vec2 uv10=uv00+vec2(u_shadow_texel_size,0.0);highp vec2 uv01=uv00+vec2(0.0,u_shadow_texel_size);highp vec2 uv11=uv01+vec2(u_shadow_texel_size,0.0);lowp vec4 stepSamples=vec4(
shadow_sample_0(uv01,compare0),shadow_sample_0(uv11,compare0),shadow_sample_0(uv10,compare0),shadow_sample_0(uv00,compare0)
);
#endif
vec2 f=fract(pos.xy*u_shadow_map_resolution-vec2(0.5));lowp vec2 lerpx=mix(stepSamples.wx,stepSamples.zy,f.xx);return mix(lerpx.x,lerpx.y,f.y);}float shadow_occlusion(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,highp float bias) {
#ifdef SHADOWS_SINGLE_CASCADE
light_view_pos0.xyz=light_view_pos0.xyz/light_view_pos0.w*0.5+0.5;return shadow_occlusion_0(light_view_pos0,bias);
#else
light_view_pos0.xyz/=light_view_pos0.w;light_view_pos1.xyz/=light_view_pos1.w;vec4 uv=vec4(light_view_pos0.xy,light_view_pos1.xy);vec4 abs_bounds=abs(uv);if (abs_bounds.x < 1.0 && abs_bounds.y < 1.0) {light_view_pos0.xyz=light_view_pos0.xyz*0.5+0.5;return shadow_occlusion_0(light_view_pos0,bias);}if (abs_bounds.z >=1.0 || abs_bounds.w >=1.0) {return 0.0;}light_view_pos1.xyz=light_view_pos1.xyz*0.5+0.5;float occlusion1=shadow_occlusion_1(light_view_pos1,bias);return mix(occlusion1,0.0,smoothstep(u_fade_range.x,u_fade_range.y,view_depth));
#endif
}highp float calculate_shadow_bias(float NDotL) {
#ifdef NORMAL_OFFSET
return 0.5*u_shadow_bias.x;
#else
return 0.5*(u_shadow_bias.x+clamp(u_shadow_bias.y*tan(acos(NDotL)),0.0,u_shadow_bias.z));
#endif
}float shadowed_light_factor_normal(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_unbiased(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadow_occlusion(float ndotl,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=calculate_shadow_bias(ndotl);return shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);}
#endif`;
      const Sb = [];
      gh(yb, Sb);
      const mh = {
          '_prelude_fog.vertex.glsl': bb,
          '_prelude_terrain.vertex.glsl': vb,
          '_prelude_shadow.vertex.glsl': Eb,
          '_prelude_fog.fragment.glsl': wb,
          '_prelude_shadow.fragment.glsl': Mb,
          '_prelude_lighting.glsl': `
#ifdef LIGHTING_3D_MODE
uniform mediump vec3 u_lighting_ambient_color;uniform mediump vec3 u_lighting_directional_dir;uniform mediump vec3 u_lighting_directional_color;uniform mediump vec3 u_ground_radiance;float calculate_ambient_directional_factor(vec3 normal) {float NdotL=dot(normal,u_lighting_directional_dir);const float factor_reduction_max=0.3;float dir_luminance=dot(u_lighting_directional_color,vec3(0.2126,0.7152,0.0722));float directional_factor_min=1.0-factor_reduction_max*min(dir_luminance,1.0);float ambient_directional_factor=mix(directional_factor_min,1.0,min((NdotL+1.0),1.0));const float vertical_factor_min=0.92;float vertical_factor=mix(vertical_factor_min,1.0,normal.z*0.5+0.5);return vertical_factor*ambient_directional_factor;}vec3 linearProduct(vec3 srgbIn,vec3 k) {return srgbIn*pow(k,vec3(1./2.2));}vec3 apply_lighting(vec3 color,vec3 normal,float dir_factor) {float ambient_directional_factor=calculate_ambient_directional_factor(normal);vec3 ambient_contrib=ambient_directional_factor*u_lighting_ambient_color;vec3 directional_contrib=u_lighting_directional_color*dir_factor;return linearProduct(color,ambient_contrib+directional_contrib);}vec4 apply_lighting(vec4 color,vec3 normal,float dir_factor) {return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting(vec3 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return apply_lighting(color.rgb,normal,dir_factor);}vec4 apply_lighting(vec4 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting_ground(vec3 color) {return color*u_ground_radiance;}vec4 apply_lighting_ground(vec4 color) {return vec4(apply_lighting_ground(color.rgb),color.a);}float calculate_NdotL(vec3 normal) {const float ext=0.70710678118;return (clamp(dot(normal,u_lighting_directional_dir),-ext,1.0)+ext)/(1.0+ext);}vec4 apply_lighting_with_emission_ground(vec4 color,float emissive_strength) {return mix(apply_lighting_ground(color),color,emissive_strength);}vec3 compute_flood_lighting(vec3 flood_light_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=flood_light_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);float occlusion_ramp=smoothstep(0.0,0.2,1.0-occlusion);return mix(fully_occluded_color,flood_light_color,occlusion_ramp);}vec3 compute_emissive_draped(vec3 unlit_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=unlit_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);return mix(fully_occluded_color,unlit_color,1.0-occlusion);}
#endif//LIGHTING_3D_MODE`,
          '_prelude_raster_array.glsl': Tb,
        },
        _h = {};
      Ve('', vb), Ve(wb, bb), Ve(Mb, Eb), Ve(Tb, '');
      const Ab = Ve(
          `
out vec4 glFragColor;highp float unpack_depth(highp vec4 rgba_depth)
{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}
#ifdef INDICATOR_CUTOUT
uniform vec2 u_indicator_cutout_centers;uniform vec4 u_indicator_cutout_params;
#endif
vec4 applyCutout(vec4 color) {
#ifdef INDICATOR_CUTOUT
float holeMinOpacity=u_indicator_cutout_params.x;float holeRadius=max(u_indicator_cutout_params.y,0.0);float holeAspectRatio=u_indicator_cutout_params.z;float fadeStart=u_indicator_cutout_params.w;float distA=distance(vec2(gl_FragCoord.x,gl_FragCoord.y*holeAspectRatio),vec2(u_indicator_cutout_centers[0],u_indicator_cutout_centers[1]*holeAspectRatio));return color*min(smoothstep(fadeStart,holeRadius,distA)+holeMinOpacity,1.0);
#else
return color;
#endif
}
#ifdef DEBUG_WIREFRAME
#define HANDLE_WIREFRAME_DEBUG \\
glFragColor=vec4(0.7,0.0,0.0,0.7); \\
gl_FragDepth=gl_FragCoord.z-0.0001;
#else
#define HANDLE_WIREFRAME_DEBUG
#endif
#ifdef RENDER_CUTOFF
uniform highp vec4 u_cutoff_params;in float v_cutoff_opacity;
#endif`,
          `
#define EXTENT 8192.0
#define RAD_TO_DEG 180.0/PI
#define DEG_TO_RAD PI/180.0
#define GLOBE_RADIUS EXTENT/PI/2.0
float wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}
#ifdef PROJECTION_GLOBE_VIEW
vec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {
#ifndef PROJECTED_POS_ON_VIEWPORT
float tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;
#else
return vec3(0.0);
#endif
}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(
unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(PI/4.0+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}
#ifdef RENDER_CUTOFF
uniform vec4 u_cutoff_params;out float v_cutoff_opacity;
#endif
const vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);const float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)
{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}`
        ),
        Ib = yb;
      var Cb = {
        background: Ve(
          `#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform vec4 u_color;uniform float u_opacity;
#ifdef LIGHTING_3D_MODE
in vec4 v_color;
#endif
void main() {vec4 out_color;
#ifdef LIGHTING_3D_MODE
out_color=v_color;
#else
out_color=u_color;
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
glFragColor=out_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`,
          `#include "_prelude_fog.vertex.glsl"
#include "_prelude_lighting.glsl"
in vec2 a_pos;uniform mat4 u_matrix;
#ifdef LIGHTING_3D_MODE
uniform mediump vec4 u_color;out vec4 v_color;uniform float u_emissive_strength;
#endif
void main() {gl_Position=u_matrix*vec4(a_pos,0,1);
#ifdef LIGHTING_3D_MODE
v_color=apply_lighting_with_emission_ground(u_color,u_emissive_strength);
#endif
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`
        ),
        backgroundPattern: Ve(
          `#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform float u_emissive_strength;uniform sampler2D u_image;in vec2 v_pos;void main() {vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=texture(u_image,pos);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
glFragColor=out_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`,
          `#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_tile_units_to_pixels,a_pos);
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`
        ),
        circle: Ve(
          `#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
uniform float u_emissive_strength;void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(
antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)
);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#endif
#ifdef FOG
out_color=fog_apply_premultiplied(out_color,v_fog_pos);
#endif
glFragColor=out_color*(v_visibility*opacity_t);
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
}`,
          `#include "_prelude_fog.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
#define NUM_VISIBILITY_RINGS 2
#define INV_SQRT2 0.70710678
#define ELEVATION_BIAS 0.0001
#define NUM_SAMPLES_PER_RING 16
uniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;in vec2 a_pos;
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;
#endif
out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
vec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {
#if defined(TERRAIN)
return elevation(pos)+ELEVATION_BIAS;
#else
return 0.0;
#endif
}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);
#ifdef PITCH_WITH_MAP
#ifdef PROJECTION_GLOBE_VIEW
return u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );
#else
return u_matrix*( world_center+vec4(sample_offset,0,0) );
#endif
#else
return projected_center+vec4(sample_offset,0,0);
#endif
}float get_sample_step() {
#ifdef PITCH_WITH_MAP
return 2.0*PI/float(NUM_SAMPLES_PER_RING);
#else
return PI/float(NUM_SAMPLES_PER_RING);
#endif
}void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;
#ifdef PROJECTION_GLOBE_VIEW
vec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);
#else 
surface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);
#endif
vec4 projected_center=u_matrix*world_center;float view_scale=0.0;
#ifdef PITCH_WITH_MAP
#ifdef SCALE_WITH_MAP
view_scale=1.0;
#else
view_scale=projected_center.w/u_camera_to_center_distance;
#endif
#else
#ifdef SCALE_WITH_MAP
view_scale=u_camera_to_center_distance;
#else
view_scale=projected_center.w;
#endif
#endif
gl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;
#ifdef TERRAIN
float step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;
#ifdef PITCH_WITH_MAP
float cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;
#else
occlusion_world_center=world_center;occlusion_projected_center=projected_center;
#endif
for(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);
#else
visibility=1.0;
#endif
#ifdef PROJECTION_GLOBE_VIEW
visibility=1.0;
#endif
v_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);
#ifdef FOG
v_fog_pos=fog_position(world_center.xyz);
#endif
}`
        ),
        clippingMask: Ve('void main() {glFragColor=vec4(1.0);}', 'in vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}'),
        heatmap: Ve(
          `#include "_prelude_fog.fragment.glsl"
uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);glFragColor=vec4(val,1.0,1.0,1.0);
#ifdef FOG
if (u_is_globe==0) {glFragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}
#endif
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`,
          `#include "_prelude_terrain.vertex.glsl"
#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;in vec2 a_pos;
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;
#endif
out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;
#ifdef PROJECTION_GLOBE_VIEW
vec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);
#else
pos=vec3(tilePos+extrude,elevation(tilePos));
#endif
gl_Position=u_matrix*vec4(pos,1);
#ifdef FOG
v_fog_pos=fog_position(pos);
#endif
}`
        ),
        heatmapTexture: Ve(
          `uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));glFragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(0.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`,
          'in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}'
        ),
        collisionBox: Ve(
          'in float v_placed;in float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);glFragColor =mix(red,blue,step(0.5,v_placed))*0.5;glFragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}',
          `#include "_prelude_terrain.vertex.glsl"
in vec3 a_pos;in vec2 a_anchor_pos;in vec2 a_extrude;in vec2 a_placed;in vec2 a_shift;in float a_size_scale;in vec2 a_padding;in float a_z_offset;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;out float v_placed;out float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*(a_z_offset+elevation(a_anchor_pos)),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(
0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}`
        ),
        collisionCircle: Ve(
          'in float v_radius;in vec2 v_extrude;in float v_perspective_ratio;in float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);glFragColor=color*alpha*opacity_t;}',
          `in vec2 a_pos_2f;in float a_radius;in vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;out float v_radius;out vec2 v_extrude;out float v_perspective_ratio;out float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(
mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(
0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}`
        ),
        debug: Ve(
          'uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);glFragColor=mix(u_color,overlay_color,overlay_color.a);}',
          `#include "_prelude_terrain.vertex.glsl"
in vec2 a_pos;
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_pos_3;
#endif
out vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;
#ifdef PROJECTION_GLOBE_VIEW
gl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);
#else
gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);
#endif
}`
        ),
        fill: Ve(
          `#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
uniform float u_emissive_strength;void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
vec4 out_color=color;
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
glFragColor=out_color*opacity;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`,
          `#include "_prelude_fog.vertex.glsl"
in vec2 a_pos;uniform mat4 u_matrix;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`
        ),
        fillOutline: Ve(
          `#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
in vec2 v_pos;uniform float u_emissive_strength;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
glFragColor=out_color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`,
          `#include "_prelude_fog.vertex.glsl"
in vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;out vec2 v_pos;
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`
        ),
        fillOutlinePattern: Ve(
          `#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_emissive_strength;in vec2 v_pos;in vec2 v_pos_world;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=texture(u_image,pos);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
glFragColor=out_color*(alpha*opacity);
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`,
          `#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos;out vec2 v_pos_world;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern
#pragma mapbox: define lowp float pixel_ratio
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize lowp float pixel_ratio
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);v_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`
        ),
        fillPattern: Ve(
          `#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform vec2 u_texsize;uniform sampler2D u_image;in vec2 v_pos;uniform float u_emissive_strength;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture(u_image,pos);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
glFragColor=out_color*opacity;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`,
          `#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern
#pragma mapbox: define lowp float pixel_ratio
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize lowp float pixel_ratio
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`
        ),
        fillExtrusion: Ve(
          `#include "_prelude_fog.fragment.glsl"
#include "_prelude_shadow.fragment.glsl"
#include "_prelude_lighting.glsl"
in vec4 v_color;in vec4 v_flat;
#ifdef RENDER_SHADOWS
in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in float v_depth;
#endif
uniform lowp float u_opacity;
#ifdef FAUX_AO
uniform lowp vec2 u_ao;in vec2 v_ao;
#endif
#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)
in vec4 v_roof_color;
#endif
#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)
in highp vec3 v_normal;
#endif
uniform vec3 u_flood_light_color;uniform highp float u_vertical_scale;uniform float u_flood_light_intensity;uniform vec3 u_ground_shadow_factor;
#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)
in float v_flood_radius;in float v_has_floodlight;
#endif
uniform float u_emissive_strength;in float v_height;void main() {
#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)
vec3 normal=normalize(v_normal);
#endif
float z;vec4 color=v_color;
#ifdef ZERO_ROOF_RADIUS
z=float(normal.z > 0.00001);
#ifdef LIGHTING_3D_MODE
normal=mix(normal,vec3(0.0,0.0,1.0),z);
#else
color=mix(v_color,v_roof_color,z);
#endif
#endif
float h=max(0.0,v_height);float ao_shade=1.0;
#ifdef FAUX_AO
float intensity=u_ao[0];float h_floors=h/(u_ao[1]*u_vertical_scale);float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);ao_shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;
#ifdef ZERO_ROOF_RADIUS
concave*=(1.0-z);
#endif
float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);ao_shade*=mix(1.0,x_shade*x_shade*x_shade,concave);
#ifdef LIGHTING_3D_MODE
#ifdef FLOOD_LIGHT
color.rgb*=mix(ao_shade,1.0,v_has_floodlight);
#else
color.rgb*=ao_shade;
#endif
#else
color.rgb*=ao_shade;
#endif
#endif
#ifdef LIGHTING_3D_MODE
float flood_radiance=0.0;
#ifdef FLOOD_LIGHT
flood_radiance=(1.0-min(h/v_flood_radius,1.0))*u_flood_light_intensity*v_has_floodlight;
#endif
#ifdef RENDER_SHADOWS
#ifdef FLOOD_LIGHT
float ndotl_unclamped=dot(normal,u_shadow_direction);float ndotl=max(0.0,ndotl_unclamped);float occlusion=ndotl_unclamped < 0.0 ? 1.0 : shadow_occlusion(ndotl,v_pos_light_view_0,v_pos_light_view_1,v_depth);vec3 litColor=apply_lighting(color.rgb,normal,(1.0-u_shadow_intensity*occlusion)*ndotl);vec3 floodLitColor=compute_flood_lighting(u_flood_light_color*u_opacity,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=mix(litColor,floodLitColor,flood_radiance);
#else
float shadowed_lighting_factor=shadowed_light_factor_normal(normal,v_pos_light_view_0,v_pos_light_view_1,v_depth);color.rgb=apply_lighting(color.rgb,normal,shadowed_lighting_factor);
#endif
#else
color.rgb=apply_lighting(color.rgb,normal);
#ifdef FLOOD_LIGHT
color.rgb=mix(color.rgb,u_flood_light_color*u_opacity,flood_radiance);
#endif
#endif
color.rgb=mix(color.rgb,v_flat.rgb,u_emissive_strength);color*=u_opacity;
#endif
#ifdef FOG
color=fog_dither(fog_apply_premultiplied(color,v_fog_pos,h));
#endif
#ifdef RENDER_CUTOFF
color*=v_cutoff_opacity;
#endif
#ifdef INDICATOR_CUTOUT
color=applyCutout(color);
#endif
glFragColor=color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`,
          `#include "_prelude_fog.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
#include "_prelude_lighting.glsl"
#ifdef RENDER_CUTOFF
invariant gl_Position;
#endif
uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;
#endif
uniform highp float u_vertical_scale;out vec4 v_color;out vec4 v_flat;
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out float v_depth;
#endif
#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)
out vec4 v_roof_color;
#endif
#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)
out highp vec3 v_normal;
#endif
#ifdef FAUX_AO
uniform lowp vec2 u_ao;out vec2 v_ao;
#endif
#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)
out float v_flood_radius;out float v_has_floodlight;
#endif
out float v_height;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
#pragma mapbox: define highp float flood_light_wall_radius
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize highp float flood_light_wall_radius
base*=u_vertical_scale;height*=u_vertical_scale;vec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));
#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)
v_normal=normal;
#endif
base=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);
#if defined(HAS_CENTROID) || defined(TERRAIN)
centroid_pos=a_centroid_pos;
#endif
float ele=0.0;float h=0.0;float c_ele;vec3 pos;
#ifdef TERRAIN
bool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);pos=vec3(pos_nx.xy,h);
#else
h=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);
#endif
#ifdef PROJECTION_GLOBE_VIEW
float lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);
#endif
float hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);h=h-ele;v_height=h;
#ifdef RENDER_SHADOWS
vec3 shd_pos0=pos;vec3 shd_pos1=pos;
#ifdef NORMAL_OFFSET
vec3 offset=shadow_normal_offset(normal);shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;
#endif
float NdotL=0.0;float colorvalue=0.0;
#ifndef LIGHTING_3D_MODE
colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);if (normal.y !=0.0) {float r=0.84;r=mix(0.7,0.98,1.0-u_lightintensity);NdotL*=(
(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}
#endif
#ifdef FAUX_AO
float concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;
#ifdef TERRAIN
top_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);
#endif
v_ao=vec2(mix(concave,-concave,start),y_ground);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);
#ifdef PROJECTION_GLOBE_VIEW
top_height+=u_height_lift;
#endif
gl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;
#endif
#ifdef LIGHTING_3D_MODE
#ifdef FLOOD_LIGHT
float is_wall=1.0-float(t > 0.0 && top_up_ny.y > 0.0);v_has_floodlight=float(flood_light_wall_radius > 0.0 && is_wall > 0.0);v_flood_radius=flood_light_wall_radius*u_vertical_scale;
#endif
v_color=vec4(color.rgb,1.0);v_flat=vec4(linearProduct(color.rgb,vec3(calculate_NdotL(normal))),1.0);
#else
v_color=vec4(0.0,0.0,0.0,1.0);v_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_color*=u_opacity;
#endif
#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)
float roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color=vec4(0.0,0.0,0.0,1.0);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_roof_color*=u_opacity;
#endif
#ifdef FOG
v_fog_pos=fog_position(pos);
#endif
#ifdef RENDER_CUTOFF
v_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);
#endif
}`
        ),
        fillExtrusionDepth: Ve(
          `in highp float v_depth;void main() {
#ifndef DEPTH_TEXTURE
glFragColor=pack_depth(v_depth);
#endif
}`,
          `#include "_prelude_terrain.vertex.glsl"
uniform mat4 u_matrix;uniform float u_edge_radius;uniform float u_vertical_scale;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
out highp float v_depth;void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
base*=u_vertical_scale;height*=u_vertical_scale;vec3 pos_nx=floor(a_pos_normal_ed.xyz*0.5);mediump vec3 top_up_ny=a_pos_normal_ed.xyz-2.0*pos_nx;base=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);
#if defined(HAS_CENTROID) || defined(TERRAIN)
centroid_pos=a_centroid_pos;
#endif
vec3 pos;
#ifdef TERRAIN
bool flat_roof=centroid_pos.x !=0.0 && t > 0.0;float ele=elevation(pos_nx.xy);float c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;float h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base);pos=vec3(pos_nx.xy,h);
#else
pos=vec3(pos_nx.xy,t > 0.0 ? height : base);
#endif
float hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);v_depth=gl_Position.z/gl_Position.w;}`
        ),
        fillExtrusionPattern: Ve(
          `#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform vec2 u_texsize;uniform sampler2D u_image;
#ifdef FAUX_AO
uniform lowp vec2 u_ao;in vec3 v_ao;
#endif
#ifdef LIGHTING_3D_MODE
in vec3 v_normal;
#endif
in vec2 v_pos;in vec4 v_lighting;uniform lowp float u_opacity;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define mediump vec4 pattern
#pragma mapbox: define highp float pixel_ratio
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize highp float pixel_ratio
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 imagecoord=mod(v_pos,1.0);vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);vec4 out_color=texture(u_image,pos);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting(out_color,normalize(v_normal))*u_opacity;
#else
out_color=out_color*v_lighting;
#endif
#ifdef FAUX_AO
float intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
#ifdef INDICATOR_CUTOUT
out_color=applyCutout(out_color);
#endif
glFragColor=out_color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`,
          `#include "_prelude_fog.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
#include "_prelude_lighting.glsl"
uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;
#endif
out vec2 v_pos;out vec4 v_lighting;
#ifdef FAUX_AO
uniform lowp vec2 u_ao;out vec3 v_ao;
#endif
#ifdef LIGHTING_3D_MODE
out vec3 v_normal;
#endif
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define mediump vec4 pattern
#pragma mapbox: define highp float pixel_ratio
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize highp float pixel_ratio
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);
#if defined(HAS_CENTROID) || defined(TERRAIN)
centroid_pos=a_centroid_pos;
#endif
float ele=0.0;float h=z;vec3 p;float c_ele;
#ifdef TERRAIN
bool flat_roof=centroid_pos.x !=0.0 && t > 0.0;ele=elevation(pos_nx.xy);c_ele=flat_roof ? centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos) : ele;h=flat_roof ? max(c_ele+height,ele+base+2.0) : ele+(t > 0.0 ? height : base==0.0 ?-5.0 : base);p=vec3(pos_nx.xy,h);
#else
p=vec3(pos_nx.xy,z);
#endif
#ifdef PROJECTION_GLOBE_VIEW
float lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);
#endif
float hidden=float(centroid_pos.x==0.0 && centroid_pos.y==1.0);gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0
? pos_nx.xy
: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;
#ifdef LIGHTING_3D_MODE
NdotL=calculate_NdotL(normal);
#else
NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);
#endif
if (normal.y !=0.0) {float r=0.84;
#ifndef LIGHTING_3D_MODE
r=mix(0.7,0.98,1.0-u_lightintensity);
#endif
NdotL*=(
(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}
#ifdef FAUX_AO
float concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;
#ifdef TERRAIN
top_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);
#endif
v_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);
#ifdef PROJECTION_GLOBE_VIEW
top_height+=u_height_lift;
#endif
gl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;
#endif
#ifdef LIGHTING_3D_MODE
v_normal=normal;
#else
v_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;
#endif 
#ifdef FOG
v_fog_pos=fog_position(p);
#endif
}`
        ),
        groundShadow: Ve(
          `#include "_prelude_shadow.fragment.glsl"
precision highp float;uniform vec3 u_ground_shadow_factor;in vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;in float v_depth;
#ifdef FOG
in float v_fog_opacity;
#endif
void main() {float light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);vec3 shadow=mix(u_ground_shadow_factor,vec3(1.0),light);
#ifdef RENDER_CUTOFF
shadow=mix(vec3(1.0),shadow,cutoff_opacity(u_cutoff_params,v_depth));
#endif
#ifdef FOG
shadow=mix(shadow,vec3(1.0),v_fog_opacity);
#endif
#ifdef INDICATOR_CUTOUT
shadow=mix(shadow,vec3(1.0),1.0-applyCutout(vec4(1.0)).r);
#endif
glFragColor=vec4(shadow,1.0);}`,
          `#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;in vec2 a_pos;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;out float v_depth;
#ifdef FOG
out float v_fog_opacity;
#endif
void main() {gl_Position=u_matrix*vec4(a_pos,0.0,1.0);v_pos_light_view_0=u_light_matrix_0*vec4(a_pos,0.0,1.0);v_pos_light_view_1=u_light_matrix_1*vec4(a_pos,0.0,1.0);v_depth=gl_Position.w;
#ifdef FOG
v_fog_pos=fog_position(a_pos);v_fog_opacity=fog(v_fog_pos);
#endif
}`
        ),
        fillExtrusionGroundEffect: Ve(
          `uniform highp float u_ao_pass;uniform highp float u_opacity;uniform highp float u_flood_light_intensity;uniform highp vec3 u_flood_light_color;uniform highp float u_attenuation;uniform sampler2D u_fb;uniform float u_fb_size;
#ifdef SDF_SUBPASS
in highp vec2 v_pos;in highp vec4 v_line_segment;in highp float v_flood_light_radius_tile;in highp vec2 v_ao;float line_df(highp vec2 a,highp vec2 b,highp vec2 p) {highp vec2 ba=b-a;highp vec2 pa=p-a;highp float r=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return length(pa-r*ba);}
#ifdef FOG
in highp float v_fog;
#endif
#endif
void main() {
#ifdef CLEAR_SUBPASS
vec4 color=vec4(1.0);
#ifdef CLEAR_FROM_TEXTURE
color=texture(u_fb,gl_FragCoord.xy/vec2(u_fb_size));
#endif
glFragColor=color;
#else
#ifdef SDF_SUBPASS
highp float d=line_df(v_line_segment.xy,v_line_segment.zw,v_pos);highp float effect_radius=mix(v_flood_light_radius_tile,v_ao.y,u_ao_pass);d/=effect_radius;d=min(d,1.0);d=1.0-pow(1.0-d,u_attenuation);highp float effect_intensity=mix(u_flood_light_intensity,v_ao.x,u_ao_pass);highp float fog=1.0;
#ifdef FOG
fog=v_fog;
#endif
#ifdef RENDER_CUTOFF
fog*=v_cutoff_opacity;
#endif
glFragColor=vec4(vec3(0.0),mix(1.0,d,effect_intensity*u_opacity*fog));
#else
vec4 color=mix(vec4(u_flood_light_color,1.0),vec4(vec3(0.0),1.0),u_ao_pass);
#ifdef OVERDRAW_INSPECTOR
color=vec4(1.0);
#endif
glFragColor=color;HANDLE_WIREFRAME_DEBUG;
#endif
#endif
}`,
          `#include "_prelude_fog.vertex.glsl"
in highp vec4 a_pos_end;in highp float a_angular_offset_factor;in highp float a_hidden_by_landmark;
#ifdef SDF_SUBPASS
out highp vec2 v_pos;out highp vec4 v_line_segment;out highp float v_flood_light_radius_tile;out highp vec2 v_ao;
#ifdef FOG
out highp float v_fog;
#endif
#endif
uniform highp float u_flood_light_intensity;uniform highp mat4 u_matrix;uniform highp float u_ao_pass;uniform highp float u_meter_to_tile;uniform highp float u_edge_radius;uniform highp vec2 u_ao;
#pragma mapbox: define highp float flood_light_ground_radius
const float TANGENT_CUTOFF=4.0;const float NORM=32767.0;void main() {
#pragma mapbox: initialize highp float flood_light_ground_radius
vec2 p=a_pos_end.xy;vec2 q=floor(a_pos_end.zw*0.5);vec2 start_bottom=a_pos_end.zw-q*2.0;float fl_ground_radius=flood_light_ground_radius;
#ifdef FORCE_ABS_FL_GROUND_RADIUS
fl_ground_radius=abs(flood_light_ground_radius);
#endif
float flood_radius_tile=fl_ground_radius*u_meter_to_tile;vec2 v=normalize(q-p);float ao_radius=u_ao.y/3.5;float effect_radius=mix(flood_radius_tile,ao_radius,u_ao_pass)+u_edge_radius;float angular_offset_factor=a_angular_offset_factor/NORM*TANGENT_CUTOFF;float angular_offset=angular_offset_factor*effect_radius;float top=1.0-start_bottom.y;float side=(0.5-start_bottom.x)*2.0;vec2 extrusion_parallel=v*side*mix(1.0,angular_offset,top);vec2 perp=vec2(v.y,-v.x);vec2 extrusion_perp=perp*effect_radius*top;vec3 pos=vec3(mix(q,p,start_bottom.x),0.0);pos.xy+=extrusion_parallel+extrusion_perp;
#ifdef SDF_SUBPASS
v_pos=pos.xy;v_line_segment=vec4(p,q)+perp.xyxy*u_edge_radius;v_flood_light_radius_tile=flood_radius_tile;v_ao=vec2(u_ao.x,ao_radius);
#ifdef FOG
v_fog_pos=fog_position(pos);v_fog=1.0-fog(v_fog_pos);
#endif
#endif
float hidden_by_landmark=0.0;
#ifdef HAS_CENTROID
hidden_by_landmark=a_hidden_by_landmark;
#endif
float isFloodlit=float(fl_ground_radius > 0.0 && u_flood_light_intensity > 0.0);float hidden=mix(1.0-isFloodlit,isFloodlit,u_ao_pass);hidden+=hidden_by_landmark;gl_Position=mix(u_matrix*vec4(pos,1.0),AWAY,float(hidden > 0.0));
#ifdef RENDER_CUTOFF
v_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);
#endif
}`
        ),
        hillshadePrepare: Ve(
          `precision highp float;uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;float getElevation(vec2 coord) {return texture(u_image,coord).r/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(
(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)
)/pow(2.0,exaggeration+(19.2562-u_zoom));glFragColor=clamp(vec4(
deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);}`,
          'uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}'
        ),
        hillshade: Ve(
          `#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;uniform float u_emissive_strength;void main() {vec4 pixel=texture(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);glFragColor=accent_color*(1.0-shade_color.a)+shade_color;
#ifdef LIGHTING_3D_MODE
glFragColor=apply_lighting_with_emission_ground(glFragColor,u_emissive_strength);
#endif
#ifdef FOG
glFragColor=fog_dither(fog_apply_premultiplied(glFragColor,v_fog_pos));
#endif
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`,
          `#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
}`
        ),
        line: Ve(
          `#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform lowp float u_device_pixel_ratio;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec4 v_uv;
#ifdef RENDER_LINE_DASH
uniform sampler2D u_dash_image;in vec2 v_tex;
#endif
#ifdef RENDER_LINE_GRADIENT
uniform sampler2D u_gradient_image;
#endif
float luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}uniform float u_emissive_strength;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 dash
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float border_width
#pragma mapbox: define lowp vec4 border_color
float linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize lowp vec4 dash
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float border_width
#pragma mapbox: initialize lowp vec4 border_color
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);
#ifdef RENDER_LINE_DASH
float sdfdist=texture(u_dash_image,v_tex).a;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;alpha*=linearstep(0.5-sdfgamma/floorwidth,0.5+sdfgamma/floorwidth,sdfdist);
#endif
highp vec4 out_color;
#ifdef RENDER_LINE_GRADIENT
out_color=texture(u_gradient_image,v_uv.xy);
#else
out_color=color;
#endif
float trimmed=1.0;
#ifdef RENDER_LINE_TRIM_OFFSET
highp float start=v_uv[2];highp float end=v_uv[3];highp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=(start+(v_uv.x)*(end-start));if (trim_end > trim_start) {if (line_progress <=trim_end && line_progress >=trim_start) {out_color=vec4(0,0,0,0);trimmed=0.0;}}
#endif
if (u_alpha_discard_threshold !=0.0) {if (alpha < u_alpha_discard_threshold) {discard;}}
#ifdef RENDER_LINE_BORDER
float edgeBlur=(border_width+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);if (border_color.a==0.0) {    
float Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}} else {out_color.rgb=mix(border_color.rgb*border_color.a*trimmed,out_color.rgb,smoothAlpha);}}
#endif
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);
#endif
#ifdef FOG
out_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));
#endif
out_color*=(alpha*opacity);
#ifdef INDICATOR_CUTOUT
out_color=applyCutout(out_color);
#endif
glFragColor=out_color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`,
          `#include "_prelude_fog.vertex.glsl"
#define EXTRUDE_SCALE 0.015873016
in vec2 a_pos_normal;in vec4 a_data;
#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)
in highp vec4 a_packed;
#endif
#ifdef RENDER_LINE_DASH
in float a_linesofar;
#endif
uniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec4 v_uv;
#ifdef RENDER_LINE_DASH
uniform vec2 u_texsize;uniform float u_tile_units_to_pixels;out vec2 v_tex;
#endif
#ifdef RENDER_LINE_GRADIENT
uniform float u_image_height;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 dash
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float border_width
#pragma mapbox: define lowp vec4 border_color
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize lowp vec4 dash
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float border_width
#pragma mapbox: initialize lowp vec4 border_color
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;
#ifndef RENDER_TO_TEXTURE
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#else
v_gamma_scale=1.0;
#endif
#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)
float a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float a_clip_start=a_packed[2];highp float a_clip_end=a_packed[3];
#ifdef RENDER_LINE_GRADIENT
highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec4(a_uv_x,a_split_index*texel_height-half_texel_height,a_clip_start,a_clip_end);
#else
v_uv=vec4(a_uv_x,0.0,a_clip_start,a_clip_end);
#endif
#endif
#ifdef RENDER_LINE_DASH
float scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/floorwidth,(-normal.y*height+dash.x+0.5)/u_texsize.y);
#endif
v_width2=vec2(outset,inset);
#ifdef FOG
v_fog_pos=fog_position(pos);
#endif
}`
        ),
        linePattern: Ve(
          `#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_tile_units_to_pixels;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;
#pragma mapbox: define lowp vec4 pattern
#pragma mapbox: define lowp float pixel_ratio
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize lowp float pixel_ratio
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;vec2 pattern_size=vec2(display_size.x/u_tile_units_to_pixels,display_size.y);float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x=mod(v_linesofar/pattern_size.x*aspect,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));vec4 color=texture(u_image,pos);
#ifdef LIGHTING_3D_MODE
color=apply_lighting_ground(color);
#endif
#ifdef FOG
color=fog_dither(fog_apply_premultiplied(color,v_fog_pos));
#endif
color*=(alpha*opacity);
#ifdef INDICATOR_CUTOUT
color=applyCutout(color);
#endif
glFragColor=color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`,
          `#include "_prelude_fog.vertex.glsl"
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;in float a_linesofar;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern
#pragma mapbox: define lowp float pixel_ratio
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern
#pragma mapbox: initialize lowp float pixel_ratio
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist*u_pixels_to_tile_units,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude;
#ifndef RENDER_TO_TEXTURE
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#else
v_gamma_scale=1.0;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;
#ifdef FOG
v_fog_pos=fog_position(pos);
#endif
}`
        ),
        raster: Ve(
          `#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
#include "_prelude_raster_array.glsl"
uniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;in vec2 v_pos0;in vec2 v_pos1;in float v_depth;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;uniform float u_emissive_strength;
#ifndef RASTER_ARRAY
uniform sampler2D u_image0;uniform sampler2D u_image1;
#endif
#ifdef RASTER_COLOR
uniform sampler2D u_color_ramp;uniform highp vec4 u_colorization_mix;uniform highp float u_colorization_offset;uniform vec2 u_texture_res;
#endif
void main() {vec4 color0,color1,color;vec2 value;
#ifdef RASTER_COLOR
#ifdef RASTER_ARRAY
#ifdef RASTER_ARRAY_LINEAR
value=mix(
raTexture2D_image0_linear(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_linear(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t
);
#else
value=mix(
raTexture2D_image0_nearest(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_nearest(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t
);
#endif
if (value.y > 0.0) value.x/=value.y;
#else
color=mix(texture(u_image0,v_pos0),texture(u_image1,v_pos1),u_fade_t);value=vec2(u_colorization_offset+dot(color.rgb,u_colorization_mix.rgb),color.a);
#endif
color=texture(u_color_ramp,vec2(value.x,0.5));if (color.a > 0.0) color.rgb/=color.a;color.a*=value.y;
#else
color0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);
#endif
color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(
dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),u_emissive_strength).rgb;
#endif
#ifdef FOG
highp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));
#endif
glFragColor=vec4(out_color*color.a,color.a);
#ifdef RENDER_CUTOFF
glFragColor=glFragColor*cutoff_opacity(u_cutoff_params,v_depth);
#endif
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`,
          `#include "_prelude_fog.vertex.glsl"
uniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;uniform vec2 u_texture_offset;uniform float u_raster_elevation;uniform vec4 u_tl_br;uniform float u_zoom_transition;uniform vec2 u_merc_center;
#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8;
#ifdef GLOBE_POLES
in vec3 a_globe_pos;in vec2 a_uv;
#elif defined(PROJECTION_GLOBE_VIEW)
in vec2 a_pos;
#else
in vec2 a_pos;in vec2 a_texture_pos;
#endif
out vec2 v_pos0;out vec2 v_pos1;out float v_depth;void main() {vec2 uv;
#ifdef GLOBE_POLES
vec3 globe_pos=a_globe_pos;globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;gl_Position=u_matrix*u_globe_matrix*vec4(globe_pos   ,1.0);uv=a_uv;
#ifdef FOG
v_fog_pos=fog_position((u_normalize_matrix*vec4(a_globe_pos,1.0)).xyz);
#endif
#else
#ifdef PROJECTION_GLOBE_VIEW
vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);vec2 globe_tl=vec2(u_tl_br.x,u_tl_br.y);vec2 globe_br=vec2(u_tl_br.z,u_tl_br.w);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=1.0-((mercatorY-globe_br.y)/(globe_tl.y-globe_br.y));float mercatorX=mercatorXfromLng(latLng[1]);float uvX=(mercatorX-globe_br.x)/(globe_tl.x-globe_br.x);vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);uv=vec2(uvX,uvY);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);gl_Position=u_matrix*interpolated_pos;
#ifdef FOG
v_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);
#endif
#else
float w=1.0+dot(a_texture_pos,u_perspective_transform);gl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation,w);
#ifdef FOG
v_fog_pos=fog_position(a_pos);
#endif
uv=a_texture_pos/8192.0;
#endif
#endif
v_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;v_pos0=u_texture_offset.x+u_texture_offset.y*v_pos0;v_pos1=u_texture_offset.x+u_texture_offset.y*v_pos1;
#ifdef RENDER_CUTOFF
v_depth=gl_Position.z;
#endif
}`
        ),
        symbolIcon: Ve(
          `#include "_prelude_lighting.glsl"
uniform sampler2D u_texture;
#ifdef ICON_TRANSITION
uniform float u_icon_transition;
#endif
in float v_fade_opacity;in vec2 v_tex_a;
#ifdef ICON_TRANSITION
in vec2 v_tex_b;
#endif
uniform mediump float u_icon_saturation;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float emissive_strength
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float emissive_strength
lowp float alpha=opacity*v_fade_opacity;vec4 out_color;
#ifdef ICON_TRANSITION
vec4 a=texture(u_texture,v_tex_a)*(1.0-u_icon_transition);vec4 b=texture(u_texture,v_tex_b)*u_icon_transition;out_color=(a+b)*alpha;
#else
out_color=texture(u_texture,v_tex_a)*alpha;
#endif
#ifdef SATURATION
vec3 luma=vec3(dot(out_color.rgb,vec3(0.2126,0.7152,0.0722)));out_color.rgb=mix(luma,out_color.rgb,u_icon_saturation);
#endif
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,emissive_strength);
#endif
glFragColor=out_color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`,
          `#include "_prelude_terrain.vertex.glsl"
in vec4 a_pos_offset;in vec4 a_tex_size;in vec4 a_pixeloffset;in vec4 a_projected_pos;in float a_fade_opacity;
#ifdef Z_OFFSET
in float a_z_offset;
#endif
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_globe_anchor;in vec3 a_globe_normal;
#endif
#ifdef ICON_TRANSITION
in vec2 a_texb;
#endif
uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform vec3 u_up_vector;
#ifdef PROJECTION_GLOBE_VIEW
uniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;
#endif
out vec2 v_tex_a;
#ifdef ICON_TRANSITION
out vec2 v_tex_b;
#endif
out float v_fade_opacity;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float emissive_strength
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float emissive_strength
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=elevation(tile_anchor);
#ifdef Z_OFFSET
e+=a_z_offset;
#endif
vec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;
#ifdef PROJECTION_GLOBE_VIEW
mercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;
#else
world_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;
#endif
vec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(
0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjected_point;
#ifdef PROJECTION_GLOBE_VIEW
vec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetProjected_point=u_matrix*vec4(a_globe_anchor+displacement,1);
#else
offsetProjected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);
#endif
vec2 a=projected_point.xy/projected_point.w;vec2 b=offsetProjected_point.xy/offsetProjected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;
#ifdef PROJECTION_GLOBE_VIEW
vec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);
#else
projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);
#endif
highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);
#ifdef TERRAIN
#ifdef PITCH_WITH_MAP_TERRAIN
vec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);
#endif
#endif
float occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;float projection_transition_fade=1.0;
#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)
projection_transition_fade=1.0-step(EPSILON,u_zoom_transition);
#endif
vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float out_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change))*projection_transition_fade;float alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);
#ifdef PROJECTION_GLOBE_VIEW
vec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,hidden);
#else
gl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,hidden);
#endif
v_tex_a=a_tex/u_texsize;
#ifdef ICON_TRANSITION
v_tex_b=a_texb/u_texsize;
#endif
v_fade_opacity=out_fade_opacity;}`
        ),
        symbolSDF: Ve(
          `#include "_prelude_lighting.glsl"
#define SDF_PX 8.0
uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;uniform bool u_is_halo;in float v_draw_halo;in vec2 v_data0;in vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
#pragma mapbox: define lowp float emissive_strength
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
#pragma mapbox: initialize lowp float emissive_strength
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;bool draw_halo=v_draw_halo > 0.0;if (draw_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);vec4 out_color=color*(alpha*opacity*fade_opacity);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,emissive_strength);
#endif
glFragColor=out_color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`,
          `#include "_prelude_terrain.vertex.glsl"
in vec4 a_pos_offset;in vec4 a_tex_size;in vec4 a_pixeloffset;in vec4 a_projected_pos;in float a_fade_opacity;
#ifdef Z_OFFSET
in float a_z_offset;
#endif
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_globe_anchor;in vec3 a_globe_normal;
#endif
uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform bool u_is_halo;
#ifdef PROJECTION_GLOBE_VIEW
uniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;
#endif
out float v_draw_halo;out vec2 v_data0;out vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
#pragma mapbox: define lowp float emissive_strength
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
#pragma mapbox: initialize lowp float emissive_strength
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=elevation(tile_anchor);
#ifdef Z_OFFSET
e+=a_z_offset;
#endif
vec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;
#ifdef PROJECTION_GLOBE_VIEW
mercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;
#else
world_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;
#endif
vec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(
0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;
#ifdef PROJECTION_GLOBE_VIEW
vec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);
#else
offsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);
#endif
vec2 a=projected_point.xy/projected_point.w;vec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;
#ifdef PROJECTION_GLOBE_VIEW
vec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);
#else
projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);
#endif
highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset);
#ifdef TERRAIN
#ifdef PITCH_WITH_MAP_TERRAIN
vec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);
#endif
#endif
float occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;float projection_transition_fade=1.0;
#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)
projection_transition_fade=1.0-step(EPSILON,u_zoom_transition);
#endif
vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float out_fade_opacity=interpolated_fade_opacity*projection_transition_fade;float alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);
#ifdef PROJECTION_GLOBE_VIEW
vec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,hidden);
#else
gl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,hidden);
#endif
float gamma_scale=gl_Position.w;v_draw_halo=(u_is_halo && float(gl_InstanceID)==0.0) ? 1.0 : 0.0;v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,out_fade_opacity);}`
        ),
        symbolTextAndIcon: Ve(
          `#include "_prelude_lighting.glsl"
#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_halo;in float v_draw_halo;in vec4 v_data0;in vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
#pragma mapbox: define lowp float emissive_strength
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
#pragma mapbox: initialize lowp float emissive_strength
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;glFragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;bool draw_halo=v_draw_halo > 0.0;if (draw_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);vec4 out_color=color*(alpha*opacity*fade_opacity);
#ifdef LIGHTING_3D_MODE
out_color=apply_lighting_with_emission_ground(out_color,emissive_strength);
#endif
glFragColor=out_color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`,
          `#include "_prelude_terrain.vertex.glsl"
in vec4 a_pos_offset;in vec4 a_tex_size;in vec4 a_projected_pos;in float a_fade_opacity;
#ifdef Z_OFFSET
in float a_z_offset;
#endif
#ifdef PROJECTION_GLOBE_VIEW
in vec3 a_globe_anchor;in vec3 a_globe_normal;
#endif
uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;uniform bool u_is_halo;
#ifdef PROJECTION_GLOBE_VIEW
uniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;
#endif
out float v_draw_halo;out vec4 v_data0;out vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
#pragma mapbox: define lowp float emissive_strength
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
#pragma mapbox: initialize lowp float emissive_strength
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=elevation(tile_anchor);
#ifdef Z_OFFSET
e+=a_z_offset;
#endif
vec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;
#ifdef PROJECTION_GLOBE_VIEW
mercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos=mix_globe_mercator(a_globe_anchor+h,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;
#else
world_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;
#endif
vec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(
0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offset_projected_point=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projected_point.xy/projected_point.w;vec2 b=offset_projected_point.xy/offset_projected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;
#ifdef PROJECTION_GLOBE_VIEW
vec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz+h,mercator_pos,u_zoom_transition);projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);
#else
projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);
#endif
highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*font_scale);
#ifdef TERRAIN
#ifdef PITCH_WITH_MAP_TERRAIN
vec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);
#endif
#endif
float occlusion_fade=occlusionFade(projected_point)*globe_occlusion_fade;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));float projection_transition_fade=1.0;
#if defined(PROJECTED_POS_ON_VIEWPORT) && defined(PROJECTION_GLOBE_VIEW)
projection_transition_fade=1.0-step(EPSILON,u_zoom_transition);
#endif
float out_fade_opacity=interpolated_fade_opacity*projection_transition_fade;float alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);
#ifdef PROJECTION_GLOBE_VIEW
vec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);gl_Position=mix(u_coord_matrix*vec4(projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y,1.0),AWAY,hidden);
#else
gl_Position=mix(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+offset,z,1.0),AWAY,hidden);
#endif
float gamma_scale=gl_Position.w;v_draw_halo=(u_is_halo && float(gl_InstanceID)==0.0) ? 1.0 : 0.0;v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,out_fade_opacity,is_sdf);}`
        ),
        terrainRaster: Ve(
          `#include "_prelude_fog.fragment.glsl"
#include "_prelude_shadow.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform sampler2D u_image0;in vec2 v_pos0;
#ifdef FOG
in float v_fog_opacity;
#endif
#ifdef RENDER_SHADOWS
in vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;in float v_depth;
#endif
uniform vec3 u_ground_shadow_factor;void main() {vec4 image_color=texture(u_image0,v_pos0);vec4 color;
#ifdef LIGHTING_3D_MODE
const vec3 normal=vec3(0.0,0.0,1.0);
#ifdef RENDER_SHADOWS
float cutoffOpacity=1.0;
#ifdef RENDER_CUTOFF
cutoffOpacity=cutoff_opacity(u_cutoff_params,v_depth);
#endif
#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS
vec3 unlit_base=image_color.rgb*(1.0-image_color.a);vec3 emissive_base=image_color.rgb*image_color.a;float ndotl=u_shadow_direction.z;float occlusion=ndotl < 0.0 ? 1.0 : shadow_occlusion(v_pos_light_view_0,v_pos_light_view_1,v_depth,0.0);ndotl=max(0.0,ndotl);vec3 lit=apply_lighting(unlit_base,normal,mix(1.0,(1.0-(u_shadow_intensity*occlusion))*ndotl,cutoffOpacity));vec3 emissive=compute_emissive_draped(emissive_base,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=lit+emissive;color.a=1.0;
#else
float lighting_factor=shadowed_light_factor_normal_unbiased(normal,v_pos_light_view_0,v_pos_light_view_1,v_depth);color=apply_lighting(image_color,normal,mix(1.0,lighting_factor,cutoffOpacity));
#endif
#else
float lighting_factor=u_lighting_directional_dir.z;color=apply_lighting(image_color,normal,lighting_factor);
#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS
color.rgb=mix(color.rgb,image_color.rgb,image_color.a);color.a=1.0;
#endif
#endif
#else
color=image_color;
#endif
#ifdef FOG
#ifdef ZERO_EXAGGERATION
color=fog_dither(fog_apply_premultiplied(color,v_fog_pos));
#else
color=fog_dither(fog_apply_from_vert(color,v_fog_opacity));
#endif
#endif
glFragColor=color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`,
          `#include "_prelude_fog.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
uniform mat4 u_matrix;uniform float u_skirt_height;in vec2 a_pos;out vec2 v_pos0;
#ifdef FOG
out float v_fog_opacity;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;out float v_depth;
#endif
void main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;v_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);
#ifdef FOG
#ifdef ZERO_EXAGGERATION
v_fog_pos=fog_position(decodedPos);
#else
v_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));
#endif
#endif
#ifdef RENDER_SHADOWS
vec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);v_depth=gl_Position.w;
#endif
}`
        ),
        terrainDepth: Ve(
          'precision highp float;in float v_depth;void main() {glFragColor=pack_depth(v_depth);}',
          `#include "_prelude_terrain.vertex.glsl"
uniform mat4 u_matrix;in vec2 a_pos;out float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}`
        ),
        skybox: Ve(
          `#include "_prelude_fog.fragment.glsl"
in lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(
cos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=texture(u_cubemap,uv).rgb;
#ifdef FOG
sky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);
#endif
sky_color.rgb=dither(sky_color.rgb,gl_FragCoord.xy+u_temporal_offset);sky_color+=0.1*sun_disk(v_uv,u_sun_direction);glFragColor=vec4(sky_color*u_opacity,u_opacity);
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
}`,
          xb
        ),
        skyboxGradient: Ve(
          `#include "_prelude_fog.fragment.glsl"
in highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture(u_color_ramp,vec2(progress,0.5));
#ifdef FOG
color.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;
#endif
color*=u_opacity;color.rgb=dither(color.rgb,gl_FragCoord.xy+u_temporal_offset);glFragColor=color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
}`,
          xb
        ),
        skyboxCapture: Ve(
          `
in highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;precision highp float;
#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)
#define BETA_M                  vec3(21e-6,21e-6,21e-6)
#define MIE_G                   0.76
#define DENSITY_HEIGHT_SCALE_R  8000.0
#define DENSITY_HEIGHT_SCALE_M  1200.0
#define PLANET_RADIUS           6360e3
#define ATMOSPHERE_RADIUS       6420e3
#define SAMPLE_STEPS            10
#define DENSITY_STEPS           4
float ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;glFragColor=vec4(color,1.0);}`,
          'in highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;out highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}'
        ),
        globeRaster: Ve(
          `#include "_prelude_fog.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform sampler2D u_image0;in vec2 v_pos0;
#ifndef FOG
uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;
#endif
void main() {vec4 color;
#ifdef CUSTOM_ANTIALIASING
vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(
mix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);vec3 dir=normalize(ray_dir);vec3 closest_point=dot(u_globe_pos,dir)*dir;float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture(u_image0,v_pos0);
#ifdef LIGHTING_3D_MODE
#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS
raster=apply_lighting_with_emission_ground(raster,raster.a);color=vec4(raster.rgb*antialias,antialias);
#else
raster=apply_lighting_ground(raster);color=vec4(raster.rgb*antialias,raster.a*antialias);
#endif
#else
color=vec4(raster.rgb*antialias,raster.a*antialias);
#endif
#else
color=texture(u_image0,v_pos0);
#ifdef LIGHTING_3D_MODE
#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS
color=apply_lighting_with_emission_ground(color,color.a);color.a=1.0;
#else
color=apply_lighting_ground(color);
#endif
#endif
#endif
#ifdef FOG
color=fog_dither(fog_apply_premultiplied(color,v_fog_pos));
#endif
glFragColor=color;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`,
          `#include "_prelude_fog.vertex.glsl"
#include "_prelude_terrain.vertex.glsl"
uniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;
#ifdef GLOBE_POLES
in vec3 a_globe_pos;in vec2 a_uv;
#else
in vec2 a_pos;
#endif
out vec2 v_pos0;void main() {
#ifdef GLOBE_POLES
vec3 globe_pos=a_globe_pos;vec2 uv=a_uv;
#else
float tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);
#endif
v_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;
#ifdef GLOBE_POLES
vec3 up_vector=globe_derived_up_vector;
#else
vec3 up_vector=elevationVector(tile_pos);
#endif
float height=elevation(tile_pos);globe_pos+=up_vector*height;
#ifndef GLOBE_POLES
globe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;
#endif
#ifdef GLOBE_POLES
vec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);
#else
vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);
#endif
gl_Position=u_proj_matrix*interpolated_pos;
#ifdef FOG
v_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);
#endif
}`
        ),
        globeAtmosphere: Ve(
          `#include "_prelude_fog.fragment.glsl"
uniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec4 u_color;uniform vec4 u_high_color;uniform vec4 u_space_color;uniform float u_horizon_angle;in highp vec3 v_ray_dir;in highp vec3 v_horizon_dir;void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;
#ifdef PROJECTION_GLOBE_VIEW
globe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {
#ifdef ALPHA_PASS
glFragColor=vec4(0,0,0,0);return;
#else
#ifdef NATIVE
glFragColor=vec4(1,1,1,1);
#else
glFragColor=vec4(0,0,0,1);
#endif
return;
#endif
}
#endif
highp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?
0.0 : max(acos(clamp(dot(dir,horizon_dir),-1.0,1.0)),0.0);float horizon_angle;
#ifdef PROJECTION_GLOBE_VIEW
highp vec3 closest_point=globe_pos_dot_dir*dir;highp float closest_point_to_center=length(closest_point-u_globe_pos);highp float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?
PI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);
#else
horizon_angle=horizon_angle_mercator;
#endif
horizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;
#ifdef ALPHA_PASS
float a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);glFragColor=vec4(1.0,1.0,1.0,a);
#else
vec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c=c2;
#ifndef NATIVE
c=dither(c,gl_FragCoord.xy+u_temporal_offset);
#endif
glFragColor=vec4(c*t,t);
#endif
}`,
          `in vec3 a_pos;in vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;out highp vec3 v_ray_dir;out highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(
mix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(
mix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}`
        ),
        model: Ve(
          `#include "_prelude_fog.fragment.glsl"
#include "_prelude_shadow.fragment.glsl"
#include "_prelude_lighting.glsl"
uniform float u_opacity;uniform vec3 u_lightcolor;uniform vec3 u_lightpos;uniform float u_lightintensity;uniform vec4 u_baseColorFactor;uniform vec4 u_emissiveFactor;uniform float u_metallicFactor;uniform float u_roughnessFactor;uniform float u_emissive_strength;in highp vec4 v_position_height;in lowp vec4 v_color_mix;
#ifdef RENDER_SHADOWS
in vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;in float v_depth_shadows;
#endif
#pragma mapbox: define-attribute highp vec3 normal_3f
#pragma mapbox: define-attribute highp vec3 color_3f
#pragma mapbox: define-attribute highp vec4 color_4f
#pragma mapbox: define-attribute highp vec2 uv_2f
#pragma mapbox: initialize-attribute highp vec3 normal_3f
#pragma mapbox: initialize-attribute highp vec3 color_3f
#pragma mapbox: initialize-attribute highp vec4 color_4f
#pragma mapbox: initialize-attribute highp vec2 uv_2f
#ifdef HAS_ATTRIBUTE_a_pbr
in lowp vec4 v_roughness_metallic_emissive_alpha;in mediump vec4 v_height_based_emission_params;
#endif
#ifdef HAS_TEXTURE_u_baseColorTexture
uniform sampler2D u_baseColorTexture;uniform bool u_baseTextureIsAlpha;uniform bool u_alphaMask;uniform float u_alphaCutoff;
#endif
#ifdef HAS_TEXTURE_u_metallicRoughnessTexture
uniform sampler2D u_metallicRoughnessTexture;
#endif
#ifdef HAS_TEXTURE_u_occlusionTexture
uniform sampler2D u_occlusionTexture;uniform float u_aoIntensity;
#endif
#ifdef HAS_TEXTURE_u_normalTexture
uniform sampler2D u_normalTexture;
#endif
#ifdef HAS_TEXTURE_u_emissionTexture
uniform sampler2D u_emissionTexture;
#endif
#ifdef TERRAIN_FRAGMENT_OCCLUSION
in highp float v_depth;uniform sampler2D u_depthTexture;uniform vec2 u_inv_depth_size;bool isOccluded() {vec2 coord=gl_FragCoord.xy*u_inv_depth_size;highp float depth=unpack_depth(texture(u_depthTexture,coord));return v_depth > depth+0.0005;}
#endif
#define saturate(_x) clamp(_x,0.,1.)
vec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}float calculate_NdotL(vec3 normal,vec3 lightDir) {const float ext=0.70710678118;return (clamp(dot(normal,lightDir),-ext,1.0)+ext)/(1.0+ext);}vec3 getDiffuseShadedColor(vec3 albedo,vec3 normal,vec3 lightDir,vec3 lightColor)
{
#ifdef LIGHTING_3D_MODE
vec3 transformed_normal=vec3(-normal.xy,normal.z);float lighting_factor;
#ifdef RENDER_SHADOWS
lighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);
#else
lighting_factor=saturate(dot(transformed_normal,u_lighting_directional_dir));
#endif
return apply_lighting(albedo,transformed_normal,lighting_factor);
#else
vec3 n=normal;float colorvalue=((albedo.x*0.2126)+(albedo.y*0.7152))+(albedo.z*0.0722);vec3 c=vec3(0.03,0.03,0.03);float directional=clamp(dot(n,vec3(lightDir)),0.0,1.0);directional=mix(1.0-u_lightintensity,max((1.0-colorvalue)+u_lightintensity,1.0),directional);vec3 c3=c+clamp((albedo*directional)*lightColor,mix(vec3(0.0),vec3(0.3),vec3(1.0)-lightColor),vec3(1.0));return c3;
#endif
}vec4 getBaseColor() {vec4 albedo=u_baseColorFactor;
#ifdef HAS_ATTRIBUTE_a_color_3f
albedo*=vec4(color_3f,1.0);
#endif
#ifdef HAS_ATTRIBUTE_a_pbr
#else
#ifdef HAS_ATTRIBUTE_a_color_4f
albedo*=color_4f;
#endif
#endif
#if defined (HAS_TEXTURE_u_baseColorTexture) && defined (HAS_ATTRIBUTE_a_uv_2f)
vec4 texColor=texture(u_baseColorTexture,uv_2f);if(u_alphaMask) {if (texColor.w < u_alphaCutoff) {discard;}}
#ifdef UNPREMULT_TEXTURE_IN_SHADER
if(texColor.w > 0.0) {texColor.rgb/=texColor.w;}texColor.w=1.0;
#endif
texColor.rgb=sRGBToLinear(texColor.rgb);if(u_baseTextureIsAlpha) {if (texColor.w < 0.5) {discard;}albedo*=mix(vec4(texColor.rgb,texColor.a),vec4(texColor.a),float(u_baseTextureIsAlpha));} else {albedo*=texColor;}
#endif
return vec4(mix(albedo.rgb,v_color_mix.rgb,v_color_mix.a),albedo.a);}highp mat3 cotangentFrame(highp vec3 N,highp vec3 p,highp vec2 uv ) {
#ifdef HAS_TEXTURE_u_normalTexture
highp vec3 dp1=vec3(dFdx(p.x),dFdx(p.y),dFdx(p.z));highp vec3 dp2=vec3(dFdy(p.x),dFdy(p.y),dFdy(p.z));highp vec2 duv1=vec2(dFdx(uv.x),dFdx(uv.y));highp vec2 duv2=vec2(dFdy(uv.x),dFdy(uv.y));highp vec3 dp2perp=cross( dp2,N );highp vec3 dp1perp=cross( N,dp1 );highp vec3 T=dp2perp*duv1.x+dp1perp*duv2.x;highp vec3 B=dp2perp*duv1.y+dp1perp*duv2.y;highp float lengthT=dot(T,T);highp float lengthB=dot(B,B);highp float maxLength=max(lengthT,lengthB);highp float invmax=inversesqrt( maxLength );highp mat3 res=mat3( T*invmax,B*invmax,N );return res;
#else
return mat3(1.0);
#endif
}highp vec3 getNormal(){highp vec3 n;
#ifdef HAS_ATTRIBUTE_a_normal_3f
n=normalize(normal_3f);
#else
highp vec3 fdx=vec3(dFdx(v_position_height.x),dFdx(v_position_height.y),dFdx(v_position_height.z));highp vec3 fdy=vec3(dFdy(v_position_height.x),dFdy(v_position_height.y),dFdy(v_position_height.z));n=normalize(cross(fdx,fdy))*-1.0;
#endif
#if defined(HAS_TEXTURE_u_normalTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)
vec3 nMap=texture( u_normalTexture,uv_2f).xyz;nMap=normalize(2.0*nMap-vec3(1.0));highp vec3 v=normalize(-v_position_height.xyz);highp mat3 TBN=cotangentFrame(n,v,uv_2f);n=normalize(TBN*nMap);
#endif
return n;}struct Material {float perceptualRoughness;float alphaRoughness;float metallic;vec3 f90;vec4 baseColor;vec3 diffuseColor;vec3 specularColor;highp vec3 normal;};Material getPBRMaterial() {Material mat;mat.baseColor=getBaseColor();mat.perceptualRoughness=u_roughnessFactor;mat.metallic=u_metallicFactor;
#ifdef HAS_ATTRIBUTE_a_pbr
mat.perceptualRoughness=v_roughness_metallic_emissive_alpha.x;mat.metallic=v_roughness_metallic_emissive_alpha.y;mat.baseColor.w*=v_roughness_metallic_emissive_alpha.w;
#endif
#if defined(HAS_TEXTURE_u_metallicRoughnessTexture) && defined(HAS_ATTRIBUTE_a_uv_2f) 
vec4 mrSample=texture(u_metallicRoughnessTexture,uv_2f);mat.perceptualRoughness*=mrSample.g;mat.metallic*=mrSample.b;
#endif
const float c_minRoughness=0.04;mat.perceptualRoughness=clamp(mat.perceptualRoughness,c_minRoughness,1.0);mat.metallic=saturate(mat.metallic);mat.alphaRoughness=mat.perceptualRoughness*mat.perceptualRoughness;const vec3 f0=vec3(0.04);mat.diffuseColor=mat.baseColor.rgb*(vec3(1.0)-f0);mat.diffuseColor*=1.0-mat.metallic;mat.specularColor=mix(f0,mat.baseColor.rgb,mat.metallic);highp float reflectance=max(max(mat.specularColor.r,mat.specularColor.g),mat.specularColor.b);highp float reflectance90=saturate(reflectance*25.0);mat.f90=vec3(reflectance90);mat.normal=getNormal();return mat;}float V_GGX(float NdotL,float NdotV,float roughness)
{float a2=roughness*roughness;float GGXV=NdotL*sqrt(NdotV*NdotV*(1.0-a2)+a2);float GGXL=NdotV*sqrt(NdotL*NdotL*(1.0-a2)+a2);return 0.5/(GGXV+GGXL);}float V_GGXFast(float NdotL,float NdotV,float roughness) {float a=roughness;float GGXV=NdotL*(NdotV*(1.0-a)+a);float GGXL=NdotV*(NdotL*(1.0-a)+a);return 0.5/(GGXV+GGXL);}vec3 F_Schlick(vec3 specularColor,vec3 f90,float VdotH)
{return specularColor+(f90-specularColor)*pow(clamp(1.0-VdotH,0.0,1.0),5.0);}vec3 F_SchlickFast(vec3 specularColor,float VdotH)
{float x=1.0-VdotH;float x4=x*x*x*x;return specularColor+(1.0-specularColor)*x4*x;}float D_GGX(highp float NdotH,float alphaRoughness)
{highp float a4=alphaRoughness*alphaRoughness;highp float f=(NdotH*a4-NdotH)*NdotH+1.0;return a4/(PI*f*f);}vec3 diffuseBurley(Material mat,float LdotH,float NdotL,float NdotV)
{float f90=2.0*LdotH*LdotH*mat.alphaRoughness-0.5;return (mat.diffuseColor/PI)*(1.0+f90*pow((1.0-NdotL),5.0))*(1.0+f90*pow((1.0-NdotV),5.0));}vec3 diffuseLambertian(Material mat)
{
#ifdef LIGHTING_3D_MODE
return mat.diffuseColor;
#else
return mat.diffuseColor/PI;
#endif
}vec3 EnvBRDFApprox(vec3 specularColor,float roughness,highp float NdotV)
{vec4 c0=vec4(-1,-0.0275,-0.572,0.022);vec4 c1=vec4(1,0.0425,1.04,-0.04);highp vec4 r=roughness*c0+c1;highp float a004=min(r.x*r.x,exp2(-9.28*NdotV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}vec3 computeIndirectLightContribution(Material mat,float NdotV,vec3 normal)
{vec3 env_light=vec3(0.65,0.65,0.65);
#ifdef LIGHTING_3D_MODE
float ambient_factor=calculate_ambient_directional_factor(normal);env_light=u_lighting_ambient_color*ambient_factor;
#endif
vec3 envBRDF=EnvBRDFApprox(mat.specularColor,mat.perceptualRoughness,NdotV);vec3 indirectSpecular= envBRDF*env_light;vec3 indirectDiffuse=mat.diffuseColor*env_light;return indirectSpecular+indirectDiffuse;}vec3 computeLightContribution(Material mat,vec3 lightPosition,vec3 lightColor)
{highp vec3 n=mat.normal;highp vec3 v=normalize(-v_position_height.xyz);highp vec3 l=normalize(lightPosition);highp vec3 h=normalize(v+l);float NdotV=clamp(abs(dot(n,v)),0.001,1.0);float NdotL=saturate(dot(n,l));highp float NdotH=saturate(dot(n,h));float VdotH=saturate(dot(v,h));vec3 f=F_SchlickFast(mat.specularColor,VdotH);float g=V_GGXFast(NdotL,NdotV,mat.alphaRoughness);float d=D_GGX(NdotH,mat.alphaRoughness);vec3 diffuseTerm=(1.0-f)*diffuseLambertian(mat);vec3 specularTerm=f*g*d;vec3 transformed_normal=vec3(-n.xy,n.z);float lighting_factor;
#ifdef RENDER_SHADOWS
lighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);
#else
lighting_factor=NdotL;
#endif
vec3 directLightColor=(specularTerm+diffuseTerm)*lighting_factor*lightColor;vec3 indirectLightColor=computeIndirectLightContribution(mat,NdotV,transformed_normal);vec3 color=(saturate(directLightColor)+indirectLightColor);float intensityFactor=1.0;
#if !defined(LIGHTING_3D_MODE)
const vec3 luminosityFactor=vec3(0.2126,0.7152,0.0722);float luminance=dot(diffuseTerm,luminosityFactor);intensityFactor=mix((1.0-u_lightintensity),max((1.0-luminance+u_lightintensity),1.0),NdotL);
#endif
color*=intensityFactor;return color;}void main() {
#ifdef TERRAIN_FRAGMENT_OCCLUSION
if (isOccluded()) {discard;}
#endif
vec3 lightDir=u_lightpos;vec3 lightColor=u_lightcolor;
#ifdef LIGHTING_3D_MODE
lightDir=u_lighting_directional_dir;lightDir.xy=-lightDir.xy;lightColor=u_lighting_directional_color;
#endif
vec4 finalColor;
#ifdef DIFFUSE_SHADED
vec3 N=getNormal();vec3 diffuse=getDiffuseShadedColor(getBaseColor().rgb,N,lightDir,lightColor);
#ifdef HAS_TEXTURE_u_occlusionTexture
float ao=(texture(u_occlusionTexture,uv_2f).r-1.0)*u_aoIntensity+1.0;diffuse*=ao;
#endif
finalColor=vec4(diffuse,1.0)*u_opacity;
#else
Material mat=getPBRMaterial();vec3 color=computeLightContribution(mat,lightDir,lightColor);float ao=1.0;
#if defined (HAS_TEXTURE_u_occlusionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)
ao=(texture(u_occlusionTexture,uv_2f).x-1.0)*u_aoIntensity+1.0;color*=ao;
#endif
vec4 emissive=u_emissiveFactor;
#if defined(HAS_TEXTURE_u_emissionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)
emissive.rgb*=sRGBToLinear(texture(u_emissionTexture,uv_2f).rgb);
#endif
color+=emissive.rgb;float opacity=mat.baseColor.w*u_opacity;
#ifdef HAS_ATTRIBUTE_a_pbr
float resEmission=v_roughness_metallic_emissive_alpha.z;resEmission*=v_height_based_emission_params.z+v_height_based_emission_params.w*pow(clamp(v_height_based_emission_params.x,0.0,1.0),v_height_based_emission_params.y);color=mix(color,v_color_mix.rgb,min(1.0,resEmission));
#ifdef HAS_ATTRIBUTE_a_color_4f
float distance=length(vec2(1.3*max(0.0,abs(color_4f.x)-color_4f.z),color_4f.y));distance+= mix(0.5,0.0,clamp(resEmission-1.0,0.0,1.0));opacity*=v_roughness_metallic_emissive_alpha.w*saturate(1.0-distance*distance);
#endif
#endif
vec3 unlitColor=mat.baseColor.rgb*ao+emissive.rgb;color=mix(color,unlitColor,u_emissive_strength);color=linearTosRGB(color);color*=opacity;finalColor=vec4(color,opacity);
#endif
#ifdef FOG
finalColor=fog_dither(fog_apply_premultiplied(finalColor,v_fog_pos,v_position_height.w));
#endif
#ifdef RENDER_CUTOFF
finalColor*=v_cutoff_opacity;
#endif
#ifdef INDICATOR_CUTOUT
finalColor=applyCutout(finalColor);
#endif
glFragColor=finalColor;
#ifdef OVERDRAW_INSPECTOR
glFragColor=vec4(1.0);
#endif
HANDLE_WIREFRAME_DEBUG;}`,
          `#include "_prelude_fog.vertex.glsl"
#include "_prelude_shadow.vertex.glsl"
in vec3 a_pos_3f;
#pragma mapbox: define-attribute highp vec3 normal_3f
#pragma mapbox: define-attribute highp vec2 uv_2f
#pragma mapbox: define-attribute highp vec3 color_3f
#pragma mapbox: define-attribute highp vec4 color_4f
#pragma mapbox: define-attribute-vertex-shader-only highp vec4 pbr
#pragma mapbox: define-attribute-vertex-shader-only highp vec3 heightBasedEmissiveStrength
uniform mat4 u_matrix;uniform mat4 u_lighting_matrix;uniform vec3 u_camera_pos;uniform vec4 u_color_mix;
#ifdef INSTANCED_ARRAYS
in vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;
#else
uniform highp mat4 u_normal_matrix;
#endif
#ifdef RENDER_SHADOWS
uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;out float v_depth_shadows;
#endif
out vec4 v_position_height;out lowp vec4 v_color_mix;
#ifdef TERRAIN_FRAGMENT_OCCLUSION
out highp float v_depth;
#endif
#ifdef HAS_ATTRIBUTE_a_pbr
out lowp vec4 v_roughness_metallic_emissive_alpha;out mediump vec4 v_height_based_emission_params;
#endif
vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}void main() {
#pragma mapbox: initialize-attribute highp vec3 normal_3f
#pragma mapbox: initialize-attribute highp vec2 uv_2f
#pragma mapbox: initialize-attribute highp vec3 color_3f
#pragma mapbox: initialize-attribute highp vec4 color_4f
#pragma mapbox: initialize-attribute-custom highp vec4 pbr
#pragma mapbox: initialize-attribute-custom highp vec3 heightBasedEmissiveStrength
highp mat4 normal_matrix;
#ifdef INSTANCED_ARRAYS
normal_matrix=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);
#else
normal_matrix=u_normal_matrix;
#endif
vec3 local_pos;mat3 rs;
#ifdef MODEL_POSITION_ON_GPU
vec3 pos_color=normal_matrix[0].xyz;vec4 translate=normal_matrix[1];vec3 pos_a=floor(pos_color);vec3 rgb=1.05*(pos_color-pos_a);float color_mix=pos_a.z/100.0;v_color_mix=vec4(sRGBToLinear(rgb),color_mix);float meter_to_tile=normal_matrix[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);rs[0].x=normal_matrix[1].w;rs[0].yz=normal_matrix[2].xy;rs[1].xy=normal_matrix[2].zw;rs[1].z=normal_matrix[3].x;rs[2].xyz=normal_matrix[3].yzw;vec4 pos_node=u_lighting_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;local_pos=pos.xyz;gl_Position=u_matrix*pos;pos.z*=meter_to_tile;v_position_height.xyz=pos.xyz-u_camera_pos;
#else
local_pos=a_pos_3f;gl_Position=u_matrix*vec4(a_pos_3f,1);v_position_height.xyz=vec3(u_lighting_matrix*vec4(a_pos_3f,1));v_color_mix=vec4(sRGBToLinear(u_color_mix.rgb),u_color_mix.a);
#endif
v_position_height.w=a_pos_3f.z;
#ifdef HAS_ATTRIBUTE_a_pbr
vec4 albedo_c=decode_color(pbr.xy);vec2 e_r_m=unpack_float(pbr.z);vec2 r_m= unpack_float(e_r_m.y*16.0);r_m.r=r_m.r*16.0;v_color_mix=vec4(albedo_c.rgb,1.0);v_roughness_metallic_emissive_alpha=vec4(vec3(r_m,e_r_m.x)/255.0,albedo_c.a);v_roughness_metallic_emissive_alpha.z*=2.0;float heightBasedRelativeIntepolation=a_pos_3f.z*heightBasedEmissiveStrength.x+heightBasedEmissiveStrength.y;v_height_based_emission_params.x=heightBasedRelativeIntepolation;v_height_based_emission_params.y=heightBasedEmissiveStrength.z;vec2 emissionMultiplierValues=unpack_float(pbr.w)/256.0;v_height_based_emission_params.z=emissionMultiplierValues.x;v_height_based_emission_params.w=emissionMultiplierValues.y-emissionMultiplierValues.x;
#endif
#ifdef FOG
v_fog_pos=fog_position(local_pos);
#endif
#ifdef RENDER_CUTOFF
v_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);
#endif
#ifdef TERRAIN_FRAGMENT_OCCLUSION
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef HAS_ATTRIBUTE_a_normal_3f
#ifdef MODEL_POSITION_ON_GPU
float x_squared_scale=dot(rs[0],rs[0]);float y_squared_scale=dot(rs[1],rs[1]);float z_squared_scale=dot(rs[2],rs[2]);vec3 squared_scale=vec3(x_squared_scale,y_squared_scale,z_squared_scale);normal_3f=rs*((u_lighting_matrix*vec4(normal_3f,0.0)).xyz/squared_scale);normal_3f=normalize(normal_3f);
#else
normal_3f=vec3(normal_matrix*vec4(normal_3f,0));
#endif
#endif
#ifdef HAS_ATTRIBUTE_a_pbr
#ifdef HAS_ATTRIBUTE_a_color_4f
v_roughness_metallic_emissive_alpha.w=clamp(color_4f.a*v_roughness_metallic_emissive_alpha.w*(v_roughness_metallic_emissive_alpha.z-1.0),0.0,1.0);
#endif
#endif
#ifdef RENDER_SHADOWS
vec3 shadow_pos=local_pos;
#ifdef NORMAL_OFFSET
#ifdef HAS_ATTRIBUTE_a_normal_3f
#ifdef MODEL_POSITION_ON_GPU
vec3 offset=shadow_normal_offset(vec3(-normal_3f.xy,normal_3f.z));shadow_pos+=offset*shadow_normal_offset_multiplier0();
#else
vec3 offset=shadow_normal_offset_model(normalize(normal_3f));shadow_pos+=offset*shadow_normal_offset_multiplier0();
#endif
#endif
#endif
v_pos_light_view_0=u_light_matrix_0*vec4(shadow_pos,1);v_pos_light_view_1=u_light_matrix_1*vec4(shadow_pos,1);v_depth_shadows=gl_Position.w;
#endif
}`
        ),
        modelDepth: Ve(
          `in highp float v_depth;void main() {
#ifndef DEPTH_TEXTURE
glFragColor=pack_depth(v_depth);
#endif
}`,
          `in vec3 a_pos_3f;uniform mat4 u_matrix;out highp float v_depth;
#ifdef MODEL_POSITION_ON_GPU
#ifdef INSTANCED_ARRAYS
in vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;
#else
uniform highp mat4 u_instance;
#endif
uniform highp mat4 u_node_matrix;
#endif
void main() {
#ifdef MODEL_POSITION_ON_GPU
highp mat4 instance;
#ifdef INSTANCED_ARRAYS
instance=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);
#else
instance=u_instance;
#endif
vec3 pos_color=instance[0].xyz;vec4 translate=instance[1];vec3 pos_a=floor(pos_color);float meter_to_tile=instance[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);mat3 rs;rs[0].x=instance[1].w;rs[0].yz=instance[2].xy;rs[1].xy=instance[2].zw;rs[1].z=instance[3].x;rs[2].xyz=instance[3].yzw;vec4 pos_node=u_node_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;gl_Position=u_matrix*pos;
#else
gl_Position=u_matrix*vec4(a_pos_3f,1);
#endif
v_depth=gl_Position.z/gl_Position.w;}`
        ),
        stars: Ve(
          `in highp vec2 v_uv;in mediump float v_intensity;float shapeCircle(in vec2 uv)
{float beginFade=0.6;float lengthFromCenter=length(v_uv);return 1.0-clamp((lengthFromCenter-beginFade)/(1.0-beginFade),0.0,1.0);}void main() {float alpha=shapeCircle(v_uv);vec3 color=vec3(1.0,1.0,1.0);alpha*=v_intensity;glFragColor=vec4(color*alpha,alpha);HANDLE_WIREFRAME_DEBUG;}`,
          `
in vec3 a_pos_3f;in vec2 a_uv;in float a_size_scale;in float a_fade_opacity;uniform mat4 u_matrix;uniform vec3 u_up;uniform vec3 u_right;uniform float u_intensity_multiplier;out highp vec2 v_uv;out mediump float v_intensity;void main() {v_uv=a_uv;v_intensity=a_fade_opacity*u_intensity_multiplier;vec3 pos=a_pos_3f;pos+=a_uv.x*u_right*a_size_scale;pos+=a_uv.y*u_up*a_size_scale;gl_Position=u_matrix*vec4(pos,1.0);}`
        ),
      };
      function gh(e, t) {
        const i = e.replace(
          /\s*\/\/[^\n]*\n/g,
          `
`
        ).split(`
`);
        for (let r of i)
          if (((r = r.trim()), r[0] === '#' && r.includes('if') && !r.includes('endif'))) {
            r = r
              .replace('#', '')
              .replace(/ifdef|ifndef|elif|if/g, '')
              .replace(/!|defined|\(|\)|\|\||&&/g, '')
              .replace(/\s+/g, ' ')
              .trim();
            const n = r.split(' ');
            for (const o of n) t.includes(o) || t.push(o);
          }
      }
      function Ve(e, t) {
        const i = /#include\s+"([^"]+)"/g,
          r = /#pragma mapbox: ([\w\-]+) ([\w]+) ([\w]+) ([\w]+)/g;
        let n = t.match(/(attribute(\S*)|(^\s*|;)in) (highp |mediump |lowp )?([\w]+) ([\w]+)/gm);
        n &&
          ((n = n.map((c) => {
            const u = c.split(' ');
            return u[u.length - 1];
          })),
          (n = [...new Set(n)]));
        const o = {},
          s = [],
          a = [];
        (e = e.replace(i, (c, u) => (a.push(u), ''))), (t = t.replace(i, (c, u) => (s.push(u), '')));
        let l = [...Sb];
        gh(e, l), gh(t, l);
        for (const c of [...s, ...a]) mh[c] || console.error(`Undefined include: ${c}`), _h[c] || ((_h[c] = []), gh(mh[c], _h[c])), (l = [...l, ..._h[c]]);
        return {
          fragmentSource: (e = e.replace(
            r,
            (c, u, h, d, f) => (
              (o[f] = !0),
              u === 'define'
                ? `
#ifndef HAS_UNIFORM_u_${f}
in ${h} ${d} ${f};
#else
uniform ${h} ${d} u_${f};
#endif
`
                : u === 'initialize'
                ? `
#ifdef HAS_UNIFORM_u_${f}
    ${h} ${d} ${f} = u_${f};
#endif
`
                : u === 'define-attribute'
                ? `
#ifdef HAS_ATTRIBUTE_a_${f}
    in ${h} ${d} ${f};
#endif
`
                : u === 'initialize-attribute'
                ? ''
                : void 0
            )
          )),
          vertexSource: (t = t.replace(r, (c, u, h, d, f) => {
            const p = d === 'float' ? 'vec2' : d,
              _ = f.match(/color/) ? 'color' : p;
            return u === 'define-attribute-vertex-shader-only'
              ? `
#ifdef HAS_ATTRIBUTE_a_${f}
in ${h} ${d} a_${f};
#endif
`
              : o[f]
              ? u === 'define'
                ? `
#ifndef HAS_UNIFORM_u_${f}
uniform lowp float u_${f}_t;
in ${h} ${p} a_${f};
out ${h} ${d} ${f};
#else
uniform ${h} ${d} u_${f};
#endif
`
                : u === 'initialize'
                ? _ === 'vec4'
                  ? `
#ifndef HAS_UNIFORM_u_${f}
    ${f} = a_${f};
#else
    ${h} ${d} ${f} = u_${f};
#endif
`
                  : `
#ifndef HAS_UNIFORM_u_${f}
    ${f} = unpack_mix_${_}(a_${f}, u_${f}_t);
#else
    ${h} ${d} ${f} = u_${f};
#endif
`
                : u === 'define-attribute'
                ? `
#ifdef HAS_ATTRIBUTE_a_${f}
    in ${h} ${d} a_${f};
    out ${h} ${d} ${f};
#endif
`
                : u === 'initialize-attribute'
                ? `
#ifdef HAS_ATTRIBUTE_a_${f}
    ${f} = a_${f};
#endif
`
                : void 0
              : u === 'define'
              ? `
#ifndef HAS_UNIFORM_u_${f}
uniform lowp float u_${f}_t;
in ${h} ${p} a_${f};
#else
uniform ${h} ${d} u_${f};
#endif
`
              : u === 'define-instanced'
              ? _ === 'mat4'
                ? `
#ifdef INSTANCED_ARRAYS
in vec4 a_${f}0;
in vec4 a_${f}1;
in vec4 a_${f}2;
in vec4 a_${f}3;
#else
uniform ${h} ${d} u_${f};
#endif
`
                : `
#ifdef INSTANCED_ARRAYS
in ${h} ${p} a_${f};
#else
uniform ${h} ${d} u_${f};
#endif
`
              : u === 'initialize-attribute-custom'
              ? `
#ifdef HAS_ATTRIBUTE_a_${f}
    ${h} ${d} ${f} = a_${f};
#endif
`
              : _ === 'vec4'
              ? `
#ifndef HAS_UNIFORM_u_${f}
    ${h} ${d} ${f} = a_${f};
#else
    ${h} ${d} ${f} = u_${f};
#endif
`
              : `
#ifndef HAS_UNIFORM_u_${f}
    ${h} ${d} ${f} = unpack_mix_${_}(a_${f}, u_${f}_t);
#else
    ${h} ${d} ${f} = u_${f};
#endif
`;
          })),
          staticAttributes: n,
          usedDefines: l,
          vertexIncludes: s,
          fragmentIncludes: a,
        };
      }
      class OP {
        constructor() {
          (this.boundProgram = null), (this.boundLayoutVertexBuffer = null), (this.boundPaintVertexBuffers = []), (this.boundIndexBuffer = null), (this.boundVertexOffset = null), (this.boundDynamicVertexBuffers = []), (this.vao = null);
        }
        bind(t, i, r, n, o, s, a, l) {
          this.context = t;
          let c = this.boundPaintVertexBuffers.length !== n.length;
          for (let h = 0; !c && h < n.length; h++) this.boundPaintVertexBuffers[h] !== n[h] && (c = !0);
          let u = this.boundDynamicVertexBuffers.length !== a.length;
          for (let h = 0; !u && h < a.length; h++) this.boundDynamicVertexBuffers[h] !== a[h] && (u = !0);
          if (!this.vao || this.boundProgram !== i || this.boundLayoutVertexBuffer !== r || c || u || this.boundIndexBuffer !== o || this.boundVertexOffset !== s) this.freshBind(i, r, n, o, s, a, l);
          else {
            t.bindVertexArrayOES.set(this.vao);
            for (const h of a) h && (h.bind(), l && h.instanceCount && h.setVertexAttribDivisor(t.gl, i, l));
            o && o.dynamicDraw && o.bind();
          }
        }
        freshBind(t, i, r, n, o, s, a) {
          const l = t.numAttributes,
            c = this.context,
            u = c.gl;
          this.vao && this.destroy(), (this.vao = c.gl.createVertexArray()), c.bindVertexArrayOES.set(this.vao), (this.boundProgram = t), (this.boundLayoutVertexBuffer = i), (this.boundPaintVertexBuffers = r), (this.boundIndexBuffer = n), (this.boundVertexOffset = o), (this.boundDynamicVertexBuffers = s), i.enableAttributes(u, t), i.bind(), i.setVertexAttribPointers(u, t, o);
          for (const h of r) h.enableAttributes(u, t), h.bind(), h.setVertexAttribPointers(u, t, o);
          for (const h of s) h && (h.enableAttributes(u, t), h.bind(), h.setVertexAttribPointers(u, t, o), a && h.instanceCount && h.setVertexAttribDivisor(u, t, a));
          n && n.bind(), (c.currentNumAttributes = l);
        }
        destroy() {
          this.vao && (this.context.gl.deleteVertexArray(this.vao), (this.vao = null));
        }
      }
      function BP(e, t) {
        const i = Math.pow(2, t.canonical.z),
          r = t.canonical.y;
        return [new Me(0, r / i).toLngLat().lat, new Me(0, (r + 1) / i).toLngLat().lat];
      }
      function FP(e, t, i, r, n, o, s) {
        const a = e.context,
          l = a.gl,
          c = i.hillshadeFBO;
        if (!c) return;
        e.prepareDrawTile();
        const u = e.isTileAffectedByFog(t),
          h = e.getOrCreateProgram('hillshade', { overrideFog: u });
        a.activeTexture.set(l.TEXTURE0), l.bindTexture(l.TEXTURE_2D, c.colorAttachment.get());
        const d = ((g, y, v, w) => {
          const T = v.paint.get('hillshade-shadow-color'),
            b = v.paint.get('hillshade-highlight-color'),
            E = v.paint.get('hillshade-accent-color'),
            S = v.paint.get('hillshade-emissive-strength');
          let I = ne(v.paint.get('hillshade-illumination-direction'));
          if (v.paint.get('hillshade-illumination-anchor') === 'viewport') I -= g.transform.angle;
          else if (g.style && g.style.enable3dLights() && g.style.directionalLight) {
            const z = g.style.directionalLight.properties.get('direction');
            I = ne(gt(z.x, z.y, z.z)[1]);
          }
          const C = !g.options.moving;
          return { u_matrix: w || g.transform.calculateProjMatrix(y.tileID.toUnwrapped(), C), u_image: 0, u_latrange: BP(0, y.tileID), u_light: [v.paint.get('hillshade-exaggeration'), I], u_shadow: T, u_highlight: b, u_emissive_strength: S, u_accent: E };
        })(e, i, r, e.terrain ? t.projMatrix : null);
        e.uploadCommonUniforms(a, h, t.toUnwrapped());
        const { tileBoundsBuffer: f, tileBoundsIndexBuffer: p, tileBoundsSegments: _ } = e.getTileBoundsBuffers(i);
        h.draw(e, l.TRIANGLES, n, o, s, ye.disabled, d, r.id, f, p, _);
      }
      function Pb(e, t, i) {
        if (!t.needsDEMTextureUpload) return;
        const r = e.context,
          n = r.gl;
        r.pixelStoreUnpackPremultiplyAlpha.set(!1), (t.demTexture = t.demTexture || e.getTileTexture(i.stride));
        const o = i.getPixels();
        t.demTexture ? t.demTexture.update(o, { premultiply: !1 }) : (t.demTexture = new vi(r, o, n.R32F, { premultiply: !1 })), (t.needsDEMTextureUpload = !1);
      }
      function NP(e, t, i) {
        const r = e.context,
          n = r.gl;
        if (!t.dem) return;
        const o = t.dem;
        if ((r.activeTexture.set(n.TEXTURE1), Pb(e, t, o), !t.demTexture)) return;
        t.demTexture.bind(n.NEAREST, n.CLAMP_TO_EDGE);
        const s = o.dim;
        r.activeTexture.set(n.TEXTURE0);
        let a = t.hillshadeFBO;
        if (!a) {
          const d = new vi(r, { width: s, height: s, data: null }, n.RGBA);
          d.bind(n.LINEAR, n.CLAMP_TO_EDGE), (a = t.hillshadeFBO = r.createFramebuffer(s, s, !0, 'renderbuffer')), a.colorAttachment.set(d.texture);
        }
        r.bindFramebuffer.set(a.framebuffer), r.viewport.set([0, 0, s, s]);
        const { tileBoundsBuffer: l, tileBoundsIndexBuffer: c, tileBoundsSegments: u } = e.getMercatorTileBoundsBuffers(),
          h = [];
        e.linearFloatFilteringSupported() && h.push('TERRAIN_DEM_FLOAT_FORMAT'),
          e.getOrCreateProgram('hillshadePrepare', { defines: h }).draw(
            e,
            n.TRIANGLES,
            Jt.disabled,
            me.disabled,
            De.unblended,
            ye.disabled,
            ((d, f) => {
              const p = f.stride,
                _ = J.create();
              return J.ortho(_, 0, lt, -lt, 0, 0, 1), J.translate(_, _, [0, -lt, 0]), { u_matrix: _, u_image: 1, u_dimension: [p, p], u_zoom: d.overscaledZ };
            })(t.tileID, o),
            i.id,
            l,
            c,
            u
          ),
          (t.needsHillshadePrepare = !1);
      }
      const zb = (e) => ({ u_matrix: new se(e), u_image0: new xe(e), u_skirt_height: new yt(e), u_ground_shadow_factor: new ce(e) }),
        Db = (e, t, i) => ({ u_matrix: e, u_image0: 0, u_skirt_height: t, u_ground_shadow_factor: i }),
        Rb = (e, t, i, r, n, o, s, a, l, c, u, h, d, f, p) => ({ u_proj_matrix: Float32Array.from(e), u_globe_matrix: t, u_normalize_matrix: Float32Array.from(r), u_merc_matrix: i, u_zoom_transition: n, u_merc_center: o, u_image0: 0, u_frustum_tl: s, u_frustum_tr: a, u_frustum_br: l, u_frustum_bl: c, u_globe_pos: u, u_globe_radius: h, u_viewport: d, u_grid_matrix: p ? Float32Array.from(p) : new Float32Array(9), u_skirt_height: f }),
        Oa = (e, t) => {
          if ((t > 0 && e.terrain && B('Cutoff is currently disabled on terrain'), t <= 0 || e.terrain)) return { shouldRenderCutoff: !1, uniformValues: { u_cutoff_params: [0, 0, 0, 0] } };
          const i = e.transform,
            r = Math.max(Math.abs(i._zoom - (e.minCutoffZoom - 1)), 1),
            n = i.isLODDisabled(!1) ? Zr(60, 45, i.pitch) : Zr(30, 15, i.pitch),
            o = i._farZ - i._nearZ,
            s = t * i.height,
            a = ((1 - (l = n)) * (0.75 * i.cameraToCenterDistance) + l * (i._farZ + s)) * r;
          var l;
          return { shouldRenderCutoff: n < 1, uniformValues: { u_cutoff_params: [i._nearZ, i._farZ, (a - i._nearZ) / o, (a - s - i._nearZ) / o] } };
        };
      function Lb(e, t) {
        return e != null && t != null && !(!e.hasData() || !t.hasData()) && e.demTexture != null && t.demTexture != null && e.tileID.key !== t.tileID.key;
      }
      const Ba = new (class {
          constructor() {
            this.operations = {};
          }
          newMorphing(e, t, i, r, n) {
            if (e in this.operations) {
              const o = this.operations[e];
              o.to.tileID.key !== i.tileID.key && (o.queued = i);
            } else this.operations[e] = { startTime: r, phase: 0, duration: n, from: t, to: i, queued: null };
          }
          getMorphValuesForProxy(e) {
            if (!(e in this.operations)) return null;
            const t = this.operations[e];
            return { from: t.from, to: t.to, phase: t.phase };
          }
          update(e) {
            for (const t in this.operations) {
              const i = this.operations[t];
              for (i.phase = (e - i.startTime) / i.duration; i.phase >= 1 || !this._validOp(i); )
                if (!this._nextOp(i, e)) {
                  delete this.operations[t];
                  break;
                }
            }
          }
          _nextOp(e, t) {
            return !!e.queued && ((e.from = e.to), (e.to = e.queued), (e.queued = null), (e.phase = 0), (e.startTime = t), !0);
          }
          _validOp(e) {
            return e.from.hasData() && e.to.hasData();
          }
        })(),
        kb = { 0: null, 1: 'TERRAIN_VERTEX_MORPHING' };
      function Ob(e, t, i) {
        if (t === 0) return 0;
        const r = t < 1 && i === 514 ? 0.25 / t : 1;
        return 6 * Math.pow(1.5, 22 - e) * Math.max(t, 1) * r;
      }
      function UP(e, t) {
        const i = 1 << e.z;
        return (!t && (e.x === 0 || e.x === i - 1)) || e.y === 0 || e.y === i - 1;
      }
      const Cm = (e) => ({ u_matrix: e });
      function Bb(e, t, i, r, n) {
        if (n > 0) {
          const o = oe.now(),
            s = (o - e.timeAdded) / n,
            a = t ? (o - t.timeAdded) / n : -1,
            l = i.getSource(),
            c = r.coveringZoomLevel({ tileSize: l.tileSize, roundZoom: l.roundZoom }),
            u = !t || Math.abs(t.tileID.overscaledZ - c) > Math.abs(e.tileID.overscaledZ - c),
            h = u && e.refreshedUponExpiration ? 1 : Bt(u ? s : 1 - a, 0, 1);
          return e.refreshedUponExpiration && s >= 1 && (e.refreshedUponExpiration = !1), t ? { opacity: 1, mix: 1 - h } : { opacity: h, mix: 0 };
        }
        return { opacity: 1, mix: 0 };
      }
      class VP extends wn {
        constructor(t) {
          const i = { type: 'raster-dem', maxzoom: t.transform.maxZoom },
            r = new Cs(Ql(), null),
            n = bm('mock-dem', i, r, t.style);
          super('mock-dem', n, !1), n.setEventedParent(this), (this._sourceLoaded = !0);
        }
        _loadTile(t, i) {
          (t.state = 'loaded'), i(null);
        }
      }
      class jP extends wn {
        constructor(t) {
          const i = bm('proxy', { type: 'geojson', maxzoom: t.transform.maxZoom }, new Cs(Ql(), null), t.style);
          super('proxy', i, !1), i.setEventedParent(this), (this.map = this.getSource().map = t), (this.used = this._sourceLoaded = !0), (this.renderCache = []), (this.renderCachePool = []), (this.proxyCachedFBO = {});
        }
        update(t, i, r) {
          if (t.freezeTileCoverage) return;
          this.transform = t;
          const n = t.coveringTiles({ tileSize: this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled }).reduce((o, s) => {
            if (((o[s.key] = ''), !this._tiles[s.key])) {
              const a = new jl(s, this._source.tileSize * s.overscaleFactor(), t.tileZoom);
              (a.state = 'loaded'), (this._tiles[s.key] = a);
            }
            return o;
          }, {});
          for (const o in this._tiles) o in n || (this.freeFBO(o), this._tiles[o].unloadVectorData(), delete this._tiles[o]);
        }
        freeFBO(t) {
          const i = this.proxyCachedFBO[t];
          if (i !== void 0) {
            const r = Object.values(i);
            this.renderCachePool.push(...r), delete this.proxyCachedFBO[t];
          }
        }
        deallocRenderCache() {
          this.renderCache.forEach((t) => t.fb.destroy()), (this.renderCache = []), (this.renderCachePool = []), (this.proxyCachedFBO = {});
        }
      }
      class Fb extends Le {
        constructor(t, i, r) {
          super(t.overscaledZ, t.wrap, t.canonical.z, t.canonical.x, t.canonical.y), (this.proxyTileKey = i), (this.projMatrix = r);
        }
      }
      class GP extends bA {
        constructor(t, i) {
          super(), (this.painter = t), (this.terrainTileForTile = {}), (this.prevTerrainTileForTile = {});
          const [r, n, o] = (function (l) {
              const c = new Rr(),
                u = new Fi(),
                h = 131;
              c.reserve(17161), u.reserve(33800);
              const d = lt / 128,
                f = lt + d / 2,
                p = f + d;
              for (let g = -d; g < p; g += d)
                for (let y = -d; y < p; y += d) {
                  const v = y < 0 || y > f || g < 0 || g > f ? 24575 : 0,
                    w = Bt(Math.round(y), 0, lt),
                    T = Bt(Math.round(g), 0, lt);
                  c.emplaceBack(w + v, T);
                }
              const _ = (g, y) => {
                const v = y * h + g;
                u.emplaceBack(v + 1, v, v + h), u.emplaceBack(v + h, v + h + 1, v + 1);
              };
              for (let g = 1; g < 129; g++) for (let y = 1; y < 129; y++) _(y, g);
              return (
                [0, 129].forEach((g) => {
                  for (let y = 0; y < 130; y++) _(y, g), _(g, y);
                }),
                [c, u, 32768]
              );
            })(),
            s = t.context;
          (this.gridBuffer = s.createVertexBuffer(r, ko.members)), (this.gridIndexBuffer = s.createIndexBuffer(n)), (this.gridSegments = He.simpleSegment(0, 0, r.length, n.length)), (this.gridNoSkirtSegments = He.simpleSegment(0, 0, r.length, o)), (this.proxyCoords = []), (this.proxiedCoords = {}), (this._visibleDemTiles = []), (this._drapedRenderBatches = []), (this._sourceTilesOverlap = {}), (this.proxySourceCache = new jP(i.map)), (this.orthoMatrix = J.create()), J.ortho(this.orthoMatrix, this.painter.transform.projection.name === 'globe' ? 0.015 : 0, lt, 0, lt, 0, 1);
          const a = s.gl;
          (this._overlapStencilMode = new me({ func: a.GEQUAL, mask: 255 }, 0, 255, a.KEEP, a.KEEP, a.REPLACE)), (this._previousZoom = t.transform.zoom), (this.pool = []), (this._findCoveringTileCache = {}), (this._tilesDirty = {}), (this.style = i), (this._useVertexMorphing = !0), (this._exaggeration = 1), (this._mockSourceCache = new VP(i.map)), (this._pendingGroundEffectLayers = []);
        }
        set style(t) {
          t.on('data', this._onStyleDataEvent.bind(this)),
            (this._style = t),
            this._style.map.on('moveend', () => {
              this._clearLineLayersFromRenderCache();
            });
        }
        update(t, i, r) {
          if (t && t.terrain) {
            this._style !== t && ((this.style = t), (this._evaluationZoom = void 0));
            const n = t.terrain.properties,
              o = t.terrain.drapeRenderMode === 0,
              s = t.terrain.isZoomDependent();
            (this._previousUpdateTimestamp = this.enabled ? this._updateTimestamp : void 0), (this._updateTimestamp = oe.now());
            const a = t.terrain && t.terrain.scope,
              l = n.get('source'),
              c = o ? this._mockSourceCache : t.getSourceCache(l, a);
            if (!c) return void B(`Couldn't find terrain source "${l}".`);
            if (((this.sourceCache = c), (this._exaggeration = s ? this.calculateExaggeration(i) : n.get('exaggeration')), !i.projection.requiresDraping && s && this._exaggeration === 0)) return void this._disable();
            this.enabled = !0;
            const u = () => {
              this.sourceCache.used &&
                B(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.
This leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);
              const h = this.getScaledDemTileSize();
              this.sourceCache.update(i, h, !0), this.resetTileLookupCache(this.sourceCache.id);
            };
            this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id), (this.sourceCache.usedForTerrain = !0), u(), (this._initializing = !0)), u(), i.updateElevation(!0, r), this.resetTileLookupCache(this.proxySourceCache.id), this.proxySourceCache.update(i), (this._emptyDEMTextureDirty = !0), (this._previousZoom = i.zoom);
          } else this._disable();
        }
        calculateExaggeration(t) {
          const i = this._previousCameraAltitude,
            r = (t.getFreeCameraOptions().position.z / t.pixelsPerMeter) * t.worldSize;
          this._previousCameraAltitude = r;
          const n = i != null ? r - i : Number.MAX_VALUE;
          if (Math.abs(n) < 2) return this._exaggeration;
          const o = t.zoom,
            s = this._style.terrain;
          if (!this._previousUpdateTimestamp) return s.getExaggeration(o);
          let a = o - this._previousZoom;
          const l = this._previousUpdateTimestamp;
          let c = o;
          this._evaluationZoom != null && ((c = this._evaluationZoom), Math.abs(o - c) > 0.5 && (a = 0.5 * (o - c + a)), a * n < 0 && (c += a)), (this._evaluationZoom = c);
          const u = s.getExaggeration(c),
            h = u === s.getExaggeration(Math.max(0, c - 0.1));
          if (h && Math.abs(u - this._exaggeration) < 0.01) return u;
          let d = Math.min(0.1, 0.00375 * (this._updateTimestamp - l));
          return (h || u < 0.1 || Math.abs(a) < 1e-4) && (d = Math.min(0.2, 4 * d)), ee(this._exaggeration, u, d);
        }
        resetTileLookupCache(t) {
          this._findCoveringTileCache[t] = {};
        }
        getScaledDemTileSize() {
          return (this.sourceCache.getSource().tileSize / 128) * this.proxySourceCache.getSource().tileSize;
        }
        _onStyleDataEvent(t) {
          t.coord && t.dataType === 'source' ? this._clearRenderCacheForTile(t.sourceCacheId, t.coord) : t.dataType === 'style' && ((this.invalidateRenderCache = !0), (this._evaluationZoom = void 0), (this._previousUpdateTimestamp = void 0), (this._previousCameraAltitude = void 0));
        }
        _disable() {
          if (this.enabled && ((this.enabled = !1), (this._sharedDepthStencil = void 0), (this._evaluationZoom = void 0), (this._previousUpdateTimestamp = void 0), this.proxySourceCache.deallocRenderCache(), this._style)) for (const t in this._style._mergedSourceCaches) this._style._mergedSourceCaches[t].usedForTerrain = !1;
        }
        destroy() {
          this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this._emptyDepthBufferTexture && this._emptyDepthBufferTexture.destroy(), this.pool.forEach((t) => t.fb.destroy()), (this.pool = []), this._depthFBO && (this._depthFBO.destroy(), (this._depthFBO = void 0), (this._depthTexture = void 0)), this.framebufferCopyTexture && this.framebufferCopyTexture.destroy();
        }
        _source() {
          return this.enabled ? this.sourceCache : null;
        }
        isUsingMockSource() {
          return this.sourceCache === this._mockSourceCache;
        }
        exaggeration() {
          return this._exaggeration;
        }
        get visibleDemTiles() {
          return this._visibleDemTiles;
        }
        get drapeBufferSize() {
          const t = 2 * this.proxySourceCache.getSource().tileSize;
          return [t, t];
        }
        set useVertexMorphing(t) {
          this._useVertexMorphing = t;
        }
        updateTileBinding(t) {
          if (!this.enabled) return;
          this.prevTerrainTileForTile = this.terrainTileForTile;
          const i = this.proxySourceCache,
            r = this.painter.transform;
          this._initializing && ((this._initializing = r._centerAltitude === 0 && this.getAtPointOrZero(Me.fromLngLat(r.center), -1) === -1), (this._emptyDEMTextureDirty = !this._initializing));
          const n = (this.proxyCoords = i.getIds().map((l) => {
            const c = i.getTileByID(l).tileID;
            return (c.projMatrix = r.calculateProjMatrix(c.toUnwrapped())), c;
          }));
          (function (l, c) {
            const u = c.transform.pointCoordinate(c.transform.getCameraPoint()),
              h = new H(u.x, u.y);
            l.sort((d, f) => {
              if (f.overscaledZ - d.overscaledZ) return f.overscaledZ - d.overscaledZ;
              const p = new H(d.canonical.x + (1 << d.canonical.z) * d.wrap, d.canonical.y),
                _ = new H(f.canonical.x + (1 << f.canonical.z) * f.wrap, f.canonical.y),
                g = h.mult(1 << d.canonical.z);
              return (g.x -= 0.5), (g.y -= 0.5), g.distSqr(p) - g.distSqr(_);
            });
          })(n, this.painter);
          const o = this.proxyToSource || {};
          (this.proxyToSource = {}),
            n.forEach((l) => {
              this.proxyToSource[l.key] = {};
            }),
            (this.terrainTileForTile = {});
          const s = this._style._mergedSourceCaches;
          for (const l in s) {
            const c = s[l];
            if (!c.used || (c !== this.sourceCache && this.resetTileLookupCache(c.id), this._setupProxiedCoordsForOrtho(c, t[l], o), c.usedForTerrain)) continue;
            const u = t[l];
            c.getSource().reparseOverscaled && this._assignTerrainTiles(u);
          }
          (this.proxiedCoords[i.id] = n.map((l) => new Fb(l, l.key, this.orthoMatrix))), this._assignTerrainTiles(n), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(o), (this.renderingToTexture = !1);
          const a = {};
          this._visibleDemTiles = [];
          for (const l of this.proxyCoords) {
            const c = this.terrainTileForTile[l.key];
            if (!c) continue;
            const u = c.tileID.key;
            u in a || (this._visibleDemTiles.push(c), (a[u] = u));
          }
        }
        _assignTerrainTiles(t) {
          this._initializing ||
            t.forEach((i) => {
              if (this.terrainTileForTile[i.key]) return;
              const r = this._findTileCoveringTileID(i, this.sourceCache);
              r && (this.terrainTileForTile[i.key] = r);
            });
        }
        _prepareDEMTextures() {
          const t = this.painter.context,
            i = t.gl;
          for (const r in this.terrainTileForTile) {
            const n = this.terrainTileForTile[r],
              o = n.dem;
            !o || (n.demTexture && !n.needsDEMTextureUpload) || (t.activeTexture.set(i.TEXTURE1), Pb(this.painter, n, o));
          }
        }
        _prepareDemTileUniforms(t, i, r, n) {
          if (!i || i.demTexture == null) return !1;
          const o = t.tileID.canonical,
            s = Math.pow(2, i.tileID.canonical.z - o.z),
            a = n || '';
          return (r[`u_dem_tl${a}`] = [(o.x * s) % 1, (o.y * s) % 1]), (r[`u_dem_scale${a}`] = s), !0;
        }
        get emptyDEMTexture() {
          return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture();
        }
        get emptyDepthBufferTexture() {
          const t = this.painter.context,
            i = t.gl;
          if (!this._emptyDepthBufferTexture) {
            const r = new Li({ width: 1, height: 1 }, Uint8Array.of(255, 255, 255, 255));
            this._emptyDepthBufferTexture = new vi(t, r, i.RGBA, { premultiply: !1 });
          }
          return this._emptyDepthBufferTexture;
        }
        _getLoadedAreaMinimum() {
          let t = 0;
          const i = this._visibleDemTiles.reduce((r, n) => {
            if (!n.dem) return r;
            const o = n.dem.tree.minimums[0];
            return o > 0 && t++, r + o;
          }, 0);
          return t ? i / t : 0;
        }
        _updateEmptyDEMTexture() {
          const t = this.painter.context,
            i = t.gl;
          t.activeTexture.set(i.TEXTURE2);
          const r = this._getLoadedAreaMinimum(),
            [n, o] = (() => {
              const a = new Cx({ width: 1, height: 1 }, new Float32Array([r]));
              return [i.R32F, a];
            })();
          this._emptyDEMTextureDirty = !1;
          let s = this._emptyDEMTexture;
          return s ? s.update(o, { premultiply: !1 }) : (s = this._emptyDEMTexture = new vi(t, o, n, { premultiply: !1 })), s;
        }
        setupElevationDraw(t, i, r) {
          const n = this.painter.context,
            o = n.gl,
            s = { u_dem: 2, u_dem_prev: 4, u_dem_tl: [0, 0], u_dem_tl_prev: [0, 0], u_dem_scale: 0, u_dem_scale_prev: 0, u_dem_size: 0, u_dem_lerp: 1, u_depth: 3, u_depth_size_inv: [0, 0], u_exaggeration: 0 };
          s.u_exaggeration = this.exaggeration();
          let a = null,
            l = null,
            c = 1;
          if (r && r.morphing && this._useVertexMorphing) {
            const d = r.morphing.srcDemTile,
              f = r.morphing.dstDemTile;
            (c = r.morphing.phase), d && f && (this._prepareDemTileUniforms(t, d, s, '_prev') && (l = d), this._prepareDemTileUniforms(t, f, s) && (a = f));
          }
          const u = (d) => (d && d.demTexture && this.painter.linearFloatFilteringSupported() ? o.LINEAR : o.NEAREST),
            h = (d) => {
              s.u_dem_size = d.size[0] === 1 ? 1 : d.size[0] - 2;
            };
          if (l && a) n.activeTexture.set(o.TEXTURE2), a.demTexture.bind(u(a), o.CLAMP_TO_EDGE), n.activeTexture.set(o.TEXTURE4), l.demTexture.bind(u(l), o.CLAMP_TO_EDGE), a.demTexture && h(a.demTexture), (s.u_dem_lerp = c);
          else {
            (a = this.terrainTileForTile[t.tileID.key]), n.activeTexture.set(o.TEXTURE2);
            const d = this._prepareDemTileUniforms(t, a, s) ? a.demTexture : this.emptyDEMTexture;
            d.bind(u(a), o.CLAMP_TO_EDGE), h(d);
          }
          if ((n.activeTexture.set(o.TEXTURE3), r && r.useDepthForOcclusion ? (this._depthTexture && this._depthTexture.bind(o.NEAREST, o.CLAMP_TO_EDGE), this._depthFBO && (s.u_depth_size_inv = [1 / this._depthFBO.width, 1 / this._depthFBO.height])) : (this.emptyDepthBufferTexture.bind(o.NEAREST, o.CLAMP_TO_EDGE), (s.u_depth_size_inv = [1, 1])), r && r.useMeterToDem && a)) {
            const d = (1 << a.tileID.canonical.z) * Je(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;
            s.u_meter_to_dem = d;
          }
          if ((r && r.labelPlaneMatrixInv && (s.u_label_plane_matrix_inv = r.labelPlaneMatrixInv), i.setTerrainUniformValues(n, s), this.painter.transform.projection.name === 'globe')) {
            const d = this.globeUniformValues(this.painter.transform, t.tileID.canonical, r && r.useDenormalizedUpVectorScale);
            i.setGlobeUniformValues(n, d);
          }
        }
        globeUniformValues(t, i, r) {
          const n = t.projection;
          return { u_tile_tl_up: n.upVector(i, 0, 0), u_tile_tr_up: n.upVector(i, lt, 0), u_tile_br_up: n.upVector(i, lt, lt), u_tile_bl_up: n.upVector(i, 0, lt), u_tile_up_scale: r ? uu(1) : n.upVectorScale(i, t.center.lat, t.worldSize).metersToTile };
        }
        renderToBackBuffer(t) {
          const i = this.painter,
            r = this.painter.context;
          t.length !== 0 &&
            (r.bindFramebuffer.set(null),
            r.viewport.set([0, 0, i.width, i.height]),
            i.gpuTimingDeferredRenderStart(),
            (this.renderingToTexture = !1),
            (function (n, o, s, a, l) {
              if (n.transform.projection.name === 'globe')
                (function (c, u, h, d, f) {
                  const p = c.context,
                    _ = p.gl;
                  let g, y;
                  const v = c.transform,
                    w = ax(c, p, v),
                    T = (V, R) => {
                      if (y === R) return;
                      const G = [kb[R], 'PROJECTION_GLOBE_VIEW'];
                      w && G.push('CUSTOM_ANTIALIASING');
                      const Z = c.isTileAffectedByFog(V);
                      (g = c.getOrCreateProgram('globeRaster', { defines: G, overrideFog: Z })), (y = R);
                    },
                    b = c.colorModeForRenderPass(),
                    E = new Jt(_.LEQUAL, Jt.ReadWrite, c.depthRangeFor3D);
                  Ba.update(f);
                  const S = ox(v),
                    I = [qi(v.center.lng), Hi(v.center.lat)],
                    C = c.globeSharedBuffers,
                    z = [v.width * oe.devicePixelRatio, v.height * oe.devicePixelRatio],
                    k = Float32Array.from(v.globeMatrix),
                    O = { useDenormalizedUpVectorScale: !0 };
                  {
                    const V = c.transform,
                      R = Ob(V.zoom, u.exaggeration(), u.sourceCache._source.tileSize);
                    y = -1;
                    const G = _.TRIANGLES;
                    for (const Z of d) {
                      const X = h.getTile(Z),
                        j = me.disabled,
                        q = u.prevTerrainTileForTile[Z.key],
                        it = u.terrainTileForTile[Z.key];
                      Lb(q, it) && Ba.newMorphing(Z.key, q, it, f, 250), p.activeTexture.set(_.TEXTURE0), X.texture && X.texture.bind(_.LINEAR, _.CLAMP_TO_EDGE);
                      const st = Ba.getMorphValuesForProxy(Z.key),
                        nt = st ? 1 : 0;
                      st && Qn(O, { morphing: { srcDemTile: st.from, dstDemTile: st.to, phase: mi(st.phase) } });
                      const ut = hu(Z.canonical),
                        ht = uS(ut.getCenter().lat),
                        pt = lx(Z.canonical, ut, ht, V.worldSize / V._pixelsPerMercatorPixel),
                        at = Bo(Yr(Z.canonical)),
                        _t = Rb(V.expandedFarZProjMatrix, k, S, at, Ji(V.zoom), I, V.frustumCorners.TL, V.frustumCorners.TR, V.frustumCorners.BR, V.frustumCorners.BL, V.globeCenterInViewSpace, V.globeRadius, z, R, pt);
                      if ((T(Z, nt), g && (u.setupElevationDraw(X, g, O), c.uploadCommonUniforms(p, g, Z.toUnwrapped()), C))) {
                        const [Ct, Pt, Ot] = C.getGridBuffers(ht, R !== 0);
                        g.draw(c, G, E, j, b, ye.backCCW, _t, 'globe_raster', Ct, Pt, Ot);
                      }
                    }
                  }
                  if (C && (c.renderDefaultNorthPole || c.renderDefaultSouthPole)) {
                    const V = ['GLOBE_POLES', 'PROJECTION_GLOBE_VIEW'];
                    w && V.push('CUSTOM_ANTIALIASING'), (g = c.getOrCreateProgram('globeRaster', { defines: V }));
                    for (const R of d) {
                      const { x: G, y: Z, z: X } = R.canonical,
                        j = Z === 0,
                        q = Z === (1 << X) - 1,
                        [it, st, nt, ut] = C.getPoleBuffers(X, !1);
                      if (ut && (j || q)) {
                        const ht = h.getTile(R);
                        p.activeTexture.set(_.TEXTURE0), ht.texture && ht.texture.bind(_.LINEAR, _.CLAMP_TO_EDGE);
                        let pt = sx(X, G, v);
                        const at = Bo(Yr(R.canonical)),
                          _t = (Ct, Pt) => Ct.draw(c, _.TRIANGLES, E, me.disabled, b, ye.disabled, Rb(v.expandedFarZProjMatrix, pt, pt, at, 0, I, v.frustumCorners.TL, v.frustumCorners.TR, v.frustumCorners.BR, v.frustumCorners.BL, v.globeCenterInViewSpace, v.globeRadius, z, 0), 'globe_pole_raster', Pt, nt, ut);
                        u.setupElevationDraw(ht, g, O), c.uploadCommonUniforms(p, g, R.toUnwrapped()), j && c.renderDefaultNorthPole && _t(g, it), q && c.renderDefaultSouthPole && ((pt = J.scale(J.create(), pt, [1, -1, 1])), _t(g, st));
                      }
                    }
                  }
                })(n, o, s, a, l);
              else {
                const c = n.context,
                  u = c.gl;
                let h, d;
                const f = n.shadowRenderer,
                  p = Oa(n, n.longestCutoffRange),
                  _ = (b) => {
                    if (d === b) return;
                    const E = [];
                    E.push(kb[b]), p.shouldRenderCutoff && E.push('RENDER_CUTOFF'), (h = n.getOrCreateProgram('terrainRaster', { defines: E })), (d = b);
                  },
                  g = n.colorModeForRenderPass(),
                  y = new Jt(u.LEQUAL, Jt.ReadWrite, n.depthRangeFor3D);
                Ba.update(l);
                const v = n.transform,
                  w = Ob(v.zoom, o.exaggeration(), o.sourceCache._source.tileSize);
                let T = [0, 0, 0];
                if (f) {
                  const b = n.style.directionalLight,
                    E = n.style.ambientLight;
                  b && E && (T = Lm(b, E));
                }
                {
                  d = -1;
                  const b = u.TRIANGLES,
                    [E, S] = [o.gridIndexBuffer, o.gridSegments];
                  for (const I of a) {
                    const C = s.getTile(I),
                      z = me.disabled,
                      k = o.prevTerrainTileForTile[I.key],
                      O = o.terrainTileForTile[I.key];
                    Lb(k, O) && Ba.newMorphing(I.key, k, O, l, 250), c.activeTexture.set(u.TEXTURE0), C.texture && C.texture.bind(u.LINEAR, u.CLAMP_TO_EDGE);
                    const V = Ba.getMorphValuesForProxy(I.key),
                      R = V ? 1 : 0;
                    let G;
                    V && (G = { morphing: { srcDemTile: V.from, dstDemTile: V.to, phase: mi(V.phase) } });
                    const Z = Db(I.projMatrix, UP(I.canonical, v.renderWorldCopies) ? w / 10 : w, T);
                    if ((_(R), !h)) continue;
                    o.setupElevationDraw(C, h, G);
                    const X = I.toUnwrapped();
                    f && f.setupShadows(X, h), n.uploadCommonUniforms(c, h, X, null, p), h.draw(n, b, y, z, g, ye.backCCW, Z, 'terrain_raster', o.gridBuffer, E, S);
                  }
                }
              }
            })(i, this, this.proxySourceCache, t, this._updateTimestamp),
            (this.renderingToTexture = !0),
            i.gpuTimingDeferredRenderEnd(),
            t.splice(0, t.length));
        }
        renderBatch(t) {
          if (this._drapedRenderBatches.length === 0) return t + 1;
          this.renderingToTexture = !0;
          const i = this.painter,
            r = this.painter.context,
            n = this.proxySourceCache,
            o = this.proxiedCoords[n.id],
            s = this._drapedRenderBatches.shift(),
            a = i.style.order,
            l = [];
          let c = 0;
          for (const u of o) {
            const h = n.getTileByID(u.proxyTileKey),
              d = n.proxyCachedFBO[u.key] ? n.proxyCachedFBO[u.key][t] : void 0,
              f = d !== void 0 ? n.renderCache[d] : this.pool[c++],
              p = d !== void 0;
            if (((h.texture = f.tex), p && !f.dirty)) {
              l.push(h.tileID);
              continue;
            }
            let _;
            r.bindFramebuffer.set(f.fb.framebuffer), (this.renderedToTile = !1), f.dirty && (r.clear({ color: pe.transparent, stencil: 0 }), (f.dirty = !1));
            for (let g = s.start; g <= s.end; ++g) {
              const y = i.style._mergedLayers[a[g]];
              if (y.isHidden(i.transform.zoom)) continue;
              const v = i.style.getLayerSourceCache(y),
                w = v ? this.proxyToSource[u.key][v.id] : [u];
              if (!w) continue;
              const T = w;
              r.viewport.set([0, 0, f.fb.width, f.fb.height]), _ !== (v ? v.id : null) && (this._setupStencil(f, w, y, v), (_ = v ? v.id : null)), i.renderLayer(i, v, y, T);
            }
            if (this._drapedRenderBatches.length === 0)
              for (const g of this._pendingGroundEffectLayers) {
                const y = i.style._mergedLayers[a[g]];
                if (y.isHidden(i.transform.zoom)) continue;
                const v = i.style.getLayerSourceCache(y),
                  w = v ? this.proxyToSource[u.key][v.id] : [u];
                if (!w) continue;
                const T = w;
                r.viewport.set([0, 0, f.fb.width, f.fb.height]), _ !== (v ? v.id : null) && (this._setupStencil(f, w, y, v), (_ = v ? v.id : null)), i.renderLayer(i, v, y, T);
              }
            this.renderedToTile ? ((f.dirty = !0), l.push(h.tileID)) : p || --c, c === 5 && ((c = 0), this.renderToBackBuffer(l));
          }
          return this.renderToBackBuffer(l), (this.renderingToTexture = !1), r.bindFramebuffer.set(null), r.viewport.set([0, 0, i.width, i.height]), s.end + 1;
        }
        postRender() {}
        isLayerOrderingCorrect(t) {
          const i = t.order.length;
          let r = -1,
            n = i;
          for (let o = 0; o < i; ++o) this._style.isLayerDraped(t._mergedLayers[t.order[o]]) ? (r = Math.max(r, o)) : (n = Math.min(n, o));
          return n > r;
        }
        getMinElevationBelowMSL() {
          let t = 0;
          return (
            this._visibleDemTiles
              .filter((i) => i.dem)
              .forEach((i) => {
                t = Math.min(t, i.dem.tree.minimums[0]);
              }),
            t === 0 ? t : (t - 30) * this._exaggeration
          );
        }
        raycast(t, i, r) {
          if (!this._visibleDemTiles) return null;
          const n = this._visibleDemTiles
            .filter((o) => o.dem)
            .map((o) => {
              const s = o.tileID,
                a = 1 << s.overscaledZ,
                { x: l, y: c } = s.canonical,
                u = l / a,
                h = (l + 1) / a,
                d = c / a,
                f = (c + 1) / a;
              return { minx: u, miny: d, maxx: h, maxy: f, t: o.dem.tree.raycastRoot(u, d, h, f, t, i, r), tile: o };
            });
          n.sort((o, s) => (o.t !== null ? o.t : Number.MAX_VALUE) - (s.t !== null ? s.t : Number.MAX_VALUE));
          for (const o of n) {
            if (o.t == null) return null;
            const s = o.tile.dem.tree.raycast(o.minx, o.miny, o.maxx, o.maxy, t, i, r);
            if (s != null) return s;
          }
          return null;
        }
        _createFBO() {
          const t = this.painter.context,
            i = t.gl,
            r = this.drapeBufferSize;
          t.activeTexture.set(i.TEXTURE0);
          const n = new vi(t, { width: r[0], height: r[1], data: null }, i.RGBA);
          n.bind(i.LINEAR, i.CLAMP_TO_EDGE);
          const o = t.createFramebuffer(r[0], r[1], !0, null);
          return o.colorAttachment.set(n.texture), (o.depthAttachment = new YI(t, o.framebuffer)), this._sharedDepthStencil === void 0 ? ((this._sharedDepthStencil = t.createRenderbuffer(t.gl.DEPTH_STENCIL, r[0], r[1])), (this._stencilRef = 0), o.depthAttachment.set(this._sharedDepthStencil), t.clear({ stencil: 0 })) : o.depthAttachment.set(this._sharedDepthStencil), t.extTextureFilterAnisotropic && i.texParameterf(i.TEXTURE_2D, t.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, t.extTextureFilterAnisotropicMax), { fb: o, tex: n, dirty: !1 };
        }
        _initFBOPool() {
          for (; this.pool.length < Math.min(5, this.proxyCoords.length); ) this.pool.push(this._createFBO());
        }
        _shouldDisableRenderCache() {
          if (this._style.hasLightTransitions()) return !0;
          for (const t in this._style._mergedSourceCaches) if (this._style._mergedSourceCaches[t].hasTransition()) return !0;
          return this._style.order.some((t) => {
            const i = this._style._mergedLayers[t],
              r = i.isHidden(this.painter.transform.zoom);
            return i.type === 'custom' ? !r && i.shouldRedrape() : !r && i.hasTransition();
          });
        }
        _clearLineLayersFromRenderCache() {
          let t = !1;
          for (const r of this._style.getSources())
            if (r instanceof X1) {
              t = !0;
              break;
            }
          if (!t) return;
          const i = {};
          for (let r = 0; r < this._style.order.length; ++r) {
            const n = this._style._mergedLayers[this._style.order[r]],
              o = this._style.getLayerSourceCache(n);
            if (o && !i[o.id] && !n.isHidden(this.painter.transform.zoom) && n.type === 'line' && n.widthExpression() instanceof Ao) {
              i[o.id] = !0;
              for (const s of this.proxyCoords) {
                const a = this.proxyToSource[s.key][o.id];
                if (a) for (const l of a) this._clearRenderCacheForTile(o.id, l);
              }
            }
          }
        }
        _clearRasterLayersFromRenderCache() {
          let t = !1;
          for (const r in this._style._mergedSourceCaches)
            if (this._style._mergedSourceCaches[r]._source instanceof um) {
              t = !0;
              break;
            }
          if (!t) return;
          const i = {};
          for (let r = 0; r < this._style.order.length; ++r) {
            const n = this._style._mergedLayers[this._style.order[r]],
              o = this._style.getLayerSourceCache(n);
            if (!o || i[o.id] || n.isHidden(this.painter.transform.zoom) || n.type !== 'raster') continue;
            const s = n.paint.get('raster-fade-duration');
            for (const a of this.proxyCoords) {
              const l = this.proxyToSource[a.key][o.id];
              if (l)
                for (const c of l) {
                  const u = Bb(o.getTile(c), o.findLoadedParent(c, 0), o, this.painter.transform, s);
                  (u.opacity !== 1 || u.mix !== 0) && this._clearRenderCacheForTile(o.id, c);
                }
            }
          }
        }
        _setupDrapedRenderBatches() {
          const t = this._style.order,
            i = t.length;
          if (i === 0) return;
          const r = [];
          this._pendingGroundEffectLayers = [];
          let n,
            o = 0,
            s = this._style._mergedLayers[t[o]];
          for (; !this._style.isLayerDraped(s) && s.isHidden(this.painter.transform.zoom) && ++o < i; ) s = this._style._mergedLayers[t[o]];
          for (; o < i; ++o) {
            const a = this._style._mergedLayers[t[o]];
            a.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(a) ? n === void 0 && (n = o) : (a.type === 'fill-extrusion' && this._pendingGroundEffectLayers.push(o), n !== void 0 && (r.push({ start: n, end: o - 1 }), (n = void 0))));
          }
          if ((n !== void 0 && r.push({ start: n, end: o - 1 }), r.length !== 0)) {
            const a = r[r.length - 1];
            this._pendingGroundEffectLayers.every((c) => c > a.end) || B('fill-extrusion with flood lighting and/or ground ambient occlusion should be moved to be on top of all draped layers.');
          }
          this._drapedRenderBatches = r;
        }
        _setupRenderCache(t) {
          const i = this.proxySourceCache;
          if (this._shouldDisableRenderCache() || this.invalidateRenderCache) {
            if (((this.invalidateRenderCache = !1), i.renderCache.length > i.renderCachePool.length)) {
              const s = Object.values(i.proxyCachedFBO);
              i.proxyCachedFBO = {};
              for (let a = 0; a < s.length; ++a) {
                const l = Object.values(s[a]);
                i.renderCachePool.push(...l);
              }
            }
            return;
          }
          this._clearRasterLayersFromRenderCache();
          const r = this.proxyCoords,
            n = this._tilesDirty;
          for (let s = r.length - 1; s >= 0; s--) {
            const a = r[s];
            if ((i.getTileByID(a.key), i.proxyCachedFBO[a.key] !== void 0)) {
              const l = t[a.key],
                c = this.proxyToSource[a.key];
              let u = 0;
              for (const h in c) {
                const d = c[h],
                  f = l[h];
                if (!f || f.length !== d.length || d.some((p, _) => p !== f[_] || (n[h] && n[h].hasOwnProperty(p.key)))) {
                  u = -1;
                  break;
                }
                ++u;
              }
              for (const h in i.proxyCachedFBO[a.key]) i.renderCache[i.proxyCachedFBO[a.key][h]].dirty = u < 0 || u !== Object.values(l).length;
            }
          }
          const o = [...this._drapedRenderBatches];
          o.sort((s, a) => a.end - a.start - (s.end - s.start));
          for (const s of o)
            for (const a of r) {
              if (i.proxyCachedFBO[a.key]) continue;
              let l = i.renderCachePool.pop();
              l === void 0 && i.renderCache.length < 50 && ((l = i.renderCache.length), i.renderCache.push(this._createFBO())), l !== void 0 && ((i.proxyCachedFBO[a.key] = {}), (i.proxyCachedFBO[a.key][s.start] = l), (i.renderCache[l].dirty = !0));
            }
          this._tilesDirty = {};
        }
        _setupStencil(t, i, r, n) {
          if (!n || !this._sourceTilesOverlap[n.id]) return void (this._overlapStencilType && (this._overlapStencilType = !1));
          const o = this.painter.context,
            s = o.gl;
          if (i.length <= 1) return void (this._overlapStencilType = !1);
          let a;
          if (r.isTileClipped()) (a = i.length), (this._overlapStencilMode.test = { func: s.EQUAL, mask: 255 }), (this._overlapStencilType = 'Clip');
          else {
            if (!(i[0].overscaledZ > i[i.length - 1].overscaledZ)) return void (this._overlapStencilType = !1);
            (a = 1), (this._overlapStencilMode.test = { func: s.GREATER, mask: 255 }), (this._overlapStencilType = 'Mask');
          }
          this._stencilRef + a > 255 && (o.clear({ stencil: 0 }), (this._stencilRef = 0)), (this._stencilRef += a), (this._overlapStencilMode.ref = this._stencilRef), r.isTileClipped() && this._renderTileClippingMasks(i, this._overlapStencilMode.ref);
        }
        clipOrMaskOverlapStencilType() {
          return this._overlapStencilType === 'Clip' || this._overlapStencilType === 'Mask';
        }
        stencilModeForRTTOverlap(t) {
          return this.renderingToTexture && this._overlapStencilType ? (this._overlapStencilType === 'Clip' && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[t.key]), this._overlapStencilMode) : me.disabled;
        }
        _renderTileClippingMasks(t, i) {
          const r = this.painter,
            n = this.painter.context,
            o = n.gl;
          (r._tileClippingMaskIDs = {}), n.setColorMode(De.disabled), n.setDepthMode(Jt.disabled);
          const s = r.getOrCreateProgram('clippingMask');
          for (const a of t) {
            const l = (r._tileClippingMaskIDs[a.key] = --i);
            s.draw(r, o.TRIANGLES, Jt.disabled, new me({ func: o.ALWAYS, mask: 0 }, l, 255, o.KEEP, o.KEEP, o.REPLACE), De.disabled, ye.disabled, Cm(a.projMatrix), '$clipping', r.tileExtentBuffer, r.quadTriangleIndexBuffer, r.tileExtentSegments);
          }
        }
        pointCoordinate(t) {
          const i = this.painter.transform;
          if (t.x < 0 || t.x > i.width || t.y < 0 || t.y > i.height) return null;
          const r = [t.x, t.y, 1, 1];
          We.transformMat4(r, r, i.pixelMatrixInverse), We.scale(r, r, 1 / r[3]), (r[0] /= i.worldSize), (r[1] /= i.worldSize);
          const n = i._camera.position,
            o = Je(1, i.center.lat),
            s = [n[0], n[1], n[2] / o, 0],
            a = N.subtract([], r.slice(0, 3), s);
          N.normalize(a, a);
          const l = this.raycast(s, a, this._exaggeration);
          return l !== null && l ? (N.scaleAndAdd(s, s, a, l), (s[3] = s[2]), (s[2] *= o), s) : null;
        }
        drawDepth() {
          const t = this.painter,
            i = t.context,
            r = this.proxySourceCache,
            n = Math.ceil(t.width),
            o = Math.ceil(t.height);
          if ((!this._depthFBO || (this._depthFBO.width === n && this._depthFBO.height === o) || (this._depthFBO.destroy(), (this._depthFBO = void 0), (this._depthTexture = void 0)), !this._depthFBO)) {
            const s = i.gl,
              a = i.createFramebuffer(n, o, !0, 'renderbuffer');
            i.activeTexture.set(s.TEXTURE0);
            const l = new vi(i, { width: n, height: o, data: null }, s.RGBA);
            l.bind(s.NEAREST, s.CLAMP_TO_EDGE), a.colorAttachment.set(l.texture);
            const c = i.createRenderbuffer(i.gl.DEPTH_COMPONENT16, n, o);
            a.depthAttachment.set(c), (this._depthFBO = a), (this._depthTexture = l);
          }
          i.bindFramebuffer.set(this._depthFBO.framebuffer),
            i.viewport.set([0, 0, n, o]),
            (function (s, a, l, c) {
              if (s.transform.projection.name === 'globe') return;
              const u = s.context,
                h = u.gl;
              u.clear({ depth: 1 });
              const d = s.getOrCreateProgram('terrainDepth'),
                f = new Jt(h.LESS, Jt.ReadWrite, s.depthRangeFor3D);
              for (const p of c) {
                const _ = l.getTile(p),
                  g = Db(p.projMatrix, 0, [0, 0, 0]);
                a.setupElevationDraw(_, d), d.draw(s, h.TRIANGLES, f, me.disabled, De.unblended, ye.backCCW, g, 'terrain_depth', a.gridBuffer, a.gridIndexBuffer, a.gridNoSkirtSegments);
              }
            })(t, this, r, this.proxyCoords);
        }
        _setupProxiedCoordsForOrtho(t, i, r) {
          if (t.getSource() instanceof fn) return this._setupProxiedCoordsForImageSource(t, i, r);
          this._findCoveringTileCache[t.id] = this._findCoveringTileCache[t.id] || {};
          const n = (this.proxiedCoords[t.id] = []),
            o = this.proxyCoords;
          for (let a = 0; a < o.length; a++) {
            const l = o[a],
              c = this._findTileCoveringTileID(l, t);
            if (c) {
              const u = this._createProxiedId(l, c, r[l.key] && r[l.key][t.id]);
              n.push(u), (this.proxyToSource[l.key][t.id] = [u]);
            }
          }
          let s = !1;
          for (let a = 0; a < i.length; a++) {
            const l = t.getTile(i[a]);
            if (!l || !l.hasData()) continue;
            const c = this._findTileCoveringTileID(l.tileID, this.proxySourceCache);
            if (c && c.tileID.canonical.z !== l.tileID.canonical.z) {
              const u = this.proxyToSource[c.tileID.key][t.id],
                h = this._createProxiedId(c.tileID, l, r[c.tileID.key] && r[c.tileID.key][t.id]);
              u ? u.splice(u.length - 1, 0, h) : (this.proxyToSource[c.tileID.key][t.id] = [h]), n.push(h), (s = !0);
            }
          }
          this._sourceTilesOverlap[t.id] = s;
        }
        _setupProxiedCoordsForImageSource(t, i, r) {
          if (!t.getSource().loaded()) return;
          const n = (this.proxiedCoords[t.id] = []),
            o = this.proxyCoords,
            s = t.getSource(),
            a = s.tileID;
          if (!a) return;
          const l = new H(a.x, a.y)._div(1 << a.z),
            c = s.coordinates.map(Me.fromLngLat).reduce((h, d) => ((h.min.x = Math.min(h.min.x, d.x - l.x)), (h.min.y = Math.min(h.min.y, d.y - l.y)), (h.max.x = Math.max(h.max.x, d.x - l.x)), (h.max.y = Math.max(h.max.y, d.y - l.y)), h), { min: new H(Number.MAX_VALUE, Number.MAX_VALUE), max: new H(-Number.MAX_VALUE, -Number.MAX_VALUE) }),
            u = (h, d) => {
              const f = h.wrap + h.canonical.x / (1 << h.canonical.z),
                p = h.canonical.y / (1 << h.canonical.z),
                _ = lt / (1 << h.canonical.z),
                g = d.wrap + d.canonical.x / (1 << d.canonical.z),
                y = d.canonical.y / (1 << d.canonical.z);
              return f + _ < g + c.min.x || f > g + c.max.x || p + _ < y + c.min.y || p > y + c.max.y;
            };
          for (let h = 0; h < o.length; h++) {
            const d = o[h];
            for (let f = 0; f < i.length; f++) {
              const p = t.getTile(i[f]);
              if (!p || !p.hasData() || u(d, p.tileID)) continue;
              const _ = this._createProxiedId(d, p, r[d.key] && r[d.key][t.id]),
                g = this.proxyToSource[d.key][t.id];
              g ? g.push(_) : (this.proxyToSource[d.key][t.id] = [_]), n.push(_);
            }
          }
        }
        _createProxiedId(t, i, r) {
          let n = this.orthoMatrix;
          if (r) {
            const o = r.find((s) => s.key === i.tileID.key);
            if (o) return o;
          }
          if (i.tileID.key !== t.key) {
            const o = t.canonical.z - i.tileID.canonical.z;
            let s, a, l;
            n = J.create();
            const c = (i.tileID.wrap - t.wrap) << t.overscaledZ;
            o > 0 ? ((s = lt >> o), (a = s * ((i.tileID.canonical.x << o) - t.canonical.x + c)), (l = s * ((i.tileID.canonical.y << o) - t.canonical.y))) : ((s = lt << -o), (a = lt * (i.tileID.canonical.x - ((t.canonical.x + c) << -o))), (l = lt * (i.tileID.canonical.y - (t.canonical.y << -o)))), J.ortho(n, 0, s, 0, s, 0, 1), J.translate(n, n, [a, l, 0]);
          }
          return new Fb(i.tileID, t.key, n);
        }
        _findTileCoveringTileID(t, i) {
          let r = i.getTile(t);
          if (r && r.hasData()) return r;
          const n = this._findCoveringTileCache[i.id],
            o = n[t.key];
          if (((r = o ? i.getTileByID(o) : null), (r && r.hasData()) || o === null)) return r;
          let s = r ? r.tileID : t,
            a = s.overscaledZ;
          const l = i.getSource().minzoom,
            c = [];
          if (!o) {
            const h = i.getSource().maxzoom;
            if (t.canonical.z >= h) {
              const d = t.canonical.z - h;
              i.getSource().reparseOverscaled ? ((a = Math.max(t.canonical.z + 2, i.transform.tileZoom)), (s = new Le(a, t.wrap, h, t.canonical.x >> d, t.canonical.y >> d))) : d !== 0 && ((a = h), (s = new Le(a, t.wrap, h, t.canonical.x >> d, t.canonical.y >> d)));
            }
            s.key !== t.key && (c.push(s.key), (r = i.getTile(s)));
          }
          const u = (h) => {
            c.forEach((d) => {
              n[d] = h;
            }),
              (c.length = 0);
          };
          for (a -= 1; a >= l && (!r || !r.hasData()); a--) {
            r && u(r.tileID.key);
            const h = s.calculateScaledKey(a);
            if (((r = i.getTileByID(h)), r && r.hasData())) break;
            const d = n[h];
            if (d === null) break;
            d === void 0 ? c.push(h) : (r = i.getTileByID(d));
          }
          return u(r ? r.tileID.key : null), r && r.hasData() ? r : null;
        }
        findDEMTileFor(t) {
          return this.enabled ? this._findTileCoveringTileID(t, this.sourceCache) : null;
        }
        prepareDrawTile() {
          this.renderedToTile = !0;
        }
        _clearRenderCacheForTile(t, i) {
          let r = this._tilesDirty[t];
          r || (r = this._tilesDirty[t] = {}), (r[i.key] = !0);
        }
      }
      function qP(e, t, i) {
        const r = (function (a, l, c) {
            const u = N.dot(l, a),
              h = N.dot(c, [0.2126, 0.7152, 0.0722]),
              d = (p, _, g) => (1 - g) * p + g * _,
              f = d(1 - 0.3 * Math.min(h, 1), 1, Math.min(u + 1, 1));
            return d(0.92, 1, Math.asin(Bt(l[2], -1, 1)) / Math.PI + 0.5) * f;
          })(e, [0, 0, 1], t),
          n = [0, 0, 0];
        N.scale(n, i.slice(0, 3), r);
        const o = [0, 0, 0];
        N.scale(o, t.slice(0, 3), e[2]);
        const s = [0, 0, 0];
        return N.add(s, n, o), bi(s);
      }
      const ZP = ['fill', 'fillOutline', 'fillPattern', 'line', 'linePattern', 'background', 'backgroundPattern', 'hillshade', 'raster'],
        $P = ['stars', 'fillExtrusion', 'fillExtrusionGroundEffect', 'model', 'symbolSDF', 'symbolIcon', 'symbolTextAndIcon'];
      class Nb {
        static cacheKey(t, i, r, n) {
          let o = `${i}${n ? n.cacheKey : ''}`;
          for (const s of r) t.usedDefines.includes(s) && (o += `/${s}`);
          return o;
        }
        constructor(t, i, r, n, o, s) {
          const a = t.gl;
          (this.program = a.createProgram()), (this.configuration = n), (this.name = i), (this.fixedDefines = [...s]);
          const l = n ? n.getBinderAttributes() : [],
            c = (r.staticAttributes || []).concat(l);
          let u = n ? n.defines() : [];
          u = u.concat(s.map((g) => `#define ${g}`));
          const h = `#version 300 es
`;
          let d =
            h +
            u.concat('precision mediump float;', Ib, Ab.fragmentSource).join(`
`);
          for (const g of r.fragmentIncludes)
            d += `
${mh[g]}`;
          d += `
${r.fragmentSource}`;
          let f =
            h +
            u.concat('precision highp float;', Ib, Ab.vertexSource).join(`
`);
          for (const g of r.vertexIncludes)
            f += `
${mh[g]}`;
          f += `
${r.vertexSource}`;
          const p = a.createShader(a.FRAGMENT_SHADER);
          if (a.isContextLost()) return void (this.failedToCreate = !0);
          a.shaderSource(p, d), a.compileShader(p), a.attachShader(this.program, p);
          const _ = a.createShader(a.VERTEX_SHADER);
          if (a.isContextLost()) this.failedToCreate = !0;
          else {
            a.shaderSource(_, f), a.compileShader(_), a.attachShader(this.program, _), (this.attributes = {}), (this.numAttributes = c.length);
            for (let g = 0; g < this.numAttributes; g++)
              if (c[g]) {
                const y = c[g].startsWith('a_') ? c[g] : `a_${c[g]}`;
                a.bindAttribLocation(this.program, g, y), (this.attributes[y] = g);
              }
            a.linkProgram(this.program), a.deleteShader(_), a.deleteShader(p), (this.fixedUniforms = o(t)), (this.binderUniforms = n ? n.getUniforms(t) : []), s.includes('TERRAIN') && (this.terrainUniforms = ((g) => ({ u_dem: new xe(g), u_dem_prev: new xe(g), u_dem_tl: new ve(g), u_dem_scale: new yt(g), u_dem_tl_prev: new ve(g), u_dem_scale_prev: new yt(g), u_dem_size: new yt(g), u_dem_lerp: new yt(g), u_exaggeration: new yt(g), u_depth: new xe(g), u_depth_size_inv: new ve(g), u_meter_to_dem: new yt(g), u_label_plane_matrix_inv: new se(g) }))(t)), s.includes('GLOBE') && (this.globeUniforms = ((g) => ({ u_tile_tl_up: new ce(g), u_tile_tr_up: new ce(g), u_tile_br_up: new ce(g), u_tile_bl_up: new ce(g), u_tile_up_scale: new yt(g) }))(t)), s.includes('FOG') && (this.fogUniforms = ((g) => ({ u_fog_matrix: new se(g), u_fog_range: new ve(g), u_fog_color: new Lr(g), u_fog_horizon_blend: new yt(g), u_fog_vertical_limit: new ve(g), u_fog_temporal_offset: new yt(g), u_frustum_tl: new ce(g), u_frustum_tr: new ce(g), u_frustum_br: new ce(g), u_frustum_bl: new ce(g), u_globe_pos: new ce(g), u_globe_radius: new yt(g), u_globe_transition: new yt(g), u_is_globe: new xe(g), u_viewport: new ve(g) }))(t)), s.includes('RENDER_CUTOFF') && (this.cutoffUniforms = ((g) => ({ u_cutoff_params: new Lr(g) }))(t)), s.includes('LIGHTING_3D_MODE') && (this.lightsUniforms = ((g) => ({ u_lighting_ambient_color: new ce(g), u_lighting_directional_dir: new ce(g), u_lighting_directional_color: new ce(g), u_ground_radiance: new ce(g) }))(t)), s.includes('RENDER_SHADOWS') && (this.shadowUniforms = ((g) => ({ u_light_matrix_0: new se(g), u_light_matrix_1: new se(g), u_fade_range: new ve(g), u_shadow_normal_offset: new ce(g), u_shadow_intensity: new yt(g), u_shadow_texel_size: new yt(g), u_shadow_map_resolution: new yt(g), u_shadow_direction: new ce(g), u_shadow_bias: new ce(g), u_shadowmap_0: new xe(g), u_shadowmap_1: new xe(g) }))(t));
          }
        }
        setTerrainUniformValues(t, i) {
          if (!this.terrainUniforms) return;
          const r = this.terrainUniforms;
          if (!this.failedToCreate) {
            t.program.set(this.program);
            for (const n in i) r[n] && r[n].set(this.program, n, i[n]);
          }
        }
        setGlobeUniformValues(t, i) {
          if (!this.globeUniforms) return;
          const r = this.globeUniforms;
          if (!this.failedToCreate) {
            t.program.set(this.program);
            for (const n in i) r[n] && r[n].set(this.program, n, i[n]);
          }
        }
        setFogUniformValues(t, i) {
          if (!this.fogUniforms) return;
          const r = this.fogUniforms;
          if (!this.failedToCreate) {
            t.program.set(this.program);
            for (const n in i) r[n].set(this.program, n, i[n]);
          }
        }
        setCutoffUniformValues(t, i) {
          if (!this.cutoffUniforms) return;
          const r = this.cutoffUniforms;
          if (!this.failedToCreate) {
            t.program.set(this.program);
            for (const n in i) r[n].set(this.program, n, i[n]);
          }
        }
        setLightsUniformValues(t, i) {
          if (!this.lightsUniforms) return;
          const r = this.lightsUniforms;
          if (!this.failedToCreate) {
            t.program.set(this.program);
            for (const n in i) r[n].set(this.program, n, i[n]);
          }
        }
        setShadowUniformValues(t, i) {
          if (this.failedToCreate || !this.shadowUniforms) return;
          const r = this.shadowUniforms;
          t.program.set(this.program);
          for (const n in i) r[n].set(this.program, n, i[n]);
        }
        _drawDebugWireframe(t, i, r, n, o, s, a, l, c, u) {
          const h = t.options.wireframe;
          if (h.terrain === !1 && h.layers2D === !1 && h.layers3D === !1) return;
          const d = t.context;
          if (!(!(!h.terrain || (this.name !== 'terrainRaster' && this.name !== 'globeRaster')) || !(!h.layers2D || (t._terrain && t._terrain.renderingToTexture) || !ZP.includes(this.name)) || !(!h.layers3D || !$P.includes(this.name)))) return;
          const f = d.gl,
            p = t.wireframeDebugCache.getLinesFromTrianglesBuffer(t.frameCounter, o, d);
          if (!p) return;
          const _ = [...this.fixedDefines];
          _.push('DEBUG_WIREFRAME');
          const g = t.getOrCreateProgram(this.name, { config: this.configuration, defines: _ });
          d.program.set(g.program);
          const y = (T, b, E) => {
            if (b[T] && E[T]) for (const S in b[T]) E[T][S] && E[T][S].set(E.program, S, b[T][S].current);
          };
          c && c.setUniforms(g.program, d, g.binderUniforms, a, { zoom: l }), y('fixedUniforms', this, g), y('terrainUniforms', this, g), y('globeUniforms', this, g), y('fogUniforms', this, g), y('lightsUniforms', this, g), y('shadowUniforms', this, g), p.bind(), d.setColorMode(new De([f.ONE, f.ONE_MINUS_SRC_ALPHA, f.ZERO, f.ONE], pe.transparent, [!0, !0, !0, !1])), d.setDepthMode(new Jt(i.func === f.LESS ? f.LEQUAL : i.func, Jt.ReadOnly, i.range)), d.setStencilMode(me.disabled);
          const v = 3 * s.primitiveLength * 2,
            w = 3 * s.primitiveOffset * 2 * 2;
          u && u > 1 ? f.drawElementsInstanced(f.LINES, v, f.UNSIGNED_SHORT, w, u) : f.drawElements(f.LINES, v, f.UNSIGNED_SHORT, w), o.bind(), d.program.set(this.program), d.setDepthMode(i), d.setStencilMode(r), d.setColorMode(n);
        }
        draw(t, i, r, n, o, s, a, l, c, u, h, d, f, p, _, g) {
          const y = t.context,
            v = y.gl;
          if (this.failedToCreate) return;
          y.program.set(this.program), y.setDepthMode(r), y.setStencilMode(n), y.setColorMode(o), y.setCullFace(s);
          for (const b of Object.keys(this.fixedUniforms)) this.fixedUniforms[b].set(this.program, b, a[b]);
          p && p.setUniforms(this.program, y, this.binderUniforms, d, { zoom: f });
          const w = { [v.LINES]: 2, [v.TRIANGLES]: 3, [v.LINE_STRIP]: 1 }[i],
            T = g && g > 0 ? 1 : void 0;
          for (const b of h.get()) {
            const E = b.vaos || (b.vaos = {});
            (E[l] || (E[l] = new OP())).bind(y, this, c, p ? p.getPaintVertexBuffers() : [], u, b.vertexOffset, _ || [], T), g && g > 1 ? v.drawElementsInstanced(i, b.primitiveLength * w, v.UNSIGNED_SHORT, b.primitiveOffset * w * 2, g) : v.drawElements(i, b.primitiveLength * w, v.UNSIGNED_SHORT, b.primitiveOffset * w * 2), i === v.TRIANGLES && this._drawDebugWireframe(t, r, n, o, u, b, d, f, p, g);
          }
        }
      }
      function Ub(e, t) {
        const i = Math.pow(2, t.tileID.overscaledZ),
          r = (t.tileSize * Math.pow(2, e.transform.tileZoom)) / i,
          n = r * (t.tileID.canonical.x + t.tileID.wrap * i),
          o = r * t.tileID.canonical.y;
        return { u_image: 0, u_texsize: t.imageAtlasTexture ? t.imageAtlasTexture.size : [0, 0], u_tile_units_to_pixels: 1 / Ms(t, 1, e.transform.tileZoom), u_pixel_coord_upper: [n >> 16, o >> 16], u_pixel_coord_lower: [65535 & n, 65535 & o] };
      }
      const HP = J.create(),
        Vb = (e, t, i, r, n, o, s, a, l, c, u, h, d, f, p, _) => {
          const g = t.style.light,
            y = g.properties.get('position'),
            v = [y.x, y.y, y.z],
            w = br.create();
          g.properties.get('anchor') === 'viewport' && (br.fromRotation(w, -t.transform.angle), N.transformMat3(v, v, w));
          const T = g.properties.get('color'),
            b = t.transform,
            E = { u_matrix: e, u_lightpos: v, u_lightintensity: g.properties.get('intensity'), u_lightcolor: [T.r, T.g, T.b], u_vertical_gradient: +i, u_opacity: r, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: HP, u_merc_center: [0, 0], u_up_dir: [0, 0, 0], u_height_lift: 0, u_ao: n, u_edge_radius: o, u_flood_light_color: h, u_vertical_scale: d, u_flood_light_intensity: f, u_ground_shadow_factor: p, u_emissive_strength: _ };
          return b.projection.name === 'globe' && ((E.u_tile_id = [s.canonical.x, s.canonical.y, 1 << s.canonical.z]), (E.u_zoom_transition = l), (E.u_inv_rot_matrix = u), (E.u_merc_center = c), (E.u_up_dir = b.projection.upVector(new cn(0, 0, 0), c[0] * lt, c[1] * lt)), (E.u_height_lift = a)), E;
        },
        WP = (e, t, i) => ({ u_matrix: e, u_edge_radius: t, u_vertical_scale: i }),
        XP = (e, t, i, r, n, o, s, a, l, c, u, h, d, f) => {
          const p = Vb(e, t, i, r, n, o, s, l, c, u, h, d, f, 1, [0, 0, 0], 0),
            _ = { u_height_factor: -Math.pow(2, s.overscaledZ) / a.tileSize / 8 };
          return Ft(p, Ub(t, a), _);
        },
        jb = (e, t) => ({ u_matrix: e, u_emissive_strength: t }),
        Gb = (e, t, i, r) => Ft(jb(e, t), Ub(i, r)),
        YP = (e, t, i) => ({ u_matrix: e, u_world: i, u_emissive_strength: t }),
        KP = (e, t, i, r, n) => Ft(Gb(e, t, i, r), { u_world: n }),
        JP = (e, t, i, r) => {
          const n = lt / i.tileSize;
          return { u_matrix: e, u_camera_to_center_distance: t.getCameraToCenterDistance(r), u_extrude_scale: [t.pixelsToGLUnits[0] / n, t.pixelsToGLUnits[1] / n] };
        },
        qb = (e, t, i = 1) => ({ u_matrix: e, u_color: t, u_overlay: 0, u_overlay_scale: i }),
        QP = J.create(),
        tz = (e, t, i, r, n, o, s) => {
          const a = e.transform,
            l = a.projection.name === 'globe',
            c = l ? rx(a.zoom, t.canonical) * a._pixelsPerMercatorPixel : Ms(i, 1, o),
            u = { u_matrix: t.projMatrix, u_extrude_scale: c, u_intensity: s, u_inv_rot_matrix: QP, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0] };
          if (l) {
            (u.u_inv_rot_matrix = r), (u.u_merc_center = n), (u.u_tile_id = [t.canonical.x, t.canonical.y, 1 << t.canonical.z]), (u.u_zoom_transition = Ji(a.zoom));
            const h = n[0] * lt,
              d = n[1] * lt;
            u.u_up_dir = a.projection.upVector(new cn(0, 0, 0), h, d);
          }
          return u;
        },
        Zb = (e, t, i, r, n, o, s, a, l, c, u, h, d, f, p, _, g, y, v, w, T, b) => {
          return { u_matrix: e, u_normalize_matrix: t, u_globe_matrix: i, u_merc_matrix: r, u_grid_matrix: n, u_tl_parent: o, u_scale_parent: u, u_fade_t: h.mix, u_opacity: h.opacity * d.paint.get('raster-opacity'), u_image0: 0, u_image1: 1, u_brightness_low: d.paint.get('raster-brightness-min'), u_brightness_high: d.paint.get('raster-brightness-max'), u_saturation_factor: ((S = d.paint.get('raster-saturation')), S > 0 ? 1 - 1 / (1.001 - S) : -S), u_contrast_factor: ((E = d.paint.get('raster-contrast')), E > 0 ? 1 / (1 - E) : 1 + E), u_spin_weights: ez(d.paint.get('raster-hue-rotate')), u_perspective_transform: f, u_raster_elevation: p, u_tl_br: s, u_zoom_transition: a, u_merc_center: l, u_cutoff_params: c, u_colorization_mix: iz(g, v), u_colorization_offset: rz(y, v), u_color_ramp: _, u_texture_offset: [T / (w + 2 * T), w / (w + 2 * T)], u_texture_res: [w + 2 * T, w + 2 * T], u_emissive_strength: b };
          var E, S;
        };
      function ez(e) {
        e *= Math.PI / 180;
        const t = Math.sin(e),
          i = Math.cos(e);
        return [(2 * i + 1) / 3, (-Math.sqrt(3) * t - i + 1) / 3, (Math.sqrt(3) * t - i + 1) / 3];
      }
      function iz([e, t, i, r], [n, o]) {
        if (n === o) return [0, 0, 0, 0];
        const s = 259 / 257 / (o - n);
        return [e * s, t * s, i * s, r * s];
      }
      function rz(e, [t, i]) {
        return t === i ? 0 : (((e - t) / (i - t)) * 259 - 1) / 257;
      }
      const $b = J.create(),
        Hb = (e, t, i, r, n, o, s, a, l, c, u, h, d, f, p, _, g, y) => {
          const v = n.transform,
            w = { u_is_size_zoom_constant: +(e === 'constant' || e === 'source'), u_is_size_feature_constant: +(e === 'constant' || e === 'camera'), u_size_t: t ? t.uSizeT : 0, u_size: t ? t.uSize : 0, u_camera_to_center_distance: v.getCameraToCenterDistance(_), u_rotate_symbol: +i, u_aspect_ratio: v.width / v.height, u_fade_change: n.options.fadeDuration ? n.symbolFadeChange : 1, u_matrix: o, u_label_plane_matrix: s, u_coord_matrix: a, u_is_text: +l, u_pitch_with_map: +r, u_texsize: c, u_texture: 0, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: $b, u_merc_center: [0, 0], u_camera_forward: [0, 0, 0], u_ecef_origin: [0, 0, 0], u_tile_matrix: $b, u_up_vector: [0, -1, 0], u_icon_transition: y || 0, u_icon_saturation: g };
          return (
            _.name === 'globe' &&
              ((w.u_tile_id = [u.canonical.x, u.canonical.y, 1 << u.canonical.z]),
              (w.u_zoom_transition = h),
              (w.u_inv_rot_matrix = f),
              (w.u_merc_center = d),
              (w.u_camera_forward = v._camera.forward()),
              (w.u_ecef_origin = (function (T, b) {
                const E = [0, 0, 0],
                  S = Bo(Yr(b.canonical));
                return N.transformMat4(E, E, S), N.transformMat4(E, E, T), E;
              })(v.globeMatrix, u.toUnwrapped())),
              (w.u_tile_matrix = Float32Array.from(v.globeMatrix)),
              (w.u_up_vector = p)),
            w
          );
        },
        Wb = (e, t, i, r, n, o, s, a, l, c, u, h, d, f, p, _, g) => Ft(Hb(e, t, i, r, n, o, s, a, l, c, h, d, f, p, _, g, 1), { u_gamma_scale: r ? n.transform.getCameraToCenterDistance(g) * Math.cos(n.terrain ? 0 : n.transform._pitch) : 1, u_device_pixel_ratio: oe.devicePixelRatio, u_is_halo: +u, undefined: void 0 }),
        nz = (e, t, i, r, n, o, s, a, l, c, u, h, d, f, p, _) => Ft(Wb(e, t, i, r, n, o, s, a, !0, l, !0, u, h, d, f, p, _), { u_texsize_icon: c, u_texture_icon: 1 }),
        oz = (e, t, i, r) => ({ u_matrix: e, u_emissive_strength: t, u_opacity: i, u_color: r }),
        sz = (e, t, i, r, n, o, s) =>
          Ft(
            (function (a, l, c, u) {
              const h = c.imageManager.getPattern(a.toString(), l),
                { width: d, height: f } = c.imageManager.getPixelSize(l),
                p = Math.pow(2, u.tileID.overscaledZ),
                _ = (u.tileSize * Math.pow(2, c.transform.tileZoom)) / p,
                g = _ * (u.tileID.canonical.x + u.tileID.wrap * p),
                y = _ * u.tileID.canonical.y;
              return { u_image: 0, u_pattern_tl: h.tl, u_pattern_br: h.br, u_texsize: [d, f], u_pattern_size: h.displaySize, u_tile_units_to_pixels: 1 / Ms(u, 1, c.transform.tileZoom), u_pixel_coord_upper: [g >> 16, y >> 16], u_pixel_coord_lower: [65535 & g, 65535 & y] };
            })(n, o, r, s),
            { u_matrix: e, u_emissive_strength: t, u_opacity: i }
          ),
        Fr = { BaseColor: 5, MetallicRoughness: 6, Normal: 7, Occlusion: 8, Emission: 9, ShadowMap0: 10 },
        Pm = (e, t, i, r, n, o, s, a, l, c, u, h, d = [0, 0, 0]) => {
          const f = r.style.light,
            p = f.properties.get('position'),
            _ = [-p.x, -p.y, p.z],
            g = br.create();
          f.properties.get('anchor') === 'viewport' && (br.fromRotation(g, -r.transform.angle), N.transformMat3(_, _, g));
          const y = c.alphaMode === 'MASK',
            v = f.properties.get('color'),
            w = h.paint.get('model-ambient-occlusion-intensity'),
            T = h.paint.get('model-color').constantOr(pe.white),
            b = h.paint.get('model-color-mix-intensity').constantOr(0);
          return { u_matrix: e, u_lighting_matrix: t, u_normal_matrix: i, u_lightpos: _, u_lightintensity: f.properties.get('intensity'), u_lightcolor: [v.r, v.g, v.b], u_camera_pos: d, u_opacity: n, u_baseTextureIsAlpha: 0, u_alphaMask: +y, u_alphaCutoff: c.alphaCutoff, u_baseColorFactor: [o.r, o.g, o.b, o.a], u_emissiveFactor: [s[0], s[1], s[2], 1], u_metallicFactor: a, u_roughnessFactor: l, u_baseColorTexture: Fr.BaseColor, u_metallicRoughnessTexture: Fr.MetallicRoughness, u_normalTexture: Fr.Normal, u_occlusionTexture: Fr.Occlusion, u_emissionTexture: Fr.Emission, u_color_mix: [T.r, T.g, T.b, b], u_aoIntensity: w, u_emissive_strength: u };
        },
        Xb = new Float32Array(16),
        Yb = (e, t = Xb, i = Xb) => ({ u_matrix: e, u_instance: t, u_node_matrix: i }),
        az = {
          fillExtrusion: (e) => ({ u_matrix: new se(e), u_lightpos: new ce(e), u_lightintensity: new yt(e), u_lightcolor: new ce(e), u_vertical_gradient: new yt(e), u_opacity: new yt(e), u_edge_radius: new yt(e), u_ao: new ve(e), u_tile_id: new ce(e), u_zoom_transition: new yt(e), u_inv_rot_matrix: new se(e), u_merc_center: new ve(e), u_up_dir: new ce(e), u_height_lift: new yt(e), u_flood_light_color: new ce(e), u_vertical_scale: new yt(e), u_flood_light_intensity: new yt(e), u_ground_shadow_factor: new ce(e), u_emissive_strength: new yt(e) }),
          fillExtrusionDepth: (e) => ({ u_matrix: new se(e), u_edge_radius: new yt(e), u_vertical_scale: new yt(e) }),
          fillExtrusionPattern: (e) => ({ u_matrix: new se(e), u_lightpos: new ce(e), u_lightintensity: new yt(e), u_lightcolor: new ce(e), u_vertical_gradient: new yt(e), u_height_factor: new yt(e), u_edge_radius: new yt(e), u_ao: new ve(e), u_tile_id: new ce(e), u_zoom_transition: new yt(e), u_inv_rot_matrix: new se(e), u_merc_center: new ve(e), u_up_dir: new ce(e), u_height_lift: new yt(e), u_image: new xe(e), u_texsize: new ve(e), u_pixel_coord_upper: new ve(e), u_pixel_coord_lower: new ve(e), u_tile_units_to_pixels: new yt(e), u_opacity: new yt(e) }),
          fillExtrusionGroundEffect: (e) => ({ u_matrix: new se(e), u_opacity: new yt(e), u_ao_pass: new yt(e), u_meter_to_tile: new yt(e), u_ao: new ve(e), u_flood_light_intensity: new yt(e), u_flood_light_color: new ce(e), u_attenuation: new yt(e), u_edge_radius: new yt(e), u_fb: new xe(e), u_fb_size: new yt(e) }),
          fill: (e) => ({ u_matrix: new se(e), u_emissive_strength: new yt(e) }),
          fillPattern: (e) => ({ u_matrix: new se(e), u_emissive_strength: new yt(e), u_image: new xe(e), u_texsize: new ve(e), u_pixel_coord_upper: new ve(e), u_pixel_coord_lower: new ve(e), u_tile_units_to_pixels: new yt(e) }),
          fillOutline: (e) => ({ u_matrix: new se(e), u_emissive_strength: new yt(e), u_world: new ve(e) }),
          fillOutlinePattern: (e) => ({ u_matrix: new se(e), u_emissive_strength: new yt(e), u_world: new ve(e), u_image: new xe(e), u_texsize: new ve(e), u_pixel_coord_upper: new ve(e), u_pixel_coord_lower: new ve(e), u_tile_units_to_pixels: new yt(e) }),
          circle: (e) => ({ u_camera_to_center_distance: new yt(e), u_extrude_scale: new qf(e), u_device_pixel_ratio: new yt(e), u_matrix: new se(e), u_inv_rot_matrix: new se(e), u_merc_center: new ve(e), u_tile_id: new ce(e), u_zoom_transition: new yt(e), u_up_dir: new ce(e), u_emissive_strength: new yt(e) }),
          collisionBox: (e) => ({ u_matrix: new se(e), u_camera_to_center_distance: new yt(e), u_extrude_scale: new ve(e) }),
          collisionCircle: (e) => ({ u_matrix: new se(e), u_inv_matrix: new se(e), u_camera_to_center_distance: new yt(e), u_viewport_size: new ve(e) }),
          debug: (e) => ({ u_color: new fa(e), u_matrix: new se(e), u_overlay: new xe(e), u_overlay_scale: new yt(e) }),
          clippingMask: (e) => ({ u_matrix: new se(e) }),
          heatmap: (e) => ({ u_extrude_scale: new yt(e), u_intensity: new yt(e), u_matrix: new se(e), u_inv_rot_matrix: new se(e), u_merc_center: new ve(e), u_tile_id: new ce(e), u_zoom_transition: new yt(e), u_up_dir: new ce(e) }),
          heatmapTexture: (e) => ({ u_image: new xe(e), u_color_ramp: new xe(e), u_opacity: new yt(e) }),
          hillshade: (e) => ({ u_matrix: new se(e), u_image: new xe(e), u_latrange: new ve(e), u_light: new ve(e), u_shadow: new fa(e), u_highlight: new fa(e), u_emissive_strength: new yt(e), u_accent: new fa(e) }),
          hillshadePrepare: (e) => ({ u_matrix: new se(e), u_image: new xe(e), u_dimension: new ve(e), u_zoom: new yt(e) }),
          line: (e) => ({ u_matrix: new se(e), u_pixels_to_tile_units: new qf(e), u_device_pixel_ratio: new yt(e), u_units_to_pixels: new ve(e), u_dash_image: new xe(e), u_gradient_image: new xe(e), u_image_height: new yt(e), u_texsize: new ve(e), u_tile_units_to_pixels: new yt(e), u_alpha_discard_threshold: new yt(e), u_trim_offset: new ve(e), u_emissive_strength: new yt(e) }),
          linePattern: (e) => ({ u_matrix: new se(e), u_texsize: new ve(e), u_pixels_to_tile_units: new qf(e), u_device_pixel_ratio: new yt(e), u_image: new xe(e), u_units_to_pixels: new ve(e), u_tile_units_to_pixels: new yt(e), u_alpha_discard_threshold: new yt(e) }),
          raster: (e) => ({ u_matrix: new se(e), u_normalize_matrix: new se(e), u_globe_matrix: new se(e), u_merc_matrix: new se(e), u_grid_matrix: new Gf(e), u_tl_parent: new ve(e), u_scale_parent: new yt(e), u_fade_t: new yt(e), u_opacity: new yt(e), u_image0: new xe(e), u_image1: new xe(e), u_brightness_low: new yt(e), u_brightness_high: new yt(e), u_saturation_factor: new yt(e), u_contrast_factor: new yt(e), u_spin_weights: new ce(e), u_perspective_transform: new ve(e), u_raster_elevation: new yt(e), u_tl_br: new Lr(e), u_zoom_transition: new yt(e), u_merc_center: new ve(e), u_cutoff_params: new Lr(e), u_colorization_mix: new Lr(e), u_colorization_offset: new yt(e), u_color_ramp: new xe(e), u_texture_offset: new ve(e), u_texture_res: new ve(e), u_emissive_strength: new yt(e) }),
          symbolIcon: (e) => ({ u_is_size_zoom_constant: new xe(e), u_is_size_feature_constant: new xe(e), u_size_t: new yt(e), u_size: new yt(e), u_camera_to_center_distance: new yt(e), u_rotate_symbol: new xe(e), u_aspect_ratio: new yt(e), u_fade_change: new yt(e), u_matrix: new se(e), u_label_plane_matrix: new se(e), u_coord_matrix: new se(e), u_is_text: new xe(e), u_pitch_with_map: new xe(e), u_texsize: new ve(e), u_tile_id: new ce(e), u_zoom_transition: new yt(e), u_inv_rot_matrix: new se(e), u_merc_center: new ve(e), u_camera_forward: new ce(e), u_tile_matrix: new se(e), u_up_vector: new ce(e), u_ecef_origin: new ce(e), u_texture: new xe(e), u_icon_transition: new yt(e), u_icon_saturation: new yt(e) }),
          symbolSDF: (e) => ({ u_is_size_zoom_constant: new xe(e), u_is_size_feature_constant: new xe(e), u_size_t: new yt(e), u_size: new yt(e), u_camera_to_center_distance: new yt(e), u_rotate_symbol: new xe(e), u_aspect_ratio: new yt(e), u_fade_change: new yt(e), u_matrix: new se(e), u_label_plane_matrix: new se(e), u_coord_matrix: new se(e), u_is_text: new xe(e), u_pitch_with_map: new xe(e), u_texsize: new ve(e), u_texture: new xe(e), u_gamma_scale: new yt(e), u_device_pixel_ratio: new yt(e), u_tile_id: new ce(e), u_zoom_transition: new yt(e), u_inv_rot_matrix: new se(e), u_merc_center: new ve(e), u_camera_forward: new ce(e), u_tile_matrix: new se(e), u_up_vector: new ce(e), u_ecef_origin: new ce(e), u_is_halo: new xe(e) }),
          symbolTextAndIcon: (e) => ({ u_is_size_zoom_constant: new xe(e), u_is_size_feature_constant: new xe(e), u_size_t: new yt(e), u_size: new yt(e), u_camera_to_center_distance: new yt(e), u_rotate_symbol: new xe(e), u_aspect_ratio: new yt(e), u_fade_change: new yt(e), u_matrix: new se(e), u_label_plane_matrix: new se(e), u_coord_matrix: new se(e), u_is_text: new xe(e), u_pitch_with_map: new xe(e), u_texsize: new ve(e), u_texsize_icon: new ve(e), u_texture: new xe(e), u_texture_icon: new xe(e), u_gamma_scale: new yt(e), u_device_pixel_ratio: new yt(e), u_is_halo: new xe(e) }),
          background: (e) => ({ u_matrix: new se(e), u_emissive_strength: new yt(e), u_opacity: new yt(e), u_color: new fa(e) }),
          backgroundPattern: (e) => ({ u_matrix: new se(e), u_emissive_strength: new yt(e), u_opacity: new yt(e), u_image: new xe(e), u_pattern_tl: new ve(e), u_pattern_br: new ve(e), u_texsize: new ve(e), u_pattern_size: new ve(e), u_pixel_coord_upper: new ve(e), u_pixel_coord_lower: new ve(e), u_tile_units_to_pixels: new yt(e) }),
          terrainRaster: zb,
          terrainDepth: zb,
          skybox: (e) => ({ u_matrix: new se(e), u_sun_direction: new ce(e), u_cubemap: new xe(e), u_opacity: new yt(e), u_temporal_offset: new yt(e) }),
          skyboxGradient: (e) => ({ u_matrix: new se(e), u_color_ramp: new xe(e), u_center_direction: new ce(e), u_radius: new yt(e), u_opacity: new yt(e), u_temporal_offset: new yt(e) }),
          skyboxCapture: (e) => ({ u_matrix_3f: new Gf(e), u_sun_direction: new ce(e), u_sun_intensity: new yt(e), u_color_tint_r: new Lr(e), u_color_tint_m: new Lr(e), u_luminance: new yt(e) }),
          globeRaster: (e) => ({ u_proj_matrix: new se(e), u_globe_matrix: new se(e), u_normalize_matrix: new se(e), u_merc_matrix: new se(e), u_zoom_transition: new yt(e), u_merc_center: new ve(e), u_image0: new xe(e), u_grid_matrix: new Gf(e), u_skirt_height: new yt(e), u_frustum_tl: new ce(e), u_frustum_tr: new ce(e), u_frustum_br: new ce(e), u_frustum_bl: new ce(e), u_globe_pos: new ce(e), u_globe_radius: new yt(e), u_viewport: new ve(e) }),
          globeAtmosphere: (e) => ({ u_frustum_tl: new ce(e), u_frustum_tr: new ce(e), u_frustum_br: new ce(e), u_frustum_bl: new ce(e), u_horizon: new yt(e), u_transition: new yt(e), u_fadeout_range: new yt(e), u_color: new Lr(e), u_high_color: new Lr(e), u_space_color: new Lr(e), u_temporal_offset: new yt(e), u_horizon_angle: new yt(e) }),
          model: (e) => ({ u_matrix: new se(e), u_lighting_matrix: new se(e), u_normal_matrix: new se(e), u_lightpos: new ce(e), u_lightintensity: new yt(e), u_lightcolor: new ce(e), u_camera_pos: new ce(e), u_opacity: new yt(e), u_baseColorFactor: new Lr(e), u_emissiveFactor: new Lr(e), u_metallicFactor: new yt(e), u_roughnessFactor: new yt(e), u_baseTextureIsAlpha: new xe(e), u_alphaMask: new xe(e), u_alphaCutoff: new yt(e), u_baseColorTexture: new xe(e), u_metallicRoughnessTexture: new xe(e), u_normalTexture: new xe(e), u_occlusionTexture: new xe(e), u_emissionTexture: new xe(e), u_color_mix: new Lr(e), u_aoIntensity: new yt(e), u_emissive_strength: new yt(e) }),
          modelDepth: (e) => ({ u_matrix: new se(e), u_instance: new se(e), u_node_matrix: new se(e) }),
          groundShadow: (e) => ({ u_matrix: new se(e), u_ground_shadow_factor: new ce(e) }),
          stars: (e) => ({ u_matrix: new se(e), u_up: new ce(e), u_right: new ce(e), u_intensity_multiplier: new yt(e) }),
        };
      let yh;
      function Kb(e, t, i, r, n, o, s) {
        const a = e.context,
          l = a.gl,
          c = e.transform,
          u = e.getOrCreateProgram('collisionBox'),
          h = [];
        let d = 0,
          f = 0;
        for (let T = 0; T < r.length; T++) {
          const b = r[T],
            E = t.getTile(b),
            S = E.getBucket(i);
          if (!S) continue;
          const I = yP(b, S, c);
          let C = I;
          (n[0] === 0 && n[1] === 0) || (C = e.translatePosMatrix(I, E, n, o));
          const z = s ? S.textCollisionBox : S.iconCollisionBox,
            k = S.collisionCircleArray;
          if (k.length > 0) {
            const O = J.create(),
              V = C;
            J.mul(O, S.placementInvProjMatrix, c.glCoordMatrix), J.mul(O, O, S.placementViewportMatrix), h.push({ circleArray: k, circleOffset: f, transform: V, invTransform: O, projection: S.getProjection() }), (d += k.length / 4), (f = d);
          }
          z && (e.terrain && e.terrain.setupElevationDraw(E, u), u.draw(e, l.LINES, Jt.disabled, me.disabled, e.colorModeForRenderPass(), ye.disabled, JP(C, c, E, S.getProjection()), i.id, z.layoutVertexBuffer, z.indexBuffer, z.segments, null, c.zoom, null, [z.collisionVertexBuffer, z.collisionVertexBufferExt]));
        }
        if (!s || !h.length) return;
        const p = e.getOrCreateProgram('collisionCircle'),
          _ = new Df();
        _.resize(4 * d), _._trim();
        let g = 0;
        for (const T of h)
          for (let b = 0; b < T.circleArray.length / 4; b++) {
            const E = 4 * b,
              S = T.circleArray[E + 0],
              I = T.circleArray[E + 1],
              C = T.circleArray[E + 2],
              z = T.circleArray[E + 3];
            _.emplace(g++, S, I, C, z, 0), _.emplace(g++, S, I, C, z, 1), _.emplace(g++, S, I, C, z, 2), _.emplace(g++, S, I, C, z, 3);
          }
        (!yh || yh.length < 2 * d) &&
          (yh = (function (T) {
            const b = 2 * T,
              E = new Fi();
            E.resize(b), E._trim();
            for (let S = 0; S < b; S++) {
              const I = 6 * S;
              (E.uint16[I + 0] = 4 * S + 0), (E.uint16[I + 1] = 4 * S + 1), (E.uint16[I + 2] = 4 * S + 2), (E.uint16[I + 3] = 4 * S + 2), (E.uint16[I + 4] = 4 * S + 3), (E.uint16[I + 5] = 4 * S + 0);
            }
            return E;
          })(d));
        const y = a.createIndexBuffer(yh, !0),
          v = a.createVertexBuffer(_, PA.members, !0);
        for (const T of h) {
          const b = { u_matrix: T.transform, u_inv_matrix: T.invTransform, u_camera_to_center_distance: (w = c).getCameraToCenterDistance(T.projection), u_viewport_size: [w.width, w.height] };
          p.draw(e, l.TRIANGLES, Jt.disabled, me.disabled, e.colorModeForRenderPass(), ye.disabled, b, i.id, v, y, He.simpleSegment(0, 2 * T.circleOffset, T.circleArray.length, T.circleArray.length / 2), null, c.zoom);
        }
        var w;
        v.destroy(), y.destroy();
      }
      const Jb = J.create();
      function lz({ width: e, height: t, anchor: i, textOffset: r, textScale: n }, o) {
        const { horizontalAlign: s, verticalAlign: a } = Ru(i),
          l = -(s - 0.5) * e,
          c = -(a - 0.5) * t,
          u = Vp(i, r);
        return new H((l / n + u[0]) * o, (c / n + u[1]) * o);
      }
      function cz(e, t, i, r, n, o, s, a, l, c, u) {
        const h = e.text.placedSymbolArray,
          d = e.text.dynamicLayoutVertexArray,
          f = e.icon.dynamicLayoutVertexArray,
          p = {},
          _ = e.getProjection(),
          g = Tm(a, _, o),
          y = o.elevation,
          v = _.upVectorScale(a.canonical, o.center.lat, o.worldSize).metersToTile;
        d.clear();
        for (let w = 0; w < h.length; w++) {
          const T = h.get(w),
            { tileAnchorX: b, tileAnchorY: E, numGlyphs: S } = T,
            I = T.hidden || !T.crossTileID || (e.allowVerticalPlacement && !T.placedOrientation) ? null : r[T.crossTileID];
          if (I) {
            let C = 0,
              z = 0,
              k = 0;
            if (y) {
              const it = y ? y.getAtTileOffset(a, b, E) : 0,
                [st, nt, ut] = _.upVector(a.canonical, b, E);
              (C = it * st * v), (z = it * nt * v), (k = it * ut * v);
            }
            let [O, V, R, G] = Tn(T.projectedAnchorX + C, T.projectedAnchorY + z, T.projectedAnchorZ + k, i ? g : s);
            const Z = jv(o.getCameraToCenterDistance(_), G);
            let X = (n.evaluateSizeForFeature(e.textSizeData, c, T) * Z) / Qi;
            i && (X *= e.tilePixelRatio / l);
            const j = lz(I, X);
            i ? (({ x: O, y: V, z: R } = _.projectTilePoint(b + j.x, E + j.y, a.canonical)), ([O, V, R] = Tn(O + C, V + z, R + k, s))) : (t && j._rotate(-o.angle), (O += j.x), (V += j.y), (R = 0));
            const q = e.allowVerticalPlacement && T.placedOrientation === di.vertical ? Math.PI / 2 : 0;
            for (let it = 0; it < S; it++) za(d, O, V, R, q);
            u && T.associatedIconIndex >= 0 && (p[T.associatedIconIndex] = { x: O, y: V, z: R, angle: q });
          } else Ra(S, d);
        }
        if (u) {
          f.clear();
          const w = e.icon.placedSymbolArray;
          for (let T = 0; T < w.length; T++) {
            const b = w.get(T),
              { numGlyphs: E } = b,
              S = p[T];
            if (b.hidden || !S) Ra(E, f);
            else {
              const { x: I, y: C, z, angle: k } = S;
              for (let O = 0; O < E; O++) za(f, I, C, z, k);
            }
          }
          e.icon.dynamicLayoutVertexBuffer.updateData(f);
        }
        e.text.dynamicLayoutVertexBuffer.updateData(d);
      }
      function uz(e, t, i) {
        return i.iconsInText && t ? 'symbolTextAndIcon' : e ? 'symbolSDF' : 'symbolIcon';
      }
      function Qb(e, t, i, r, n, o, s, a, l, c, u, h, d) {
        const f = e.context,
          p = f.gl,
          _ = e.transform,
          g = a === 'map',
          y = l === 'map',
          v = g && i.layout.get('symbol-placement') !== 'point',
          w = g && !y && !v,
          T = i.layout.get('symbol-sort-key').constantOr(1) !== void 0;
        let b = !1;
        const E = e.depthModeForSublayer(0, Jt.ReadOnly),
          S = [qi(_.center.lng), Hi(_.center.lat)],
          I = i.layout.get('text-variable-anchor'),
          C = _.projection.name === 'globe',
          z = [],
          k = [0, -1, 0];
        let O = k;
        (!C && !_.mercatorFromTransition) ||
          g ||
          (O = (function (V) {
            const R = V._camera.getWorldToCamera(V.worldSize, 1),
              G = J.multiply([], R, V.globeMatrix);
            J.invert(G, G);
            const Z = [0, 0, 0],
              X = [0, 1, 0, 0];
            return We.transformMat4(X, X, G), (Z[0] = X[0]), (Z[1] = X[1]), (Z[2] = X[2]), N.normalize(Z, Z), Z;
          })(_));
        for (const V of r) {
          const R = t.getTile(V),
            G = R.getBucket(i);
          if (!G || (G.projection.name === 'mercator' && C)) continue;
          const Z = n ? G.text : G.icon;
          if (!Z || G.fullyClipped || !Z.segments.get().length) continue;
          const X = Z.programConfigurations.get(i.id),
            j = n || G.sdfIcons,
            q = n ? G.textSizeData : G.iconSizeData,
            it = y || _.pitch !== 0,
            st = Bn(q, _.zoom);
          let nt,
            ut,
            ht,
            pt,
            at = [0, 0],
            _t = null;
          if (n) (ut = R.glyphAtlasTexture ? R.glyphAtlasTexture : null), (ht = p.LINEAR), (nt = R.glyphAtlasTexture ? R.glyphAtlasTexture.size : [0, 0]), G.iconsInText && ((at = R.imageAtlasTexture ? R.imageAtlasTexture.size : [0, 0]), (_t = R.imageAtlasTexture ? R.imageAtlasTexture : null), (pt = it || e.options.rotating || e.options.zooming || q.kind === 'composite' || q.kind === 'camera' ? p.LINEAR : p.NEAREST));
          else {
            const ci = i.layout.get('icon-size').constantOr(0) !== 1 || G.iconsNeedLinear;
            (ut = R.imageAtlasTexture ? R.imageAtlasTexture : null), (ht = j || e.options.rotating || e.options.zooming || ci || it ? p.LINEAR : p.NEAREST), (nt = R.imageAtlasTexture ? R.imageAtlasTexture.size : [0, 0]);
          }
          const Ct = G.projection.name === 'globe',
            Pt = Ct ? O : k,
            Ot = Ct ? Ji(_.zoom) : 0,
            Ut = Tm(V, G.getProjection(), _),
            Qt = _.calculatePixelsToTileUnitsMatrix(R),
            Ht = Ju(Ut, R.tileID.canonical, y, g, _, G.getProjection(), Qt),
            Ce = e.terrain && y && v ? J.invert(J.create(), Ht) : Jb,
            be = Vv(Ut, R.tileID.canonical, y, g, _, G.getProjection(), Qt),
            te = I && G.hasTextData(),
            Kt = G.hasIconTextFit() && te && G.hasIconData();
          if (v) {
            const ci = _.elevation,
              je = ci ? ci.getAtTileOffsetFunc(V, _.center.lat, _.worldSize, G.getProjection()) : null,
              rr = Uv(Ut, R.tileID.canonical, y, g, _, G.getProjection(), Qt);
            lC(G, Ut, e, n, rr, be, y, c, je, V);
          }
          const Wt = v || (n && I) || Kt,
            Ee = e.translatePosMatrix(Ut, R, o, s),
            Ae = Wt ? Jb : Ht,
            fe = e.translatePosMatrix(be, R, o, s, !0),
            Qe = G.getProjection().createInversionMatrix(_, V.canonical),
            Ci = i.paint.get('icon-image-cross-fade').constantOr(0),
            Xe = [];
          e.terrainRenderModeElevated() && y && Xe.push('PITCH_WITH_MAP_TERRAIN'), Ct && (Xe.push('PROJECTION_GLOBE_VIEW'), Wt && Xe.push('PROJECTED_POS_ON_VIEWPORT')), Ci > 0 && Xe.push('ICON_TRANSITION'), Z.zOffsetVertexBuffer && Xe.push('Z_OFFSET');
          const oi = j && i.paint.get(n ? 'text-halo-width' : 'icon-halo-width').constantOr(1) !== 0;
          let Ri;
          j ? (Ri = G.iconsInText ? nz(q.kind, st, w, y, e, Ee, Ae, fe, nt, at, V, Ot, S, Qe, Pt, G.getProjection()) : Wb(q.kind, st, w, y, e, Ee, Ae, fe, n, nt, !0, V, Ot, S, Qe, Pt, G.getProjection())) : (u < 1 && Xe.push('SATURATION'), (Ri = Hb(q.kind, st, w, y, e, Ee, Ae, fe, n, nt, V, Ot, S, Qe, Pt, G.getProjection(), u, Ci)));
          const Pi = { program: e.getOrCreateProgram(uz(j, n, G), { config: X, defines: Xe }), buffers: Z, uniformValues: Ri, atlasTexture: ut, atlasTextureIcon: _t, atlasInterpolation: ht, atlasInterpolationIcon: pt, isSDF: j, hasHalo: oi, tile: R, labelPlaneMatrixInv: Ce };
          if (T && G.canOverlap) {
            b = !0;
            const ci = Z.segments.get();
            for (const je of ci) z.push({ segments: new He([je]), sortKey: je.sortKey, state: Pi });
          } else z.push({ segments: Z.segments, sortKey: 0, state: Pi });
        }
        b && z.sort((V, R) => V.sortKey - R.sortKey);
        for (const V of z) {
          const R = V.state;
          if ((e.terrain && e.terrain.setupElevationDraw(R.tile, R.program, { useDepthForOcclusion: _.depthOcclusionForSymbolsAndCircles, labelPlaneMatrixInv: R.labelPlaneMatrixInv }), f.activeTexture.set(p.TEXTURE0), R.atlasTexture && R.atlasTexture.bind(R.atlasInterpolation, p.CLAMP_TO_EDGE), R.atlasTextureIcon && (f.activeTexture.set(p.TEXTURE1), R.atlasTextureIcon && R.atlasTextureIcon.bind(R.atlasInterpolationIcon, p.CLAMP_TO_EDGE)), e.uploadCommonLightUniforms(e.context, R.program), R.hasHalo)) {
            const G = R.uniformValues;
            (G.u_is_halo = 1), zm(R.buffers, V.segments, i, e, R.program, E, h, d, G, 2), (G.u_is_halo = 0);
          } else {
            if (R.isSDF) {
              const G = R.uniformValues;
              R.hasHalo && ((G.u_is_halo = 1), zm(R.buffers, V.segments, i, e, R.program, E, h, d, G, 1)), (G.u_is_halo = 0);
            }
            zm(R.buffers, V.segments, i, e, R.program, E, h, d, R.uniformValues, 1);
          }
        }
      }
      function zm(e, t, i, r, n, o, s, a, l, c) {
        const u = [e.dynamicLayoutVertexBuffer, e.opacityVertexBuffer, e.iconTransitioningVertexBuffer, e.globeExtVertexBuffer, e.zOffsetVertexBuffer];
        n.draw(r, r.context.gl.TRIANGLES, o, s, a, ye.disabled, l, i.id, e.layoutVertexBuffer, e.indexBuffer, t, i.paint, r.transform.zoom, e.programConfigurations.get(i.id), u, c);
      }
      function tw(e, t, i, r, n, o, s) {
        const a = e.context.gl,
          l = i.paint.get('fill-pattern'),
          c = l && l.constantOr(1);
        let u, h, d, f, p;
        s ? ((h = c && !i.getPaintProperty('fill-outline-color') ? 'fillOutlinePattern' : 'fillOutline'), (u = a.LINES)) : ((h = c ? 'fillPattern' : 'fill'), (u = a.TRIANGLES));
        for (const _ of r) {
          const g = t.getTile(_);
          if (c && !g.patternsLoaded()) continue;
          const y = g.getBucket(i);
          if (!y) continue;
          e.prepareDrawTile();
          const v = y.programConfigurations.get(i.id),
            w = e.isTileAffectedByFog(_),
            T = e.getOrCreateProgram(h, { config: v, overrideFog: w });
          c && (e.context.activeTexture.set(a.TEXTURE0), g.imageAtlasTexture && g.imageAtlasTexture.bind(a.LINEAR, a.CLAMP_TO_EDGE), v.updatePaintBuffers());
          const b = l.constantOr(null);
          if (b && g.imageAtlas) {
            const I = g.imageAtlas.patternPositions[b.toString()];
            I && v.setConstantPatternPositions(I);
          }
          const E = e.translatePosMatrix(_.projMatrix, g, i.paint.get('fill-translate'), i.paint.get('fill-translate-anchor')),
            S = i.paint.get('fill-emissive-strength');
          if (s) {
            (f = y.indexBuffer2), (p = y.segments2);
            const I = e.terrain && e.terrain.renderingToTexture ? e.terrain.drapeBufferSize : [a.drawingBufferWidth, a.drawingBufferHeight];
            d = h === 'fillOutlinePattern' && c ? KP(E, S, e, g, I) : YP(E, S, I);
          } else (f = y.indexBuffer), (p = y.segments), (d = c ? Gb(E, S, e, g) : jb(E, S));
          e.uploadCommonUniforms(e.context, T, _.toUnwrapped()), T.draw(e, u, n, e.stencilModeForClipping(_), o, ye.disabled, d, i.id, y.layoutVertexBuffer, f, p, i.paint, e.transform.zoom, v, void 0);
        }
      }
      function xh(e, t, i, r, n, o, s, a) {
        i.resetLayerRenderingStats();
        const l = e.context,
          c = l.gl,
          u = e.transform,
          h = i.paint.get('fill-extrusion-pattern'),
          d = h.constantOr(1),
          f = i.paint.get('fill-extrusion-opacity'),
          p = e.style.enable3dLights(),
          _ = i.paint.get(p && !d ? 'fill-extrusion-ambient-occlusion-wall-radius' : 'fill-extrusion-ambient-occlusion-radius'),
          g = [i.paint.get('fill-extrusion-ambient-occlusion-intensity'), _],
          y = i.layout.get('fill-extrusion-edge-radius'),
          v = y > 0 && !i.paint.get('fill-extrusion-rounded-roof'),
          w = v ? 0 : y,
          T = u.projection.name === 'globe' ? T1() : 0,
          b = u.projection.name === 'globe',
          E = b ? Ji(u.zoom) : 0,
          S = [qi(u.center.lng), Hi(u.center.lat)],
          I = i.paint.get('fill-extrusion-flood-light-color').toArray01().slice(0, 3),
          C = i.paint.get('fill-extrusion-flood-light-intensity'),
          z = i.paint.get('fill-extrusion-vertical-scale'),
          k = Oa(e, i.paint.get('fill-extrusion-cutoff-fade-range')),
          O = i.paint.get('fill-extrusion-emissive-strength'),
          V = [];
        let R;
        b && V.push('PROJECTION_GLOBE_VIEW'), g[0] > 0 && V.push('FAUX_AO'), v && V.push('ZERO_ROOF_RADIUS'), a && V.push('HAS_CENTROID'), C > 0 && V.push('FLOOD_LIGHT'), k.shouldRenderCutoff && V.push('RENDER_CUTOFF');
        const G = e.renderPass === 'shadow',
          Z = e.shadowRenderer,
          X = G && !!Z;
        e.shadowRenderer && (e.shadowRenderer.useNormalOffset = !0);
        let j = [0, 0, 0];
        if (Z) {
          const st = e.style.directionalLight,
            nt = e.style.ambientLight;
          st && nt && (j = Lm(st, nt)), (R = V.concat(['SHADOWS_SINGLE_CASCADE']));
        }
        const q = X ? 'fillExtrusionDepth' : d ? 'fillExtrusionPattern' : 'fillExtrusion',
          it = i.getLayerRenderingStats();
        for (const st of r) {
          const nt = t.getTile(st),
            ut = nt.getBucket(i);
          if (!ut || ut.projection.name !== u.projection.name) continue;
          let ht = !1;
          Z && (ht = Z.getMaxCascadeForTile(st.toUnwrapped()) === 0);
          const pt = e.isTileAffectedByFog(st),
            at = ut.programConfigurations.get(i.id),
            _t = e.getOrCreateProgram(q, { config: at, defines: ht ? R : V, overrideFog: pt });
          if ((e.terrain && e.terrain.setupElevationDraw(nt, _t, { useMeterToDem: !0 }), !ut.centroidVertexBuffer)) {
            const Ht = _t.attributes.a_centroid_pos;
            Ht !== void 0 && c.vertexAttrib2f(Ht, 0, 0);
          }
          !G && Z && Z.setupShadows(nt.tileID.toUnwrapped(), _t, 'vector-tile', nt.tileID.overscaledZ), d && (e.context.activeTexture.set(c.TEXTURE0), nt.imageAtlasTexture && nt.imageAtlasTexture.bind(c.LINEAR, c.CLAMP_TO_EDGE), at.updatePaintBuffers());
          const Ct = h.constantOr(null);
          if (Ct && nt.imageAtlas) {
            const Ht = nt.imageAtlas.patternPositions[Ct.toString()];
            Ht && at.setConstantPatternPositions(Ht);
          }
          const Pt = i.paint.get('fill-extrusion-vertical-gradient');
          let Ot;
          if (G && Z) {
            if (mz(nt.tileID, ut, e)) continue;
            const Ht = Z.calculateShadowPassMatrixFromTile(nt.tileID.toUnwrapped());
            Ot = WP(Ht, w, z);
          } else {
            const Ht = e.translatePosMatrix(st.expandedProjMatrix, nt, i.paint.get('fill-extrusion-translate'), i.paint.get('fill-extrusion-translate-anchor')),
              Ce = u.projection.createInversionMatrix(u, st.canonical);
            Ot = d ? XP(Ht, e, Pt, f, g, w, st, nt, T, E, S, Ce, I, z) : Vb(Ht, e, Pt, f, g, w, st, T, E, S, Ce, I, z, C, j, O);
          }
          e.uploadCommonUniforms(l, _t, st.toUnwrapped(), null, k);
          let Ut = ut.segments;
          if (u.projection.name === 'mercator' && !G && ((Ut = ut.getVisibleSegments(nt.tileID, e.terrain, e.transform.getFrustum(0))), !Ut.get().length)) continue;
          if (it)
            if (G) for (const Ht of Ut.get()) it.numRenderedVerticesInShadowPass += Ht.primitiveLength;
            else for (const Ht of Ut.get()) it.numRenderedVerticesInTransparentPass += Ht.primitiveLength;
          const Qt = [];
          (e.terrain || a) && Qt.push(ut.centroidVertexBuffer), b && Qt.push(ut.layoutVertexExtBuffer), _t.draw(e, l.gl.TRIANGLES, n, o, s, ye.backCCW, Ot, i.id, ut.layoutVertexBuffer, ut.indexBuffer, Ut, i.paint, e.transform.zoom, at, Qt);
        }
        e.shadowRenderer && (e.shadowRenderer.useNormalOffset = !1);
      }
      function Fa(e, t, i, r, n, o, s, a, l, c, u, h, d, f, p, _, g, y, v) {
        const w = e.context,
          T = w.gl,
          b = e.transform,
          E = e.transform.zoom,
          S = [],
          I = Oa(e, i.paint.get('fill-extrusion-cutoff-fade-range'));
        c === 'clear' ? (S.push('CLEAR_SUBPASS'), v && (S.push('CLEAR_FROM_TEXTURE'), w.activeTexture.set(T.TEXTURE0), v.bind(T.LINEAR, T.CLAMP_TO_EDGE))) : c === 'sdf' && S.push('SDF_SUBPASS'), g && S.push('HAS_CENTROID'), I.shouldRenderCutoff && S.push('RENDER_CUTOFF');
        const C = i.layout.get('fill-extrusion-edge-radius'),
          z = (k, O, V, R, G) => {
            const Z = O.programConfigurations.get(i.id),
              X = e.isTileAffectedByFog(k),
              j = e.getOrCreateProgram('fillExtrusionGroundEffect', { config: Z, defines: S, overrideFog: X }),
              q = ((st, nt, ut, ht, pt, at, _t, Ct, Pt, Ot, Ut) => ({ u_matrix: nt, u_opacity: ut, u_ao_pass: ht ? 1 : 0, u_meter_to_tile: pt, u_ao: at, u_flood_light_intensity: _t, u_flood_light_color: Ct, u_attenuation: Pt, u_edge_radius: Ot, u_fb: 0, u_fb_size: Ut }))(0, R, u, l, G, [h, d * G], f, p, _, E >= 17 ? 0 : C * G, v ? v.size[0] : 0),
              it = [];
            g && it.push(O.hiddenByLandmarkVertexBuffer), e.uploadCommonUniforms(w, j, k.toUnwrapped(), null, I), j.draw(e, w.gl.TRIANGLES, n, o, s, a, q, i.id, O.vertexBuffer, O.indexBuffer, V, i.paint, E, Z, it);
          };
        for (const k of r) {
          const O = t.getTile(k),
            V = O.getBucket(i);
          if (!V || V.projection.name !== b.projection.name || !V.groundEffect || (V.groundEffect && !V.groundEffect.hasData())) continue;
          const R = V.groundEffect,
            G = 1 / V.tileToMeter;
          {
            const Z = e.translatePosMatrix(k.projMatrix, O, i.paint.get('fill-extrusion-translate'), i.paint.get('fill-extrusion-translate-anchor')),
              X = R.getDefaultSegment();
            z(k, R, X, Z, G);
          }
          if (y)
            for (let Z = 0; Z < 4; Z++) {
              const X = X0[Z](k),
                j = t.getTile(X);
              if (!j) continue;
              const q = j.getBucket(i);
              if (!q || q.projection.name !== b.projection.name || !q.groundEffect || (q.groundEffect && !q.groundEffect.hasData())) continue;
              const it = q.groundEffect;
              let st, nt;
              Z === 0 ? ((st = [-lt, 0, 0]), (nt = 1)) : Z === 1 ? ((st = [lt, 0, 0]), (nt = 0)) : Z === 2 ? ((st = [0, -lt, 0]), (nt = 3)) : ((st = [0, lt, 0]), (nt = 2));
              const ut = it.regionSegments[nt];
              if (!ut) continue;
              const ht = new Float32Array(16);
              J.translate(ht, k.projMatrix, st), z(k, it, ut, e.translatePosMatrix(ht, O, i.paint.get('fill-extrusion-translate'), i.paint.get('fill-extrusion-translate-anchor')), G);
            }
        }
      }
      function hz(e, t, i, r, n, o, s) {
        r.centroidVertexArray.length === 0 && r.createCentroidsBuffer();
        const a = o ? o.findDEMTileFor(i) : null;
        if (!((a && a.dem) || s)) return;
        const l = (y) => {
            const v = t.getSource().minzoom,
              w = (b) => {
                const E = t.getTileByID(b);
                if (E && E.hasData()) return E.getBucket(n);
              },
              T = [0, -1, 1];
            for (const b of T) {
              if (y.overscaledZ + b < v) continue;
              const E = w(y.calculateScaledKey(y.overscaledZ + b));
              if (E) return E;
            }
          },
          c = [0, 0, 0],
          u = (y, v) => ((c[0] = Math.min(y.min.y, v.min.y)), (c[1] = Math.max(y.max.y, v.max.y)), (c[2] = lt - v.min.x > y.max.x ? v.min.x - lt : y.max.x), c),
          h = (y, v) => ((c[0] = Math.min(y.min.x, v.min.x)), (c[1] = Math.max(y.max.x, v.max.x)), (c[2] = lt - v.min.y > y.max.y ? v.min.y - lt : y.max.y), c),
          d = [(y, v) => u(y, v), (y, v) => u(v, y), (y, v) => h(y, v), (y, v) => h(v, y)],
          f = (y, v, w, T, b, E, S) => {
            if (!o) return 0;
            const I = [
                [E ? w : y, E ? y : w, 0],
                [E ? w : v, E ? v : w, 0],
              ],
              C = S < 0 ? lt + S : S,
              z = [E ? C : (y + v) / 2, E ? (y + v) / 2 : C, 0];
            return (w === 0 && S < 0) || (w !== 0 && S > 0) ? o.getForTilePoints(b, [z], !0, T) : I.push(z), o.getForTilePoints(i, I, !0, a), Math.max(I[0][2], I[1][2], z[2]) / o.exaggeration();
          };
        for (let y = 0; y < 4; y++) {
          const v = r.borderFeatureIndices[y];
          if (v.length === 0) continue;
          const w = X0[y](i),
            T = l(w);
          if (!(T && T instanceof Xl) || r.borderDoneWithNeighborZ[y] === T.canonical.z) continue;
          T.centroidVertexArray.length === 0 && T.createCentroidsBuffer();
          const b = o ? o.findDEMTileFor(w) : null;
          if (!((b && b.dem) || s)) continue;
          const E = (y < 2 ? 1 : 5) - y,
            S = T.borderDoneWithNeighborZ[E] !== r.canonical.z,
            I = T.borderFeatureIndices[E];
          let C = 0;
          if (r.canonical.z !== T.canonical.z) {
            for (const z of v) r.showCentroid(r.featuresOnBorder[z]);
            if (S) for (const z of I) T.showCentroid(T.featuresOnBorder[z]);
            (r.borderDoneWithNeighborZ[y] = T.canonical.z), (T.borderDoneWithNeighborZ[E] = r.canonical.z);
          }
          for (const z of v) {
            const k = r.featuresOnBorder[z],
              O = r.centroidData[k.centroidDataIndex],
              V = k.borders[y];
            let R;
            for (; C < I.length; ) {
              R = T.featuresOnBorder[I[C]];
              const G = R.borders[E];
              if (G[1] > V[0] + 3 || G[0] > V[0] - 3) break;
              T.showCentroid(R), C++;
            }
            if (R && C < I.length) {
              const G = C;
              let Z = 0;
              for (; !(R.borders[E][0] > V[1] - 3) && (Z++, ++C !== I.length); ) R = T.featuresOnBorder[I[C]];
              if (((R = T.featuresOnBorder[I[G]]), Z > 1)) {
                const q = R.borders[E];
                Math.abs(V[0] - q[0]) < 3 && Math.abs(V[1] - q[1]) < 3 && ((Z = 1), (C = G + 1));
              } else if (Z === 0) {
                r.showCentroid(k);
                continue;
              }
              const X = T.centroidData[R.centroidDataIndex];
              s && Z === 1 && (((_ = O).flags | (g = X).flags) & Un ? ((_.flags |= Un), (g.flags |= Un)) : ((_.flags &= 2147483647), (g.flags &= 2147483647)));
              let j = new H(0, 0);
              if (Z > 1) C = G;
              else if (b && b.dem && !(k.intersectsCount() > 1 || R.intersectsCount() > 1)) {
                const q = d[y](O, X),
                  it = y % 2 ? lt - 1 : 0;
                (p = f(q[0], Math.min(lt - 1, q[1]), it, b, w, y < 2, q[2])), (j = new H(Math.ceil(7 * (p + 450)), 0));
              }
              (O.centroidXY = X.centroidXY = j), r.writeCentroidToBuffer(O), T.writeCentroidToBuffer(X);
            } else r.showCentroid(k);
          }
          (r.borderDoneWithNeighborZ[y] = T.canonical.z), (T.borderDoneWithNeighborZ[E] = r.canonical.z);
        }
        var p, _, g;
        (r.needsCentroidUpdate || (!r.centroidVertexBuffer && r.centroidVertexArray.length !== 0)) && r.uploadCentroid(e);
      }
      const dz = [1, 0, 0],
        fz = [0, 1, 0],
        pz = [0, 0, 1];
      function mz(e, t, i) {
        const r = i.transform,
          n = i.shadowRenderer;
        if (!n) return !0;
        const o = e.toUnwrapped(),
          s = r.tileSize * n._cascades[i.currentShadowCascade].scale;
        let a = t.maxHeight;
        if (r.elevation) {
          const _ = r.elevation.getMinMaxForTile(e);
          _ && (a += _.max);
        }
        const l = [...n.shadowDirection];
        l[2] = -l[2];
        const c = n.computeSimplifiedTileShadowVolume(o, a, s, l);
        if (!c) return !1;
        const u = [dz, fz, pz, l, [l[0], 0, l[2]], [0, l[1], l[2]]],
          h = r.projection.name === 'globe',
          d = r.scaleZoom(s),
          f = uo.fromInvProjectionMatrix(r.invProjMatrix, r.worldSize, d, !h),
          p = n.getCurrentCascadeFrustum();
        return f.intersectsPrecise(c.vertices, c.planes, u) === 0 || p.intersectsPrecise(c.vertices, c.planes, u) === 0;
      }
      function _z(e) {
        const t = e._nearZ,
          i = e.projection.farthestPixelDistance(e),
          r = i - t,
          n = 0.2 * e.height,
          o = t + n;
        return [t, i, (o - n - t) / r, (o - t) / r];
      }
      const gz = new pe(1, 0, 0, 1),
        yz = new pe(0, 1, 0, 1),
        xz = new pe(0, 0, 1, 1),
        vz = new pe(1, 0, 1, 1),
        bz = new pe(0, 1, 1, 1);
      function wz(e, t, i) {
        const r = e.context,
          n = e.transform,
          o = r.gl,
          s = n.projection.name === 'globe',
          a = s ? ['PROJECTION_GLOBE_VIEW'] : [];
        let l = i.projMatrix;
        if (s && Ji(n.zoom) > 0) {
          const z = fp(tx(i.canonical, n));
          (l = J.multiply(new Float32Array(16), n.globeMatrix, z)), J.multiply(l, n.projMatrix, l);
        }
        const c = e.getOrCreateProgram('debug', { defines: a }),
          u = t.getTileByID(i.key);
        e.terrain && e.terrain.setupElevationDraw(u, c);
        const h = Jt.disabled,
          d = me.disabled,
          f = e.colorModeForRenderPass(),
          p = '$debug';
        r.activeTexture.set(o.TEXTURE0), e.emptyTexture.bind(o.LINEAR, o.CLAMP_TO_EDGE), s ? u._makeGlobeTileDebugBuffers(e.context, n) : u._makeDebugTileBoundsBuffers(e.context, n.projection);
        const _ = u._tileDebugBuffer || e.debugBuffer,
          g = u._tileDebugIndexBuffer || e.debugIndexBuffer,
          y = u._tileDebugSegments || e.debugSegments;
        c.draw(e, o.LINE_STRIP, h, d, f, ye.disabled, qb(l, pe.red), p, _, g, y, null, null, null, [u._globeTileDebugBorderBuffer]);
        const v = u.latestRawTileData,
          w = Math.floor(((v && v.byteLength) || 0) / 1024),
          T = t.getTile(i).tileSize,
          b = (512 / Math.min(T, 512)) * (i.overscaledZ / n.zoom) * 0.5;
        let E = i.canonical.toString();
        i.overscaledZ !== i.canonical.z && (E += ` => ${i.overscaledZ}`),
          (E += ` ${w}kb`),
          (function (z, k) {
            z.initDebugOverlayCanvas();
            const O = z.debugOverlayCanvas,
              V = z.context.gl,
              R = z.debugOverlayCanvas.getContext('2d');
            R.clearRect(0, 0, O.width, O.height), (R.shadowColor = 'white'), (R.shadowBlur = 2), (R.lineWidth = 1.5), (R.strokeStyle = 'white'), (R.textBaseline = 'top'), (R.font = 'bold 36px Open Sans, sans-serif'), R.fillText(k, 5, 5), R.strokeText(k, 5, 5), z.debugOverlayTexture.update(O), z.debugOverlayTexture.bind(V.LINEAR, V.CLAMP_TO_EDGE);
          })(e, E);
        const S = u._tileDebugTextBuffer || e.debugBuffer,
          I = u._tileDebugTextIndexBuffer || e.quadTriangleIndexBuffer,
          C = u._tileDebugTextSegments || e.debugSegments;
        c.draw(e, o.TRIANGLES, h, d, De.alphaBlended, ye.disabled, qb(l, pe.transparent, b), p, S, I, C, null, null, null, [u._globeTileDebugTextBuffer]);
      }
      function ew(e, t, i, r) {
        vh(e, 0, t + i / 2, e.transform.width, i, r);
      }
      function iw(e, t, i, r) {
        vh(e, t - i / 2, 0, i, e.transform.height, r);
      }
      function vh(e, t, i, r, n, o) {
        const s = e.context,
          a = s.gl;
        a.enable(a.SCISSOR_TEST), a.scissor(t * oe.devicePixelRatio, i * oe.devicePixelRatio, r * oe.devicePixelRatio, n * oe.devicePixelRatio), s.clear({ color: o }), a.disable(a.SCISSOR_TEST);
      }
      const Tz = Ne([{ name: 'a_pos_3f', components: 3, type: 'Float32' }]),
        { members: Ez } = Tz;
      function Ko(e, t, i, r) {
        e.emplaceBack(t, i, r);
      }
      class rw {
        constructor(t) {
          (this.vertexArray = new xs()), (this.indices = new Fi()), Ko(this.vertexArray, -1, -1, 1), Ko(this.vertexArray, 1, -1, 1), Ko(this.vertexArray, -1, 1, 1), Ko(this.vertexArray, 1, 1, 1), Ko(this.vertexArray, -1, -1, -1), Ko(this.vertexArray, 1, -1, -1), Ko(this.vertexArray, -1, 1, -1), Ko(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), (this.vertexBuffer = t.createVertexBuffer(this.vertexArray, Ez)), (this.indexBuffer = t.createIndexBuffer(this.indices)), (this.segment = He.simpleSegment(0, 0, 36, 12));
        }
      }
      function Na(e, t, i, r, n, o) {
        const s = e.context.gl,
          a = t.paint.get('sky-atmosphere-color'),
          l = t.paint.get('sky-atmosphere-halo-color'),
          c = t.paint.get('sky-atmosphere-sun-intensity'),
          u = ((h, d, f, p, _) => ({ u_matrix_3f: h, u_sun_direction: d, u_sun_intensity: f, u_color_tint_r: [p.r, p.g, p.b, p.a], u_color_tint_m: [_.r, _.g, _.b, _.a], u_luminance: 5e-5 }))(br.fromMat4(br.create(), r), n, c, a, l);
        s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + o, t.skyboxTexture, 0), i.draw(e, s.TRIANGLES, Jt.disabled, me.disabled, De.unblended, ye.frontCW, u, 'skyboxCapture', t.skyboxGeometry.vertexBuffer, t.skyboxGeometry.indexBuffer, t.skyboxGeometry.segment);
      }
      const Mz = Ne([
        { type: 'Float32', name: 'a_pos', components: 3 },
        { type: 'Float32', name: 'a_uv', components: 2 },
      ]);
      class Sz {
        constructor(t) {
          const i = new ys();
          i.emplaceBack(-1, 1, 1, 0, 0), i.emplaceBack(1, 1, 1, 1, 0), i.emplaceBack(1, -1, 1, 1, 1), i.emplaceBack(-1, -1, 1, 0, 1);
          const r = new Fi();
          r.emplaceBack(0, 1, 2), r.emplaceBack(2, 3, 0), (this.vertexBuffer = t.createVertexBuffer(i, Mz.members)), (this.indexBuffer = t.createIndexBuffer(r)), (this.segments = He.simpleSegment(0, 0, 4, 2));
        }
        destroy() {
          this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy();
        }
      }
      const Az = Ne([
        { type: 'Float32', name: 'a_pos_3f', components: 3 },
        { type: 'Float32', name: 'a_uv', components: 2 },
        { type: 'Float32', name: 'a_size_scale', components: 1 },
        { type: 'Float32', name: 'a_fade_opacity', components: 1 },
      ]);
      class Iz {
        constructor() {
          (this.colorModeAlphaBlendedWriteRGB = new De([1, Yu, 1, Yu], pe.transparent, [!0, !0, !0, !1])), (this.colorModeWriteAlpha = new De([1, 0, 1, 0], pe.transparent, [!1, !1, !1, !0]));
        }
        update(t) {
          const i = t.context;
          if (!this.atmosphereBuffer) {
            this.atmosphereBuffer = new Sz(i);
            const r = 100,
              n = 200,
              o = (function (u) {
                const h = of(30),
                  d = [];
                for (let f = 0; f < 16e3; ++f) {
                  const p = 2 * Math.PI * h(),
                    _ = Math.acos(1 - 2 * h()) - 0.5 * Math.PI;
                  d.push(N.fromValues(Math.cos(_) * Math.cos(p), Math.cos(_) * Math.sin(p), Math.sin(_)));
                }
                return d;
              })(),
              s = of(300),
              a = new Of(),
              l = new Fi();
            let c = 0;
            for (let u = 0; u < o.length; ++u) {
              const h = N.scale([], o[u], 200),
                d = Math.max(0, 1 + 0.01 * r * (1 * s() - 0.5)),
                f = Math.max(0, 1 + 0.01 * n * (1 * s() - 0.5));
              a.emplaceBack(h[0], h[1], h[2], -1, -1, d, f), a.emplaceBack(h[0], h[1], h[2], 1, -1, d, f), a.emplaceBack(h[0], h[1], h[2], 1, 1, d, f), a.emplaceBack(h[0], h[1], h[2], -1, 1, d, f), l.emplaceBack(c + 0, c + 1, c + 2), l.emplaceBack(c + 0, c + 2, c + 3), (c += 4);
            }
            (this.starsVx = i.createVertexBuffer(a, Az.members)), (this.starsIdx = i.createIndexBuffer(l)), (this.starsSegments = He.simpleSegment(0, 0, a.length, l.length));
          }
        }
        destroy() {
          this.atmosphereBuffer && this.atmosphereBuffer.destroy(), this.starsVx && this.starsVx.destroy(), this.starsIdx && this.starsIdx.destroy();
        }
        drawAtmosphereGlow(t, i) {
          const r = t.context,
            n = r.gl,
            o = t.transform,
            s = new Jt(n.LEQUAL, Jt.ReadOnly, [0, 1]),
            a = Ji(o.zoom),
            l = i.properties.get('color').toArray01(),
            c = i.properties.get('high-color').toArray01(),
            u = i.properties.get('space-color').toArray01PremultipliedAlpha(),
            h = 5e-4,
            d = Bt(((i.properties.get('horizon-blend') - 0) / 1) * 0.2495 + h, 5e-4, 0.25),
            f = ax(t, r, o) && d === h ? o.worldSize / (2 * Math.PI * 1.025) - 1 : o.globeRadius,
            p = (t.frameCounter / 1e3) % 1,
            _ = N.length(o.globeCenterInViewSpace),
            g = Math.sqrt(Math.pow(_, 2) - Math.pow(f, 2)),
            y = Math.acos(g / _),
            v = (w) => {
              const T = o.projection.name === 'globe' ? ['PROJECTION_GLOBE_VIEW', 'FOG'] : ['FOG'];
              w && T.push('ALPHA_PASS');
              const b = t.getOrCreateProgram('globeAtmosphere', { defines: T }),
                E = ((I, C, z, k, O, V, R, G, Z, X, j, q) => ({ u_frustum_tl: I, u_frustum_tr: C, u_frustum_br: z, u_frustum_bl: k, u_horizon: O, u_transition: V, u_fadeout_range: R, u_color: G, u_high_color: Z, u_space_color: X, u_temporal_offset: j, u_horizon_angle: q }))(o.frustumCorners.TL, o.frustumCorners.TR, o.frustumCorners.BR, o.frustumCorners.BL, o.frustumCorners.horizon, a, d, l, c, u, p, y);
              t.uploadCommonUniforms(r, b);
              const S = this.atmosphereBuffer;
              S && b.draw(t, n.TRIANGLES, s, me.disabled, w ? this.colorModeWriteAlpha : this.colorModeAlphaBlendedWriteRGB, ye.backCW, E, w ? 'atmosphere_glow_alpha' : 'atmosphere_glow', S.vertexBuffer, S.indexBuffer, S.segments);
            };
          v(!1), v(!0);
        }
        drawStars(t, i) {
          const r = Bt(i.properties.get('star-intensity'), 0, 1);
          if (r === 0) return;
          const n = t.context,
            o = n.gl,
            s = t.transform,
            a = t.getOrCreateProgram('stars'),
            l = sr.identity([]);
          sr.rotateX(l, l, -s._pitch), sr.rotateZ(l, l, -s.angle), sr.rotateX(l, l, ne(s._center.lat)), sr.rotateY(l, l, -ne(s._center.lng));
          const c = J.fromQuat(new Float32Array(16), l),
            u = J.multiply([], s.starsProjMatrix, c),
            h = br.fromMat4([], c),
            d = br.invert([], h),
            f = [0, 1, 0];
          N.transformMat3(f, f, d), N.scale(f, f, 0.15);
          const p = [1, 0, 0];
          N.transformMat3(p, p, d), N.scale(p, p, 0.15);
          const _ = ((g, y, v, w) => ({ u_matrix: Float32Array.from(g), u_up: y, u_right: v, u_intensity_multiplier: w }))(u, f, p, r);
          t.uploadCommonUniforms(n, a), this.starsVx && this.starsIdx && a.draw(t, o.TRIANGLES, Jt.disabled, me.disabled, this.colorModeAlphaBlendedWriteRGB, ye.disabled, _, 'atmosphere_stars', this.starsVx, this.starsIdx, this.starsSegments);
        }
      }
      function nw(e, t) {
        const i = [...e],
          r = t.cameraWorldSizeForFog / t.worldSize,
          n = J.identity([]);
        return J.scale(n, n, [r, r, 1]), J.multiply(i, n, i), J.multiply(i, t.worldToFogMatrix, i), i;
      }
      function Dm(e, t, i, r) {
        const n = i.material,
          o = r.context,
          { baseColorTexture: s, metallicRoughnessTexture: a } = n.pbrMetallicRoughness,
          { normalTexture: l, occlusionTexture: c, emissionTexture: u } = n;
        function h(d, f, p) {
          if (d && (e.push(f), o.activeTexture.set(o.gl.TEXTURE0 + p), d.gfxTexture)) {
            const { minFilter: _, magFilter: g, wrapS: y, wrapT: v } = d.sampler;
            d.gfxTexture.bindExtraParam(_, g, y, v);
          }
        }
        h(s, 'HAS_TEXTURE_u_baseColorTexture', Fr.BaseColor), h(a, 'HAS_TEXTURE_u_metallicRoughnessTexture', Fr.MetallicRoughness), h(l, 'HAS_TEXTURE_u_normalTexture', Fr.Normal), h(c, 'HAS_TEXTURE_u_occlusionTexture', Fr.Occlusion), h(u, 'HAS_TEXTURE_u_emissionTexture', Fr.Emission), i.texcoordBuffer && (e.push('HAS_ATTRIBUTE_a_uv_2f'), t.push(i.texcoordBuffer)), i.colorBuffer && (e.push(i.colorBuffer.itemSize === 12 ? 'HAS_ATTRIBUTE_a_color_3f' : 'HAS_ATTRIBUTE_a_color_4f'), t.push(i.colorBuffer)), i.normalBuffer && (e.push('HAS_ATTRIBUTE_a_normal_3f'), t.push(i.normalBuffer)), i.pbrBuffer && (e.push('HAS_ATTRIBUTE_a_pbr'), e.push('HAS_ATTRIBUTE_a_heightBasedEmissiveStrength'), t.push(i.pbrBuffer)), (n.alphaMode !== 'OPAQUE' && n.alphaMode !== 'MASK') || e.push('UNPREMULT_TEXTURE_IN_SHADER'), n.defined || e.push('DIFFUSE_SHADED'), e.push('USE_STANDARD_DERIVATIVES');
      }
      function bh(e, t, i, r, n, o) {
        const s = i.paint.get('model-opacity'),
          a = t.context,
          l = new Jt(t.context.gl.LEQUAL, Jt.ReadWrite, t.depthRangeFor3D),
          c = t.transform,
          u = e.mesh,
          h = u.material,
          d = h.pbrMetallicRoughness,
          f = t.style.fog;
        let p;
        (p = t.transform.projection.zAxisUnit === 'pixels' ? [...e.nodeModelMatrix] : J.multiply([], r.zScaleMatrix, e.nodeModelMatrix)), J.multiply(p, r.negCameraPosMatrix, p);
        const _ = J.invert([], p);
        J.transpose(_, _);
        const g = i.paint.get('model-emissive-strength').constantOr(0),
          y = Pm(new Float32Array(e.worldViewProjection), new Float32Array(p), new Float32Array(_), t, s, d.baseColorFactor, h.emissiveFactor, d.metallicFactor, d.roughnessFactor, h, g, i),
          v = { defines: [] },
          w = [];
        Dm(v.defines, w, u, t);
        const T = t.shadowRenderer;
        T && (T.useNormalOffset = !1);
        let b = null;
        if (f) {
          const I = nw(e.nodeModelMatrix, t.transform);
          if (((b = new Float32Array(I)), c.projection.name !== 'globe')) {
            const C = u.aabb.min,
              z = u.aabb.max,
              [k, O] = f.getOpacityForBounds(I, C[0], C[1], z[0], z[1]);
            v.overrideFog = k >= Is || O >= Is;
          }
        }
        const E = Oa(t, i.paint.get('model-cutoff-fade-range'));
        E.shouldRenderCutoff && v.defines.push('RENDER_CUTOFF');
        const S = t.getOrCreateProgram('model', v);
        t.uploadCommonUniforms(a, S, null, b, E), t.renderPass !== 'shadow' && T && T.setupShadowsFromMatrix(e.nodeModelMatrix, S), S.draw(t, a.gl.TRIANGLES, l, n, o, u.material.doubleSided ? ye.disabled : ye.backCCW, y, i.id, u.vertexBuffer, u.indexBuffer, u.segments, i.paint, t.transform.zoom, void 0, w);
      }
      function ow(e, t, i, r, n, o, s) {
        let a;
        (a = e.projection.name === 'globe' ? Jv(i, e) : [...i]), J.multiply(a, a, t.matrix);
        const l = J.multiply([], r, a);
        if (t.meshes)
          for (const c of t.meshes) {
            if (c.material.alphaMode !== 'BLEND') {
              s.push({ mesh: c, depth: 0, modelIndex: n, worldViewProjection: l, nodeModelMatrix: a });
              continue;
            }
            const u = N.transformMat4([], c.centroid, l);
            u[2] > 0 && o.push({ mesh: c, depth: u[2], modelIndex: n, worldViewProjection: l, nodeModelMatrix: a });
          }
        if (t.children) for (const c of t.children) ow(e, c, i, r, n, o, s);
      }
      function Rm(e, t, i, r) {
        const n = i.shadowRenderer;
        if (!n) return;
        const o = n.getShadowPassDepthMode(),
          s = n.getShadowPassColorMode(),
          a = n.calculateShadowPassMatrixFromMatrix(t),
          l = Yb(a);
        i.getOrCreateProgram('modelDepth', { defines: ['DEPTH_TEXTURE'] }).draw(i, i.context.gl.TRIANGLES, o, me.disabled, s, ye.backCCW, l, r.id, e.vertexBuffer, e.indexBuffer, e.segments, r.paint, i.transform.zoom, void 0, void 0);
      }
      function Cz(e, t, i) {
        const r = t.updateZoomBasedPaintProperties(),
          n = (function (o, s, a) {
            let l,
              c,
              u,
              h = o.terrain ? o.terrain.exaggeration() : 0;
            if (o.terrain && h > 0) {
              const d = o.terrain,
                f = d.findDEMTileFor(a);
              f && f.dem ? (l = Ma.create(d, a, f)) : (h = 0);
            }
            if ((h === 0 && ((s.terrainElevationMin = 0), (s.terrainElevationMax = 0)), h === s.validForExaggeration && (h === 0 || (l && l._demTile && l._demTile.tileID === s.validForDEMTile.id && l._dem._timestamp === s.validForDEMTile.timestamp)))) return !1;
            for (const d in s.instancesPerModel) {
              const f = s.instancesPerModel[d];
              for (let p = 0; p < f.instancedDataArray.length; ++p) {
                const _ = (l ? h * l.getElevationAt(0 | f.instancedDataArray.float32[16 * p], 0 | f.instancedDataArray.float32[16 * p + 1], !0, !0) : 0) + f.instancesEvaluatedElevation[p];
                (f.instancedDataArray.float32[16 * p + 6] = _), (c = c ? Math.min(s.terrainElevationMin, _) : _), (u = u ? Math.max(s.terrainElevationMax, _) : _);
              }
            }
            return (s.terrainElevationMin = c || 0), (s.terrainElevationMax = u || 0), (s.validForExaggeration = h), (s.validForDEMTile = l && l._demTile ? { id: l._demTile.tileID, timestamp: l._dem._timestamp } : { id: void 0, timestamp: 0 }), !0;
          })(e, t, i);
        (r || n) && ((t.uploaded = !1), t.upload(e.context));
      }
      const jn = { shadowUniformsInitialized: !1, useSingleShadowCascade: !1, tileMatrix: new Float64Array(16), shadowTileMatrix: new Float32Array(16), aabb: new ni([0, 0, 0], [lt, lt, 0]) };
      function Pz(e, t) {
        const i = 1 << e.canonical.z,
          r = t.getFreeCameraOptions().position,
          n = t.elevation,
          o = e.canonical.x / i,
          s = (e.canonical.x + 1) / i,
          a = e.canonical.y / i,
          l = (e.canonical.y + 1) / i;
        let c = t._centerAltitude;
        if (n) {
          const f = n.getMinMaxForTile(e);
          f && f.max > c && (c = f.max);
        }
        const u = Bt(r.x, o, s) - r.x,
          h = Bt(r.y, a, l) - r.y,
          d = Je(c, t.center.lat) - r.z;
        return t._zoomFromMercatorZ(Math.sqrt(u * u + h * h + d * d));
      }
      function sw(e, t, i, r, n, o, s) {
        const a = e.context,
          l = e.renderPass === 'shadow',
          c = e.shadowRenderer,
          u = l && c ? c.getShadowPassDepthMode() : new Jt(a.gl.LEQUAL, Jt.ReadWrite, e.depthRangeFor3D),
          h = e.isTileAffectedByFog(o);
        if (i.meshes)
          for (const d of i.meshes) {
            const f = ['MODEL_POSITION_ON_GPU'],
              p = [];
            let _, g, y;
            r.instancedDataArray.length > 20 && f.push('INSTANCED_ARRAYS');
            const v = Oa(e, t.paint.get('model-cutoff-fade-range'));
            if ((v.shouldRenderCutoff && f.push('RENDER_CUTOFF'), l && c)) (_ = e.getOrCreateProgram('modelDepth', { defines: f })), (g = Yb(s.shadowTileMatrix, s.shadowTileMatrix, Float32Array.from(i.matrix))), (y = c.getShadowPassColorMode());
            else {
              Dm(f, p, d, e), (_ = e.getOrCreateProgram('model', { defines: f, overrideFog: h }));
              const T = d.material,
                b = T.pbrMetallicRoughness,
                E = t.paint.get('model-opacity'),
                S = t.paint.get('model-emissive-strength').constantOr(0);
              (g = Pm(o.expandedProjMatrix, Float32Array.from(i.matrix), new Float32Array(16), e, E, b.baseColorFactor, T.emissiveFactor, b.metallicFactor, b.roughnessFactor, T, S, t, n)), c && (s.shadowUniformsInitialized ? _.setShadowUniformValues(a, c.getShadowUniformValues()) : (c.setupShadows(o.toUnwrapped(), _, 'model-tile', o.overscaledZ), (s.shadowUniformsInitialized = !0))), (y = v.shouldRenderCutoff || E < 1 || T.alphaMode !== 'OPAQUE' ? De.alphaBlended : De.unblended);
            }
            e.uploadCommonUniforms(a, _, o.toUnwrapped(), null, v);
            const w = d.material.doubleSided ? ye.disabled : ye.backCCW;
            if (r.instancedDataArray.length > 20) p.push(r.instancedDataBuffer), _.draw(e, a.gl.TRIANGLES, u, me.disabled, y, w, g, t.id, d.vertexBuffer, d.indexBuffer, d.segments, t.paint, e.transform.zoom, void 0, p, r.instancedDataArray.length);
            else {
              const T = l ? 'u_instance' : 'u_normal_matrix';
              for (let b = 0; b < r.instancedDataArray.length; ++b) (g[T] = new Float32Array(r.instancedDataArray.arrayBuffer, 64 * b, 16)), _.draw(e, a.gl.TRIANGLES, u, me.disabled, y, w, g, t.id, d.vertexBuffer, d.indexBuffer, d.segments, t.paint, e.transform.zoom, void 0, p);
            }
          }
        if (i.children) for (const d of i.children) sw(e, t, d, r, n, o, s);
      }
      const zz = [1, -1, 1];
      function Dz(e, t, i, r) {
        if (!i.modelManager) return !0;
        const n = i.modelManager;
        if (!i.shadowRenderer) return !0;
        const o = i.shadowRenderer,
          s = t.aabb;
        let a = !0,
          l = e.maxHeight;
        if (l === 0) {
          let u = 0;
          for (const h in e.instancesPerModel) {
            const d = n.getModel(h, r);
            d ? (u = Math.max(u, Math.max(Math.max(d.aabb.max[0], d.aabb.max[1]), d.aabb.max[2]))) : (a = !1);
          }
          (l = e.maxScale * u * 1.41 + e.maxVerticalOffset), a && (e.maxHeight = l);
        }
        (s.max[2] = l), (s.min[2] += e.terrainElevationMin), (s.max[2] += e.terrainElevationMax), N.transformMat4(s.min, s.min, t.tileMatrix), N.transformMat4(s.max, s.max, t.tileMatrix);
        const c = s.intersects(o.getCurrentCascadeFrustum());
        return i.currentShadowCascade === 0 && (e.isInsideFirstShadowMapFrustum = c === 2), c === 0;
      }
      class Rz {}
      class Lz {
        constructor() {
          this._storage = new Map();
        }
        getLinesFromTrianglesBuffer(t, i, r) {
          {
            const h = this._storage.get(i.id);
            if (h) return (h.lastUsedFrameIdx = t), h.buf;
          }
          const n = r.gl,
            o = n.getBufferParameter(n.ELEMENT_ARRAY_BUFFER, n.BUFFER_SIZE),
            s = new ArrayBuffer(o),
            a = new Int16Array(s);
          n.getBufferSubData(n.ELEMENT_ARRAY_BUFFER, 0, new Int16Array(s));
          const l = new zo();
          for (let h = 0; h < o / 2; h += 3) {
            const d = a[h],
              f = a[h + 1],
              p = a[h + 2];
            l.emplaceBack(d, f), l.emplaceBack(f, p), l.emplaceBack(p, d);
          }
          const c = r.bindVertexArrayOES.current,
            u = new Rz();
          return (u.buf = new Wo(r, l)), (u.lastUsedFrameIdx = t), this._storage.set(i.id, u), r.bindVertexArrayOES.set(c), u.buf;
        }
        update(t) {
          for (const [i, r] of this._storage) t - r.lastUsedFrameIdx > 30 && (r.buf.destroy(), this._storage.delete(i));
        }
        destroy() {
          for (const [t, i] of this._storage) i.buf.destroy(), this._storage.delete(t);
        }
      }
      const aw = {
          symbol: function (e, t, i, r, n) {
            if (e.renderPass !== 'translucent') return;
            const o = me.disabled,
              s = e.colorModeForRenderPass();
            i.layout.get('text-variable-anchor') &&
              (function (a, l, c, u, h, d, f) {
                const p = l.transform,
                  _ = h === 'map',
                  g = d === 'map';
                for (const y of a) {
                  const v = u.getTile(y),
                    w = v.getBucket(c);
                  if (!w || !w.text || !w.text.segments.get().length) continue;
                  const T = Bn(w.textSizeData, p.zoom),
                    b = Tm(y, w.getProjection(), p),
                    E = p.calculatePixelsToTileUnitsMatrix(v),
                    S = Ju(b, v.tileID.canonical, g, _, p, w.getProjection(), E),
                    I = w.hasIconTextFit() && w.hasIconData();
                  if (T) {
                    const C = Math.pow(2, p.zoom - v.tileID.overscaledZ);
                    cz(w, _, g, f, zA, p, S, y, C, T, I);
                  }
                }
              })(r, e, i, t, i.layout.get('text-rotation-alignment'), i.layout.get('text-pitch-alignment'), n),
              i.paint.get('icon-opacity').constantOr(1) !== 0 && Qb(e, t, i, r, !1, i.paint.get('icon-translate'), i.paint.get('icon-translate-anchor'), i.layout.get('icon-rotation-alignment'), i.layout.get('icon-pitch-alignment'), i.layout.get('icon-keep-upright'), i.paint.get('icon-color-saturation'), o, s),
              i.paint.get('text-opacity').constantOr(1) !== 0 && Qb(e, t, i, r, !0, i.paint.get('text-translate'), i.paint.get('text-translate-anchor'), i.layout.get('text-rotation-alignment'), i.layout.get('text-pitch-alignment'), i.layout.get('text-keep-upright'), i.paint.get('icon-color-saturation'), o, s),
              t.map.showCollisionBoxes && (Kb(e, t, i, r, i.paint.get('text-translate'), i.paint.get('text-translate-anchor'), !0), Kb(e, t, i, r, i.paint.get('icon-translate'), i.paint.get('icon-translate-anchor'), !1));
          },
          circle: function (e, t, i, r) {
            if (e.renderPass !== 'translucent') return;
            const n = i.paint.get('circle-opacity'),
              o = i.paint.get('circle-stroke-width'),
              s = i.paint.get('circle-stroke-opacity'),
              a = i.layout.get('circle-sort-key').constantOr(1) !== void 0,
              l = i.paint.get('circle-emissive-strength');
            if (n.constantOr(1) === 0 && (o.constantOr(1) === 0 || s.constantOr(1) === 0)) return;
            const c = e.context,
              u = c.gl,
              h = e.transform,
              d = e.depthModeForSublayer(0, Jt.ReadOnly),
              f = me.disabled,
              p = e.colorModeForDrapableLayerRenderPass(l),
              _ = h.projection.name === 'globe',
              g = [qi(h.center.lng), Hi(h.center.lat)],
              y = [];
            for (let w = 0; w < r.length; w++) {
              const T = r[w],
                b = t.getTile(T),
                E = b.getBucket(i);
              if (!E || E.projection.name !== h.projection.name) continue;
              const S = E.programConfigurations.get(i.id),
                I = Tx(i),
                C = e.isTileAffectedByFog(T);
              _ && I.push('PROJECTION_GLOBE_VIEW');
              const z = e.getOrCreateProgram('circle', { config: S, defines: I, overrideFog: C }),
                k = E.layoutVertexBuffer,
                O = E.globeExtVertexBuffer,
                V = E.indexBuffer,
                R = h.projection.createInversionMatrix(h, T.canonical),
                G = { programConfiguration: S, program: z, layoutVertexBuffer: k, globeExtVertexBuffer: O, indexBuffer: V, uniformValues: MS(e, T, b, R, g, i), tile: b };
              if (a) {
                const Z = E.segments.get();
                for (const X of Z) y.push({ segments: new He([X]), sortKey: X.sortKey, state: G });
              } else y.push({ segments: E.segments, sortKey: 0, state: G });
            }
            a && y.sort((w, T) => w.sortKey - T.sortKey);
            const v = { useDepthForOcclusion: h.depthOcclusionForSymbolsAndCircles };
            for (const w of y) {
              const { programConfiguration: T, program: b, layoutVertexBuffer: E, globeExtVertexBuffer: S, indexBuffer: I, uniformValues: C, tile: z } = w.state,
                k = w.segments;
              e.terrain && e.terrain.setupElevationDraw(z, b, v), e.uploadCommonUniforms(c, b, z.tileID.toUnwrapped()), b.draw(e, u.TRIANGLES, d, f, p, ye.disabled, C, i.id, E, I, k, i.paint, h.zoom, T, [S]);
            }
          },
          heatmap: function (e, t, i, r) {
            if (i.paint.get('heatmap-opacity') !== 0)
              if (e.renderPass === 'offscreen') {
                const n = e.context,
                  o = n.gl,
                  s = me.disabled,
                  a = new De([o.ONE, o.ONE, o.ONE, o.ONE], pe.transparent, [!0, !0, !0, !0]);
                (function (f, p, _, g) {
                  const y = f.gl,
                    v = p.width * g,
                    w = p.height * g;
                  f.activeTexture.set(y.TEXTURE1), f.viewport.set([0, 0, v, w]);
                  let T = _.heatmapFbo;
                  if (!T || (T && (T.width !== v || T.height !== w))) {
                    T && T.destroy();
                    const b = y.createTexture();
                    y.bindTexture(y.TEXTURE_2D, b),
                      y.texParameteri(y.TEXTURE_2D, y.TEXTURE_WRAP_S, y.CLAMP_TO_EDGE),
                      y.texParameteri(y.TEXTURE_2D, y.TEXTURE_WRAP_T, y.CLAMP_TO_EDGE),
                      y.texParameteri(y.TEXTURE_2D, y.TEXTURE_MIN_FILTER, y.LINEAR),
                      y.texParameteri(y.TEXTURE_2D, y.TEXTURE_MAG_FILTER, y.LINEAR),
                      (T = _.heatmapFbo = f.createFramebuffer(v, w, !0, null)),
                      (function (E, S, I, C, z, k) {
                        const O = E.gl;
                        O.texImage2D(O.TEXTURE_2D, 0, E.extRenderToTextureHalfFloat ? O.RGBA16F : O.RGBA, z, k, 0, O.RGBA, E.extRenderToTextureHalfFloat ? O.HALF_FLOAT : O.UNSIGNED_BYTE, null), C.colorAttachment.set(I);
                      })(f, 0, b, T, v, w);
                  } else y.bindTexture(y.TEXTURE_2D, T.colorAttachment.get()), f.bindFramebuffer.set(T.framebuffer);
                })(n, e, i, e.transform.projection.name === 'globe' ? 0.5 : 0.25),
                  n.clear({ color: pe.transparent });
                const l = e.transform,
                  c = l.projection.name === 'globe',
                  u = c ? ['PROJECTION_GLOBE_VIEW'] : [],
                  h = c ? ye.frontCCW : ye.disabled,
                  d = [qi(l.center.lng), Hi(l.center.lat)];
                for (let f = 0; f < r.length; f++) {
                  const p = r[f];
                  if (t.hasRenderableParent(p)) continue;
                  const _ = t.getTile(p),
                    g = _.getBucket(i);
                  if (!g || g.projection.name !== l.projection.name) continue;
                  const y = e.isTileAffectedByFog(p),
                    v = g.programConfigurations.get(i.id),
                    w = e.getOrCreateProgram('heatmap', { config: v, defines: u, overrideFog: y }),
                    { zoom: T } = e.transform;
                  e.terrain && e.terrain.setupElevationDraw(_, w), e.uploadCommonUniforms(n, w, p.toUnwrapped());
                  const b = l.projection.createInversionMatrix(l, p.canonical);
                  w.draw(e, o.TRIANGLES, Jt.disabled, s, a, h, tz(e, p, _, b, d, T, i.paint.get('heatmap-intensity')), i.id, g.layoutVertexBuffer, g.indexBuffer, g.segments, i.paint, e.transform.zoom, v, c ? [g.globeExtVertexBuffer] : null);
                }
                n.viewport.set([0, 0, e.width, e.height]);
              } else
                e.renderPass === 'translucent' &&
                  (e.context.setColorMode(e.colorModeForRenderPass()),
                  (function (n, o) {
                    const s = n.context,
                      a = s.gl,
                      l = o.heatmapFbo;
                    if (!l) return;
                    s.activeTexture.set(a.TEXTURE0), a.bindTexture(a.TEXTURE_2D, l.colorAttachment.get()), s.activeTexture.set(a.TEXTURE1);
                    let c = o.colorRampTexture;
                    c || (c = o.colorRampTexture = new vi(s, o.colorRamp, a.RGBA)), c.bind(a.LINEAR, a.CLAMP_TO_EDGE), n.getOrCreateProgram('heatmapTexture').draw(n, a.TRIANGLES, Jt.disabled, me.disabled, n.colorModeForRenderPass(), ye.disabled, ((u, h, d, f) => ({ u_image: 0, u_color_ramp: 1, u_opacity: h.paint.get('heatmap-opacity') }))(0, o), o.id, n.viewportBuffer, n.quadTriangleIndexBuffer, n.viewportSegments, o.paint, n.transform.zoom);
                  })(e, i));
          },
          line: function (e, t, i, r) {
            if (e.renderPass !== 'translucent') return;
            const n = i.paint.get('line-opacity'),
              o = i.paint.get('line-width');
            if (n.constantOr(1) === 0 || o.constantOr(1) === 0) return;
            const s = i.paint.get('line-emissive-strength'),
              a = e.depthModeForSublayer(0, Jt.ReadOnly),
              l = e.colorModeForDrapableLayerRenderPass(s),
              c = e.terrain && e.terrain.renderingToTexture ? 1 : oe.devicePixelRatio,
              u = i.paint.get('line-dasharray'),
              h = u.constantOr(1),
              d = i.layout.get('line-cap'),
              f = i.paint.get('line-pattern'),
              p = f.constantOr(1),
              _ = i.paint.get('line-pattern').constantOr(1),
              g = i.paint.get('line-opacity').constantOr(1) !== 1;
            let y = !_ && g;
            const v = i.paint.get('line-gradient'),
              w = p ? 'linePattern' : 'line',
              T = e.context,
              b = T.gl,
              E = P1(i);
            e.terrain && e.terrain.clipOrMaskOverlapStencilType() && (y = !1);
            for (const S of r) {
              const I = t.getTile(S);
              if (p && !I.patternsLoaded()) continue;
              const C = I.getBucket(i);
              if (!C) continue;
              e.prepareDrawTile();
              const z = C.programConfigurations.get(i.id),
                k = e.isTileAffectedByFog(S),
                O = e.getOrCreateProgram(w, { config: z, defines: E, overrideFog: k }),
                V = f.constantOr(null);
              if (V && I.imageAtlas) {
                const st = I.imageAtlas.patternPositions[V.toString()];
                st && z.setConstantPatternPositions(st);
              }
              const R = u.constantOr(null),
                G = d.constantOr(null);
              if (!p && R && G && I.lineAtlas) {
                const st = I.lineAtlas.getDash(R, G);
                st && z.setConstantPatternPositions(st);
              }
              let [Z, X] = i.paint.get('line-trim-offset');
              (G === 'round' || G === 'square') && Z !== X && (Z === 0 && (Z -= 1), X === 1 && (X += 1));
              const j = e.terrain ? S.projMatrix : null,
                q = p ? PC(e, I, i, j, c) : CC(e, I, i, j, C.lineClipsArray.length, c, [Z, X]);
              if (v) {
                const st = C.gradients[i.id];
                let nt = st.texture;
                if (i.gradientVersion !== st.version) {
                  let ut = 256;
                  if (i.stepInterpolant) {
                    const ht = t.getSource().maxzoom,
                      pt = S.canonical.z === ht ? Math.ceil(1 << (e.transform.maxZoom - S.canonical.z)) : 1;
                    ut = Bt(wo((C.maxLineLength / lt) * 1024 * pt), 256, T.maxTextureSize);
                  }
                  (st.gradient = yu({ expression: i.gradientExpression(), evaluationKey: 'lineProgress', resolution: ut, image: st.gradient || void 0, clips: C.lineClipsArray })), st.texture ? st.texture.update(st.gradient) : (st.texture = new vi(T, st.gradient, b.RGBA)), (st.version = i.gradientVersion), (nt = st.texture);
                }
                T.activeTexture.set(b.TEXTURE1), nt.bind(i.stepInterpolant ? b.NEAREST : b.LINEAR, b.CLAMP_TO_EDGE);
              }
              h && (T.activeTexture.set(b.TEXTURE0), I.lineAtlasTexture && I.lineAtlasTexture.bind(b.LINEAR, b.REPEAT), z.updatePaintBuffers()), p && (T.activeTexture.set(b.TEXTURE0), I.imageAtlasTexture && I.imageAtlasTexture.bind(b.LINEAR, b.CLAMP_TO_EDGE), z.updatePaintBuffers()), e.uploadCommonUniforms(T, O, S.toUnwrapped());
              const it = (st) => {
                O.draw(e, b.TRIANGLES, a, st, l, ye.disabled, q, i.id, C.layoutVertexBuffer, C.indexBuffer, C.segments, i.paint, e.transform.zoom, z, [C.layoutVertexBuffer2]);
              };
              if (y) {
                const st = e.stencilModeForClipping(S).ref;
                st === 0 && e.terrain && T.clear({ stencil: 0 });
                const nt = { func: b.EQUAL, mask: 255 };
                (q.u_alpha_discard_threshold = 0.8), it(new me(nt, st, 255, b.KEEP, b.KEEP, b.INVERT)), (q.u_alpha_discard_threshold = 0), it(new me(nt, st, 255, b.KEEP, b.KEEP, b.KEEP));
              } else it(e.stencilModeForClipping(S));
            }
            y && (e.resetStencilClippingMasks(), e.terrain && T.clear({ stencil: 0 }));
          },
          fill: function (e, t, i, r) {
            const n = i.paint.get('fill-color'),
              o = i.paint.get('fill-opacity');
            if (o.constantOr(1) === 0) return;
            const s = i.paint.get('fill-emissive-strength'),
              a = e.colorModeForDrapableLayerRenderPass(s),
              l = i.paint.get('fill-pattern'),
              c = e.opaquePassEnabledForLayer() && !l.constantOr(1) && n.constantOr(pe.transparent).a === 1 && o.constantOr(0) === 1 ? 'opaque' : 'translucent';
            if (e.renderPass === c) {
              const u = e.depthModeForSublayer(1, e.renderPass === 'opaque' ? Jt.ReadWrite : Jt.ReadOnly);
              tw(e, t, i, r, u, a, !1);
            }
            if (e.renderPass === 'translucent' && i.paint.get('fill-antialias')) {
              const u = e.depthModeForSublayer(i.getPaintProperty('fill-outline-color') ? 2 : 0, Jt.ReadOnly);
              tw(e, t, i, r, u, a, !0);
            }
          },
          'fill-extrusion': function (e, t, i, r) {
            const n = i.paint.get('fill-extrusion-opacity'),
              o = e.context,
              s = o.gl,
              a = e.terrain,
              l = a && a.renderingToTexture,
              c = i.paint.get('fill-extrusion-cutoff-fade-range');
            if (n === 0) return;
            const u = e.conflationActive && e.layerUsedInConflation(i, t.getSource());
            if (
              (u &&
                (function (h, d, f, p) {
                  for (const _ of p) {
                    const g = d.getTile(_).getBucket(f);
                    g && (g.updateReplacement(_, h.replacementSource), g.uploadCentroid(h.context));
                  }
                })(e, t, i, r),
              a || u)
            )
              for (const h of r) {
                const d = t.getTile(h).getBucket(i);
                d && hz(e.context, t, h, d, i, a, u);
              }
            if (e.renderPass === 'shadow' && e.shadowRenderer) {
              const h = e.shadowRenderer;
              if (a && n < 0.65 && i._transitionablePaint._values['fill-extrusion-opacity'].value.expression instanceof Ao) return;
              const d = h.getShadowPassDepthMode(),
                f = h.getShadowPassColorMode();
              xh(e, t, i, r, d, me.disabled, f, u);
            } else if (e.renderPass === 'translucent') {
              const h = !i.paint.get('fill-extrusion-pattern').constantOr(1);
              if (!l) {
                const d = new Jt(e.context.gl.LEQUAL, Jt.ReadWrite, e.depthRangeFor3D);
                c === 0 && n === 1 && h ? xh(e, t, i, r, d, me.disabled, De.unblended, u) : (xh(e, t, i, r, d, me.disabled, De.disabled, u), xh(e, t, i, r, d, e.stencilModeFor3D(), e.colorModeForRenderPass(), u), e.resetStencilClippingMasks());
              }
              if (e.style.enable3dLights() && h && ((!a && e.transform.projection.name !== 'globe') || l)) {
                const d = i.paint.get('fill-extrusion-opacity'),
                  f = i.paint.get('fill-extrusion-ambient-occlusion-intensity'),
                  p = i.paint.get('fill-extrusion-ambient-occlusion-ground-radius'),
                  _ = i.paint.get('fill-extrusion-flood-light-intensity'),
                  g = i.paint.get('fill-extrusion-flood-light-color').toArray01().slice(0, 3),
                  y = f > 0 && p > 0,
                  v = _ > 0,
                  w = (b, E, S) => (1 - S) * b + S * E,
                  T = (b) => {
                    const E = e.depthModeForSublayer(1, Jt.ReadOnly, s.LEQUAL, !0),
                      S = i.paint.get(b ? 'fill-extrusion-ambient-occlusion-ground-attenuation' : 'fill-extrusion-flood-light-ground-attenuation'),
                      I = w(0.1, 3, S),
                      C = e._showOverdrawInspector;
                    if (!C) {
                      const z = new me({ func: s.ALWAYS, mask: 255 }, 255, 255, s.KEEP, s.KEEP, s.REPLACE),
                        k = new De([s.ONE, s.ONE, s.ONE, s.ONE], pe.transparent, [!1, !1, !1, !0], s.MIN);
                      Fa(e, t, i, r, E, z, k, ye.disabled, b, 'sdf', d, f, p, _, g, I, u, !1);
                    }
                    {
                      const z = C ? me.disabled : new me({ func: s.EQUAL, mask: 255 }, 255, 255, s.KEEP, s.DECR, s.DECR),
                        k = C ? e.colorModeForRenderPass() : new De([s.ONE_MINUS_DST_ALPHA, s.DST_ALPHA, s.ONE, s.ONE], pe.transparent, [!0, !0, !0, !0]);
                      Fa(e, t, i, r, E, z, k, ye.disabled, b, 'color', d, f, p, _, g, I, u, !1);
                    }
                  };
                if (l) {
                  const b = (E, S, I) => {
                    const C = e.depthModeForSublayer(1, Jt.ReadOnly, s.LEQUAL, !1),
                      z = i.paint.get(E ? 'fill-extrusion-ambient-occlusion-ground-attenuation' : 'fill-extrusion-flood-light-ground-attenuation'),
                      k = w(0.1, 3, z);
                    {
                      const O = new De([s.ONE, s.ONE, s.ONE, s.ONE], pe.transparent, [!1, !1, !1, !0]);
                      Fa(e, t, i, r, C, me.disabled, O, ye.disabled, E, 'clear', d, f, p, _, g, k, u, S);
                    }
                    {
                      const O = new me({ func: s.ALWAYS, mask: 255 }, 255, 255, s.KEEP, s.KEEP, s.REPLACE),
                        V = new De([s.ONE, s.ONE, s.ONE, s.ONE], pe.transparent, [!1, !1, !1, !0], s.MIN);
                      Fa(e, t, i, r, C, O, V, ye.disabled, E, 'sdf', d, f, p, _, g, k, u, S);
                    }
                    {
                      const O = E ? s.ZERO : s.ONE_MINUS_DST_ALPHA,
                        V = new me({ func: s.EQUAL, mask: 255 }, 255, 255, s.KEEP, s.DECR, s.DECR),
                        R = new De([O, s.DST_ALPHA, s.ONE_MINUS_DST_ALPHA, s.ZERO], pe.transparent, [!0, !0, !0, !0]);
                      Fa(e, t, i, r, C, V, R, ye.disabled, E, 'color', d, f, p, _, g, k, u, S);
                    }
                    {
                      const O = new De([s.ONE, s.ONE, s.ONE, E ? s.ZERO : s.ONE], pe.transparent, [!1, !1, !1, !0], E ? s.FUNC_ADD : s.MAX);
                      Fa(e, t, i, r, C, me.disabled, O, ye.disabled, E, 'clear', d, f, p, _, g, k, u, S, I);
                    }
                  };
                  if (y || v) {
                    let E;
                    if ((e.prepareDrawTile(), a)) {
                      const S = a.drapeBufferSize[0],
                        I = a.drapeBufferSize[1];
                      (E = a.framebufferCopyTexture), (E && (!E || (E.size[0] === S && E.size[1] === I))) || (E && E.destroy(), (E = a.framebufferCopyTexture = new vi(o, new Li({ width: S, height: I }), s.RGBA))), E.bind(s.LINEAR, s.CLAMP_TO_EDGE), s.copyTexImage2D(s.TEXTURE_2D, 0, s.RGBA, 0, 0, S, I, 0);
                    }
                    y && b(!0, !1, E), v && b(!1, !0, E);
                  }
                } else y && T(!0), v && T(!1);
              }
            }
          },
          hillshade: function (e, t, i, r) {
            if ((e.renderPass !== 'offscreen' && e.renderPass !== 'translucent') || e.style.disableElevatedTerrain) return;
            const n = e.context,
              o = e.terrain && e.terrain.renderingToTexture,
              [s, a] = e.renderPass !== 'translucent' || o ? [{}, r] : e.stencilConfigForOverlap(r);
            for (const l of a) {
              const c = t.getTile(l);
              if (c.needsHillshadePrepare && e.renderPass === 'offscreen') NP(e, c, i);
              else if (e.renderPass === 'translucent') {
                const u = e.depthModeForSublayer(0, Jt.ReadOnly),
                  h = i.paint.get('hillshade-emissive-strength'),
                  d = e.colorModeForDrapableLayerRenderPass(h),
                  f = o && e.terrain ? e.terrain.stencilModeForRTTOverlap(l) : s[l.overscaledZ];
                FP(e, l, c, i, u, f, d);
              }
            }
            n.viewport.set([0, 0, e.width, e.height]), e.resetStencilClippingMasks();
          },
          raster: function (e, t, i, r, n, o) {
            if (e.renderPass !== 'translucent' || i.paint.get('raster-opacity') === 0) return;
            const s = e.context,
              a = s.gl,
              l = t.getSource(),
              c = (function (S, I, C) {
                const z = S.paint.get('raster-color'),
                  k = [],
                  O = S.paint.get('raster-resampling'),
                  V = S.paint.get('raster-color-mix'),
                  R = S.paint.get('raster-color-range'),
                  G = [V[0], V[1], V[2], 0],
                  Z = V[3],
                  X = O === 'nearest' ? C.NEAREST : C.LINEAR;
                if ((z && k.push('RASTER_COLOR'), z)) {
                  I.activeTexture.set(C.TEXTURE2);
                  let j = S.colorRampTexture;
                  j || (j = S.colorRampTexture = new vi(I, S.colorRamp, C.RGBA)), j.bind(C.LINEAR, C.CLAMP_TO_EDGE);
                }
                return { mix: G, range: R, offset: Z, defines: k, resampling: X };
              })(i, s, a),
              u = c.defines,
              h = e.transform.projection.name === 'globe';
            let d = !1;
            if (l instanceof fn && !r.length) {
              if (!h) return;
              if (l.onNorthPole) (d = !0), u.push('GLOBE_POLES');
              else {
                if (!l.onSouthPole) return;
                (d = !0), u.push('GLOBE_POLES');
              }
            }
            const f = i.paint.get('raster-emissive-strength'),
              p = e.colorModeForDrapableLayerRenderPass(f),
              _ = e.terrain && e.terrain.renderingToTexture,
              g = l instanceof fn && i.paint.get('raster-elevation') !== 0,
              y = !e.options.moving,
              v = i.paint.get('raster-resampling') === 'nearest' ? a.NEAREST : a.LINEAR;
            if (d) {
              const S = t.getSource();
              if (!(S instanceof fn)) return;
              const I = S.texture;
              if (!I) return;
              const C = e.globeSharedBuffers;
              if (!C) return;
              const z = new Jt(a.LEQUAL, Jt.ReadWrite, e.depthRangeFor3D),
                k = Float32Array.from(e.transform.expandedFarZProjMatrix);
              let O = sx(0, 0, e.transform);
              const V = Float32Array.from(Bo(Yr(new cn(0, 0, 0)))),
                R = { opacity: 1, mix: 0 };
              e.terrain && e.terrain.prepareDrawTile(), s.activeTexture.set(a.TEXTURE0), I.bind(v, a.CLAMP_TO_EDGE), s.activeTexture.set(a.TEXTURE1), I.bind(v, a.CLAMP_TO_EDGE), I.useMipmap && s.extTextureFilterAnisotropic && e.transform.pitch > 20 && a.texParameterf(a.TEXTURE_2D, s.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, s.extTextureFilterAnisotropicMax);
              const [G, Z, X, j] = C.getPoleBuffers(0, !0);
              let q;
              S.onNorthPole ? ((q = G), (e.renderDefaultNorthPole = !1)) : ((O = J.scale(J.create(), O, [1, -1, 1])), (q = Z), (e.renderDefaultSouthPole = !1));
              const it = ((nt, ut, ht, pt, at, _t, Ct, Pt, Ot, Ut, Qt, Ht) => Zb(nt, ut, ht, new Float32Array(16), new Float32Array(9), [0, 0], [0, 0, 0, 0], 0, [0, 0], [0, 0, 0, 0], 1, pt, at, _t || [0, 0], Ct, 2, Ot, Ut, Qt, 1, 0, Ht))(k, V, O, R, i, S.perspectiveTransform || [0, 0], i.paint.get('raster-elevation'), 0, c.mix, c.offset, c.range, f),
                st = e.getOrCreateProgram('raster', { defines: c.defines });
              return e.uploadCommonUniforms(s, st, null), void st.draw(e, a.TRIANGLES, z, me.disabled, p, ye.disabled, it, i.id, q, X, j);
            }
            if (!r.length) return;
            const [w, T] = l instanceof fn || _ ? [{}, r] : e.stencilConfigForOverlap(r),
              b = T[T.length - 1].overscaledZ,
              E = g && h;
            E && c.defines.push('PROJECTION_GLOBE_VIEW'), g && c.defines.push('RENDER_CUTOFF');
            for (const S of T) {
              const I = S.toUnwrapped(),
                C = t.getTile(S);
              if ((_ && (!C || !C.hasData())) || !C.texture) continue;
              let z, k;
              _ ? ((z = Jt.disabled), (k = S.projMatrix)) : g ? ((z = new Jt(a.LEQUAL, Jt.ReadWrite, e.depthRangeFor3D)), (k = h ? Float32Array.from(e.transform.expandedFarZProjMatrix) : e.transform.calculateProjMatrix(I, y))) : ((z = e.depthModeForSublayer(S.overscaledZ - b, i.paint.get('raster-opacity') === 1 ? Jt.ReadWrite : Jt.ReadOnly, a.LESS)), (k = e.transform.calculateProjMatrix(I, y)));
              const O = e.terrain && _ ? e.terrain.stencilModeForRTTOverlap(S) : w[S.overscaledZ],
                V = o ? 0 : i.paint.get('raster-fade-duration');
              C.registerFadeDuration(V);
              const R = t.findLoadedParent(S, 0),
                G = Bb(C, R, t, e.transform, V);
              let Z, X;
              e.terrain && e.terrain.prepareDrawTile(), s.activeTexture.set(a.TEXTURE0), C.texture && C.texture.bind(v, a.CLAMP_TO_EDGE), s.activeTexture.set(a.TEXTURE1), R ? (R.texture && R.texture.bind(v, a.CLAMP_TO_EDGE), (Z = Math.pow(2, R.tileID.overscaledZ - C.tileID.overscaledZ)), (X = [(C.tileID.canonical.x * Z) % 1, (C.tileID.canonical.y * Z) % 1])) : C.texture && C.texture.bind(v, a.CLAMP_TO_EDGE), C.texture && C.texture.useMipmap && s.extTextureFilterAnisotropic && e.transform.pitch > 20 && a.texParameterf(a.TEXTURE_2D, s.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, s.extTextureFilterAnisotropicMax);
              const j = e.transform,
                q = l instanceof fn ? l.perspectiveTransform : [0, 0],
                it = g ? _z(j) : [0, 0, 0, 0];
              let st, nt, ut, ht, pt, at;
              if (E && l instanceof fn && l.coordinates.length > 3) {
                (st = Float32Array.from(Bo(Yr(new cn(0, 0, 0))))), (nt = Float32Array.from(j.globeMatrix)), (ut = Float32Array.from(ox(j))), (ht = [qi(j.center.lng), Hi(j.center.lat)]), (at = [qi(l.coordinates[1][0]), Hi(l.coordinates[1][1]), qi(l.coordinates[3][0]), Hi(l.coordinates[3][1])]);
                const Ot = new kr(l.coordinates[1], l.coordinates[3]);
                pt = Float32Array.from(lx(new cn(0, 0, 0), Ot, 0, j.worldSize / e.transform._pixelsPerMercatorPixel));
              } else (st = new Float32Array(16)), (nt = new Float32Array(9)), (ut = new Float32Array(16)), (ht = [0, 0]), (pt = new Float32Array(16)), (at = [0, 0, 0, 0]);
              const _t = Zb(k, st, nt, ut, pt, X || [0, 0], at, Ji(e.transform.zoom), ht, it, Z || 1, G, i, q, g ? i.paint.get('raster-elevation') : 0, 2, c.mix, c.offset, c.range, 1, 0, f),
                Ct = e.isTileAffectedByFog(S),
                Pt = e.getOrCreateProgram('raster', { defines: c.defines, overrideFog: Ct });
              if ((e.uploadCommonUniforms(s, Pt, I), l instanceof fn)) {
                if (_ || !h) l.boundsBuffer && l.boundsSegments && Pt.draw(e, a.TRIANGLES, z, me.disabled, p, ye.disabled, _t, i.id, l.boundsBuffer, e.quadTriangleIndexBuffer, l.boundsSegments);
                else if (e.globeSharedBuffers) {
                  const [Ot, Ut, Qt] = e.globeSharedBuffers.getGridBuffers(0, !1);
                  Pt.draw(e, a.TRIANGLES, z, me.disabled, p, ye.frontCCW, _t, i.id, Ot, Ut, Qt), Pt.draw(e, a.TRIANGLES, z, me.disabled, p, ye.backCCW, _t, i.id, Ot, Ut, Qt);
                }
              } else {
                const { tileBoundsBuffer: Ot, tileBoundsIndexBuffer: Ut, tileBoundsSegments: Qt } = e.getTileBoundsBuffers(C);
                Pt.draw(e, a.TRIANGLES, z, O, p, ye.disabled, _t, i.id, Ot, Ut, Qt);
              }
            }
            e.resetStencilClippingMasks();
          },
          background: function (e, t, i, r) {
            const n = i.paint.get('background-color'),
              o = i.paint.get('background-opacity'),
              s = i.paint.get('background-emissive-strength');
            if (o === 0) return;
            const a = e.context,
              l = a.gl,
              c = e.transform,
              u = c.tileSize,
              h = i.paint.get('background-pattern');
            if (e.isPatternMissing(h, i.scope)) return;
            const d = !h && n.a === 1 && o === 1 && e.opaquePassEnabledForLayer() ? 'opaque' : 'translucent';
            if (e.renderPass !== d) return;
            const f = me.disabled,
              p = e.depthModeForSublayer(0, d === 'opaque' ? Jt.ReadWrite : Jt.ReadOnly),
              _ = e.colorModeForDrapableLayerRenderPass(s),
              g = h ? 'backgroundPattern' : 'background';
            let y,
              v = r;
            v || ((y = e.getBackgroundTiles()), (v = Object.values(y).map((w) => w.tileID))), h && (a.activeTexture.set(l.TEXTURE0), e.imageManager.bind(e.context, i.scope));
            for (const w of v) {
              const T = e.isTileAffectedByFog(w),
                b = e.getOrCreateProgram(g, { overrideFog: T }),
                E = w.toUnwrapped(),
                S = r ? w.projMatrix : e.transform.calculateProjMatrix(E);
              e.prepareDrawTile();
              const I = t ? t.getTile(w) : y ? y[w.key] : new jl(w, u, c.zoom, e),
                C = h ? sz(S, s, o, e, h, i.scope, { tileID: w, tileSize: u }) : oz(S, s, o, n);
              e.uploadCommonUniforms(a, b, E);
              const { tileBoundsBuffer: z, tileBoundsIndexBuffer: k, tileBoundsSegments: O } = e.getTileBoundsBuffers(I);
              b.draw(e, l.TRIANGLES, p, f, _, ye.disabled, C, i.id, z, k, O);
            }
          },
          sky: function (e, t, i) {
            const r = e._atmosphere ? Ji(e.transform.zoom) : 1,
              n = i.paint.get('sky-opacity') * r;
            if (n === 0) return;
            const o = e.context,
              s = i.paint.get('sky-type'),
              a = new Jt(o.gl.LEQUAL, Jt.ReadOnly, [0, 1]),
              l = (e.frameCounter / 1e3) % 1;
            s === 'atmosphere'
              ? e.renderPass === 'offscreen'
                ? i.needsSkyboxCapture(e) &&
                  ((function (c, u, h, d) {
                    const f = c.context,
                      p = f.gl;
                    let _ = u.skyboxFbo;
                    if (!_) {
                      (_ = u.skyboxFbo = f.createFramebuffer(32, 32, !0, null)), (u.skyboxGeometry = new rw(f)), (u.skyboxTexture = f.gl.createTexture()), p.bindTexture(p.TEXTURE_CUBE_MAP, u.skyboxTexture), p.texParameteri(p.TEXTURE_CUBE_MAP, p.TEXTURE_WRAP_S, p.CLAMP_TO_EDGE), p.texParameteri(p.TEXTURE_CUBE_MAP, p.TEXTURE_WRAP_T, p.CLAMP_TO_EDGE), p.texParameteri(p.TEXTURE_CUBE_MAP, p.TEXTURE_MIN_FILTER, p.LINEAR), p.texParameteri(p.TEXTURE_CUBE_MAP, p.TEXTURE_MAG_FILTER, p.LINEAR);
                      for (let w = 0; w < 6; ++w) p.texImage2D(p.TEXTURE_CUBE_MAP_POSITIVE_X + w, 0, p.RGBA, 32, 32, 0, p.RGBA, p.UNSIGNED_BYTE, null);
                    }
                    f.bindFramebuffer.set(_.framebuffer), f.viewport.set([0, 0, 32, 32]);
                    const g = u.getCenter(c, !0),
                      y = c.getOrCreateProgram('skyboxCapture'),
                      v = new Float64Array(16);
                    J.identity(v), J.rotateY(v, v, 0.5 * -Math.PI), Na(c, u, y, v, g, 0), J.identity(v), J.rotateY(v, v, 0.5 * Math.PI), Na(c, u, y, v, g, 1), J.identity(v), J.rotateX(v, v, 0.5 * -Math.PI), Na(c, u, y, v, g, 2), J.identity(v), J.rotateX(v, v, 0.5 * Math.PI), Na(c, u, y, v, g, 3), J.identity(v), Na(c, u, y, v, g, 4), J.identity(v), J.rotateY(v, v, Math.PI), Na(c, u, y, v, g, 5), f.viewport.set([0, 0, c.width, c.height]);
                  })(e, i),
                  i.markSkyboxValid(e))
                : e.renderPass === 'sky' &&
                  (function (c, u, h, d, f) {
                    const p = c.context,
                      _ = p.gl,
                      g = c.transform,
                      y = c.getOrCreateProgram('skybox');
                    p.activeTexture.set(_.TEXTURE0), _.bindTexture(_.TEXTURE_CUBE_MAP, u.skyboxTexture);
                    const v = ((w, T, b, E, S) => ({ u_matrix: w, u_sun_direction: T, u_cubemap: 0, u_opacity: E, u_temporal_offset: S }))(g.skyboxMatrix, u.getCenter(c, !1), 0, d, f);
                    c.uploadCommonUniforms(p, y), y.draw(c, _.TRIANGLES, h, me.disabled, c.colorModeForRenderPass(), ye.backCW, v, 'skybox', u.skyboxGeometry.vertexBuffer, u.skyboxGeometry.indexBuffer, u.skyboxGeometry.segment);
                  })(e, i, a, n, l)
              : s === 'gradient' &&
                e.renderPass === 'sky' &&
                (function (c, u, h, d, f) {
                  const p = c.context,
                    _ = p.gl,
                    g = c.transform,
                    y = c.getOrCreateProgram('skyboxGradient');
                  u.skyboxGeometry || (u.skyboxGeometry = new rw(p)), p.activeTexture.set(_.TEXTURE0);
                  let v = u.colorRampTexture;
                  v || (v = u.colorRampTexture = new vi(p, u.colorRamp, _.RGBA)), v.bind(_.LINEAR, _.CLAMP_TO_EDGE);
                  const w = ((T, b, E, S, I) => ({ u_matrix: T, u_color_ramp: 0, u_center_direction: b, u_radius: ne(E), u_opacity: S, u_temporal_offset: I }))(g.skyboxMatrix, u.getCenter(c, !1), u.paint.get('sky-gradient-radius'), d, f);
                  c.uploadCommonUniforms(p, y), y.draw(c, _.TRIANGLES, h, me.disabled, c.colorModeForRenderPass(), ye.backCW, w, 'skyboxGradient', u.skyboxGeometry.vertexBuffer, u.skyboxGeometry.indexBuffer, u.skyboxGeometry.segment);
                })(e, i, a, n, l);
          },
          debug: function (e, t, i) {
            for (let r = 0; r < i.length; r++) wz(e, t, i[r]);
          },
          custom: function (e, t, i, r) {
            const n = e.context,
              o = i.implementation;
            if (!e.transform.projection.unsupportedLayers || !e.transform.projection.unsupportedLayers.includes('custom') || (e.terrain && (e.terrain.renderingToTexture || e.renderPass === 'offscreen') && i.isLayerDraped(t))) {
              if (e.renderPass === 'offscreen') {
                const s = o.prerender;
                if (s) {
                  if ((e.setCustomLayerDefaults(), n.setColorMode(e.colorModeForRenderPass()), e.transform.projection.name === 'globe')) {
                    const a = e.transform.pointMerc;
                    s.call(o, n.gl, e.transform.customLayerMatrix(), e.transform.getProjection(), e.transform.globeToMercatorMatrix(), Ji(e.transform.zoom), [a.x, a.y], e.transform.pixelsPerMeterRatio);
                  } else s.call(o, n.gl, e.transform.customLayerMatrix());
                  n.setDirty(), e.setBaseState();
                }
              } else if (e.renderPass === 'translucent') {
                if (e.terrain && e.terrain.renderingToTexture) {
                  const a = o.renderToTile;
                  if (a) {
                    const l = r[0].canonical,
                      c = new Me(l.x + r[0].wrap * (1 << l.z), l.y, l.z);
                    n.setDepthMode(Jt.disabled), n.setStencilMode(me.disabled), n.setColorMode(e.colorModeForRenderPass()), e.setCustomLayerDefaults(), a.call(o, n.gl, c), n.setDirty(), e.setBaseState();
                  }
                  return;
                }
                e.setCustomLayerDefaults(), n.setColorMode(e.colorModeForRenderPass()), n.setStencilMode(me.disabled);
                const s = o.renderingMode === '3d' ? new Jt(e.context.gl.LEQUAL, Jt.ReadWrite, e.depthRangeFor3D) : e.depthModeForSublayer(0, Jt.ReadOnly);
                if ((n.setDepthMode(s), e.transform.projection.name === 'globe')) {
                  const a = e.transform.pointMerc;
                  o.render(n.gl, e.transform.customLayerMatrix(), e.transform.getProjection(), e.transform.globeToMercatorMatrix(), Ji(e.transform.zoom), [a.x, a.y], e.transform.pixelsPerMeterRatio);
                } else o.render(n.gl, e.transform.customLayerMatrix());
                n.setDirty(), e.setBaseState(), n.bindFramebuffer.set(null);
              }
            } else B('Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers.');
          },
          model: function (e, t, i, r) {
            if (e.renderPass === 'opaque') return;
            const n = i.paint.get('model-opacity');
            if (n === 0) return;
            const o = i.paint.get('model-cast-shadows');
            if (e.renderPass === 'shadow' && (!o || (e.terrain && n < 0.65 && i._transitionablePaint._values['model-opacity'].value.expression instanceof Ao))) return;
            const s = e.shadowRenderer,
              a = i.paint.get('model-receive-shadows');
            s && ((s.useNormalOffset = !0), a || (s.enabled = !1));
            const l = () => {
                s && ((s.useNormalOffset = !0), a || (s.enabled = !0));
              },
              c = t.getSource();
            if (e.renderPass === 'light-beam' && c.type !== 'batched-model') return;
            if (c.type === 'vector' || c.type === 'geojson')
              return (
                (function (y, v, w, T) {
                  const b = y.transform;
                  if (b.projection.name !== 'mercator') return void B(`Drawing 3D models for ${b.projection.name} projection is not yet implemented`);
                  const E = b.getFreeCameraOptions().position;
                  if (!y.modelManager) return;
                  const S = y.modelManager,
                    I = y.shadowRenderer;
                  if (!w._unevaluatedLayout._values.hasOwnProperty('model-id')) return;
                  const C = w._unevaluatedLayout._values['model-id'],
                    z = { ...w.layout.get('model-id').parameters };
                  for (const k of T) {
                    const O = v.getTile(k).getBucket(w);
                    if (!O || O.projection.name !== b.projection.name) continue;
                    const V = Pz(k, b);
                    z.zoom = V;
                    const R = C.possiblyEvaluate(z);
                    if ((Cz(y, O, k), (jn.shadowUniformsInitialized = !1), (jn.useSingleShadowCascade = !!I && I.getMaxCascadeForTile(k.toUnwrapped()) === 0), y.renderPass === 'shadow' && I)) {
                      if (y.currentShadowCascade === 1 && O.isInsideFirstShadowMapFrustum) continue;
                      const X = b.calculatePosMatrix(k.toUnwrapped(), b.worldSize);
                      if ((jn.tileMatrix.set(X), (jn.shadowTileMatrix = Float32Array.from(I.calculateShadowPassMatrixFromMatrix(X))), jn.aabb.min.fill(0), (jn.aabb.max[0] = jn.aabb.max[1] = lt), (jn.aabb.max[2] = 0), Dz(O, jn, y, w.scope))) continue;
                    }
                    const G = 1 << k.canonical.z,
                      Z = [((E.x - k.wrap) * G - k.canonical.x) * lt, (E.y * G - k.canonical.y) * lt, E.z * G * lt];
                    for (let X in O.instancesPerModel) {
                      const j = O.instancesPerModel[X];
                      j.features.length > 0 && (X = R.evaluate(j.features[0].feature, {}));
                      const q = S.getModel(X, w.scope);
                      if (q && q.uploaded) for (const it of q.nodes) sw(y, w, it, j, Z, k, jn);
                    }
                  }
                })(e, t, i, r),
                void l()
              );
            if (!c.loaded()) return;
            if (c.type === 'batched-model')
              return (
                (function (y, v, w, T) {
                  const b = y.context,
                    E = y.transform,
                    S = y.style.fog,
                    I = y.shadowRenderer;
                  if (E.projection.name !== 'mercator') return void B(`Drawing 3D landmark models for ${E.projection.name} projection is not yet implemented`);
                  const C = y.transform.getFreeCameraOptions().position,
                    z = N.scale([], [C.x, C.y, C.z], y.transform.worldSize);
                  N.negate(z, z);
                  const k = J.identity([]),
                    O = No(E.center.lat, E.zoom),
                    V = J.fromScaling([], [1, 1, 1 / O]);
                  J.translate(k, k, z);
                  const R = w.paint.get('model-opacity'),
                    G = new Jt(b.gl.LEQUAL, Jt.ReadWrite, y.depthRangeFor3D),
                    Z = new Jt(b.gl.LEQUAL, Jt.ReadOnly, y.depthRangeFor3D),
                    X = function (j, q) {
                      for (const it of T) {
                        const st = v.getTile(it).getBucket(w);
                        if (!st || !st.uploaded) continue;
                        let nt = !1;
                        I && (nt = I.getMaxCascadeForTile(it.toUnwrapped()) === 0);
                        const ut = E.calculatePosMatrix(it.toUnwrapped(), E.worldSize),
                          ht = st.modelTraits;
                        for (const pt of st.getNodesInfo()) {
                          if (pt.hiddenByReplacement || !pt.node.meshes) continue;
                          const at = pt.node,
                            _t = y.renderPass === 'light-beam',
                            Ct = [...ut],
                            Pt = pt.evaluatedScale;
                          let Ot = 0;
                          y.terrain && at.elevation && (Ot = at.elevation * y.terrain.exaggeration()), J.translate(Ct, Ct, [(at.anchor ? at.anchor[0] : 0) * (Pt[0] - 1), (at.anchor ? at.anchor[1] : 0) * (Pt[1] - 1), Ot]), Pt !== cC && J.scale(Ct, Ct, Pt), J.multiply(Ct, Ct, at.matrix);
                          const Ut = J.multiply([], V, Ct);
                          J.multiply(Ut, k, Ut);
                          const Qt = J.invert([], Ut);
                          J.transpose(Qt, Qt), J.scale(Qt, Qt, zz);
                          const Ht = J.multiply([], E.expandedFarZProjMatrix, Ct);
                          for (let Ce = 0; Ce < at.meshes.length; ++Ce) {
                            const be = at.meshes[Ce],
                              te = Ce === at.lightMeshIndex;
                            if (te) {
                              if (!_t && !y.terrain && y.shadowRenderer) {
                                y.currentLayer < y.firstLightBeamLayer && (y.firstLightBeamLayer = y.currentLayer);
                                continue;
                              }
                            } else if (_t) continue;
                            const Kt = { defines: [] },
                              Wt = [];
                            Dm(Kt.defines, Wt, be, y), 4 & ht || Kt.defines.push('DIFFUSE_SHADED'), nt && Kt.defines.push('SHADOWS_SINGLE_CASCADE');
                            const Ee = y.renderPass === 'shadow';
                            if (Ee) {
                              Rm(be, Ct, y, w);
                              continue;
                            }
                            let Ae = null;
                            if (S) {
                              const Ri = nw(Ct, y.transform);
                              if (((Ae = new Float32Array(Ri)), E.projection.name !== 'globe')) {
                                const Pi = be.aabb.min,
                                  ci = be.aabb.max,
                                  [je, rr] = S.getOpacityForBounds(Ri, Pi[0], Pi[1], ci[0], ci[1]);
                                Kt.overrideFog = je >= Is || rr >= Is;
                              }
                            }
                            const fe = y.getOrCreateProgram('model', Kt);
                            !Ee && I && ((I.useNormalOffset = !!be.normalBuffer), I.setupShadowsFromMatrix(Ct, fe, I.useNormalOffset)), y.uploadCommonUniforms(b, fe, it.toUnwrapped(), Ae);
                            const Qe = be.material,
                              Ci = Qe.pbrMetallicRoughness;
                            (Ci.metallicFactor = 0.9), (Ci.roughnessFactor = 0.5);
                            const Xe = 0,
                              oi = Pm(new Float32Array(Ht), new Float32Array(Ut), new Float32Array(Qt), y, R, Ci.baseColorFactor, Qe.emissiveFactor, Ci.metallicFactor, Ci.roughnessFactor, Qe, Xe, w);
                            fe.draw(y, b.gl.TRIANGLES, q && !te ? G : Z, me.disabled, j ? (te || R < 1 || pt.hasTranslucentParts ? De.alphaBlended : De.unblended) : De.disabled, ye.backCCW, oi, w.id, be.vertexBuffer, be.indexBuffer, be.segments, w.paint, y.transform.zoom, void 0, Wt);
                          }
                        }
                      }
                    };
                  (function (j, q, it, st) {
                    const nt = j.terrain ? j.terrain.exaggeration() : 0,
                      ut = j.transform.zoom;
                    for (const ht of st) {
                      const pt = q.getTile(ht).getBucket(it);
                      pt && (j.conflationActive && pt.updateReplacement(ht, j.replacementSource), pt.evaluateScale(j, it), j.terrain && nt > 0 && pt.elevationUpdate(j.terrain, nt, ht, it.source), pt.needsReEvaluation(j, ut, it) && pt.evaluate(it));
                    }
                  })(y, v, w, T),
                    R === 1 ? X(!0, !0) : (X(!1, !0), X(!0, !1));
                })(e, t, i, r),
                void l()
              );
            const u = c.getModels(),
              h = [],
              d = e.transform.getFreeCameraOptions().position,
              f = N.scale([], [d.x, d.y, d.z], e.transform.worldSize);
            N.negate(f, f);
            const p = [],
              _ = [];
            let g = 0;
            for (const y of u) {
              const v = i.paint.get('model-rotation').constantOr(null),
                w = i.paint.get('model-scale').constantOr(null),
                T = i.paint.get('model-translation').constantOr(null);
              y.computeModelMatrix(e, v, w, T, !0, !0, !1);
              const b = J.identity([]),
                E = No(y.position.lat, e.transform.zoom),
                S = J.fromScaling([], [1, 1, 1 / E]);
              J.translate(b, b, f), h.push({ zScaleMatrix: S, negCameraPosMatrix: b });
              for (const I of y.nodes) ow(e.transform, I, y.matrix, e.transform.expandedFarZProjMatrix, g, p, _);
              g++;
            }
            if ((p.sort((y, v) => v.depth - y.depth), e.renderPass !== 'shadow')) {
              if (n === 1) for (const y of _) bh(y, e, i, h[y.modelIndex], me.disabled, e.colorModeForRenderPass());
              else {
                for (const y of _) bh(y, e, i, h[y.modelIndex], me.disabled, De.disabled);
                for (const y of _) bh(y, e, i, h[y.modelIndex], e.stencilModeFor3D(), e.colorModeForRenderPass());
                e.resetStencilClippingMasks();
              }
              for (const y of p) bh(y, e, i, h[y.modelIndex], me.disabled, e.colorModeForRenderPass());
              l();
            } else {
              for (const y of _) Rm(y.mesh, y.nodeModelMatrix, e, i);
              for (const y of p) Rm(y.mesh, y.nodeModelMatrix, e, i);
              l();
            }
          },
        },
        lw = {
          modelUpload: function (e, t, i) {
            const r = t.getSource();
            if (!r.loaded()) return;
            if (r.type === 'vector' || r.type === 'geojson') return void (e.modelManager && e.modelManager.upload(e, i));
            if (r.type === 'batched-model') return;
            const n = r.getModels();
            for (const o of n) o.upload(e.context);
          },
        };
      class kz {
        constructor(t, i, r) {
          (this.context = new JI(t, i)), (this.transform = r), (this._tileTextures = {}), (this.frameCopies = []), (this.loadTimeStamps = []), this.setup(), (this.numSublayers = wn.maxUnderzooming + wn.maxOverzooming + 1), (this.depthEpsilon = 1 / Math.pow(2, 16)), (this.deferredRenderGpuTimeQueries = []), (this.gpuTimers = {}), (this.frameCounter = 0), (this._backgroundTiles = {}), (this.conflationActive = !1), (this.replacementSource = new mC()), (this.longestCutoffRange = 0), (this.minCutoffZoom = 0), (this._fogVisible = !1), (this._cachedTileFogOpacities = {}), (this._shadowRenderer = new Fz(this)), (this._wireframeDebugCache = new Lz()), (this.renderDefaultNorthPole = !0), (this.renderDefaultSouthPole = !0);
        }
        updateTerrain(t, i) {
          const r = !!t && !!t.terrain && this.transform.projection.supportsTerrain;
          if (!(r || (this._terrain && this._terrain.enabled))) return;
          this._terrain || (this._terrain = new GP(this, t));
          const n = this._terrain;
          (this.transform.elevation = r ? n : null), n.update(t, this.transform, i), this.transform.elevation && !n.enabled && (this.transform.elevation = null);
        }
        _updateFog(t) {
          const i = t.fog;
          if (!i || this.transform.projection.name === 'globe' || i.getOpacity(this.transform.pitch) < 1 || i.properties.get('horizon-blend') < 0.03) return void (this.transform.fogCullDistSq = null);
          const [r, n] = i.getFovAdjustedRange(this.transform._fov);
          if (r > n) return void (this.transform.fogCullDistSq = null);
          const o = r + 0.78 * (n - r);
          this.transform.fogCullDistSq = o * o;
        }
        get terrain() {
          return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled ? this._terrain : null;
        }
        get shadowRenderer() {
          return this._shadowRenderer && this._shadowRenderer.enabled ? this._shadowRenderer : null;
        }
        get wireframeDebugCache() {
          return this._wireframeDebugCache;
        }
        resize(t, i) {
          if (((this.width = t * oe.devicePixelRatio), (this.height = i * oe.devicePixelRatio), this.context.viewport.set([0, 0, this.width, this.height]), this.style)) for (const r of this.style.order) this.style._mergedLayers[r].resize();
        }
        setup() {
          const t = this.context,
            i = new Rr();
          i.emplaceBack(0, 0), i.emplaceBack(lt, 0), i.emplaceBack(0, lt), i.emplaceBack(lt, lt), (this.tileExtentBuffer = t.createVertexBuffer(i, ko.members)), (this.tileExtentSegments = He.simpleSegment(0, 0, 4, 2));
          const r = new Rr();
          r.emplaceBack(0, 0), r.emplaceBack(lt, 0), r.emplaceBack(0, lt), r.emplaceBack(lt, lt), (this.debugBuffer = t.createVertexBuffer(r, ko.members)), (this.debugSegments = He.simpleSegment(0, 0, 4, 5));
          const n = new Rr();
          n.emplaceBack(-1, -1), n.emplaceBack(1, -1), n.emplaceBack(-1, 1), n.emplaceBack(1, 1), (this.viewportBuffer = t.createVertexBuffer(n, ko.members)), (this.viewportSegments = He.simpleSegment(0, 0, 4, 2));
          const o = new gs();
          o.emplaceBack(0, 0, 0, 0), o.emplaceBack(lt, 0, lt, 0), o.emplaceBack(0, lt, 0, lt), o.emplaceBack(lt, lt, lt, lt), (this.mercatorBoundsBuffer = t.createVertexBuffer(o, Hp.members)), (this.mercatorBoundsSegments = He.simpleSegment(0, 0, 4, 2));
          const s = new Fi();
          s.emplaceBack(0, 1, 2), s.emplaceBack(2, 1, 3), (this.quadTriangleIndexBuffer = t.createIndexBuffer(s));
          const a = new vl();
          for (const c of [0, 1, 3, 2, 0]) a.emplaceBack(c);
          (this.debugIndexBuffer = t.createIndexBuffer(a)), (this.emptyTexture = new vi(t, new Li({ width: 1, height: 1 }, Uint8Array.of(0, 0, 0, 0)), t.gl.RGBA)), (this.identityMat = J.create());
          const l = this.context.gl;
          (this.stencilClearMode = new me({ func: l.ALWAYS, mask: 0 }, 0, 255, l.ZERO, l.ZERO, l.ZERO)), this.loadTimeStamps.push(U.performance.now());
        }
        getMercatorTileBoundsBuffers() {
          return { tileBoundsBuffer: this.mercatorBoundsBuffer, tileBoundsIndexBuffer: this.quadTriangleIndexBuffer, tileBoundsSegments: this.mercatorBoundsSegments };
        }
        getTileBoundsBuffers(t) {
          return t._makeTileBoundsBuffers(this.context, this.transform.projection), t._tileBoundsBuffer ? { tileBoundsBuffer: t._tileBoundsBuffer, tileBoundsIndexBuffer: t._tileBoundsIndexBuffer, tileBoundsSegments: t._tileBoundsSegments } : this.getMercatorTileBoundsBuffers();
        }
        clearStencil() {
          const t = this.context.gl;
          (this.nextStencilID = 1), (this.currentStencilSource = void 0), (this._tileClippingMaskIDs = {}), this.getOrCreateProgram('clippingMask').draw(this, t.TRIANGLES, Jt.disabled, this.stencilClearMode, De.disabled, ye.disabled, Cm(this.identityMat), '$clipping', this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
        }
        resetStencilClippingMasks() {
          this.terrain || ((this.currentStencilSource = void 0), (this._tileClippingMaskIDs = {}));
        }
        _renderTileClippingMasks(t, i, r) {
          if (!i || this.currentStencilSource === i.id || !t.isTileClipped() || !r || r.length === 0) return;
          if (this._tileClippingMaskIDs && !this.terrain) {
            let a = !1;
            for (const l of r)
              if (this._tileClippingMaskIDs[l.key] === void 0) {
                a = !0;
                break;
              }
            if (!a) return;
          }
          this.currentStencilSource = i.id;
          const n = this.context,
            o = n.gl;
          this.nextStencilID + r.length > 256 && this.clearStencil(), n.setColorMode(De.disabled), n.setDepthMode(Jt.disabled);
          const s = this.getOrCreateProgram('clippingMask');
          this._tileClippingMaskIDs = {};
          for (const a of r) {
            const l = i.getTile(a),
              c = (this._tileClippingMaskIDs[a.key] = this.nextStencilID++),
              { tileBoundsBuffer: u, tileBoundsIndexBuffer: h, tileBoundsSegments: d } = this.getTileBoundsBuffers(l);
            s.draw(this, o.TRIANGLES, Jt.disabled, new me({ func: o.ALWAYS, mask: 0 }, c, 255, o.KEEP, o.KEEP, o.REPLACE), De.disabled, ye.disabled, Cm(a.projMatrix), '$clipping', u, h, d);
          }
        }
        stencilModeFor3D() {
          (this.currentStencilSource = void 0), this.nextStencilID + 1 > 256 && this.clearStencil();
          const t = this.nextStencilID++,
            i = this.context.gl;
          return new me({ func: i.NOTEQUAL, mask: 255 }, t, 255, i.KEEP, i.KEEP, i.REPLACE);
        }
        stencilModeForClipping(t) {
          if (this.terrain) return this.terrain.stencilModeForRTTOverlap(t);
          const i = this.context.gl;
          return new me({ func: i.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t.key], 0, i.KEEP, i.KEEP, i.REPLACE);
        }
        stencilConfigForOverlap(t) {
          const i = this.context.gl,
            r = t.sort((s, a) => a.overscaledZ - s.overscaledZ),
            n = r[r.length - 1].overscaledZ,
            o = r[0].overscaledZ - n + 1;
          if (o > 1) {
            (this.currentStencilSource = void 0), this.nextStencilID + o > 256 && this.clearStencil();
            const s = {};
            for (let a = 0; a < o; a++) s[a + n] = new me({ func: i.GEQUAL, mask: 255 }, a + this.nextStencilID, 255, i.KEEP, i.KEEP, i.REPLACE);
            return (this.nextStencilID += o), [s, r];
          }
          return [{ [n]: me.disabled }, r];
        }
        colorModeForRenderPass() {
          const t = this.context.gl;
          return this._showOverdrawInspector ? new De([t.CONSTANT_COLOR, t.ONE, t.CONSTANT_COLOR, t.ONE], new pe(0.125, 0.125, 0.125, 0), [!0, !0, !0, !0]) : this.renderPass === 'opaque' ? De.unblended : De.alphaBlended;
        }
        colorModeForDrapableLayerRenderPass(t) {
          const i = this.context.gl;
          return this.style && this.style.enable3dLights() && this.terrain && this.terrain.renderingToTexture && this.renderPass === 'translucent' ? new De([i.ONE, i.ONE_MINUS_SRC_ALPHA, i.CONSTANT_ALPHA, i.ONE_MINUS_SRC_ALPHA], new pe(0, 0, 0, t === void 0 ? 0 : t), [!0, !0, !0, !0]) : this.colorModeForRenderPass();
        }
        depthModeForSublayer(t, i, r, n = !1) {
          if (!this.opaquePassEnabledForLayer() && !n) return Jt.disabled;
          const o = 1 - ((1 + this.currentLayer) * this.numSublayers + t) * this.depthEpsilon;
          return new Jt(r || this.context.gl.LEQUAL, i, [o, o]);
        }
        opaquePassEnabledForLayer() {
          return this.currentLayer < this.opaquePassCutoff;
        }
        render(t, i) {
          this._wireframeDebugCache.update(this.frameCounter), (this.style = t), (this.options = i);
          const r = this.style._mergedLayers,
            n = this.style.order,
            o = n.map((b) => r[b]),
            s = this.style._mergedSourceCaches;
          (this.imageManager = t.imageManager), (this.modelManager = t.modelManager), (this.symbolFadeChange = t.placement.symbolFadeChange(oe.now())), this.imageManager.beginFrame();
          let a = 0,
            l = !1;
          for (const b in s) {
            const E = s[b];
            E.used && (E.prepare(this.context), E.getSource().usedInConflation && ++a);
          }
          const c = {},
            u = {},
            h = {},
            d = {},
            f = {};
          for (const b in s) {
            const E = s[b];
            (c[b] = E.getVisibleCoordinates()), (u[b] = c[b].slice().reverse()), (h[b] = E.getVisibleCoordinates(!0).reverse()), (d[b] = E.getShadowCasterCoordinates()), (f[b] = E.sortCoordinatesByDistance(c[b]));
          }
          const p = (b) => {
            const E = this.style.getLayerSourceCache(b);
            return E && E.used ? E.getSource() : null;
          };
          if (a) {
            const b = [];
            for (const E of o) this.layerUsedInConflation(E, p(E)) && b.push(E);
            if (b && b.length > 1) {
              const E = [];
              for (const S of b) {
                const I = this.style.getLayerSourceCache(S);
                I && I.used && I.getSource().usedInConflation && E.push({ layer: S.fqid, cache: I });
              }
              this.replacementSource.setSources(E), (l = !0);
            }
          }
          l || this.replacementSource.clear(), (this.conflationActive = l), (this.minCutoffZoom = 0), (this.longestCutoffRange = 0);
          for (const b of o) {
            const E = b.cutoffRange();
            if (((this.longestCutoffRange = Math.max(E, this.longestCutoffRange)), E > 0)) {
              const S = p(b);
              S && (this.minCutoffZoom = Math.max(S.minzoom, this.minCutoffZoom)), b.minzoom && (this.minCutoffZoom = Math.max(b.minzoom, this.minCutoffZoom));
            }
          }
          this.opaquePassCutoff = 1 / 0;
          for (let b = 0; b < o.length; b++)
            if (o[b].is3D()) {
              this.opaquePassCutoff = b;
              break;
            }
          const _ = this.style && this.style.fog;
          _ ? ((this._fogVisible = _.getOpacity(this.transform.pitch) !== 0), this._fogVisible && this.transform.projection.name !== 'globe' && (this._fogVisible = _.isVisibleOnFrustum(this.transform.cameraFrustum))) : (this._fogVisible = !1), (this._cachedTileFogOpacities = {}), this.terrain && (this.terrain.updateTileBinding(h), (this.opaquePassCutoff = 0));
          const g = this._shadowRenderer;
          if (g) {
            g.updateShadowParameters(this.transform, this.style.directionalLight);
            for (const b in s)
              for (const E of c[b]) {
                let S = { min: 0, max: 0 };
                this.terrain && (S = this.terrain.getMinMaxForTile(E) || S), g.addShadowReceiver(E.toUnwrapped(), S.min, S.max);
              }
          }
          this.transform.projection.name !== 'globe' || this.globeSharedBuffers || (this.globeSharedBuffers = new fS(this.context));
          for (const b of o) {
            if (b.isHidden(this.transform.zoom)) continue;
            const E = t.getLayerSourceCache(b);
            this.uploadLayer(this, b, E);
          }
          if ((this.style.fog && this.transform.projection.supportsFog ? (this._atmosphere || (this._atmosphere = new Iz()), this._atmosphere.update(this)) : this._atmosphere && (this._atmosphere.destroy(), (this._atmosphere = void 0)), !xc.has(this.context.gl))) return;
          this.renderPass = 'offscreen';
          for (const b of o) {
            const E = t.getLayerSourceCache(b);
            if (!b.hasOffscreenPass() || b.isHidden(this.transform.zoom)) continue;
            const S = E ? u[E.id] : void 0;
            (b.type === 'custom' || b.type === 'raster' || b.isSky() || (S && S.length)) && this.renderLayer(this, E, b, S);
          }
          this.depthRangeFor3D = [0, 1 - (o.length + 2) * this.numSublayers * this.depthEpsilon];
          const y = this.terrain;
          y && (this.style.hasSymbolLayers() || this.style.hasCircleLayers()) && !this.transform.isOrthographic && y.drawDepth(), this._shadowRenderer && ((this.renderPass = 'shadow'), this._shadowRenderer.drawShadowPass(this.style, d)), this.context.bindFramebuffer.set(null), this.context.viewport.set([0, 0, this.width, this.height]);
          const v = this.transform.projection.name === 'globe' || this.transform.isHorizonVisible(),
            w = (() => {
              if (i.showOverdrawInspector) return pe.black;
              if (this.style.fog && this.transform.projection.supportsFog && !v) {
                const b = this.style.fog.properties.get('color').toArray01();
                return new pe(...b);
              }
              if (this.style.fog && this.transform.projection.supportsFog && v) {
                const b = this.style.fog.properties.get('space-color').toArray01();
                return new pe(...b);
              }
              return pe.transparent;
            })();
          if ((this.context.clear({ color: w, depth: 1 }), this.clearStencil(), (this._showOverdrawInspector = i.showOverdrawInspector), (this.renderPass = 'opaque'), this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && v && this._atmosphere.drawStars(this, this.style.fog), !this.terrain))
            for (this.currentLayer = n.length - 1; this.currentLayer >= 0; this.currentLayer--) {
              const b = o[this.currentLayer],
                E = t.getLayerSourceCache(b);
              if (b.isSky()) continue;
              const S = E ? (b.is3D() ? f : u)[E.id] : void 0;
              this._renderTileClippingMasks(b, E, S), this.renderLayer(this, E, b, S);
            }
          if ((this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && v && this._atmosphere.drawAtmosphereGlow(this, this.style.fog), (this.renderPass = 'sky'), (!this._atmosphere || Ji(this.transform.zoom) > 0) && (this.transform.projection.name === 'globe' || this.transform.isHorizonVisible())))
            for (this.currentLayer = 0; this.currentLayer < n.length; this.currentLayer++) {
              const b = o[this.currentLayer],
                E = t.getLayerSourceCache(b);
              b.isSky() && this.renderLayer(this, E, b, E ? u[E.id] : void 0);
            }
          (this.renderPass = 'translucent'), (this.currentLayer = 0), (this.firstLightBeamLayer = Number.MAX_SAFE_INTEGER);
          let T = 0;
          for (g && (T = g.getShadowCastingLayerCount()); this.currentLayer < n.length; ) {
            const b = o[this.currentLayer],
              E = t.getLayerSourceCache(b);
            if (b.isSky()) {
              ++this.currentLayer;
              continue;
            }
            if (y && this.style.isLayerDraped(b)) {
              if (b.isHidden(this.transform.zoom)) {
                ++this.currentLayer;
                continue;
              }
              this.currentLayer = y.renderBatch(this.currentLayer);
              continue;
            }
            let S;
            if ((E && (S = (b.type === 'symbol' ? h : b.is3D() ? f : u)[E.id]), this._renderTileClippingMasks(b, E, E ? c[E.id] : void 0), this.renderLayer(this, E, b, S), !y && g && T > 0 && b.hasShadowPass() && --T == 0 && (g.drawGroundShadows(), this.firstLightBeamLayer <= this.currentLayer))) {
              const I = this.currentLayer;
              for (this.renderPass = 'light-beam', this.currentLayer = this.firstLightBeamLayer; this.currentLayer <= I; this.currentLayer++) {
                const C = o[this.currentLayer];
                if (!C.hasLightBeamPass()) continue;
                const z = t.getLayerSourceCache(C);
                this.renderLayer(this, z, C, z ? u[z.id] : void 0);
              }
              (this.currentLayer = I), (this.renderPass = 'translucent');
            }
            ++this.currentLayer;
          }
          if ((this.terrain && this.terrain.postRender(), this.options.showTileBoundaries || this.options.showQueryGeometry || this.options.showTileAABBs)) {
            let b = null;
            o.forEach((E) => {
              const S = t.getLayerSourceCache(E);
              S && !E.isHidden(this.transform.zoom) && S.getVisibleCoordinates().length && (!b || b.getSource().maxzoom < S.getSource().maxzoom) && (b = S);
            }),
              b && this.options.showTileBoundaries && aw.debug(this, b, b.getVisibleCoordinates());
          }
          this.options.showPadding &&
            (function (b) {
              const E = b.transform.padding;
              ew(b, b.transform.height - (E.top || 0), 3, gz), ew(b, E.bottom || 0, 3, yz), iw(b, E.left || 0, 3, xz), iw(b, b.transform.width - (E.right || 0), 3, vz);
              const S = b.transform.centerPoint;
              (function (I, C, z, k) {
                vh(I, C - 1, z - 10, 2, 20, k), vh(I, C - 10, z - 1, 20, 2, k);
              })(b, S.x, b.transform.height - S.y, bz);
            })(this),
            this.context.setDefault(),
            (this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER),
            this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(U.performance.now()), this.saveCanvasCopy()),
            l || (this.conflationActive = !1);
        }
        uploadLayer(t, i, r) {
          this.gpuTimingStart(i), (!t.transform.projection.unsupportedLayers || !t.transform.projection.unsupportedLayers.includes(i.type) || (t.terrain && i.type === 'custom')) && lw[`${i.type}Upload`] && lw[`${i.type}Upload`](t, r, i.scope), this.gpuTimingEnd();
        }
        renderLayer(t, i, r, n) {
          r.isHidden(this.transform.zoom) || ((r.type === 'background' || r.type === 'sky' || r.type === 'custom' || r.type === 'model' || r.type === 'raster' || (n && n.length)) && ((this.id = r.id), this.gpuTimingStart(r), (!t.transform.projection.unsupportedLayers || !t.transform.projection.unsupportedLayers.includes(r.type) || (t.terrain && r.type === 'custom')) && aw[r.type](t, i, r, n, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd()));
        }
        gpuTimingStart(t) {
          if (!this.options.gpuTiming) return;
          const i = this.context.extTimerQuery,
            r = this.context.gl;
          let n = this.gpuTimers[t.id];
          n || (n = this.gpuTimers[t.id] = { calls: 0, cpuTime: 0, query: r.createQuery() }), n.calls++, r.beginQuery(i.TIME_ELAPSED_EXT, n.query);
        }
        gpuTimingDeferredRenderStart() {
          if (this.options.gpuTimingDeferredRender) {
            const t = this.context.extTimerQuery,
              i = this.context.gl,
              r = i.createQuery();
            this.deferredRenderGpuTimeQueries.push(r), i.beginQuery(t.TIME_ELAPSED_EXT, r);
          }
        }
        gpuTimingDeferredRenderEnd() {
          this.options.gpuTimingDeferredRender && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);
        }
        gpuTimingEnd() {
          this.options.gpuTiming && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);
        }
        collectGpuTimers() {
          const t = this.gpuTimers;
          return (this.gpuTimers = {}), t;
        }
        collectDeferredRenderGpuQueries() {
          const t = this.deferredRenderGpuTimeQueries;
          return (this.deferredRenderGpuTimeQueries = []), t;
        }
        queryGpuTimers(t) {
          const i = {};
          for (const r in t) {
            const n = t[r],
              o = this.context.extTimerQuery,
              s = o.getQueryParameter(n.query, this.context.gl.QUERY_RESULT) / 1e6;
            o.deleteQueryEXT(n.query), (i[r] = s);
          }
          return i;
        }
        queryGpuTimeDeferredRender(t) {
          if (!this.options.gpuTimingDeferredRender) return 0;
          const i = this.context.extTimerQuery,
            r = this.context.gl;
          let n = 0;
          for (const o of t) (n += i.getQueryParameter(o, r.QUERY_RESULT) / 1e6), i.deleteQueryEXT(o);
          return n;
        }
        translatePosMatrix(t, i, r, n, o) {
          if (!r[0] && !r[1]) return t;
          const s = o ? (n === 'map' ? this.transform.angle : 0) : n === 'viewport' ? -this.transform.angle : 0;
          if (s) {
            const c = Math.sin(s),
              u = Math.cos(s);
            r = [r[0] * u - r[1] * c, r[0] * c + r[1] * u];
          }
          const a = [o ? r[0] : Ms(i, r[0], this.transform.zoom), o ? r[1] : Ms(i, r[1], this.transform.zoom), 0],
            l = new Float32Array(16);
          return J.translate(l, t, a), l;
        }
        saveTileTexture(t) {
          const i = t.size[0],
            r = this._tileTextures[i];
          r ? r.push(t) : (this._tileTextures[i] = [t]);
        }
        getTileTexture(t) {
          const i = this._tileTextures[t];
          return i && i.length > 0 ? i.pop() : null;
        }
        isPatternMissing(t, i) {
          return t === null || (t !== void 0 && !this.imageManager.getPattern(t.toString(), i));
        }
        terrainRenderModeElevated() {
          return this.style && !!this.style.getTerrain() && !!this.terrain && !this.terrain.renderingToTexture;
        }
        linearFloatFilteringSupported() {
          return this.context.extTextureFloatLinear != null;
        }
        currentGlobalDefines(t, i, r) {
          const n = r === void 0 ? this.terrain && this.terrain.renderingToTexture : r,
            o = this.terrain && this.terrain.exaggeration() === 0,
            s = [];
          return this.style && this.style.enable3dLights() && (t === 'globeRaster' || t === 'terrainRaster' ? (s.push('LIGHTING_3D_MODE'), s.push('LIGHTING_3D_ALPHA_EMISSIVENESS')) : n || s.push('LIGHTING_3D_MODE')), this.renderPass === 'shadow' ? this._shadowMapDebug || s.push('DEPTH_TEXTURE') : this.shadowRenderer && (this.shadowRenderer.useNormalOffset ? s.push('RENDER_SHADOWS', 'DEPTH_TEXTURE', 'NORMAL_OFFSET') : s.push('RENDER_SHADOWS', 'DEPTH_TEXTURE')), this.terrainRenderModeElevated() && (s.push('TERRAIN'), this.linearFloatFilteringSupported() && s.push('TERRAIN_DEM_FLOAT_FORMAT'), o && s.push('ZERO_EXAGGERATION')), this.transform.projection.name === 'globe' && s.push('GLOBE'), !this._fogVisible || n || (i !== void 0 && !i) || s.push('FOG', 'FOG_DITHERING'), n && s.push('RENDER_TO_TEXTURE'), this._showOverdrawInspector && s.push('OVERDRAW_INSPECTOR'), s;
        }
        getOrCreateProgram(t, i) {
          this.cache = this.cache || {};
          const r = (i && i.defines) || [],
            n = i && i.config,
            o = this.currentGlobalDefines(t, i && i.overrideFog, i && i.overrideRtt).concat(r),
            s = Nb.cacheKey(Cb[t], t, o, n);
          return this.cache[s] || (this.cache[s] = new Nb(this.context, t, Cb[t], n, az[t], o)), this.cache[s];
        }
        setCustomLayerDefaults() {
          this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
        }
        setBaseState() {
          const t = this.context.gl;
          this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(t.FUNC_ADD);
        }
        initDebugOverlayCanvas() {
          this.debugOverlayCanvas == null && ((this.debugOverlayCanvas = U.document.createElement('canvas')), (this.debugOverlayCanvas.width = 512), (this.debugOverlayCanvas.height = 512), (this.debugOverlayTexture = new vi(this.context, this.debugOverlayCanvas, this.context.gl.RGBA)));
        }
        destroy() {
          this._terrain && this._terrain.destroy(), this._atmosphere && (this._atmosphere.destroy(), (this._atmosphere = void 0)), this.globeSharedBuffers && this.globeSharedBuffers.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this._wireframeDebugCache.destroy();
        }
        prepareDrawTile() {
          this.terrain && this.terrain.prepareDrawTile();
        }
        uploadCommonLightUniforms(t, i) {
          if (this.style.enable3dLights()) {
            const r = this.style.directionalLight,
              n = this.style.ambientLight;
            if (r && n) {
              const o = ((s, a) => {
                const l = s.properties.get('direction'),
                  c = s.properties.get('color').toArray01(),
                  u = s.properties.get('intensity'),
                  h = a.properties.get('color').toArray01(),
                  d = a.properties.get('intensity'),
                  f = [l.x, l.y, l.z],
                  p = ii(h, d),
                  _ = ii(c, u);
                return { u_lighting_ambient_color: p, u_lighting_directional_dir: f, u_lighting_directional_color: _, u_ground_radiance: qP(f, _, p) };
              })(r, n);
              i.setLightsUniformValues(t, o);
            }
          }
        }
        uploadCommonUniforms(t, i, r, n, o) {
          if ((this.uploadCommonLightUniforms(t, i), this.terrain && this.terrain.renderingToTexture)) return;
          const s = this.style.fog;
          if (s) {
            const a = s.getOpacity(this.transform.pitch),
              l = ((c, u, h, d, f, p, _, g, y, v, w, T) => {
                const b = c.transform,
                  E = u.properties.get('color').toArray01();
                E[3] = d;
                const S = (c.frameCounter / 1e3) % 1,
                  [I, C] = u.properties.get('vertical-range');
                return { u_fog_matrix: h ? b.calculateFogTileMatrix(h) : T || c.identityMat, u_fog_range: u.getFovAdjustedRange(b._fov), u_fog_color: E, u_fog_horizon_blend: u.properties.get('horizon-blend'), u_fog_vertical_limit: [Math.min(I, C), C], u_fog_temporal_offset: S, u_frustum_tl: f, u_frustum_tr: p, u_frustum_br: _, u_frustum_bl: g, u_globe_pos: y, u_globe_radius: v, u_viewport: w, u_globe_transition: Ji(b.zoom), u_is_globe: +(b.projection.name === 'globe') };
              })(this, s, r, a, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [this.transform.width * oe.devicePixelRatio, this.transform.height * oe.devicePixelRatio], n);
            i.setFogUniformValues(t, l);
          }
          o && i.setCutoffUniformValues(t, o.uniformValues);
        }
        setTileLoadedFlag(t) {
          this.tileLoaded = t;
        }
        saveCanvasCopy() {
          const t = this.canvasCopy();
          t && (this.frameCopies.push(t), (this.tileLoaded = !1));
        }
        canvasCopy() {
          const t = this.context.gl,
            i = t.createTexture();
          return t.bindTexture(t.TEXTURE_2D, i), t.copyTexImage2D(t.TEXTURE_2D, 0, t.RGBA, 0, 0, t.drawingBufferWidth, t.drawingBufferHeight, 0), i;
        }
        getCanvasCopiesAndTimestamps() {
          return { canvasCopies: this.frameCopies, timeStamps: this.loadTimeStamps };
        }
        averageElevationNeedsEasing() {
          if (!this.transform._elevation) return !1;
          const t = this.style && this.style.fog;
          return !!t && t.getOpacity(this.transform.pitch) !== 0;
        }
        getBackgroundTiles() {
          const t = this._backgroundTiles,
            i = (this._backgroundTiles = {}),
            r = this.transform.coveringTiles({ tileSize: 512 });
          for (const n of r) i[n.key] = t[n.key] || new jl(n, 512, this.transform.tileZoom, this);
          return i;
        }
        clearBackgroundTiles() {
          this._backgroundTiles = {};
        }
        layerUsedInConflation(t, i) {
          return !(!t.is3D() || (t.minzoom && t.minzoom > this.transform.zoom) || (t.sourceLayer !== 'building' && (!i || i.type !== 'batched-model')));
        }
        isTileAffectedByFog(t) {
          if (!this.style || !this.style.fog) return !1;
          if (this.transform.projection.name === 'globe') return !0;
          let i = this._cachedTileFogOpacities[t.key];
          return i || (this._cachedTileFogOpacities[t.key] = i = this.style.fog.getOpacityForTile(t)), i[0] >= Is || i[1] >= Is;
        }
      }
      const zs = 2048;
      class Oz {
        constructor(t, i) {
          (this.aabb = t), (this.lastCascade = i);
        }
      }
      class Bz {
        add(t, i) {
          const r = this.receivers[t.key];
          r !== void 0 ? ((r.aabb.min[0] = Math.min(r.aabb.min[0], i.min[0])), (r.aabb.min[1] = Math.min(r.aabb.min[1], i.min[1])), (r.aabb.min[2] = Math.min(r.aabb.min[2], i.min[2])), (r.aabb.max[0] = Math.max(r.aabb.max[0], i.max[0])), (r.aabb.max[1] = Math.max(r.aabb.max[1], i.max[1])), (r.aabb.max[2] = Math.max(r.aabb.max[2], i.max[2]))) : (this.receivers[t.key] = new Oz(i, null));
        }
        clear() {
          this.receivers = {};
        }
        get(t) {
          return this.receivers[t.key];
        }
        computeRequiredCascades(t, i, r) {
          const n = ni.fromPoints(t.points);
          let o = 0;
          for (const s in this.receivers) {
            const a = this.receivers[s];
            if (!a || !n.intersectsAabb(a.aabb)) continue;
            (a.aabb.min = n.closestPoint(a.aabb.min)), (a.aabb.max = n.closestPoint(a.aabb.max));
            const l = a.aabb.getCorners();
            for (let c = 0; c < r.length; c++) {
              let u = !0;
              for (const h of l) {
                const d = [h[0] * i, h[1] * i, h[2]];
                if ((N.transformMat4(d, d, r[c].matrix), d[0] < -1 || d[0] > 1 || d[1] < -1 || d[1] > 1)) {
                  u = !1;
                  break;
                }
              }
              if (((a.lastCascade = c), (o = Math.max(o, c)), u)) break;
            }
          }
          return o + 1;
        }
      }
      class Fz {
        constructor(t) {
          (this.painter = t), (this._enabled = !1), (this._shadowLayerCount = 0), (this._numCascadesToRender = 0), (this._cascades = []), (this._groundShadowTiles = []), (this._receivers = new Bz()), (this._depthMode = new Jt(t.context.gl.LEQUAL, Jt.ReadWrite, [0, 1])), (this._uniformValues = { u_light_matrix_0: new Float32Array(16), u_light_matrix_1: new Float32Array(16), u_shadow_intensity: 0, u_fade_range: [0, 0], u_shadow_normal_offset: [1, 1, 1], u_shadow_texel_size: 1, u_shadow_map_resolution: 1, u_shadow_direction: [0, 0, 1], u_shadow_bias: [36e-5, 0.0012, 0.012], u_shadowmap_0: 0, u_shadowmap_1: 0 }), (this.useNormalOffset = !1);
        }
        destroy() {
          for (const t of this._cascades) t.texture.destroy(), t.framebuffer.destroy();
          this._cascades = [];
        }
        updateShadowParameters(t, i) {
          const r = this.painter;
          if (((this._enabled = !1), (this._shadowLayerCount = 0), this._receivers.clear(), !i || !i.properties)) return;
          const n = i.properties.get('shadow-intensity');
          if (
            !i.shadowsEnabled() ||
            n <= 0 ||
            ((this._shadowLayerCount = r.style.order.reduce((f, p) => {
              const _ = r.style._mergedLayers[p];
              return f + (_.hasShadowPass() && !_.isHidden(t.zoom) ? 1 : 0);
            }, 0)),
            (this._enabled = this._shadowLayerCount > 0),
            !this._enabled)
          )
            return;
          const o = r.context,
            s = zs,
            a = zs;
          if (this._cascades.length === 0)
            for (let f = 0; f < 2; ++f) {
              const p = r._shadowMapDebug,
                _ = o.gl,
                g = o.createFramebuffer(s, a, p, 'texture'),
                y = new vi(o, { width: s, height: a, data: null }, _.DEPTH_COMPONENT);
              if ((g.depthAttachment.set(y.texture), p)) {
                const v = new vi(o, { width: s, height: a, data: null }, _.RGBA);
                g.colorAttachment.set(v.texture);
              }
              this._cascades.push({ framebuffer: g, texture: y, matrix: [], far: 0, boundingSphereRadius: 0, frustum: new uo(), scale: 0 });
            }
          this.shadowDirection = cw(i);
          let l = 0;
          if (t.elevation) {
            const f = t.elevation,
              p = [1e4, -1e4];
            f.visibleDemTiles
              .filter((_) => _.dem)
              .forEach((_) => {
                const g = _.dem.tree;
                (p[0] = Math.min(p[0], g.minimums[0])), (p[1] = Math.max(p[1], g.maximums[0]));
              }),
              p[0] !== 1e4 && (l = (p[1] - p[0]) * f.exaggeration());
          }
          const c = 1.5 * t.cameraToCenterDistance,
            u = 3 * c,
            h = new Float64Array(16);
          for (let f = 0; f < 2; ++f) {
            const p = this._cascades[f];
            let _ = t.height / 50,
              g = 1;
            f === 0 ? (g = c) : ((_ = c), (g = u));
            const [y, v] = Nz(t, this.shadowDirection, _, g, zs, l);
            (p.scale = t.scale), (p.matrix = y), (p.boundingSphereRadius = v), J.invert(h, p.matrix), (p.frustum = uo.fromInvProjectionMatrix(h, 1, 0, !0)), (p.far = g);
          }
          (this._uniformValues.u_fade_range = [0.75 * this._cascades[1].far, this._cascades[1].far]), (this._uniformValues.u_shadow_intensity = n), (this._uniformValues.u_shadow_direction = [this.shadowDirection[0], this.shadowDirection[1], this.shadowDirection[2]]), (this._uniformValues.u_shadow_texel_size = 0.00048828125), (this._uniformValues.u_shadow_map_resolution = zs), (this._uniformValues.u_shadowmap_0 = Fr.ShadowMap0), (this._uniformValues.u_shadowmap_1 = Fr.ShadowMap0 + 1), (this._groundShadowTiles = r.transform.coveringTiles({ tileSize: 512, renderWorldCopies: !0 }));
          const d = r.transform.elevation;
          for (const f of this._groundShadowTiles) {
            let p = { min: 0, max: 0 };
            if (d) {
              const _ = d.getMinMaxForTile(f);
              _ && (p = _);
            }
            this.addShadowReceiver(f.toUnwrapped(), p.min, p.max);
          }
        }
        get enabled() {
          return this._enabled;
        }
        set enabled(t) {
          this._enabled = t;
        }
        drawShadowPass(t, i) {
          if (!this._enabled) return;
          const r = this.painter,
            n = r.context;
          (this._numCascadesToRender = this._receivers.computeRequiredCascades(r.transform.getFrustum(0), r.transform.worldSize, this._cascades)), n.viewport.set([0, 0, zs, zs]);
          for (let o = 0; o < this._numCascadesToRender; ++o) {
            (r.currentShadowCascade = o), n.bindFramebuffer.set(this._cascades[o].framebuffer.framebuffer), n.clear({ color: pe.white, depth: 1 });
            for (const s of t.order) {
              const a = t._mergedLayers[s];
              if (!a.hasShadowPass() || a.isHidden(r.transform.zoom)) continue;
              const l = t.getLayerSourceCache(a),
                c = l ? i[l.id] : void 0;
              (a.type === 'model' || (c && c.length)) && r.renderLayer(r, l, a, c);
            }
          }
          r.currentShadowCascade = 0;
        }
        drawGroundShadows() {
          if (!this._enabled) return;
          const t = this.painter,
            i = t.style,
            r = t.context,
            n = i.directionalLight,
            o = i.ambientLight;
          if (!n || !o) return;
          const s = [],
            a = Oa(t, t.longestCutoffRange);
          a.shouldRenderCutoff && s.push('RENDER_CUTOFF');
          const l = Lm(n, o),
            c = new Jt(r.gl.LEQUAL, Jt.ReadOnly, t.depthRangeFor3D);
          for (const u of this._groundShadowTiles) {
            const h = u.toUnwrapped(),
              d = t.isTileAffectedByFog(u),
              f = t.getOrCreateProgram('groundShadow', { defines: s, overrideFog: d });
            this.setupShadows(h, f), t.uploadCommonUniforms(r, f, h, null, a);
            const p = { u_matrix: t.transform.calculateProjMatrix(h), u_ground_shadow_factor: l };
            f.draw(t, r.gl.TRIANGLES, c, me.disabled, De.multiply, ye.disabled, p, 'ground_shadow', t.tileExtentBuffer, t.quadTriangleIndexBuffer, t.tileExtentSegments, {}, t.transform.zoom, null, null);
          }
        }
        getShadowPassColorMode() {
          return this.painter._shadowMapDebug ? De.unblended : De.disabled;
        }
        getShadowPassDepthMode() {
          return this._depthMode;
        }
        getShadowCastingLayerCount() {
          return this._shadowLayerCount;
        }
        calculateShadowPassMatrixFromTile(t) {
          const i = this.painter.transform,
            r = i.calculatePosMatrix(t, i.worldSize);
          return J.multiply(r, this._cascades[this.painter.currentShadowCascade].matrix, r), Float32Array.from(r);
        }
        calculateShadowPassMatrixFromMatrix(t) {
          return J.multiply(t, this._cascades[this.painter.currentShadowCascade].matrix, t), Float32Array.from(t);
        }
        setupShadows(t, i, r, n = 0) {
          if (!this._enabled) return;
          const o = this.painter.transform,
            s = this.painter.context,
            a = s.gl,
            l = this._uniformValues,
            c = new Float64Array(16),
            u = o.calculatePosMatrix(t, o.worldSize);
          for (let h = 0; h < 2; h++) J.multiply(c, this._cascades[h].matrix, u), (l[h === 0 ? 'u_light_matrix_0' : 'u_light_matrix_1'] = Float32Array.from(c)), s.activeTexture.set(a.TEXTURE0 + Fr.ShadowMap0 + h), this._cascades[h].texture.bind(a.NEAREST, a.CLAMP_TO_EDGE);
          if (((this.useNormalOffset = !!r), this.useNormalOffset)) {
            const h = Il(t.canonical),
              d = ((2 / o.tileSize) * lt) / zs,
              f = d * this._cascades[0].boundingSphereRadius,
              p = d * this._cascades[1].boundingSphereRadius,
              _ = (r === 'vector-tile' ? 1 : 3) / Math.pow(2, n - t.canonical.z - (1 - o.zoom + Math.floor(o.zoom)));
            (l.u_shadow_normal_offset = [h, f * _, p * _]), (l.u_shadow_bias = [6e-5, 0.0012, 0.012]);
          } else l.u_shadow_bias = [36e-5, 0.0012, 0.012];
          i.setShadowUniformValues(s, l);
        }
        setupShadowsFromMatrix(t, i, r = !1) {
          if (!this._enabled) return;
          const n = this.painter.context,
            o = n.gl,
            s = this._uniformValues,
            a = new Float64Array(16);
          for (let l = 0; l < 2; l++) J.multiply(a, this._cascades[l].matrix, t), (s[l === 0 ? 'u_light_matrix_0' : 'u_light_matrix_1'] = Float32Array.from(a)), n.activeTexture.set(o.TEXTURE0 + Fr.ShadowMap0 + l), this._cascades[l].texture.bind(o.NEAREST, o.CLAMP_TO_EDGE);
          (this.useNormalOffset = r), r ? ((s.u_shadow_normal_offset = [1, 5, 5]), (s.u_shadow_bias = [6e-5, 0.0012, 0.012])) : (s.u_shadow_bias = [36e-5, 0.0012, 0.012]), i.setShadowUniformValues(n, s);
        }
        getShadowUniformValues() {
          return this._uniformValues;
        }
        getCurrentCascadeFrustum() {
          return this._cascades[this.painter.currentShadowCascade].frustum;
        }
        computeSimplifiedTileShadowVolume(t, i, r, n) {
          if (n[2] >= 0) return {};
          const o = (function (l, c, u) {
              const h = u / (1 << l.canonical.z);
              return new ni([l.canonical.x * h + l.wrap * u, l.canonical.y * h + l.wrap * u, 0], [(l.canonical.x + 1) * h + l.wrap * u, (l.canonical.y + 1) * h + l.wrap * u, c]);
            })(t, i, r).getCorners(),
            s = i / -n[2];
          n[0] < 0 ? (N.add(o[0], o[0], [n[0] * s, 0, 0]), N.add(o[3], o[3], [n[0] * s, 0, 0])) : n[0] > 0 && (N.add(o[1], o[1], [n[0] * s, 0, 0]), N.add(o[2], o[2], [n[0] * s, 0, 0])), n[1] < 0 ? (N.add(o[0], o[0], [0, n[1] * s, 0]), N.add(o[1], o[1], [0, n[1] * s, 0])) : n[1] > 0 && (N.add(o[2], o[2], [0, n[1] * s, 0]), N.add(o[3], o[3], [0, n[1] * s, 0]));
          const a = {};
          return (a.vertices = o), (a.planes = [wh(o[1], o[0], o[4]), wh(o[2], o[1], o[5]), wh(o[3], o[2], o[6]), wh(o[0], o[3], o[7])]), a;
        }
        addShadowReceiver(t, i, r) {
          this._receivers.add(t, ni.fromTileIdAndHeight(t, i, r));
        }
        getMaxCascadeForTile(t) {
          const i = this._receivers.get(t);
          return i && i.lastCascade ? i.lastCascade : 0;
        }
      }
      function wh(e, t, i) {
        const r = N.sub([], i, t),
          n = N.sub([], e, t),
          o = N.cross([], r, n),
          s = N.length(o);
        return s === 0 ? [0, 0, 1, 0] : (N.scale(o, o, 1 / s), [o[0], o[1], o[2], -N.dot(o, t)]);
      }
      function cw(e) {
        const t = e.properties.get('direction'),
          i = gt(t.x, t.y, t.z);
        i[2] = Bt(i[2], 0, 75);
        const r = ft([i[0], i[1], i[2]]);
        return N.fromValues(r.x, r.y, r.z);
      }
      function Lm(e, t) {
        const i = e.properties.get('color'),
          r = e.properties.get('intensity'),
          n = e.properties.get('direction'),
          o = [n.x, n.y, n.z],
          s = t.properties.get('color'),
          a = t.properties.get('intensity'),
          l = Math.max(N.dot([0, 0, 1], o), 0),
          c = [0, 0, 0];
        N.scale(c, s.toArray01Linear().slice(0, 3), a);
        const u = [0, 0, 0];
        return N.scale(u, i.toArray01Linear().slice(0, 3), l * r), bi([c[0] > 0 ? c[0] / (c[0] + u[0]) : 0, c[1] > 0 ? c[1] / (c[1] + u[1]) : 0, c[2] > 0 ? c[2] / (c[2] + u[2]) : 0]);
      }
      function Nz(e, t, i, r, n, o) {
        const s = e.zoom,
          a = e.scale,
          l = e.worldSize,
          c = 1 / l,
          u = e.aspect,
          h = Math.sqrt(1 + u * u) * Math.tan(0.5 * e.fovX),
          d = h * h,
          f = r - i,
          p = r + i;
        let _, g;
        d > f / p ? ((_ = r), (g = r * h)) : ((_ = 0.5 * p * (1 + d)), (g = 0.5 * Math.sqrt(f * f + 2 * (r * r + i * i) * d + p * p * d * d)));
        const y = e.projection.pixelsPerMeter(e.center.lat, l),
          v = e._camera.getCameraToWorldMercator(),
          w = [0, 0, -_ * c];
        N.transformMat4(w, w, v);
        let T = g * c;
        const b = e._edgeInsets;
        if (!((b.left === 0 && b.top === 0 && b.right === 0 && b.bottom === 0) || (b.left === b.right && b.top === b.bottom))) {
          const st = e._camera.getWorldToCamera(e.worldSize, e.projection.zAxisUnit === 'meters' ? y : 1),
            nt = e._camera.getCameraToClipPerspective(e._fov, e.width / e.height, i, r);
          (nt[8] = (2 * -e.centerOffset.x) / e.width), (nt[9] = (2 * e.centerOffset.y) / e.height);
          const ut = new Float64Array(16);
          J.mul(ut, nt, st);
          const ht = new Float64Array(16);
          J.invert(ht, ut);
          const pt = uo.fromInvProjectionMatrix(ht, l, s, !0);
          for (const at of pt.points) {
            const _t = (((E = at)[0] /= a), (E[1] /= a), (E[2] = Je(E[2], e._center.lat)), E);
            T = Math.max(T, N.len(N.subtract([], w, _t)));
          }
        }
        var E;
        T *= n / (n - 1);
        const S = Math.acos(t[2]),
          I = Math.atan2(-t[0], -t[1]),
          C = new Ku();
        (C.position = w), C.setPitchBearing(S, I);
        const z = C.getWorldToCamera(l, y),
          k = T * l,
          O = Math.min(e._mercatorZfromZoom(17) * l * -2, -2 * k),
          V = C.getCameraToClipOrthographic(-k, k, -k, k, O, (k + o * y) / t[2]),
          R = new Float64Array(16);
        J.multiply(R, V, z);
        const G = N.fromValues((Math.floor(1e6 * w[0]) / 1e6) * l, (Math.floor(1e6 * w[1]) / 1e6) * l, 0),
          Z = 0.5 * n,
          X = [0, 0, 0];
        N.transformMat4(X, G, R), N.scale(X, X, Z);
        const j = [Math.floor(X[0]), Math.floor(X[1]), Math.floor(X[2])],
          q = [0, 0, 0];
        N.sub(q, X, j), N.scale(q, q, -1 / Z);
        const it = new Float64Array(16);
        return J.identity(it), J.translate(it, it, q), J.multiply(R, it, R), [R, k];
      }
      class Uz extends Oi {
        constructor(t) {
          super(), (this.requestManager = t), (this.models = { '': {} }), (this.numModelsLoading = {});
        }
        loadModel(t, i) {
          return rb(this.requestManager.transformRequest(i, dt.Model).url)
            .then((r) => {
              if (!r) return;
              const n = xm(r),
                o = new Qv(t, void 0, void 0, n);
              return o.computeBoundsAndApplyParent(), o;
            })
            .catch((r) => {
              this.fire(new re(new Error(`Could not load model ${t} from ${i}: ${r.message}`)));
            });
        }
        load(t, i) {
          this.models[i] || (this.models[i] = {});
          const r = Object.keys(t);
          this.numModelsLoading[i] = (this.numModelsLoading[i] || 0) + r.length;
          const n = [];
          for (const o of r) n.push(this.loadModel(o, t[o]));
          Promise.allSettled(n)
            .then((o) => {
              for (let s = 0; s < o.length; s++) {
                const { status: a, value: l } = o[s];
                a === 'fulfilled' && l && (this.models[i][r[s]] = l);
              }
              (this.numModelsLoading[i] -= r.length), this.fire(new wt('data', { dataType: 'style' }));
            })
            .catch((o) => {
              this.fire(new re(new Error(`Could not load models: ${o.message}`)));
            });
        }
        isLoaded() {
          for (const t in this.numModelsLoading) if (this.numModelsLoading[t] > 0) return !1;
          return !0;
        }
        hasModel(t, i) {
          return !!this.getModel(t, i);
        }
        getModel(t, i) {
          return this.models[i] || (this.models[i] = {}), this.models[i][t];
        }
        addModel(t, i, r) {
          this.models[r] || (this.models[r] = {}), this.hasModel(t, r) && this.removeModel(t, r), this.load({ [t]: this.requestManager.normalizeModelURL(i) }, r);
        }
        addModels(t, i) {
          const r = {};
          for (const n in t) r[n] = this.requestManager.normalizeModelURL(t[n]);
          this.load(r, i);
        }
        removeModel(t, i) {
          this.models[i] || (this.models[i] = {});
          const r = this.models[i][t];
          delete this.models[i][t], r.destroy();
        }
        listModels(t) {
          return this.models[t] || (this.models[t] = {}), Object.keys(this.models[t]);
        }
        upload(t, i) {
          this.models[i] || (this.models[i] = {});
          for (const r in this.models[i]) this.models[i][r].upload(t.context);
        }
      }
      const ic = (e, t) => $c(e, t && t.filter((i) => i.identifier !== 'source.canvas')),
        Vz = ar(Be, ['addLayer', 'removeLayer', 'setLights', 'setPaintProperty', 'setLayoutProperty', 'setSlot', 'setFilter', 'addSource', 'removeSource', 'setLayerZoomRange', 'setLight', 'setTransition', 'setGeoJSONSourceData', 'setTerrain', 'setFog', 'setProjection', 'setCamera', 'addImport', 'removeImport', 'setImportUrl', 'setImportData', 'setImportConfig']),
        jz = ar(Be, ['setCenter', 'setZoom', 'setBearing', 'setPitch']),
        uw = { version: 8, layers: [], sources: {} },
        hw = { duration: 300, delay: 0 },
        Gz = new Set(['fill', 'line', 'background', 'hillshade', 'raster']);
      class Mn extends Oi {
        constructor(t, i = {}) {
          super(), (this.map = t), (this.scope = i.scope || ''), (this.fragments = []), (this.importDepth = i.importDepth || 0), (this.importsCache = i.importsCache || new Map()), (this.resolvedImports = i.resolvedImports || new Set()), (this.transition = Ft({}, hw)), (this._buildingIndex = new dP(this)), (this.crossTileSymbolIndex = new kP()), (this._mergedOrder = []), (this._drapedFirstOrder = []), (this._mergedLayers = {}), (this._mergedSourceCaches = {}), (this._mergedOtherSourceCaches = {}), (this._mergedSymbolSourceCaches = {}), (this._has3DLayers = !1), (this._hasCircleLayers = !1), (this._hasSymbolLayers = !1), (this._changes = i.styleChanges || new MM()), (this.dispatcher = i.dispatcher ? i.dispatcher : new Cs(Ql(), this)), i.imageManager ? (this.imageManager = i.imageManager) : ((this.imageManager = new VC()), this.imageManager.setEventedParent(this)), this.imageManager.createScope(this.scope), (this.glyphManager = i.glyphManager ? i.glyphManager : new Aa(t._requestManager, i.localFontFamily ? 2 : i.localIdeographFontFamily ? 1 : 0, i.localFontFamily || i.localIdeographFontFamily)), i.modelManager ? (this.modelManager = i.modelManager) : ((this.modelManager = new Uz(t._requestManager)), this.modelManager.setEventedParent(this)), (this._layers = {}), (this._serializedLayers = {}), (this._sourceCaches = {}), (this._otherSourceCaches = {}), (this._symbolSourceCaches = {}), (this._loaded = !1), (this._precompileDone = !1), (this._shouldPrecompile = !1), (this._availableImages = []), (this._order = []), (this._markersNeedUpdate = !1), (this.options = new Map()), (this._configDependentLayers = new Set()), (this._config = i.config), this.dispatcher.broadcast('setReferrer', bt());
          const r = this;
          (this._rtlTextPluginCallback = Mn.registerForPluginStateChange((n) => {
            r.dispatcher.broadcast('syncRTLPluginState', { pluginStatus: n.pluginStatus, pluginURL: n.pluginURL }, (o, s) => {
              if ((hy(o), s && s.every((a) => a)))
                for (const a in r._sourceCaches) {
                  const l = r._sourceCaches[a],
                    c = l.getSource().type;
                  (c !== 'vector' && c !== 'geojson') || l.reload();
                }
            });
          })),
            this.on('data', (n) => {
              if (n.dataType !== 'source' || n.sourceDataType !== 'metadata') return;
              const o = this.getOwnSource(n.sourceId);
              if (o && o.vectorLayerIds)
                for (const s in this._layers) {
                  const a = this._layers[s];
                  a.source === o.id && this._validateLayer(a);
                }
            });
        }
        loadURL(t, i = {}) {
          this.fire(new wt('dataloading', { dataType: 'style' }));
          const r = typeof i.validate == 'boolean' ? i.validate : !Ze(t);
          (t = this.map._requestManager.normalizeStyleURL(t, i.accessToken)), this.resolvedImports.add(t);
          const n = this.importsCache.get(t);
          if (n) return this._load(n, r);
          const o = this.map._requestManager.transformRequest(t, dt.Style);
          this._request = At(o, (s, a) => {
            if (((this._request = null), s)) this.fire(new re(s));
            else if (a) return this.importsCache.set(t, a), this._load(a, r);
          });
        }
        loadJSON(t, i = {}) {
          this.fire(new wt('dataloading', { dataType: 'style' })),
            (this._request = oe.frame(() => {
              (this._request = null), this._load(t, i.validate !== !1);
            }));
        }
        loadEmpty() {
          this.fire(new wt('dataloading', { dataType: 'style' })), this._load(uw, !1);
        }
        _loadImports(t, i) {
          if (this.importDepth >= 4) return B("Style doesn't support nesting deeper than 5"), Promise.resolve();
          const r = [];
          for (const n of t) {
            const o = this._createFragmentStyle(n),
              s = new Promise((l) => {
                o.once('style.import.load', l), o.once('error', l);
              }).then(() => this.mergeAll());
            if ((r.push(s), this.resolvedImports.has(n.url))) {
              o.loadEmpty();
              continue;
            }
            const a = n.data || this.importsCache.get(n.url);
            a ? o.loadJSON(a, { validate: i }) : n.url ? o.loadURL(n.url, { validate: i }) : o.loadEmpty(), this.fragments.push({ style: o, id: n.id, config: n.config });
          }
          return Promise.allSettled(r);
        }
        _createFragmentStyle(t) {
          const i = this.scope ? pr(t.id, this.scope) : t.id,
            r = new Mn(this.map, { scope: i, styleChanges: this._changes, importDepth: this.importDepth + 1, importsCache: this.importsCache, resolvedImports: new Set(this.resolvedImports), dispatcher: this.dispatcher, imageManager: this.imageManager, glyphManager: this.glyphManager, modelManager: this.modelManager, config: t.config });
          return r.setEventedParent(this.map, { style: r }), r;
        }
        _reloadImports() {
          this.mergeAll(), this._updateMapProjection(), this.map._triggerCameraUpdate(this.camera), this.dispatcher.broadcast('setLayers', { layers: this._serializeLayers(this._order), scope: this.scope, options: this.options });
          const t = this.isRootStyle();
          (this._shouldPrecompile = t), this.fire(new wt(t ? 'style.load' : 'style.import.load'));
        }
        _load(t, i) {
          const r = t.schema;
          if (this.isRootStyle() && (t.fragment || (r && t.fragment !== !1))) {
            const s = Ft({}, uw, { imports: [{ id: 'basemap', data: t, url: '' }] });
            return void this._load(s, i);
          }
          if ((this.setConfig(this._config, r), i && ic(this, la(t)))) return;
          (this._loaded = !0), (this.stylesheet = P(t));
          for (const s in t.sources) this.addSource(s, t.sources[s], { validate: !1, isInitialLoad: !0 });
          t.sprite ? this._loadSprite(t.sprite) : (this.imageManager.setLoaded(!0, this.scope), this.dispatcher.broadcast('spriteLoaded', { scope: this.scope, isLoaded: !0 })), this.glyphManager.setURL(t.glyphs, this.scope);
          const n = lb(this.stylesheet.layers);
          if (((this._order = n.map((s) => s.id)), this.stylesheet.light && B('The `light` root property is deprecated, prefer using `lights` with `flat` light type instead.'), this.stylesheet.lights))
            if (this.stylesheet.lights.length === 1 && this.stylesheet.lights[0].type === 'flat') {
              const s = this.stylesheet.lights[0];
              this.light = new k1(s.properties, s.id);
            } else this.setLights(this.stylesheet.lights);
          this.light || (this.light = new k1(this.stylesheet.light)), (this._layers = {}), (this._serializedLayers = {});
          for (const s of n) {
            const a = oh(s, this.options);
            a.setScope(this.scope), a.isConfigDependent && this._configDependentLayers.add(a.fqid), a.setEventedParent(this, { layer: { id: a.id } }), (this._layers[a.id] = a), (this._serializedLayers[a.id] = a.serialize());
            const l = this.getOwnLayerSourceCache(a),
              c = !!this.directionalLight && this.directionalLight.shadowsEnabled();
            l && a.canCastShadows() && c && (l.castsShadows = !0);
          }
          this.stylesheet.models && this.modelManager.addModels(this.stylesheet.models, this.scope);
          const o = this.stylesheet.terrain;
          o && (this.disableElevatedTerrain === void 0 && (this.disableElevatedTerrain = oe.hasCanvasFingerprintNoise()), this.disableElevatedTerrain ? B('Terrain and hillshade are disabled because of Canvas2D limitations when fingerprinting protection is enabled (e.g. in private browsing mode).') : this.terrainSetForDrapingOnly() || this._createTerrain(o, 1)), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this.stylesheet.transition && this.setTransition(this.stylesheet.transition), this.fire(new wt('data', { dataType: 'style' })), t.imports ? this._loadImports(t.imports, i).then(() => this._reloadImports()) : this._reloadImports();
        }
        isRootStyle() {
          return this.importDepth === 0;
        }
        mergeAll() {
          let t, i, r, n, o, s, a, l;
          this.terrain && this.terrain.scope !== this.scope && delete this.terrain,
            this.forEachFragmentStyle((c) => {
              if (c.stylesheet) {
                if ((c.light != null && (t = c.light), c.stylesheet.lights)) for (const u of c.stylesheet.lights) u.type === 'ambient' && c.ambientLight != null && (i = c.ambientLight), u.type === 'directional' && c.directionalLight != null && (r = c.directionalLight);
                (n = this._prioritizeTerrain(n, c.terrain, c.stylesheet.terrain)), c.stylesheet.fog && c.fog != null && (o = c.fog), c.stylesheet.camera != null && (l = c.stylesheet.camera), c.stylesheet.projection != null && (s = c.stylesheet.projection), c.stylesheet.transition != null && (a = c.stylesheet.transition);
              }
            }),
            (this.light = t),
            (this.ambientLight = i),
            (this.directionalLight = r),
            (this.fog = o),
            n === null ? delete this.terrain : (this.terrain = n),
            (this.camera = l || { 'camera-projection': 'perspective' }),
            (this.projection = s || { name: 'mercator' }),
            (this.transition = Ft({}, hw, a)),
            this.mergeSources(),
            this.mergeLayers();
        }
        forEachFragmentStyle(t) {
          const i = (r) => {
            for (const n of r.fragments) i(n.style);
            t(r);
          };
          i(this);
        }
        _prioritizeTerrain(t, i, r) {
          const n = t && t.drapeRenderMode === 0;
          return r === null ? (i && i.drapeRenderMode === 0 ? i : n ? t : null) : i != null && (!t || n || (i && i.drapeRenderMode === 1)) ? i : t;
        }
        mergeTerrain() {
          let t;
          this.terrain && this.terrain.scope !== this.scope && delete this.terrain,
            this.forEachFragmentStyle((i) => {
              t = this._prioritizeTerrain(t, i.terrain, i.stylesheet.terrain);
            }),
            t === null ? delete this.terrain : (this.terrain = t);
        }
        mergeProjection() {
          let t;
          this.forEachFragmentStyle((i) => {
            i.stylesheet.projection != null && (t = i.stylesheet.projection);
          }),
            (this.projection = t || { name: 'mercator' });
        }
        mergeSources() {
          const t = {},
            i = {},
            r = {};
          this.forEachFragmentStyle((n) => {
            for (const o in n._sourceCaches) {
              const s = pr(o, n.scope);
              t[s] = n._sourceCaches[o];
            }
            for (const o in n._otherSourceCaches) {
              const s = pr(o, n.scope);
              i[s] = n._otherSourceCaches[o];
            }
            for (const o in n._symbolSourceCaches) {
              const s = pr(o, n.scope);
              r[s] = n._symbolSourceCaches[o];
            }
          }),
            (this._mergedSourceCaches = t),
            (this._mergedOtherSourceCaches = i),
            (this._mergedSymbolSourceCaches = r);
        }
        mergeLayers() {
          const t = {},
            i = [],
            r = {};
          (this._has3DLayers = !1),
            (this._hasCircleLayers = !1),
            (this._hasSymbolLayers = !1),
            this.forEachFragmentStyle((o) => {
              for (const s of o._order) {
                const a = o._layers[s];
                if (a.type === 'slot') {
                  const l = Yc(s);
                  if (t[l]) continue;
                  t[l] = [];
                }
                a.slot && t[a.slot] ? t[a.slot].push(a) : i.push(a);
              }
            }),
            (this._mergedOrder = []);
          const n = (o = []) => {
            for (const s of o)
              if (s.type === 'slot') {
                const a = Yc(s.id);
                t[a] && n(t[a]);
              } else {
                const a = pr(s.id, s.scope);
                this._mergedOrder.push(a), (r[a] = s), s.is3D() && (this._has3DLayers = !0), s.type === 'circle' && (this._hasCircleLayers = !0), s.type === 'symbol' && (this._hasSymbolLayers = !0);
              }
          };
          n(i), (this._mergedLayers = r), this.updateDrapeFirstLayers(), this._buildingIndex.processLayersChanged();
        }
        terrainSetForDrapingOnly() {
          return !!this.terrain && this.terrain.drapeRenderMode === 0;
        }
        getCamera() {
          return this.stylesheet.camera;
        }
        setCamera(t) {
          return (this.stylesheet.camera = Ft({}, this.stylesheet.camera, t)), (this.camera = this.stylesheet.camera), this;
        }
        setProjection(t) {
          t ? (this.stylesheet.projection = t) : delete this.stylesheet.projection, this.mergeProjection(), this._updateMapProjection();
        }
        applyProjectionUpdate() {
          this._loaded && (this.dispatcher.broadcast('setProjection', this.map.transform.projectionOptions), this.map.transform.projection.requiresDraping ? this.getTerrain() || this.stylesheet.terrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null));
        }
        _updateMapProjection() {
          this.isRootStyle() && (this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.projection));
        }
        _loadSprite(t) {
          this._spriteRequest = (function (i, r, n) {
            let o, s, a;
            const l = oe.devicePixelRatio > 1 ? '@2x' : '';
            let c = At(r.transformRequest(r.normalizeSpriteURL(i, l, '.json'), dt.SpriteJSON), (d, f) => {
                (c = null), a || ((a = d), (o = f), h());
              }),
              u = de(r.transformRequest(r.normalizeSpriteURL(i, l, '.png'), dt.SpriteImage), (d, f) => {
                (u = null), a || ((a = d), (s = f), h());
              });
            function h() {
              if (a) n(a);
              else if (o && s) {
                const d = oe.getImageData(s),
                  f = {};
                for (const p in o) {
                  const { width: _, height: g, x: y, y: v, sdf: w, pixelRatio: T, stretchX: b, stretchY: E, content: S } = o[p],
                    I = new Li({ width: _, height: g });
                  Li.copy(d, I, { x: y, y: v }, { x: 0, y: 0 }, { width: _, height: g }), (f[p] = { data: I, pixelRatio: T, sdf: w, stretchX: b, stretchY: E, content: S });
                }
                n(null, f);
              }
            }
            return {
              cancel() {
                c && (c.cancel(), (c = null)), u && (u.cancel(), (u = null));
              },
            };
          })(t, this.map._requestManager, (i, r) => {
            if (((this._spriteRequest = null), i)) this.fire(new re(i));
            else if (r) for (const n in r) this.imageManager.addImage(n, this.scope, r[n]);
            this.imageManager.setLoaded(!0, this.scope), (this._availableImages = this.imageManager.listImages(this.scope)), this.dispatcher.broadcast('setImages', { scope: this.scope, images: this._availableImages }), this.dispatcher.broadcast('spriteLoaded', { scope: this.scope, isLoaded: !0 }), this.fire(new wt('data', { dataType: 'style' }));
          });
        }
        _validateLayer(t) {
          const i = this.getOwnSource(t.source);
          if (!i) return;
          const r = t.sourceLayer;
          r && (i.type === 'geojson' || (i.vectorLayerIds && i.vectorLayerIds.indexOf(r) === -1)) && this.fire(new re(new Error(`Source layer "${r}" does not exist on source "${i.id}" as specified by style layer "${t.id}"`)));
        }
        loaded() {
          if (!this._loaded || Object.keys(this._changes.getUpdatedSourceCaches()).length) return !1;
          for (const t in this._sourceCaches) if (!this._sourceCaches[t].loaded()) return !1;
          if (!this.imageManager.isLoaded() || !this.modelManager.isLoaded()) return !1;
          for (const { style: t } of this.fragments) if (!t.loaded()) return !1;
          return !0;
        }
        _serializeImports() {
          if (this.stylesheet.imports)
            return this.stylesheet.imports.map((t, i) => {
              const r = this.fragments[i];
              return r && r.style && (t.data = r.style.serialize()), t;
            });
        }
        _serializeSources() {
          const t = {};
          for (const i in this._sourceCaches) {
            const r = this._sourceCaches[i].getSource();
            t[r.id] || (t[r.id] = r.serialize());
          }
          return t;
        }
        _serializeLayers(t) {
          const i = [];
          for (const r of t) {
            const n = this._layers[r];
            n && n.type !== 'custom' && i.push(n.serialize());
          }
          return i;
        }
        hasLightTransitions() {
          return !(!this.light || !this.light.hasTransition()) || !(!this.ambientLight || !this.ambientLight.hasTransition()) || !(!this.directionalLight || !this.directionalLight.hasTransition());
        }
        hasFogTransition() {
          return !!this.fog && this.fog.hasTransition();
        }
        hasTransitions() {
          if (this.hasLightTransitions() || this.hasFogTransition()) return !0;
          for (const t in this._sourceCaches) if (this._sourceCaches[t].hasTransition()) return !0;
          for (const t in this._layers) if (this._layers[t].hasTransition()) return !0;
          return !1;
        }
        get order() {
          return this.terrain ? this._drapedFirstOrder : this._mergedOrder;
        }
        isLayerDraped(t) {
          return !!this.terrain && (typeof t.isLayerDraped == 'function' ? t.isLayerDraped(this.getLayerSourceCache(t)) : Gz.has(t.type));
        }
        _checkLoaded() {
          if (!this._loaded) throw new Error('Style is not done loading');
        }
        _checkLayer(t) {
          const i = this.getOwnLayer(t);
          if (i) return i;
          this.fire(new re(new Error(`The layer '${t}' does not exist in the map's style.`)));
        }
        _checkSource(t) {
          const i = this.getOwnSource(t);
          if (i) return i;
          this.fire(new re(new Error(`The source '${t}' does not exist in the map's style.`)));
        }
        update(t) {
          if (!this._loaded) return;
          this.ambientLight && this.ambientLight.recalculate(t), this.directionalLight && this.directionalLight.recalculate(t);
          const i = this.calculateLightsBrightness();
          (t.brightness = i || 0), i !== this._brightness && ((this._brightness = i), this.dispatcher.broadcast('setBrightness', i));
          const r = this._changes.isDirty();
          if (this._changes.isDirty()) {
            const o = this._changes.getLayerUpdatesByScope();
            for (const s in o) {
              const { updatedIds: a, removedIds: l } = o[s];
              (a || l) && this._updateWorkerLayers(s, a, l);
            }
            this.updateSourceCaches(), this._updateTilesForChangedImages(), this.updateLayers(t), this.light && this.light.updateTransitions(t), this.ambientLight && this.ambientLight.updateTransitions(t), this.directionalLight && this.directionalLight.updateTransitions(t), this.fog && this.fog.updateTransitions(t), this._changes.reset();
          }
          const n = {};
          for (const o in this._mergedSourceCaches) {
            const s = this._mergedSourceCaches[o];
            (n[o] = s.used), (s.used = !1);
          }
          for (const o of this._mergedOrder) {
            const s = this._mergedLayers[o];
            if ((s.recalculate(t, this._availableImages), !s.isHidden(t.zoom))) {
              const a = this.getLayerSourceCache(s);
              a && (a.used = !0);
            }
            if (!this._precompileDone && this._shouldPrecompile)
              for (let a = s.minzoom || 0; a < (s.maxzoom || 25.5); a++) {
                const l = this.map.painter;
                if (l) {
                  const c = s.getProgramIds();
                  if (!c) continue;
                  for (const u of c) {
                    const h = s.getDefaultProgramParams(u, t.zoom);
                    h && ((l.style = this), this.fog && ((l._fogVisible = !0), (h.overrideFog = !0), l.getOrCreateProgram(u, h)), (l._fogVisible = !1), (h.overrideFog = !1), l.getOrCreateProgram(u, h), (this.stylesheet.terrain || (this.stylesheet.projection && this.stylesheet.projection.name === 'globe')) && ((h.overrideRtt = !0), l.getOrCreateProgram(u, h)));
                  }
                }
              }
          }
          this._shouldPrecompile && (this._precompileDone = !0);
          for (const o in n) {
            const s = this._mergedSourceCaches[o];
            n[o] !== s.used && s.getSource().fire(new wt('data', { sourceDataType: 'visibility', dataType: 'source', sourceId: s.getSource().id }));
          }
          this.light && this.light.recalculate(t), this.terrain && this.terrain.recalculate(t), this.fog && this.fog.recalculate(t), (this.z = t.zoom), this._markersNeedUpdate && (this._updateMarkersOpacity(), (this._markersNeedUpdate = !1)), r && this.fire(new wt('data', { dataType: 'style' }));
        }
        _updateTilesForChangedImages() {
          const t = this._changes.getUpdatedImages();
          if (t.length) {
            for (const i in this._sourceCaches) this._sourceCaches[i].reloadTilesForDependencies(['icons', 'patterns'], t);
            this._changes.resetUpdatedImages();
          }
        }
        _updateWorkerLayers(t, i, r) {
          const n = this.getFragmentStyle(t);
          n && this.dispatcher.broadcast('updateLayers', { layers: i ? n._serializeLayers(i) : [], scope: t, removedIds: r || [], options: n.options });
        }
        setState(t) {
          if ((this._checkLoaded(), ic(this, la(t)))) return !1;
          (t = P(t)).layers = lb(t.layers);
          const i = (function (n, o) {
            if (!n) return [{ command: Be.setStyle, args: [o] }];
            let s = [];
            try {
              if (!we(n.version, o.version)) return [{ command: Be.setStyle, args: [o] }];
              we(n.center, o.center) || s.push({ command: Be.setCenter, args: [o.center] }),
                we(n.zoom, o.zoom) || s.push({ command: Be.setZoom, args: [o.zoom] }),
                we(n.bearing, o.bearing) || s.push({ command: Be.setBearing, args: [o.bearing] }),
                we(n.pitch, o.pitch) || s.push({ command: Be.setPitch, args: [o.pitch] }),
                we(n.sprite, o.sprite) || s.push({ command: Be.setSprite, args: [o.sprite] }),
                we(n.glyphs, o.glyphs) || s.push({ command: Be.setGlyphs, args: [o.glyphs] }),
                we(n.imports, o.imports) ||
                  (function (h = [], d = [], f) {
                    d = d || [];
                    const p = (h = h || []).map(uh),
                      _ = d.map(uh),
                      g = h.reduce(hh, {}),
                      y = d.reduce(hh, {}),
                      v = p.slice();
                    let w, T, b, E;
                    for (w = 0, T = 0; w < p.length; w++) (b = p[w]), y.hasOwnProperty(b) ? T++ : (f.push({ command: Be.removeImport, args: [b] }), v.splice(v.indexOf(b, T), 1));
                    for (w = 0, T = 0; w < _.length; w++) (b = _[_.length - 1 - w]), v[v.length - 1 - w] !== b && (g.hasOwnProperty(b) ? (f.push({ command: Be.removeImport, args: [b] }), v.splice(v.lastIndexOf(b, v.length - T), 1)) : T++, (E = v[v.length - w]), f.push({ command: Be.addImport, args: [y[b], E] }), v.splice(v.length - w, 0, b));
                    for (const S of d) {
                      const I = g[S.id];
                      if (!I || we(I, S)) continue;
                      we(I.config, S.config) || f.push({ command: Be.setImportConfig, args: [S.id, S.config] }), we(I.url, S.url) || f.push({ command: Be.setImportUrl, args: [S.id, S.url] });
                      const C = S.data;
                      we(I && I.data, C) || f.push({ command: Be.setImportData, args: [S.id, C] });
                    }
                  })(n.imports, o.imports, s),
                we(n.transition, o.transition) || s.push({ command: Be.setTransition, args: [o.transition] }),
                we(n.light, o.light) || s.push({ command: Be.setLight, args: [o.light] }),
                we(n.fog, o.fog) || s.push({ command: Be.setFog, args: [o.fog] }),
                we(n.projection, o.projection) || s.push({ command: Be.setProjection, args: [o.projection] }),
                we(n.lights, o.lights) || s.push({ command: Be.setLights, args: [o.lights] }),
                we(n.camera, o.camera) || s.push({ command: Be.setCamera, args: [o.camera] });
              const a = {},
                l = [];
              (function (h, d, f, p) {
                let _;
                for (_ in ((d = d || {}), (h = h || {}))) h.hasOwnProperty(_) && (d.hasOwnProperty(_) || ub(_, f, p));
                for (_ in d) {
                  if (!d.hasOwnProperty(_)) continue;
                  const g = d[_];
                  h.hasOwnProperty(_) ? we(h[_], g) || (h[_].type === 'geojson' && g.type === 'geojson' && mP(h, d, _) ? f.push({ command: Be.setGeoJSONSourceData, args: [_, g.data] }) : pP(_, d, f, p)) : cb(_, d, f);
                }
              })(n.sources, o.sources, l, a);
              const c = [];
              n.layers &&
                n.layers.forEach((h) => {
                  h.source && a[h.source] ? s.push({ command: Be.removeLayer, args: [h.id] }) : c.push(h);
                });
              let u = n.terrain;
              u && a[u.source] && (s.push({ command: Be.setTerrain, args: [void 0] }), (u = void 0)),
                (s = s.concat(l)),
                we(u, o.terrain) || s.push({ command: Be.setTerrain, args: [o.terrain] }),
                (function (h, d, f) {
                  d = d || [];
                  const p = (h = h || []).map(uh),
                    _ = d.map(uh),
                    g = h.reduce(hh, {}),
                    y = d.reduce(hh, {}),
                    v = p.slice(),
                    w = Object.create(null);
                  let T, b, E, S, I, C, z;
                  for (T = 0, b = 0; T < p.length; T++) (E = p[T]), y.hasOwnProperty(E) ? b++ : (f.push({ command: Be.removeLayer, args: [E] }), v.splice(v.indexOf(E, b), 1));
                  for (T = 0, b = 0; T < _.length; T++) (E = _[_.length - 1 - T]), v[v.length - 1 - T] !== E && (g.hasOwnProperty(E) ? (f.push({ command: Be.removeLayer, args: [E] }), v.splice(v.lastIndexOf(E, v.length - b), 1)) : b++, (C = v[v.length - T]), f.push({ command: Be.addLayer, args: [y[E], C] }), v.splice(v.length - T, 0, E), (w[E] = !0));
                  for (T = 0; T < _.length; T++)
                    if (((E = _[T]), (S = g[E]), (I = y[E]), !w[E] && !we(S, I)))
                      if (we(S.source, I.source) && we(S['source-layer'], I['source-layer']) && we(S.type, I.type)) {
                        for (z in (ch(S.layout, I.layout, f, E, null, Be.setLayoutProperty), ch(S.paint, I.paint, f, E, null, Be.setPaintProperty), we(S.slot, I.slot) || f.push({ command: Be.setSlot, args: [E, I.slot] }), we(S.filter, I.filter) || f.push({ command: Be.setFilter, args: [E, I.filter] }), (we(S.minzoom, I.minzoom) && we(S.maxzoom, I.maxzoom)) || f.push({ command: Be.setLayerZoomRange, args: [E, I.minzoom, I.maxzoom] }), S)) S.hasOwnProperty(z) && z !== 'layout' && z !== 'paint' && z !== 'filter' && z !== 'metadata' && z !== 'minzoom' && z !== 'maxzoom' && z !== 'slot' && (z.indexOf('paint.') === 0 ? ch(S[z], I[z], f, E, z.slice(6), Be.setPaintProperty) : we(S[z], I[z]) || f.push({ command: Be.setLayerProperty, args: [E, z, I[z]] }));
                        for (z in I) I.hasOwnProperty(z) && !S.hasOwnProperty(z) && z !== 'layout' && z !== 'paint' && z !== 'filter' && z !== 'metadata' && z !== 'minzoom' && z !== 'maxzoom' && z !== 'slot' && (z.indexOf('paint.') === 0 ? ch(S[z], I[z], f, E, z.slice(6), Be.setPaintProperty) : we(S[z], I[z]) || f.push({ command: Be.setLayerProperty, args: [E, z, I[z]] }));
                      } else f.push({ command: Be.removeLayer, args: [E] }), (C = v[v.lastIndexOf(E) + 1]), f.push({ command: Be.addLayer, args: [I, C] });
                })(c, o.layers, s);
            } catch (a) {
              console.warn('Unable to compute style diff:', a), (s = [{ command: Be.setStyle, args: [o] }]);
            }
            return s;
          })(this.serialize(), t).filter((n) => !(n.command in jz));
          if (i.length === 0) return !1;
          const r = i.filter((n) => !(n.command in Vz));
          if (r.length > 0) throw new Error(`Unimplemented: ${r.map((n) => n.command).join(', ')}.`);
          return (
            i.forEach((n) => {
              this[n.command].apply(this, n.args);
            }),
            (this.stylesheet = t),
            this.mergeAll(),
            this.dispatcher.broadcast('setLayers', { layers: this._serializeLayers(this._order), scope: this.scope, options: this.options }),
            !0
          );
        }
        addImage(t, i) {
          return this.getImage(t) ? this.fire(new re(new Error('An image with this name already exists.'))) : (this.imageManager.addImage(t, this.scope, i), this._afterImageUpdated(t), this);
        }
        updateImage(t, i) {
          this.imageManager.updateImage(t, this.scope, i);
        }
        getImage(t) {
          return this.imageManager.getImage(t, this.scope);
        }
        removeImage(t) {
          return this.getImage(t) ? (this.imageManager.removeImage(t, this.scope), this._afterImageUpdated(t), this) : this.fire(new re(new Error('No image with this name exists.')));
        }
        _afterImageUpdated(t) {
          (this._availableImages = this.imageManager.listImages(this.scope)), this._changes.updateImage(t), this.dispatcher.broadcast('setImages', { scope: this.scope, images: this._availableImages }), this.fire(new wt('data', { dataType: 'style' }));
        }
        listImages() {
          return this._checkLoaded(), this._availableImages.slice();
        }
        addModel(t, i, r = {}) {
          return this._checkLoaded(), this._validate(yM, `models.${t}`, i, null, r) || (this.modelManager.addModel(t, i, this.scope), this._changes.setDirty()), this;
        }
        hasModel(t) {
          return this.modelManager.hasModel(t, this.scope);
        }
        removeModel(t) {
          return this.hasModel(t) ? (this.modelManager.removeModel(t, this.scope), this) : this.fire(new re(new Error('No model with this ID exists.')));
        }
        listModels() {
          return this._checkLoaded(), this.modelManager.listModels(this.scope);
        }
        addSource(t, i, r = {}) {
          if ((this._checkLoaded(), this.getOwnSource(t) !== void 0)) throw new Error(`There is already a source with ID "${t}".`);
          if (!i.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i).join(', ')}.`);
          if (['vector', 'raster', 'geojson', 'video', 'image'].indexOf(i.type) >= 0 && this._validate(uM, `sources.${t}`, i, null, r)) return;
          this.map && this.map._collectResourceTiming && (i.collectResourceTiming = !0);
          const n = bm(t, i, this.dispatcher, this);
          (n.scope = this.scope), n.setEventedParent(this, () => ({ isSourceLoaded: this._isSourceCacheLoaded(n.id), source: n.serialize(), sourceId: n.id }));
          const o = (s) => {
            const a = (s ? 'symbol:' : 'other:') + n.id,
              l = pr(a, this.scope),
              c = (this._sourceCaches[a] = new wn(l, n, s));
            ((s ? this._symbolSourceCaches : this._otherSourceCaches)[n.id] = c), c.onAdd(this.map);
          };
          o(!1), (i.type !== 'vector' && i.type !== 'geojson') || o(!0), n.onAdd && n.onAdd(this.map), r.isInitialLoad || (this.mergeSources(), this._changes.setDirty());
        }
        removeSource(t) {
          this._checkLoaded();
          const i = this.getOwnSource(t);
          if (!i) throw new Error('There is no source with this ID');
          for (const n in this._layers) if (this._layers[n].source === t) return this.fire(new re(new Error(`Source "${t}" cannot be removed while layer "${n}" is using it.`)));
          if (this.terrain && this.terrain.scope === this.scope && this.terrain.get().source === t) return this.fire(new re(new Error(`Source "${t}" cannot be removed while terrain is using it.`)));
          const r = this.getOwnSourceCaches(t);
          for (const n of r) {
            const o = Yc(n.id);
            delete this._sourceCaches[o], this._changes.discardSourceCacheUpdate(n.id), n.fire(new wt('data', { sourceDataType: 'metadata', dataType: 'source', sourceId: n.getSource().id })), n.setEventedParent(null), n.clearTiles();
          }
          return delete this._otherSourceCaches[t], delete this._symbolSourceCaches[t], this.mergeSources(), i.setEventedParent(null), i.onRemove && i.onRemove(this.map), this._changes.setDirty(), this;
        }
        setGeoJSONSourceData(t, i) {
          this._checkLoaded(), this.getOwnSource(t).setData(i), this._changes.setDirty();
        }
        getOwnSource(t) {
          const i = this.getOwnSourceCache(t);
          return i && i.getSource();
        }
        getOwnSources() {
          const t = [];
          for (const i in this._otherSourceCaches) {
            const r = this.getOwnSourceCache(i);
            r && t.push(r.getSource());
          }
          return t;
        }
        setLights(t) {
          if ((this._checkLoaded(), !t)) return delete this.ambientLight, void delete this.directionalLight;
          const i = this._getTransitionParameters();
          for (const n of t) {
            if (this._validate(dM, 'lights', n)) return;
            switch (n.type) {
              case 'ambient':
                if (this.ambientLight) {
                  const o = this.ambientLight;
                  o.set(n), o.updateTransitions(i);
                } else this.ambientLight = new j1(n, XC, this.scope, this.options);
                break;
              case 'directional':
                if (this.directionalLight) {
                  const o = this.directionalLight;
                  o.set(n), o.updateTransitions(i);
                } else this.directionalLight = new j1(n, YC, this.scope, this.options);
            }
          }
          const r = new gi(this.z || 0, i);
          this.ambientLight && this.ambientLight.recalculate(r), this.directionalLight && this.directionalLight.recalculate(r), (this._brightness = this.calculateLightsBrightness()), this.dispatcher.broadcast('setBrightness', this._brightness);
        }
        calculateLightsBrightness() {
          const t = this.directionalLight,
            i = this.ambientLight;
          if (!t || !i) return;
          const r = (h) => 0.2126 * (h[0] <= 0.03928 ? h[0] / 12.92 : Math.pow((h[0] + 0.055) / 1.055, 2.4)) + 0.7152 * (h[1] <= 0.03928 ? h[1] / 12.92 : Math.pow((h[1] + 0.055) / 1.055, 2.4)) + 0.0722 * (h[2] <= 0.03928 ? h[2] / 12.92 : Math.pow((h[2] + 0.055) / 1.055, 2.4)),
            n = t.properties.get('color').toArray01(),
            o = t.properties.get('intensity'),
            s = t.properties.get('direction'),
            a = 1 - gt(s.x, s.y, s.z)[2] / 90,
            l = r(n) * o * a,
            c = i.properties.get('color').toArray01(),
            u = i.properties.get('intensity');
          return (l + r(c) * u) / 2;
        }
        getBrightness() {
          return this._brightness;
        }
        getLights() {
          if (!this.enable3dLights()) return null;
          const t = [];
          return this.directionalLight && t.push(this.directionalLight.get()), this.ambientLight && t.push(this.ambientLight.get()), t;
        }
        enable3dLights() {
          return !!this.ambientLight && !!this.directionalLight;
        }
        getFragmentStyle(t) {
          if (!t) return this;
          if (my(t)) {
            const i = (function (o) {
                const s = o.indexOf(Xc);
                return s >= 0 ? o.slice(s + 1) : '';
              })(t),
              r = this.fragments.find(({ id: o }) => o === i);
            if (!r) throw new Error(`Style import not found: ${t}`);
            const n = Yc(t);
            return r.style.getFragmentStyle(n);
          }
          {
            const i = this.fragments.find(({ id: r }) => r === t);
            if (!i) throw new Error(`Style import not found: ${t}`);
            return i.style;
          }
        }
        getConfigProperty(t, i) {
          const r = this.getFragmentStyle(t);
          if (!r) return null;
          const n = r.options.get(i),
            o = n ? n.value || n.default : null;
          return o ? o.serialize() : null;
        }
        setConfigProperty(t, i, r) {
          const n = So(r);
          if (n.result !== 'success') return void ic(this, n.value);
          const o = n.value.expression,
            s = this.getFragmentStyle(t);
          if (!s) return;
          const a = s.options.get(i);
          a && (s.options.set(i, { ...a, value: o }), s.updateConfigDependencies());
        }
        setConfig(t, i) {
          if (((this._config = t), t || i))
            if (i) {
              this.options.clear();
              for (const r in i) {
                let n, o;
                const s = So(i[r].default);
                if ((s.result === 'success' && (n = s.value.expression), t && t[r] !== void 0)) {
                  const d = So(t[r]);
                  d.result === 'success' && (o = d.value.expression);
                }
                const { minValue: a, maxValue: l, stepValue: c, type: u, values: h } = i[r];
                n ? this.options.set(r, { default: n, value: o, minValue: a, maxValue: l, stepValue: c, type: u, values: h }) : this.fire(new re(new Error(`No schema defined for config option "${r}".`)));
              }
            } else this.fire(new re(new Error('Attempting to set config for a style without schema.')));
        }
        updateConfigDependencies() {
          for (const t of this._configDependentLayers) {
            const i = this.getLayer(t);
            i && (i.possiblyEvaluateVisibility(), this._updateLayer(i));
          }
          this.ambientLight && this.ambientLight.scope === this.scope && this.ambientLight.updateConfig(this.options), this.directionalLight && this.directionalLight.scope === this.scope && this.directionalLight.updateConfig(this.options), this._changes.setDirty();
        }
        addLayer(t, i, r = {}) {
          this._checkLoaded();
          const n = t.id;
          if (this._layers[n]) return void this.fire(new re(new Error(`Layer with id "${n}" already exists on this map`)));
          let o;
          if (t.type === 'custom') {
            if (
              ic(
                this,
                (function (u) {
                  const h = [],
                    d = u.id;
                  return d === void 0 && h.push({ message: `layers.${d}: missing required property "id"` }), u.render === void 0 && h.push({ message: `layers.${d}: missing required method "render"` }), u.renderingMode && u.renderingMode !== '2d' && u.renderingMode !== '3d' && h.push({ message: `layers.${d}: property "renderingMode" must be either "2d" or "3d"` }), h;
                })(t)
              )
            )
              return;
            o = oh(t, this.options);
          } else {
            if ((typeof t.source == 'object' && (this.addSource(n, t.source), (t = Ft((t = P(t)), { source: n }))), this._validate(mM, `layers.${n}`, t, { arrayIndex: -1 }, r))) return;
            (o = oh(t, this.options)), this._validateLayer(o), o.setEventedParent(this, { layer: { id: n } }), (this._serializedLayers[o.id] = o.serialize());
          }
          o.isConfigDependent && this._configDependentLayers.add(o.fqid), o.setScope(this.scope);
          let s = this._order.length;
          if (i) {
            const u = this._order.indexOf(i);
            if (u === -1) return void this.fire(new re(new Error(`Layer with id "${i}" does not exist on this map.`)));
            o.slot === this._layers[i].slot ? (s = u) : B(`Layer with id "${i}" has a different slot. Layers can only be rearranged within the same slot.`);
          }
          this._order.splice(s, 0, n), (this._layerOrderChanged = !0), (this._layers[n] = o);
          const a = this.getOwnLayerSourceCache(o),
            l = !!this.directionalLight && this.directionalLight.shadowsEnabled();
          a && o.canCastShadows() && l && (a.castsShadows = !0);
          const c = this._changes.getRemovedLayer(o);
          if (c && o.source && a && o.type !== 'custom') {
            this._changes.discardLayerRemoval(o);
            const u = pr(o.source, o.scope);
            c.type !== o.type ? this._changes.updateSourceCache(u, 'clear') : (this._changes.updateSourceCache(u, 'reload'), a.pause());
          }
          this._updateLayer(o), o.onAdd && o.onAdd(this.map), (o.scope = this.scope), this.mergeLayers();
        }
        moveLayer(t, i) {
          this._checkLoaded();
          const r = this._checkLayer(t);
          if (!r || t === i) return;
          const n = this._order.indexOf(t);
          this._order.splice(n, 1);
          let o = this._order.length;
          if (i) {
            const s = this._order.indexOf(i);
            if (s === -1) return void this.fire(new re(new Error(`Layer with id "${i}" does not exist on this map.`)));
            r.slot === this._layers[i].slot ? (o = s) : B(`Layer with id "${i}" has a different slot. Layers can only be rearranged within the same slot.`);
          }
          this._order.splice(o, 0, t), this._changes.setDirty(), (this._layerOrderChanged = !0), this.mergeLayers();
        }
        removeLayer(t) {
          this._checkLoaded();
          const i = this._checkLayer(t);
          if (!i) return;
          i.setEventedParent(null);
          const r = this._order.indexOf(t);
          this._order.splice(r, 1), delete this._layers[t], delete this._serializedLayers[t], this._changes.setDirty(), (this._layerOrderChanged = !0), this._configDependentLayers.delete(i.fqid), this._changes.removeLayer(i);
          const n = this.getOwnLayerSourceCache(i);
          if (n && n.castsShadows) {
            let o = !1;
            for (const s in this._layers)
              if (this._layers[s].source === i.source && this._layers[s].canCastShadows()) {
                o = !0;
                break;
              }
            n.castsShadows = o;
          }
          i.onRemove && i.onRemove(this.map), this.mergeLayers();
        }
        getOwnLayer(t) {
          return this._layers[t];
        }
        hasLayer(t) {
          return t in this._mergedLayers;
        }
        hasLayerType(t) {
          for (const i in this._layers) if (this._layers[i].type === t) return !0;
          return !1;
        }
        setLayerZoomRange(t, i, r) {
          this._checkLoaded();
          const n = this._checkLayer(t);
          n && ((n.minzoom === i && n.maxzoom === r) || (i != null && (n.minzoom = i), r != null && (n.maxzoom = r), this._updateLayer(n)));
        }
        setSlot(t, i) {
          this._checkLoaded();
          const r = this._checkLayer(t);
          r && r.slot !== i && ((r.slot = i), this._updateLayer(r));
        }
        setFilter(t, i, r = {}) {
          this._checkLoaded();
          const n = this._checkLayer(t);
          if (n && !we(n.filter, i)) return i == null ? ((n.filter = void 0), void this._updateLayer(n)) : void (this._validate(mf, `layers.${n.id}.filter`, i, { layerType: n.type }, r) || ((n.filter = P(i)), this._updateLayer(n)));
        }
        getFilter(t) {
          const i = this._checkLayer(t);
          if (i) return P(i.filter);
        }
        setLayoutProperty(t, i, r, n = {}) {
          this._checkLoaded();
          const o = this._checkLayer(t);
          o && (we(o.getLayoutProperty(i), r) || (o.setLayoutProperty(i, r, n), o.isConfigDependent && this._configDependentLayers.add(o.fqid), this._updateLayer(o)));
        }
        getLayoutProperty(t, i) {
          const r = this._checkLayer(t);
          if (r) return r.getLayoutProperty(i);
        }
        setPaintProperty(t, i, r, n = {}) {
          this._checkLoaded();
          const o = this._checkLayer(t);
          if (!o || we(o.getPaintProperty(i), r)) return;
          const s = o.setPaintProperty(i, r, n);
          o.isConfigDependent && this._configDependentLayers.add(o.fqid), s && this._updateLayer(o), this._changes.updatePaintProperties(o);
        }
        getPaintProperty(t, i) {
          const r = this._checkLayer(t);
          if (r) return r.getPaintProperty(i);
        }
        setFeatureState(t, i) {
          this._checkLoaded();
          const r = t.source,
            n = t.sourceLayer,
            o = this._checkSource(r);
          if (!o) return;
          const s = o.type;
          if (s === 'geojson' && n) return void this.fire(new re(new Error('GeoJSON sources cannot have a sourceLayer parameter.')));
          if (s === 'vector' && !n) return void this.fire(new re(new Error('The sourceLayer parameter must be provided for vector source types.')));
          t.id === void 0 && this.fire(new re(new Error('The feature id parameter must be provided.')));
          const a = this.getOwnSourceCaches(r);
          for (const l of a) l.setFeatureState(n, t.id, i);
        }
        removeFeatureState(t, i) {
          this._checkLoaded();
          const r = t.source,
            n = this._checkSource(r);
          if (!n) return;
          const o = n.type,
            s = o === 'vector' ? t.sourceLayer : void 0;
          if (o === 'vector' && !s) return void this.fire(new re(new Error('The sourceLayer parameter must be provided for vector source types.')));
          if (i && typeof t.id != 'string' && typeof t.id != 'number') return void this.fire(new re(new Error('A feature id is required to remove its specific state property.')));
          const a = this.getOwnSourceCaches(r);
          for (const l of a) l.removeFeatureState(s, t.id, i);
        }
        getFeatureState(t) {
          this._checkLoaded();
          const i = t.source,
            r = t.sourceLayer,
            n = this._checkSource(i);
          if (n) {
            if (n.type !== 'vector' || r) return t.id === void 0 && this.fire(new re(new Error('The feature id parameter must be provided.'))), this.getOwnSourceCaches(i)[0].getFeatureState(r, t.id);
            this.fire(new re(new Error('The sourceLayer parameter must be provided for vector source types.')));
          }
        }
        setTransition(t) {
          return (this.stylesheet.transition = Ft({}, this.stylesheet.transition, t)), (this.transition = this.stylesheet.transition), this;
        }
        getTransition() {
          return Ft({}, this.stylesheet.transition);
        }
        serialize() {
          this._checkLoaded();
          const t = this.getTerrain(),
            i = t && this.terrain && this.terrain.scope === this.scope ? t : this.stylesheet.terrain;
          return tt({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, imports: this._serializeImports(), schema: this.stylesheet.schema, camera: this.stylesheet.camera, light: this.stylesheet.light, lights: this.stylesheet.lights, terrain: i, fog: this.stylesheet.fog, center: this.stylesheet.center, zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, projection: this.stylesheet.projection, sources: this._serializeSources(), layers: this._serializeLayers(this._order) }, (r) => r !== void 0);
        }
        _updateLayer(t) {
          this._changes.updateLayer(t);
          const i = this.getLayerSourceCache(t),
            r = pr(t.source, t.scope),
            n = this._changes.getUpdatedSourceCaches();
          t.source && !n[r] && i && i.getSource().type !== 'raster' && (this._changes.updateSourceCache(r, 'reload'), i.pause()), t.invalidateCompiledFilter();
        }
        _flattenAndSortRenderedFeatures(t) {
          const i = (a) => this._mergedLayers[a].type === 'fill-extrusion',
            r = this.order,
            n = {},
            o = [];
          for (let a = r.length - 1; a >= 0; a--) {
            const l = r[a];
            if (i(l)) {
              n[l] = a;
              for (const c of t) {
                const u = c[l];
                if (u) for (const h of u) o.push(h);
              }
            }
          }
          o.sort((a, l) => l.intersectionZ - a.intersectionZ);
          const s = [];
          for (let a = r.length - 1; a >= 0; a--) {
            const l = r[a];
            if (i(l))
              for (let c = o.length - 1; c >= 0; c--) {
                const u = o[c].feature;
                if (n[u.layer.id] < a) break;
                s.push(u), o.pop();
              }
            else
              for (const c of t) {
                const u = c[l];
                if (u) for (const h of u) s.push(h.feature);
              }
          }
          return s;
        }
        queryRenderedFeatures(t, i, r) {
          i && i.filter && this._validate(mf, 'queryRenderedFeatures.filter', i.filter, null, i), (i.scope = this.scope), (i.availableImages = this._availableImages), (i.serializedLayers = this._serializedLayers);
          const n = {};
          if (i && i.layers) {
            if (!Array.isArray(i.layers)) return this.fire(new re(new Error('parameters.layers must be an Array.'))), [];
            for (const c of i.layers) {
              const u = this._mergedLayers[c];
              if (!u) return this.fire(new re(new Error(`The layer '${c}' does not exist in the map's style and cannot be queried for features.`))), [];
              n[u.source] = !0;
            }
          }
          const o = [],
            s = i.serializedLayers || {},
            a =
              i && i.layers
                ? i.layers.some((c) => {
                    const u = this.getLayer(c);
                    return u && u.is3D();
                  })
                : this.has3DLayers(),
            l = sm.createFromScreenPoints(t, r);
          for (const c in this._mergedSourceCaches) {
            const u = this._mergedSourceCaches[c].getSource();
            if (!u || u.scope !== i.scope) continue;
            const h = this._mergedSourceCaches[c].getSource().id;
            (i.layers && !n[h]) || o.push(uP(this._mergedSourceCaches[c], this._mergedLayers, s, l, i, r, a, !!this.map._showQueryGeometry));
          }
          return (
            this.placement &&
              o.push(
                (function (c, u, h, d, f, p, _) {
                  const g = {},
                    y = p.queryRenderedSymbols(d),
                    v = [];
                  for (const w of Object.keys(y).map(Number)) v.push(_[w]);
                  v.sort(sb);
                  for (const w of v) {
                    const T = w.featureIndex.lookupSymbolFeatures(y[w.bucketInstanceId], u, w.bucketIndex, w.sourceLayerIndex, f.filter, f.layers, f.availableImages, c);
                    for (const b in T) {
                      const E = (g[b] = g[b] || []),
                        S = T[b];
                      S.sort((I, C) => {
                        const z = w.featureSortOrder;
                        if (z) {
                          const k = z.indexOf(I.featureIndex);
                          return z.indexOf(C.featureIndex) - k;
                        }
                        return C.featureIndex - I.featureIndex;
                      });
                      for (const I of S) E.push(I);
                    }
                  }
                  for (const w in g)
                    g[w].forEach((T) => {
                      const b = T.feature,
                        E = h(c[w]);
                      if (!E) return;
                      const S = E.getFeatureState(b.layer['source-layer'], b.id);
                      (b.source = b.layer.source), b.layer['source-layer'] && (b.sourceLayer = b.layer['source-layer']), (b.state = S);
                    });
                  return g;
                })(this._mergedLayers, s, this.getLayerSourceCache.bind(this), l.screenGeometry, i, this.placement.collisionIndex, this.placement.retainedQueryData)
              ),
            this._flattenAndSortRenderedFeatures(o)
          );
        }
        querySourceFeatures(t, i) {
          i && i.filter && this._validate(mf, 'querySourceFeatures.filter', i.filter, null, i);
          const r = this.getOwnSourceCaches(t);
          let n = [];
          for (const o of r) n = n.concat(hP(o, i));
          return n;
        }
        addSourceType(t, i, r) {
          return Mn.getSourceType(t) ? r(new Error(`A source type called "${t}" already exists.`)) : (Mn.setSourceType(t, i), i.workerSourceURL ? void this.dispatcher.broadcast('loadWorkerSource', { name: t, url: i.workerSourceURL }, r) : r(null, null));
        }
        getFlatLight() {
          return this.light.getLight();
        }
        setFlatLight(t, i, r = {}) {
          this._checkLoaded();
          const n = this.light.getLight();
          let o = !1;
          for (const a in t)
            if (!we(t[a], n[a])) {
              o = !0;
              break;
            }
          if (!o) return;
          const s = this._getTransitionParameters();
          this.light.setLight(t, i, r), this.light.updateTransitions(s);
        }
        getTerrain() {
          return this.terrain && this.terrain.drapeRenderMode === 1 ? this.terrain.get() : null;
        }
        setTerrainForDraping() {
          this.setTerrain({ source: '', exaggeration: 0 }, 0);
        }
        setTerrain(t, i = 1) {
          if ((this._checkLoaded(), !t)) return delete this.terrain, t === null ? (this.stylesheet.terrain = null) : delete this.stylesheet.terrain, this._force3DLayerUpdate(), void (this._markersNeedUpdate = !0);
          let r = t;
          const n = t.source == null;
          if (i === 1) {
            if (typeof r.source == 'object') {
              const a = 'terrain-dem-src';
              this.addSource(a, r.source), (r = P(r)), (r = Ft(r, { source: a }));
            }
            const o = Ft({}, r),
              s = {};
            if (this.terrain && n) {
              o.source = this.terrain.get().source;
              const a = this.terrain ? this.getFragmentStyle(this.terrain.scope) : null;
              a && (s.style = a.serialize());
            }
            if (this._validate(fM, 'terrain', o, s)) return;
          }
          if (!this.terrain || (this.terrain.scope !== this.scope && !n) || (this.terrain && i !== this.terrain.drapeRenderMode)) {
            if (!r) return;
            this._createTerrain(r, i), this.fire(new wt('data', { dataType: 'style' }));
          } else {
            const o = this.terrain,
              s = o.get();
            for (const a of Object.keys(Q.terrain)) !r.hasOwnProperty(a) && Q.terrain[a].default && (r[a] = Q.terrain[a].default);
            for (const a in t)
              if (!we(t[a], s[a])) {
                o.set(t, this.options), (this.stylesheet.terrain = t);
                const l = this._getTransitionParameters({ duration: 0 });
                o.updateTransitions(l), this.fire(new wt('data', { dataType: 'style' }));
                break;
              }
          }
          this.mergeTerrain(), this.updateDrapeFirstLayers(), (this._markersNeedUpdate = !0);
        }
        _createFog(t) {
          const i = (this.fog = new $C(t, this.map.transform));
          this.stylesheet.fog = i.get();
          const r = this._getTransitionParameters({ duration: 0 });
          i.updateTransitions(r);
        }
        _updateMarkersOpacity() {
          this.map._markers.length !== 0 &&
            this.map._requestDomTask(() => {
              for (const t of this.map._markers) t._evaluateOpacity();
            });
        }
        getFog() {
          return this.fog ? this.fog.get() : null;
        }
        setFog(t) {
          if ((this._checkLoaded(), !t)) return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = !0);
          if (this.fog) {
            const i = this.fog;
            if (!we(i.get(), t)) {
              i.set(t), (this.stylesheet.fog = i.get());
              const r = this._getTransitionParameters({ duration: 0 });
              i.updateTransitions(r);
            }
          } else this._createFog(t);
          this._markersNeedUpdate = !0;
        }
        _getTransitionParameters(t) {
          return { now: oe.now(), transition: Ft(this.transition, t) };
        }
        updateDrapeFirstLayers() {
          if (!this.terrain) return;
          const t = [],
            i = [];
          for (const r in this._mergedLayers) this.isLayerDraped(this._mergedLayers[r]) ? t.push(r) : i.push(r);
          (this._drapedFirstOrder = []), this._drapedFirstOrder.push(...t), this._drapedFirstOrder.push(...i);
        }
        _createTerrain(t, i) {
          const r = (this.terrain = new qC(t, i, this.scope, this.options));
          i === 1 && (this.stylesheet.terrain = t), this.mergeTerrain(), this.updateDrapeFirstLayers(), this._force3DLayerUpdate();
          const n = this._getTransitionParameters({ duration: 0 });
          r.updateTransitions(n);
        }
        _force3DLayerUpdate() {
          for (const t in this._layers) {
            const i = this._layers[t];
            i.type === 'fill-extrusion' && this._updateLayer(i);
          }
        }
        _forceSymbolLayerUpdate() {
          for (const t in this._layers) {
            const i = this._layers[t];
            i.type === 'symbol' && this._updateLayer(i);
          }
        }
        _validate(t, i, r, n, o = {}) {
          if (o && o.validate === !1) return !1;
          const s = Ft({}, this.serialize());
          return ic(this, t.call(la, Ft({ key: i, style: s, value: r, styleSpec: Q }, n)));
        }
        _remove() {
          this._request && (this._request.cancel(), (this._request = null)), this._spriteRequest && (this._spriteRequest.cancel(), (this._spriteRequest = null)), Tf.off('pluginStateChange', this._rtlTextPluginCallback);
          for (const t in this._mergedLayers) this._mergedLayers[t].setEventedParent(null);
          for (const t in this._mergedSourceCaches) this._mergedSourceCaches[t].clearTiles(), this._mergedSourceCaches[t].setEventedParent(null);
          this.setEventedParent(null), delete this.fog, delete this.terrain, delete this.ambientLight, delete this.directionalLight, this.isRootStyle() && (this.imageManager.setEventedParent(null), this.modelManager.setEventedParent(null), this.dispatcher.remove());
        }
        clearSource(t) {
          const i = this.getSourceCaches(t);
          for (const r of i) r.clearTiles();
        }
        clearSources() {
          for (const t in this._mergedSourceCaches) this._mergedSourceCaches[t].clearTiles();
        }
        reloadSource(t) {
          const i = this.getSourceCaches(t);
          for (const r of i) r.resume(), r.reload();
        }
        reloadSources() {
          for (const t of this.getSources()) t.reload && t.reload();
        }
        updateSources(t) {
          let i;
          this.directionalLight && (i = cw(this.directionalLight));
          for (const r in this._mergedSourceCaches) this._mergedSourceCaches[r].update(t, void 0, void 0, i);
        }
        _generateCollisionBoxes() {
          for (const t in this._sourceCaches) {
            const i = this._sourceCaches[t];
            i.resume(), i.reload();
          }
        }
        _updatePlacement(t, i, r, n, o = !1) {
          let s = !1,
            a = !1;
          const l = {},
            c = {};
          for (const u of this._mergedOrder) {
            const h = this._mergedLayers[u];
            if (h.type !== 'symbol') continue;
            const d = pr(h.source, h.scope);
            let f = l[d];
            if (!f) {
              const _ = this.getLayerSourceCache(h);
              if (!_) continue;
              const g = _.getRenderableIds(!0).map((y) => _.getTileByID(y));
              (c[d] = g.slice()), (f = l[d] = g.sort((y, v) => v.tileID.overscaledZ - y.tileID.overscaledZ || (y.tileID.isLessThan(v.tileID) ? -1 : 1)));
            }
            const p = this.crossTileSymbolIndex.addLayer(h, f, t.center.lng, t.projection);
            s = s || p;
          }
          if ((this.crossTileSymbolIndex.pruneUnusedLayers(this._mergedOrder), (o = o || this._layerOrderChanged || r === 0), this._layerOrderChanged && this.fire(new wt('neworder')), (o || !this.pauseablePlacement || (this.pauseablePlacement.isDone() && !this.placement.stillRecent(oe.now(), t.zoom))) && ((this.pauseablePlacement = new zP(t, this._mergedOrder, o, i, r, n, this.placement, this.fog && t.projection.supportsFog ? this.fog.state : null, this._buildingIndex)), (this._layerOrderChanged = !1)), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._mergedOrder, this._mergedLayers, l, c), this.pauseablePlacement.isDone() && ((this.placement = this.pauseablePlacement.commit(oe.now())), (a = !0)), s && this.pauseablePlacement.placement.setStale()), a || s))
            for (const u of this._mergedOrder) {
              const h = this._mergedLayers[u];
              h.type === 'symbol' && this.placement.updateLayerOpacities(h, l[pr(h.source, h.scope)]);
            }
          return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(oe.now());
        }
        _releaseSymbolFadeTiles() {
          for (const t in this._sourceCaches) this._sourceCaches[t].releaseSymbolFadeTiles();
        }
        addImport(t) {
          this._checkLoaded();
          const i = (this.stylesheet.imports = this.stylesheet.imports || []);
          return i.findIndex(({ id: n }) => n === t.id) !== -1 ? this.fire(new re(new Error(`Import with id '${t.id}' already exists in the map's style.`))) : (i.push(t), this._loadImports([t], !0), this);
        }
        setImportUrl(t, i) {
          this._checkLoaded();
          const r = this.stylesheet.imports || [],
            n = this.getImportIndex(t);
          if (n === -1) return this;
          r[n].url = i;
          const o = this.fragments[n];
          return (o.style = this._createFragmentStyle(r[n])), o.style.on('style.import.load', () => this.mergeAll()), o.style.loadURL(i), this;
        }
        setImportData(t, i) {
          this._checkLoaded();
          const r = this.getImportIndex(t),
            n = this.stylesheet.imports || [];
          return r === -1 ? this : i ? (this.fragments[r].style.setState(i), this._reloadImports(), this) : (delete n[r].data, this.setImportUrl(t, n[r].url));
        }
        setImportConfig(t, i) {
          this._checkLoaded();
          const r = this.getImportIndex(t),
            n = this.stylesheet.imports || [];
          if (r === -1) return this;
          i ? (n[r].config = i) : delete n[r].config;
          const o = this.fragments[r],
            s = o.style.stylesheet && o.style.stylesheet.schema;
          return (o.config = i), o.style.setConfig(i, s), o.style.updateConfigDependencies(), this;
        }
        removeImport(t) {
          this._checkLoaded();
          const i = this.stylesheet.imports || [],
            r = this.getImportIndex(t);
          return r === -1 || (i.splice(r, 1), this.fragments[r].style._remove(), this.fragments.splice(r, 1), this._reloadImports()), this;
        }
        getImportIndex(t) {
          const i = (this.stylesheet.imports || []).findIndex((r) => r.id === t);
          return i === -1 && this.fire(new re(new Error(`Import '${t}' does not exist in the map's style and cannot be updated.`))), i;
        }
        getLayer(t) {
          return this._mergedLayers[t];
        }
        getSources() {
          const t = [];
          for (const i in this._mergedOtherSourceCaches) {
            const r = this._mergedOtherSourceCaches[i];
            r && t.push(r.getSource());
          }
          return t;
        }
        getSource(t, i) {
          const r = this.getSourceCache(t, i);
          return r && r.getSource();
        }
        getLayerSource(t) {
          const i = this.getLayerSourceCache(t);
          return i && i.getSource();
        }
        getSourceCache(t, i) {
          const r = pr(t, i);
          return this._mergedOtherSourceCaches[r];
        }
        getLayerSourceCache(t) {
          const i = pr(t.source, t.scope);
          return t.type === 'symbol' ? this._mergedSymbolSourceCaches[i] : this._mergedOtherSourceCaches[i];
        }
        getSourceCaches(t) {
          const i = [];
          return this._mergedOtherSourceCaches[t] && i.push(this._mergedOtherSourceCaches[t]), this._mergedSymbolSourceCaches[t] && i.push(this._mergedSymbolSourceCaches[t]), i;
        }
        updateSourceCaches() {
          const t = this._changes.getUpdatedSourceCaches();
          for (const i in t) {
            const r = t[i];
            r === 'reload' ? this.reloadSource(i) : r === 'clear' && this.clearSource(i);
          }
        }
        updateLayers(t) {
          const i = this._changes.getUpdatedPaintProperties();
          for (const r of i) {
            const n = this.getLayer(r);
            n && n.updateTransitions(t);
          }
        }
        getImages(t, i, r) {
          this.imageManager.getImages(i.icons, i.scope, r), this._updateTilesForChangedImages();
          const n = (o) => {
            o && o.setDependencies(i.tileID.key, i.type, i.icons);
          };
          n(this._otherSourceCaches[i.source]), n(this._symbolSourceCaches[i.source]);
        }
        getGlyphs(t, i, r) {
          this.glyphManager.getGlyphs(i.stacks, i.scope, r);
        }
        getResource(t, i, r) {
          return St(i, r);
        }
        getOwnSourceCache(t) {
          return this._otherSourceCaches[t];
        }
        getOwnLayerSourceCache(t) {
          return t.type === 'symbol' ? this._symbolSourceCaches[t.source] : this._otherSourceCaches[t.source];
        }
        getOwnSourceCaches(t) {
          const i = [];
          return this._otherSourceCaches[t] && i.push(this._otherSourceCaches[t]), this._symbolSourceCaches[t] && i.push(this._symbolSourceCaches[t]), i;
        }
        _isSourceCacheLoaded(t) {
          const i = this.getOwnSourceCaches(t);
          return i.length === 0 ? (this.fire(new re(new Error(`There is no source with ID '${t}'`))), !1) : i.every((r) => r.loaded());
        }
        has3DLayers() {
          return this._has3DLayers;
        }
        hasSymbolLayers() {
          return this._hasSymbolLayers;
        }
        hasCircleLayers() {
          return this._hasCircleLayers;
        }
        _clearWorkerCaches() {
          this.dispatcher.broadcast('clearCaches');
        }
        destroy() {
          this._clearWorkerCaches(), this.terrainSetForDrapingOnly() && (delete this.terrain, delete this.stylesheet.terrain);
        }
      }
      function dw(e, t) {
        let i = !1,
          r = null;
        const n = () => {
          (r = null), i && (e(), (r = setTimeout(n, t)), (i = !1));
        };
        return () => ((i = !0), r || n(), r);
      }
      (Mn.getSourceType = function (e) {
        return vm[e];
      }),
        (Mn.setSourceType = function (e, t) {
          vm[e] = t;
        }),
        (Mn.registerForPluginStateChange = function (e) {
          return e({ pluginStatus: Dr, pluginURL: Co }), Tf.on('pluginStateChange', e), e;
        });
      class qz {
        constructor(t) {
          (this._hashName = t && encodeURIComponent(t)), ot(['_getCurrentHash', '_onHashChange', '_updateHash'], this), (this._updateHash = dw(this._updateHashUnthrottled.bind(this), 300));
        }
        addTo(t) {
          return (this._map = t), U.addEventListener('hashchange', this._onHashChange, !1), t.on('moveend', this._updateHash), this;
        }
        remove() {
          return this._map ? (this._map.off('moveend', this._updateHash), U.removeEventListener('hashchange', this._onHashChange, !1), clearTimeout(this._updateHash()), (this._map = void 0), this) : this;
        }
        getHashString() {
          const t = this._map;
          if (!t) return '';
          const i = fw(t);
          if (this._hashName) {
            const r = this._hashName;
            let n = !1;
            const o = U.location.hash
              .slice(1)
              .split('&')
              .map((s) => {
                const a = s.split('=')[0];
                return a === r ? ((n = !0), `${a}=${i}`) : s;
              })
              .filter((s) => s);
            return n || o.push(`${r}=${i}`), `#${o.join('&')}`;
          }
          return `#${i}`;
        }
        _getCurrentHash() {
          const t = U.location.hash.replace('#', '');
          if (this._hashName) {
            let i;
            return (
              t
                .split('&')
                .map((r) => r.split('='))
                .forEach((r) => {
                  r[0] === this._hashName && (i = r);
                }),
              ((i && i[1]) || '').split('/')
            );
          }
          return t.split('/');
        }
        _onHashChange() {
          const t = this._map;
          if (!t) return !1;
          const i = this._getCurrentHash();
          if (i.length >= 3 && !i.some((r) => isNaN(r))) {
            const r = t.dragRotate.isEnabled() && t.touchZoomRotate.isEnabled() ? +(i[3] || 0) : t.getBearing();
            return t.jumpTo({ center: [+i[2], +i[1]], zoom: +i[0], bearing: r, pitch: +(i[4] || 0) }), !0;
          }
          return !1;
        }
        _updateHashUnthrottled() {
          const t = U.location.href.replace(/(#.+)?$/, this.getHashString());
          U.history.replaceState(U.history.state, null, t);
        }
      }
      function fw(e, t) {
        const i = e.getCenter(),
          r = Math.round(100 * e.getZoom()) / 100,
          n = Math.ceil((r * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10),
          o = Math.pow(10, n),
          s = Math.round(i.lng * o) / o,
          a = Math.round(i.lat * o) / o,
          l = e.getBearing(),
          c = e.getPitch();
        let u = t ? `/${s}/${a}/${r}` : `${r}/${a}/${s}`;
        return (l || c) && (u += '/' + Math.round(10 * l) / 10), c && (u += `/${Math.round(c)}`), u;
      }
      const Th = { linearity: 0.3, easing: tn(0, 0, 0.3, 1) },
        Zz = Ft({ deceleration: 2500, maxSpeed: 1400 }, Th),
        $z = Ft({ deceleration: 20, maxSpeed: 1400 }, Th),
        Hz = Ft({ deceleration: 1e3, maxSpeed: 360 }, Th),
        Wz = Ft({ deceleration: 1e3, maxSpeed: 90 }, Th);
      class Xz {
        constructor(t) {
          (this._map = t), this.clear();
        }
        clear() {
          this._inertiaBuffer = [];
        }
        record(t) {
          this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: oe.now(), settings: t });
        }
        _drainInertiaBuffer() {
          const t = this._inertiaBuffer,
            i = oe.now();
          for (; t.length > 0 && i - t[0].time > 160; ) t.shift();
        }
        _onMoveEnd(t) {
          if (this._map._prefersReducedMotion() || (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2)) return;
          const i = { zoom: 0, bearing: 0, pitch: 0, pan: new H(0, 0), pinchAround: void 0, around: void 0 };
          for (const { settings: o } of this._inertiaBuffer) (i.zoom += o.zoomDelta || 0), (i.bearing += o.bearingDelta || 0), (i.pitch += o.pitchDelta || 0), o.panDelta && i.pan._add(o.panDelta), o.around && (i.around = o.around), o.pinchAround && (i.pinchAround = o.pinchAround);
          const r = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time,
            n = {};
          if (i.pan.mag()) {
            const o = Mh(i.pan.mag(), r, Ft({}, Zz, t || {}));
            (n.offset = i.pan.mult(o.amount / i.pan.mag())), (n.center = this._map.transform.center), Eh(n, o);
          }
          if (i.zoom) {
            const o = Mh(i.zoom, r, $z);
            (n.zoom = this._map.transform.zoom + o.amount), Eh(n, o);
          }
          if (i.bearing) {
            const o = Mh(i.bearing, r, Hz);
            (n.bearing = this._map.transform.bearing + Bt(o.amount, -179, 179)), Eh(n, o);
          }
          if (i.pitch) {
            const o = Mh(i.pitch, r, Wz);
            (n.pitch = this._map.transform.pitch + o.amount), Eh(n, o);
          }
          if (n.zoom || n.bearing) {
            const o = i.pinchAround === void 0 ? i.around : i.pinchAround;
            n.around = o ? this._map.unproject(o) : this._map.getCenter();
          }
          return this.clear(), (n.noMoveStart = !0), n;
        }
      }
      function Eh(e, t) {
        (!e.duration || e.duration < t.duration) && ((e.duration = t.duration), (e.easing = t.easing));
      }
      function Mh(e, t, i) {
        const { maxSpeed: r, linearity: n, deceleration: o } = i,
          s = Bt((e * n) / (t / 1e3), -r, r),
          a = Math.abs(s) / (o * n);
        return { easing: i.easing, duration: 1e3 * a, amount: s * (a / 2) };
      }
      class Kr extends wt {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(t, i, r, n = {}) {
          const o = Ja(i.getCanvasContainer(), r);
          super(t, Ft({ point: o, lngLat: i.unproject(o), originalEvent: r }, n)), (this._defaultPrevented = !1), (this.target = i);
        }
      }
      class Sh extends wt {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(t, i, r) {
          const n = t === 'touchend' ? r.changedTouches : r.touches,
            o = Tc(i.getCanvasContainer(), n),
            s = o.map((l) => i.unproject(l)),
            a = o.reduce((l, c, u, h) => l.add(c.div(h.length)), new H(0, 0));
          super(t, { points: o, point: a, lngLats: s, lngLat: i.unproject(a), originalEvent: r }), (this._defaultPrevented = !1);
        }
      }
      class Yz extends wt {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(t, i, r) {
          super(t, { originalEvent: r }), (this._defaultPrevented = !1);
        }
      }
      class Kz {
        constructor(t, i) {
          (this._map = t), (this._clickTolerance = i.clickTolerance);
        }
        reset() {
          this._mousedownPos = void 0;
        }
        wheel(t) {
          return this._firePreventable(new Yz(t.type, this._map, t));
        }
        mousedown(t, i) {
          return (this._mousedownPos = i), this._firePreventable(new Kr(t.type, this._map, t));
        }
        mouseup(t) {
          this._map.fire(new Kr(t.type, this._map, t));
        }
        preclick(t) {
          const i = Ft({}, t);
          (i.type = 'preclick'), this._map.fire(new Kr(i.type, this._map, i));
        }
        click(t, i) {
          (this._mousedownPos && this._mousedownPos.dist(i) >= this._clickTolerance) || (this.preclick(t), this._map.fire(new Kr(t.type, this._map, t)));
        }
        dblclick(t) {
          return this._firePreventable(new Kr(t.type, this._map, t));
        }
        mouseover(t) {
          this._map.fire(new Kr(t.type, this._map, t));
        }
        mouseout(t) {
          this._map.fire(new Kr(t.type, this._map, t));
        }
        touchstart(t) {
          return this._firePreventable(new Sh(t.type, this._map, t));
        }
        touchmove(t) {
          this._map.fire(new Sh(t.type, this._map, t));
        }
        touchend(t) {
          this._map.fire(new Sh(t.type, this._map, t));
        }
        touchcancel(t) {
          this._map.fire(new Sh(t.type, this._map, t));
        }
        _firePreventable(t) {
          if ((this._map.fire(t), t.defaultPrevented)) return {};
        }
        isEnabled() {
          return !0;
        }
        isActive() {
          return !1;
        }
        enable() {}
        disable() {}
      }
      class Jz {
        constructor(t) {
          this._map = t;
        }
        reset() {
          (this._delayContextMenu = !1), (this._contextMenuEvent = void 0);
        }
        mousemove(t) {
          this._map.fire(new Kr(t.type, this._map, t));
        }
        mousedown() {
          this._delayContextMenu = !0;
        }
        mouseup() {
          (this._delayContextMenu = !1), this._contextMenuEvent && (this._map.fire(new Kr('contextmenu', this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
        }
        contextmenu(t) {
          this._delayContextMenu ? (this._contextMenuEvent = t) : this._map.fire(new Kr(t.type, this._map, t)), this._map.listens('contextmenu') && t.preventDefault();
        }
        isEnabled() {
          return !0;
        }
        isActive() {
          return !1;
        }
        enable() {}
        disable() {}
      }
      class Qz {
        constructor(t, i) {
          (this._map = t), (this._el = t.getCanvasContainer()), (this._container = t.getContainer()), (this._clickTolerance = i.clickTolerance || 1);
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
        enable() {
          this.isEnabled() || (this._enabled = !0);
        }
        disable() {
          this.isEnabled() && (this._enabled = !1);
        }
        mousedown(t, i) {
          this.isEnabled() && t.shiftKey && t.button === 0 && (G_(), (this._startPos = this._lastPos = i), (this._active = !0));
        }
        mousemoveWindow(t, i) {
          if (!this._active) return;
          const r = i,
            n = this._startPos,
            o = this._lastPos;
          if (!n || !o || o.equals(r) || (!this._box && r.dist(n) < this._clickTolerance)) return;
          (this._lastPos = r), this._box || ((this._box = ri('div', 'mapboxgl-boxzoom', this._container)), this._container.classList.add('mapboxgl-crosshair'), this._fireEvent('boxzoomstart', t));
          const s = Math.min(n.x, r.x),
            a = Math.max(n.x, r.x),
            l = Math.min(n.y, r.y),
            c = Math.max(n.y, r.y);
          this._map._requestDomTask(() => {
            this._box && ((this._box.style.transform = `translate(${s}px,${l}px)`), (this._box.style.width = a - s + 'px'), (this._box.style.height = c - l + 'px'));
          });
        }
        mouseupWindow(t, i) {
          if (!this._active) return;
          const r = this._startPos,
            n = i;
          if (r && t.button === 0) {
            if ((this.reset(), pd(), r.x !== n.x || r.y !== n.y)) return this._map.fire(new wt('boxzoomend', { originalEvent: t })), { cameraAnimation: (o) => o.fitScreenCoordinates(r, n, this._map.getBearing(), { linear: !1 }) };
            this._fireEvent('boxzoomcancel', t);
          }
        }
        keydown(t) {
          this._active && t.keyCode === 27 && (this.reset(), this._fireEvent('boxzoomcancel', t));
        }
        blur() {
          this.reset();
        }
        reset() {
          (this._active = !1), this._container.classList.remove('mapboxgl-crosshair'), this._box && (this._box.remove(), (this._box = null)), q_(), delete this._startPos, delete this._lastPos;
        }
        _fireEvent(t, i) {
          return this._map.fire(new wt(t, { originalEvent: i }));
        }
      }
      function km(e, t) {
        const i = {};
        for (let r = 0; r < e.length; r++) i[e[r].identifier] = t[r];
        return i;
      }
      class tD {
        constructor(t) {
          this.reset(), (this.numTouches = t.numTouches);
        }
        reset() {
          (this.centroid = void 0), (this.startTime = 0), (this.touches = {}), (this.aborted = !1);
        }
        touchstart(t, i, r) {
          (this.centroid || r.length > this.numTouches) && (this.aborted = !0),
            this.aborted ||
              (this.startTime === 0 && (this.startTime = t.timeStamp),
              r.length === this.numTouches &&
                ((this.centroid = (function (n) {
                  const o = new H(0, 0);
                  for (const s of n) o._add(s);
                  return o.div(n.length);
                })(i)),
                (this.touches = km(r, i))));
        }
        touchmove(t, i, r) {
          if (this.aborted || !this.centroid) return;
          const n = km(r, i);
          for (const o in this.touches) {
            const s = n[o];
            (!s || s.dist(this.touches[o]) > 30) && (this.aborted = !0);
          }
        }
        touchend(t, i, r) {
          if (((!this.centroid || t.timeStamp - this.startTime > 500) && (this.aborted = !0), r.length === 0)) {
            const n = !this.aborted && this.centroid;
            if ((this.reset(), n)) return n;
          }
        }
      }
      class Om {
        constructor(t) {
          (this.singleTap = new tD(t)), (this.numTaps = t.numTaps), this.reset();
        }
        reset() {
          (this.lastTime = 1 / 0), (this.lastTap = void 0), (this.count = 0), this.singleTap.reset();
        }
        touchstart(t, i, r) {
          this.singleTap.touchstart(t, i, r);
        }
        touchmove(t, i, r) {
          this.singleTap.touchmove(t, i, r);
        }
        touchend(t, i, r) {
          const n = this.singleTap.touchend(t, i, r);
          if (n) {
            const o = t.timeStamp - this.lastTime < 500,
              s = !this.lastTap || this.lastTap.dist(n) < 30;
            if (((o && s) || this.reset(), this.count++, (this.lastTime = t.timeStamp), (this.lastTap = n), this.count === this.numTaps)) return this.reset(), n;
          }
        }
      }
      class eD {
        constructor() {
          (this._zoomIn = new Om({ numTouches: 1, numTaps: 2 })), (this._zoomOut = new Om({ numTouches: 2, numTaps: 1 })), this.reset();
        }
        reset() {
          (this._active = !1), this._zoomIn.reset(), this._zoomOut.reset();
        }
        touchstart(t, i, r) {
          this._zoomIn.touchstart(t, i, r), this._zoomOut.touchstart(t, i, r);
        }
        touchmove(t, i, r) {
          this._zoomIn.touchmove(t, i, r), this._zoomOut.touchmove(t, i, r);
        }
        touchend(t, i, r) {
          const n = this._zoomIn.touchend(t, i, r),
            o = this._zoomOut.touchend(t, i, r);
          return n ? ((this._active = !0), t.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (s) => s.easeTo({ duration: 300, zoom: s.getZoom() + 1, around: s.unproject(n) }, { originalEvent: t }) }) : o ? ((this._active = !0), t.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (s) => s.easeTo({ duration: 300, zoom: s.getZoom() - 1, around: s.unproject(o) }, { originalEvent: t }) }) : void 0;
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          (this._enabled = !1), this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      const iD = { 0: 1, 2: 2 };
      class Bm {
        constructor(t) {
          this.reset(), (this._clickTolerance = t.clickTolerance || 1);
        }
        blur() {
          this.reset();
        }
        reset() {
          (this._active = !1), (this._moved = !1), (this._lastPoint = void 0), (this._eventButton = void 0);
        }
        _correctButton(t, i) {
          return !1;
        }
        _move(t, i) {
          return {};
        }
        mousedown(t, i) {
          if (this._lastPoint) return;
          const r = Z_(t);
          this._correctButton(t, r) && ((this._lastPoint = i), (this._eventButton = r));
        }
        mousemoveWindow(t, i) {
          const r = this._lastPoint;
          if (r) {
            if (
              (t.preventDefault(),
              this._eventButton != null &&
                (function (n, o) {
                  const s = iD[o];
                  return n.buttons === void 0 || (n.buttons & s) !== s;
                })(t, this._eventButton))
            )
              this.reset();
            else if (this._moved || !(i.dist(r) < this._clickTolerance)) return (this._moved = !0), (this._lastPoint = i), this._move(r, i);
          }
        }
        mouseupWindow(t) {
          this._lastPoint && Z_(t) === this._eventButton && (this._moved && pd(), this.reset());
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          (this._enabled = !1), this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class rD extends Bm {
        mousedown(t, i) {
          super.mousedown(t, i), this._lastPoint && (this._active = !0);
        }
        _correctButton(t, i) {
          return i === 0 && !t.ctrlKey;
        }
        _move(t, i) {
          return { around: i, panDelta: i.sub(t) };
        }
      }
      class pw extends Bm {
        _correctButton(t, i) {
          return (i === 0 && t.ctrlKey) || i === 2;
        }
        _move(t, i) {
          const r = 0.8 * (i.x - t.x);
          if (r) return (this._active = !0), { bearingDelta: r };
        }
        contextmenu(t) {
          t.preventDefault();
        }
      }
      class mw extends Bm {
        _correctButton(t, i) {
          return (i === 0 && t.ctrlKey) || i === 2;
        }
        _move(t, i) {
          const r = -0.5 * (i.y - t.y);
          if (r) return (this._active = !0), { pitchDelta: r };
        }
        contextmenu(t) {
          t.preventDefault();
        }
      }
      class nD {
        constructor(t, i) {
          (this._map = t), (this._el = t.getCanvasContainer()), (this._minTouches = 1), (this._clickTolerance = i.clickTolerance || 1), this.reset(), ot(['_addTouchPanBlocker', '_showTouchPanBlockerAlert'], this);
        }
        reset() {
          (this._active = !1), (this._touches = {}), (this._sum = new H(0, 0));
        }
        touchstart(t, i, r) {
          return this._calculateTransform(t, i, r);
        }
        touchmove(t, i, r) {
          if (this._active && !(r.length < this._minTouches)) {
            if (this._map._cooperativeGestures && !this._map.isMoving()) {
              if (r.length === 1 && !jt()) return void this._showTouchPanBlockerAlert();
              this._alertContainer.style.visibility !== 'hidden' && ((this._alertContainer.style.visibility = 'hidden'), clearTimeout(this._alertTimer));
            }
            return t.cancelable && t.preventDefault(), this._calculateTransform(t, i, r);
          }
        }
        touchend(t, i, r) {
          this._calculateTransform(t, i, r), this._active && r.length < this._minTouches && this.reset();
        }
        touchcancel() {
          this.reset();
        }
        _calculateTransform(t, i, r) {
          r.length > 0 && (this._active = !0);
          const n = km(r, i),
            o = new H(0, 0),
            s = new H(0, 0);
          let a = 0;
          for (const c in n) {
            const u = n[c],
              h = this._touches[c];
            h && (o._add(u), s._add(u.sub(h)), a++, (n[c] = u));
          }
          if (((this._touches = n), a < this._minTouches || !s.mag())) return;
          const l = s.div(a);
          return this._sum._add(l), this._sum.mag() < this._clickTolerance ? void 0 : { around: o.div(a), panDelta: l };
        }
        enable() {
          (this._enabled = !0), this._map._cooperativeGestures && (this._addTouchPanBlocker(), this._el.classList.add('mapboxgl-touch-pan-blocker-override', 'mapboxgl-scrollable-page'));
        }
        disable() {
          (this._enabled = !1), this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove(), this._el.classList.remove('mapboxgl-touch-pan-blocker-override', 'mapboxgl-scrollable-page')), this.reset();
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
        _addTouchPanBlocker() {
          this._map && !this._alertContainer && ((this._alertContainer = ri('div', 'mapboxgl-touch-pan-blocker', this._map._container)), (this._alertContainer.textContent = this._map._getUIString('TouchPanBlocker.Message')), (this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`));
        }
        _showTouchPanBlockerAlert() {
          (this._alertContainer.style.visibility = 'visible'),
            this._alertContainer.classList.add('mapboxgl-touch-pan-blocker-show'),
            this._alertContainer.setAttribute('role', 'alert'),
            clearTimeout(this._alertTimer),
            (this._alertTimer = setTimeout(() => {
              this._alertContainer.classList.remove('mapboxgl-touch-pan-blocker-show'), this._alertContainer.setAttribute('role', 'null');
            }, 500));
        }
      }
      class Fm {
        constructor() {
          this.reset();
        }
        reset() {
          (this._active = !1), (this._firstTwoTouches = void 0);
        }
        _start(t) {}
        _move(t, i, r) {
          return {};
        }
        touchstart(t, i, r) {
          this._firstTwoTouches || r.length < 2 || ((this._firstTwoTouches = [r[0].identifier, r[1].identifier]), this._start([i[0], i[1]]));
        }
        touchmove(t, i, r) {
          const n = this._firstTwoTouches;
          if (!n) return;
          t.preventDefault();
          const [o, s] = n,
            a = Ah(r, i, o),
            l = Ah(r, i, s);
          if (!a || !l) return;
          const c = this._aroundCenter ? null : a.add(l).div(2);
          return this._move([a, l], c, t);
        }
        touchend(t, i, r) {
          if (!this._firstTwoTouches) return;
          const [n, o] = this._firstTwoTouches,
            s = Ah(r, i, n),
            a = Ah(r, i, o);
          (s && a) || (this._active && pd(), this.reset());
        }
        touchcancel() {
          this.reset();
        }
        enable(t) {
          (this._enabled = !0), (this._aroundCenter = !!t && t.around === 'center');
        }
        disable() {
          (this._enabled = !1), this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      function Ah(e, t, i) {
        for (let r = 0; r < e.length; r++) if (e[r].identifier === i) return t[r];
      }
      function _w(e, t) {
        return Math.log(e / t) / Math.LN2;
      }
      class oD extends Fm {
        reset() {
          super.reset(), (this._distance = 0), (this._startDistance = 0);
        }
        _start(t) {
          this._startDistance = this._distance = t[0].dist(t[1]);
        }
        _move(t, i) {
          const r = this._distance;
          if (((this._distance = t[0].dist(t[1])), this._active || !(Math.abs(_w(this._distance, this._startDistance)) < 0.1))) return (this._active = !0), { zoomDelta: _w(this._distance, r), pinchAround: i };
        }
      }
      function gw(e, t) {
        return (180 * e.angleWith(t)) / Math.PI;
      }
      class sD extends Fm {
        reset() {
          super.reset(), (this._minDiameter = 0), (this._startVector = void 0), (this._vector = void 0);
        }
        _start(t) {
          (this._startVector = this._vector = t[0].sub(t[1])), (this._minDiameter = t[0].dist(t[1]));
        }
        _move(t, i) {
          const r = this._vector;
          if (((this._vector = t[0].sub(t[1])), r && (this._active || !this._isBelowThreshold(this._vector)))) return (this._active = !0), { bearingDelta: gw(this._vector, r), pinchAround: i };
        }
        _isBelowThreshold(t) {
          this._minDiameter = Math.min(this._minDiameter, t.mag());
          const i = (25 / (Math.PI * this._minDiameter)) * 360,
            r = this._startVector;
          if (!r) return !1;
          const n = gw(t, r);
          return Math.abs(n) < i;
        }
      }
      function Nm(e) {
        return Math.abs(e.y) > Math.abs(e.x);
      }
      class aD extends Fm {
        constructor(t) {
          super(), (this._map = t);
        }
        reset() {
          super.reset(), (this._valid = void 0), (this._firstMove = void 0), (this._lastPoints = void 0);
        }
        _start(t) {
          (this._lastPoints = t), Nm(t[0].sub(t[1])) && (this._valid = !1);
        }
        _move(t, i, r) {
          const n = this._lastPoints;
          if (!n) return;
          const o = t[0].sub(n[0]),
            s = t[1].sub(n[1]);
          return (this._map._cooperativeGestures && !jt() && r.touches.length < 3) || ((this._valid = this.gestureBeginsVertically(o, s, r.timeStamp)), !this._valid) ? void 0 : ((this._lastPoints = t), (this._active = !0), { pitchDelta: ((o.y + s.y) / 2) * -0.5 });
        }
        gestureBeginsVertically(t, i, r) {
          if (this._valid !== void 0) return this._valid;
          const n = t.mag() >= 2,
            o = i.mag() >= 2;
          if (!n && !o) return;
          if (!n || !o) return this._firstMove == null && (this._firstMove = r), r - this._firstMove < 100 && void 0;
          const s = t.y > 0 == i.y > 0;
          return Nm(t) && Nm(i) && s;
        }
      }
      const lD = { panStep: 100, bearingStep: 15, pitchStep: 10 };
      class cD {
        constructor() {
          const t = lD;
          (this._panStep = t.panStep), (this._bearingStep = t.bearingStep), (this._pitchStep = t.pitchStep), (this._rotationDisabled = !1);
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = !1;
        }
        keydown(t) {
          if (t.altKey || t.ctrlKey || t.metaKey) return;
          let i = 0,
            r = 0,
            n = 0,
            o = 0,
            s = 0;
          switch (t.keyCode) {
            case 61:
            case 107:
            case 171:
            case 187:
              i = 1;
              break;
            case 189:
            case 109:
            case 173:
              i = -1;
              break;
            case 37:
              t.shiftKey ? (r = -1) : (t.preventDefault(), (o = -1));
              break;
            case 39:
              t.shiftKey ? (r = 1) : (t.preventDefault(), (o = 1));
              break;
            case 38:
              t.shiftKey ? (n = 1) : (t.preventDefault(), (s = -1));
              break;
            case 40:
              t.shiftKey ? (n = -1) : (t.preventDefault(), (s = 1));
              break;
            default:
              return;
          }
          return (
            this._rotationDisabled && ((r = 0), (n = 0)),
            {
              cameraAnimation: (a) => {
                const l = a.getZoom();
                a.easeTo({ duration: 300, easeId: 'keyboardHandler', easing: uD, zoom: i ? Math.round(l) + i * (t.shiftKey ? 2 : 1) : l, bearing: a.getBearing() + r * this._bearingStep, pitch: a.getPitch() + n * this._pitchStep, offset: [-o * this._panStep, -s * this._panStep], center: a.getCenter() }, { originalEvent: t });
              },
            }
          );
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          (this._enabled = !1), this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        disableRotation() {
          this._rotationDisabled = !0;
        }
        enableRotation() {
          this._rotationDisabled = !1;
        }
      }
      function uD(e) {
        return e * (2 - e);
      }
      const yw = 4.000244140625;
      class hD {
        constructor(t, i) {
          (this._map = t), (this._el = t.getCanvasContainer()), (this._handler = i), (this._delta = 0), (this._lastDelta = 0), (this._defaultZoomRate = 0.01), (this._wheelZoomRate = 0.0022222222222222222), ot(['_onTimeout', '_addScrollZoomBlocker', '_showBlockerAlert'], this);
        }
        setZoomRate(t) {
          this._defaultZoomRate = t;
        }
        setWheelZoomRate(t) {
          this._wheelZoomRate = t;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return this._active || this._finishTimeout !== void 0;
        }
        isZooming() {
          return !!this._zooming;
        }
        enable(t) {
          this.isEnabled() || ((this._enabled = !0), (this._aroundCenter = !!t && t.around === 'center'), this._map._cooperativeGestures && this._addScrollZoomBlocker());
        }
        disable() {
          this.isEnabled() && ((this._enabled = !1), this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove()));
        }
        wheel(t) {
          if (!this.isEnabled()) return;
          if (this._map._cooperativeGestures) {
            if (!(t.ctrlKey || t.metaKey || this.isZooming() || jt())) return void this._showBlockerAlert();
            this._alertContainer.style.visibility !== 'hidden' && ((this._alertContainer.style.visibility = 'hidden'), clearTimeout(this._alertTimer));
          }
          let i = t.deltaMode === U.WheelEvent.DOM_DELTA_LINE ? 40 * t.deltaY : t.deltaY;
          const r = oe.now(),
            n = r - (this._lastWheelEventTime || 0);
          (this._lastWheelEventTime = r), i !== 0 && i % yw == 0 ? (this._type = 'wheel') : i !== 0 && Math.abs(i) < 4 ? (this._type = 'trackpad') : n > 400 ? ((this._type = null), (this._lastValue = i), (this._timeout = setTimeout(this._onTimeout, 40, t))) : this._type || ((this._type = Math.abs(n * i) < 200 ? 'trackpad' : 'wheel'), this._timeout && (clearTimeout(this._timeout), (this._timeout = null), (i += this._lastValue))), t.shiftKey && i && (i /= 4), this._type && ((this._lastWheelEvent = t), (this._delta -= i), this._active || this._start(t)), t.preventDefault();
        }
        _onTimeout(t) {
          (this._type = 'wheel'), (this._delta -= this._lastValue), this._active || this._start(t);
        }
        _start(t) {
          if (!this._delta) return;
          this._frameId && (this._frameId = null), (this._active = !0), this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          const i = Ja(this._el, t);
          (this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : i), (this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint)), (this._targetZoom = void 0), this._frameId || ((this._frameId = !0), this._handler._triggerRenderFrame());
        }
        renderFrame() {
          if (!this._frameId || ((this._frameId = null), !this.isActive())) return;
          const t = this._map.transform;
          this._type === 'wheel' && t.projection.wrap && (t._center.lng >= 180 || t._center.lng <= -180) && ((this._prevEase = null), (this._easing = null), (this._lastWheelEvent = null), (this._lastWheelEventTime = 0));
          const i = () => (t._terrainEnabled() && this._aroundCoord ? t.computeZoomRelativeTo(this._aroundCoord) : t.zoom);
          if (this._delta !== 0) {
            const c = this._type === 'wheel' && Math.abs(this._delta) > yw ? this._wheelZoomRate : this._defaultZoomRate;
            let u = 2 / (1 + Math.exp(-Math.abs(this._delta * c)));
            this._delta < 0 && u !== 0 && (u = 1 / u);
            const h = i(),
              d = Math.pow(2, h),
              f = typeof this._targetZoom == 'number' ? t.zoomScale(this._targetZoom) : d;
            (this._targetZoom = Math.min(t.maxZoom, Math.max(t.minZoom, t.scaleZoom(f * u)))), this._type === 'wheel' && ((this._startZoom = h), (this._easing = this._smoothOutEasing(200))), (this._lastDelta = this._delta), (this._delta = 0);
          }
          const r = typeof this._targetZoom == 'number' ? this._targetZoom : i(),
            n = this._startZoom,
            o = this._easing;
          let s,
            a = !1;
          if (this._type === 'wheel' && n && o) {
            const c = Math.min((oe.now() - this._lastWheelEventTime) / 200, 1);
            (s = ee(n, r, o(c))), c < 1 ? this._frameId || (this._frameId = !0) : (a = !0);
          } else (s = r), (a = !0);
          (this._active = !0),
            a &&
              ((this._active = !1),
              (this._finishTimeout = setTimeout(() => {
                (this._zooming = !1), this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
              }, 200)));
          let l = s - i();
          return l * this._lastDelta < 0 && (l = 0), { noInertia: !0, needsRenderFrame: !a, zoomDelta: l, around: this._aroundPoint, aroundCoord: this._aroundCoord, originalEvent: this._lastWheelEvent };
        }
        _smoothOutEasing(t) {
          let i = tr;
          if (this._prevEase) {
            const r = this._prevEase,
              n = (oe.now() - r.start) / r.duration,
              o = r.easing(n + 0.01) - r.easing(n),
              s = (0.27 / Math.sqrt(o * o + 1e-4)) * 0.01;
            i = tn(s, Math.sqrt(0.0729 - s * s), 0.25, 1);
          }
          return (this._prevEase = { start: oe.now(), duration: t, easing: i }), i;
        }
        blur() {
          this.reset();
        }
        reset() {
          this._active = !1;
        }
        _addScrollZoomBlocker() {
          this._map && !this._alertContainer && ((this._alertContainer = ri('div', 'mapboxgl-scroll-zoom-blocker', this._map._container)), (this._alertContainer.textContent = /(Mac|iPad)/i.test(U.navigator.userAgent) ? this._map._getUIString('ScrollZoomBlocker.CmdMessage') : this._map._getUIString('ScrollZoomBlocker.CtrlMessage')), (this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`));
        }
        _showBlockerAlert() {
          (this._alertContainer.style.visibility = 'visible'),
            this._alertContainer.classList.add('mapboxgl-scroll-zoom-blocker-show'),
            this._alertContainer.setAttribute('role', 'alert'),
            clearTimeout(this._alertTimer),
            (this._alertTimer = setTimeout(() => {
              this._alertContainer.classList.remove('mapboxgl-scroll-zoom-blocker-show'), this._alertContainer.setAttribute('role', 'null');
            }, 200));
        }
      }
      class dD {
        constructor(t, i) {
          (this._clickZoom = t), (this._tapZoom = i);
        }
        enable() {
          this._clickZoom.enable(), this._tapZoom.enable();
        }
        disable() {
          this._clickZoom.disable(), this._tapZoom.disable();
        }
        isEnabled() {
          return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
        }
        isActive() {
          return this._clickZoom.isActive() || this._tapZoom.isActive();
        }
      }
      class fD {
        constructor() {
          this.reset();
        }
        reset() {
          this._active = !1;
        }
        blur() {
          this.reset();
        }
        dblclick(t, i) {
          return (
            t.preventDefault(),
            {
              cameraAnimation: (r) => {
                r.easeTo({ duration: 300, zoom: r.getZoom() + (t.shiftKey ? -1 : 1), around: r.unproject(i) }, { originalEvent: t });
              },
            }
          );
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          (this._enabled = !1), this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class pD {
        constructor() {
          (this._tap = new Om({ numTouches: 1, numTaps: 1 })), this.reset();
        }
        reset() {
          (this._active = !1), (this._swipePoint = void 0), (this._swipeTouch = 0), (this._tapTime = 0), this._tap.reset();
        }
        touchstart(t, i, r) {
          this._swipePoint || (this._tapTime && t.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? r.length > 0 && ((this._swipePoint = i[0]), (this._swipeTouch = r[0].identifier)) : this._tap.touchstart(t, i, r));
        }
        touchmove(t, i, r) {
          if (this._tapTime) {
            if (this._swipePoint) {
              if (r[0].identifier !== this._swipeTouch) return;
              const n = i[0],
                o = n.y - this._swipePoint.y;
              return (this._swipePoint = n), t.preventDefault(), (this._active = !0), { zoomDelta: o / 128 };
            }
          } else this._tap.touchmove(t, i, r);
        }
        touchend(t, i, r) {
          this._tapTime ? this._swipePoint && r.length === 0 && this.reset() : this._tap.touchend(t, i, r) && (this._tapTime = t.timeStamp);
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          (this._enabled = !1), this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class mD {
        constructor(t, i, r) {
          (this._el = t), (this._mousePan = i), (this._touchPan = r);
        }
        enable(t) {
          (this._inertiaOptions = t || {}), this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add('mapboxgl-touch-drag-pan');
        }
        disable() {
          this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove('mapboxgl-touch-drag-pan');
        }
        isEnabled() {
          return this._mousePan.isEnabled() && this._touchPan.isEnabled();
        }
        isActive() {
          return this._mousePan.isActive() || this._touchPan.isActive();
        }
      }
      class _D {
        constructor(t, i, r) {
          (this._pitchWithRotate = t.pitchWithRotate), (this._mouseRotate = i), (this._mousePitch = r);
        }
        enable() {
          this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
        }
        disable() {
          this._mouseRotate.disable(), this._mousePitch.disable();
        }
        isEnabled() {
          return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
        }
        isActive() {
          return this._mouseRotate.isActive() || this._mousePitch.isActive();
        }
      }
      class gD {
        constructor(t, i, r, n) {
          (this._el = t), (this._touchZoom = i), (this._touchRotate = r), (this._tapDragZoom = n), (this._rotationDisabled = !1), (this._enabled = !0);
        }
        enable(t) {
          this._touchZoom.enable(t), this._rotationDisabled || this._touchRotate.enable(t), this._tapDragZoom.enable(), this._el.classList.add('mapboxgl-touch-zoom-rotate');
        }
        disable() {
          this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove('mapboxgl-touch-zoom-rotate');
        }
        isEnabled() {
          return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
        }
        isActive() {
          return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
        }
        disableRotation() {
          (this._rotationDisabled = !0), this._touchRotate.disable();
        }
        enableRotation() {
          (this._rotationDisabled = !1), this._touchZoom.isEnabled() && this._touchRotate.enable();
        }
      }
      const Ih = (e) => e.zoom || e.drag || e.pitch || e.rotate;
      class yD extends wt {}
      class xD {
        constructor() {
          (this.constants = [1, 1, 0.01]), (this.radius = 0);
        }
        setup(t, i) {
          const r = N.sub([], i, t);
          this.radius = N.length(r[2] < 0 ? N.div([], r, this.constants) : [r[0], r[1], 0]);
        }
        projectRay(t) {
          N.div(t, t, this.constants), N.normalize(t, t), N.mul(t, t, this.constants);
          const i = N.scale([], t, this.radius);
          if (i[2] > 0) {
            const r = N.scale([], [0, 0, 1], N.dot(i, [0, 0, 1])),
              n = N.scale([], N.normalize([], [i[0], i[1], 0]), this.radius),
              o = N.add([], i, N.scale([], N.sub([], N.add([], n, r), i), 2));
            (i[0] = o[0]), (i[1] = o[1]);
          }
          return i;
        }
      }
      function Ch(e) {
        return (e.panDelta && e.panDelta.mag()) || e.zoomDelta || e.bearingDelta || e.pitchDelta;
      }
      class vD {
        constructor(t, i) {
          (this._map = t), (this._el = this._map.getCanvasContainer()), (this._handlers = []), (this._handlersById = {}), (this._changes = []), (this._inertia = new Xz(t)), (this._bearingSnap = i.bearingSnap), (this._previousActiveHandlers = {}), (this._trackingEllipsoid = new xD()), (this._dragOrigin = null), (this._eventsInProgress = {}), this._addDefaultHandlers(i), ot(['handleEvent', 'handleWindowEvent'], this);
          const r = this._el;
          this._listeners = [
            [r, 'touchstart', { passive: !0 }],
            [r, 'touchmove', { passive: !1 }],
            [r, 'touchend', void 0],
            [r, 'touchcancel', void 0],
            [r, 'mousedown', void 0],
            [r, 'mousemove', void 0],
            [r, 'mouseup', void 0],
            [U.document, 'mousemove', { capture: !0 }],
            [U.document, 'mouseup', void 0],
            [r, 'mouseover', void 0],
            [r, 'mouseout', void 0],
            [r, 'dblclick', void 0],
            [r, 'click', void 0],
            [r, 'keydown', { capture: !1 }],
            [r, 'keyup', void 0],
            [r, 'wheel', { passive: !1 }],
            [r, 'contextmenu', void 0],
            [U, 'blur', void 0],
          ];
          for (const [n, o, s] of this._listeners) n.addEventListener(o, n === U.document ? this.handleWindowEvent : this.handleEvent, s);
        }
        destroy() {
          for (const [t, i, r] of this._listeners) t.removeEventListener(i, t === U.document ? this.handleWindowEvent : this.handleEvent, r);
        }
        _addDefaultHandlers(t) {
          const i = this._map,
            r = i.getCanvasContainer();
          this._add('mapEvent', new Kz(i, t));
          const n = (i.boxZoom = new Qz(i, t));
          this._add('boxZoom', n);
          const o = new eD(),
            s = new fD();
          (i.doubleClickZoom = new dD(s, o)), this._add('tapZoom', o), this._add('clickZoom', s);
          const a = new pD();
          this._add('tapDragZoom', a);
          const l = (i.touchPitch = new aD(i));
          this._add('touchPitch', l);
          const c = new pw(t),
            u = new mw(t);
          (i.dragRotate = new _D(t, c, u)), this._add('mouseRotate', c, ['mousePitch']), this._add('mousePitch', u, ['mouseRotate']);
          const h = new rD(t),
            d = new nD(i, t);
          (i.dragPan = new mD(r, h, d)), this._add('mousePan', h), this._add('touchPan', d, ['touchZoom', 'touchRotate']);
          const f = new sD(),
            p = new oD();
          (i.touchZoomRotate = new gD(r, p, f, a)), this._add('touchRotate', f, ['touchPan', 'touchZoom']), this._add('touchZoom', p, ['touchPan', 'touchRotate']), this._add('blockableMapEvent', new Jz(i));
          const _ = (i.scrollZoom = new hD(i, this));
          this._add('scrollZoom', _, ['mousePan']);
          const g = (i.keyboard = new cD());
          this._add('keyboard', g);
          for (const y of ['boxZoom', 'doubleClickZoom', 'tapDragZoom', 'touchPitch', 'dragRotate', 'dragPan', 'touchZoomRotate', 'scrollZoom', 'keyboard']) t.interactive && t[y] && i[y].enable(t[y]);
        }
        _add(t, i, r) {
          this._handlers.push({ handlerName: t, handler: i, allowed: r }), (this._handlersById[t] = i);
        }
        stop(t) {
          if (!this._updatingCamera) {
            for (const { handler: i } of this._handlers) i.reset();
            this._inertia.clear(), this._fireEvents({}, {}, t), (this._changes = []), (this._originalZoom = void 0);
          }
        }
        isActive() {
          for (const { handler: t } of this._handlers) if (t.isActive()) return !0;
          return !1;
        }
        isZooming() {
          return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
        }
        isRotating() {
          return !!this._eventsInProgress.rotate;
        }
        isMoving() {
          return !!Ih(this._eventsInProgress) || this.isZooming();
        }
        _isDragging() {
          return !!this._eventsInProgress.drag;
        }
        _blockedByActive(t, i, r) {
          for (const n in t) if (n !== r && (!i || i.indexOf(n) < 0)) return !0;
          return !1;
        }
        handleWindowEvent(t) {
          this.handleEvent(t, `${t.type}Window`);
        }
        _getMapTouches(t) {
          const i = [];
          for (const r of t) this._el.contains(r.target) && i.push(r);
          return i;
        }
        handleEvent(t, i) {
          this._updatingCamera = !0;
          const r = t.type === 'renderFrame',
            n = r ? void 0 : t,
            o = { needsRenderFrame: !1 },
            s = {},
            a = {},
            l = t.touches ? this._getMapTouches(t.touches) : void 0,
            c = l ? Tc(this._el, l) : r ? void 0 : Ja(this._el, t);
          for (const { handlerName: d, handler: f, allowed: p } of this._handlers) {
            if (!f.isEnabled()) continue;
            let _;
            this._blockedByActive(a, p, d) ? f.reset() : f[i || t.type] && ((_ = f[i || t.type](t, c, l)), this.mergeHandlerResult(o, s, _, d, n), _ && _.needsRenderFrame && this._triggerRenderFrame()), (_ || f.isActive()) && (a[d] = f);
          }
          const u = {};
          for (const d in this._previousActiveHandlers) a[d] || (u[d] = n);
          (this._previousActiveHandlers = a), (Object.keys(u).length || Ch(o)) && (this._changes.push([o, s, u]), this._triggerRenderFrame()), (Object.keys(a).length || Ch(o)) && this._map._stop(!0), (this._updatingCamera = !1);
          const { cameraAnimation: h } = o;
          h && (this._inertia.clear(), this._fireEvents({}, {}, !0), (this._changes = []), h(this._map));
        }
        mergeHandlerResult(t, i, r, n, o) {
          if (!r) return;
          Ft(t, r);
          const s = { handlerName: n, originalEvent: r.originalEvent || o };
          r.zoomDelta !== void 0 && (i.zoom = s), r.panDelta !== void 0 && (i.drag = s), r.pitchDelta !== void 0 && (i.pitch = s), r.bearingDelta !== void 0 && (i.rotate = s);
        }
        _applyChanges() {
          const t = {},
            i = {},
            r = {};
          for (const [n, o, s] of this._changes) n.panDelta && (t.panDelta = (t.panDelta || new H(0, 0))._add(n.panDelta)), n.zoomDelta && (t.zoomDelta = (t.zoomDelta || 0) + n.zoomDelta), n.bearingDelta && (t.bearingDelta = (t.bearingDelta || 0) + n.bearingDelta), n.pitchDelta && (t.pitchDelta = (t.pitchDelta || 0) + n.pitchDelta), n.around !== void 0 && (t.around = n.around), n.aroundCoord !== void 0 && (t.aroundCoord = n.aroundCoord), n.pinchAround !== void 0 && (t.pinchAround = n.pinchAround), n.noInertia && (t.noInertia = n.noInertia), Ft(i, o), Ft(r, s);
          this._updateMapTransform(t, i, r), (this._changes = []);
        }
        _updateMapTransform(t, i, r) {
          const n = this._map,
            o = n.transform,
            s = (v) => [v.x, v.y, v.z];
          if (
            ((v) => {
              const w = this._eventsInProgress.drag;
              return w && !this._handlersById[w.handlerName].isActive();
            })() &&
            !Ch(t)
          ) {
            const v = o.zoom;
            (o.cameraElevationReference = 'sea'), this._originalZoom != null && o._orthographicProjectionAtLowPitch && o.projection.name !== 'globe' && o.pitch === 0 ? ((o.cameraElevationReference = 'ground'), (o.zoom = this._originalZoom)) : (o.recenterOnTerrain(), (o.cameraElevationReference = 'ground')), v !== o.zoom && this._map._update(!0);
          }
          if ((o._isCameraConstrained && n._stop(!0), !Ch(t))) return void this._fireEvents(i, r, !0);
          let { panDelta: a, zoomDelta: l, bearingDelta: c, pitchDelta: u, around: h, aroundCoord: d, pinchAround: f } = t;
          o._isCameraConstrained && (l > 0 && (l = 0), (o._isCameraConstrained = !1)), f !== void 0 && (h = f), (l || ((v) => i[v] && !this._eventsInProgress[v])('drag')) && h && ((this._dragOrigin = s(o.pointCoordinate3D(h))), (this._originalZoom = o.zoom), this._trackingEllipsoid.setup(o._camera.position, this._dragOrigin)), (o.cameraElevationReference = 'sea'), n._stop(!0), (h = h || n.transform.centerPoint), c && (o.bearing += c), u && (o.pitch += u), o._updateCameraState();
          const p = [0, 0, 0];
          if (a)
            if (o.projection.name === 'mercator') {
              const v = this._trackingEllipsoid.projectRay(o.screenPointToMercatorRay(h).dir),
                w = this._trackingEllipsoid.projectRay(o.screenPointToMercatorRay(h.sub(a)).dir);
              (p[0] = w[0] - v[0]), (p[1] = w[1] - v[1]);
            } else {
              const v = o.pointCoordinate(h);
              if (o.projection.name === 'globe') {
                a = a.rotate(-o.angle);
                const w = o._pixelsPerMercatorPixel / o.worldSize;
                (p[0] = -a.x * _p(Ni(v.y)) * w), (p[1] = -a.y * _p(o.center.lat) * w);
              } else {
                const w = o.pointCoordinate(h.sub(a));
                v && w && ((p[0] = w.x - v.x), (p[1] = w.y - v.y));
              }
            }
          const _ = o.zoom,
            g = [0, 0, 0];
          if (l) {
            const v = s(d || o.pointCoordinate3D(h)),
              w = { dir: N.normalize([], N.sub([], v, o._camera.position)) };
            if (w.dir[2] < 0) {
              const T = o.zoomDeltaToMovement(v, l);
              N.scale(g, w.dir, T);
            }
          }
          const y = N.add(p, p, g);
          o._translateCameraConstrained(y), l && Math.abs(o.zoom - _) > 1e-4 && o.recenterOnTerrain(), (o.cameraElevationReference = 'ground'), this._map._update(), t.noInertia || this._inertia.record(t), this._fireEvents(i, r, !0);
        }
        _fireEvents(t, i, r) {
          const n = Ih(this._eventsInProgress),
            o = Ih(t),
            s = {};
          for (const u in t) {
            const { originalEvent: h } = t[u];
            this._eventsInProgress[u] || (s[`${u}start`] = h), (this._eventsInProgress[u] = t[u]);
          }
          !n && o && this._fireEvent('movestart', o.originalEvent);
          for (const u in s) this._fireEvent(u, s[u]);
          o && this._fireEvent('move', o.originalEvent);
          for (const u in t) {
            const { originalEvent: h } = t[u];
            this._fireEvent(u, h);
          }
          const a = {};
          let l;
          for (const u in this._eventsInProgress) {
            const { handlerName: h, originalEvent: d } = this._eventsInProgress[u];
            this._handlersById[h].isActive() || (delete this._eventsInProgress[u], (l = i[h] || d), (a[`${u}end`] = l));
          }
          for (const u in a) this._fireEvent(u, a[u]);
          const c = Ih(this._eventsInProgress);
          if (r && (n || o) && !c) {
            this._updatingCamera = !0;
            const u = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions),
              h = (d) => d !== 0 && -this._bearingSnap < d && d < this._bearingSnap;
            u ? (h(u.bearing || this._map.getBearing()) && (u.bearing = 0), this._map.easeTo(u, { originalEvent: l })) : (this._map.fire(new wt('moveend', { originalEvent: l })), h(this._map.getBearing()) && this._map.resetNorth()), (this._updatingCamera = !1);
          }
        }
        _fireEvent(t, i) {
          this._map.fire(new wt(t, i ? { originalEvent: i } : {}));
        }
        _requestFrame() {
          return (
            this._map.triggerRepaint(),
            this._map._renderTaskQueue.add((t) => {
              (this._frameId = void 0), this.handleEvent(new yD('renderFrame', { timeStamp: t })), this._applyChanges();
            })
          );
        }
        _triggerRenderFrame() {
          this._frameId === void 0 && (this._frameId = this._requestFrame());
        }
      }
      const xw = 'map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.';
      class bD extends Oi {
        constructor(t, i) {
          super(), (this._moving = !1), (this._zooming = !1), (this.transform = t), (this._bearingSnap = i.bearingSnap), (this._respectPrefersReducedMotion = i.respectPrefersReducedMotion !== !1), ot(['_renderFrameCallback'], this);
        }
        getCenter() {
          return new ie(this.transform.center.lng, this.transform.center.lat);
        }
        setCenter(t, i) {
          return this.jumpTo({ center: t }, i);
        }
        panBy(t, i, r) {
          return (t = H.convert(t).mult(-1)), this.panTo(this.transform.center, Ft({ offset: t }, i), r);
        }
        panTo(t, i, r) {
          return this.easeTo(Ft({ center: t }, i), r);
        }
        getZoom() {
          return this.transform.zoom;
        }
        setZoom(t, i) {
          return this.jumpTo({ zoom: t }, i), this;
        }
        zoomTo(t, i, r) {
          return this.easeTo(Ft({ zoom: t }, i), r);
        }
        zoomIn(t, i) {
          return this.zoomTo(this.getZoom() + 1, t, i), this;
        }
        zoomOut(t, i) {
          return this.zoomTo(this.getZoom() - 1, t, i), this;
        }
        getBearing() {
          return this.transform.bearing;
        }
        setBearing(t, i) {
          return this.jumpTo({ bearing: t }, i), this;
        }
        getPadding() {
          return this.transform.padding;
        }
        setPadding(t, i) {
          return this.jumpTo({ padding: t }, i), this;
        }
        rotateTo(t, i, r) {
          return this.easeTo(Ft({ bearing: t }, i), r);
        }
        resetNorth(t, i) {
          return this.rotateTo(0, Ft({ duration: 1e3 }, t), i), this;
        }
        resetNorthPitch(t, i) {
          return this.easeTo(Ft({ bearing: 0, pitch: 0, duration: 1e3 }, t), i), this;
        }
        snapToNorth(t, i) {
          return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t, i) : this;
        }
        getPitch() {
          return this.transform.pitch;
        }
        setPitch(t, i) {
          return this.jumpTo({ pitch: t }, i), this;
        }
        cameraForBounds(t, i) {
          t = kr.convert(t);
          const r = (i && i.bearing) || 0,
            n = (i && i.pitch) || 0,
            o = t.getNorthWest(),
            s = t.getSouthEast();
          return this._cameraForBounds(this.transform, o, s, r, n, i);
        }
        _extendCameraOptions(t) {
          const i = { top: 0, bottom: 0, right: 0, left: 0 };
          if (typeof (t = Ft({ padding: i, offset: [0, 0], maxZoom: this.transform.maxZoom }, t)).padding == 'number') {
            const r = t.padding;
            t.padding = { top: r, bottom: r, right: r, left: r };
          }
          return (t.padding = Ft(i, t.padding)), t;
        }
        _minimumAABBFrustumDistance(t, i) {
          const r = i.max[0] - i.min[0],
            n = i.max[1] - i.min[1];
          return r / n > t.aspect ? r / (2 * Math.tan(0.5 * t.fovX) * t.aspect) : n / (2 * Math.tan(0.5 * t.fovY) * t.aspect);
        }
        _cameraForBoundsOnGlobe(t, i, r, n, o, s) {
          const a = t.clone(),
            l = this._extendCameraOptions(s);
          (a.bearing = n), (a.pitch = o);
          const c = ie.convert(i),
            u = ie.convert(r),
            h = 0.5 * (c.lat + u.lat),
            d = 0.5 * (c.lng + u.lng),
            f = wr(h, d),
            p = N.normalize([], f),
            _ = N.normalize([], N.cross([], p, [0, 1, 0])),
            g = N.cross([], _, p),
            y = [_[0], _[1], _[2], 0, g[0], g[1], g[2], 0, p[0], p[1], p[2], 0, 0, 0, 0, 1],
            v = [f, wr(c.lat, c.lng), wr(u.lat, c.lng), wr(u.lat, u.lng), wr(c.lat, u.lng), wr(h, c.lng), wr(h, u.lng), wr(c.lat, d), wr(u.lat, d)];
          let w = ni.fromPoints(v.map((q) => [N.dot(_, q), N.dot(g, q), N.dot(p, q)]));
          const T = N.transformMat4([], w.center, y);
          N.squaredLength(T) === 0 && N.set(T, 0, 0, 1),
            N.normalize(T, T),
            N.scale(T, T, mr),
            (a.center = (function ([q, it, st]) {
              const nt = Math.hypot(q, it, st),
                ut = Math.atan2(q, st),
                ht = 0.5 * Math.PI - Math.acos(-it / nt);
              return new ie(Vi(ut), Vi(ht));
            })(T));
          const b = a.getWorldToCameraMatrix(),
            E = J.invert(new Float64Array(16), b);
          (w = ni.applyTransform(w, J.multiply([], b, y))), N.transformMat4(T, T, b);
          const S = 0.5 * (w.max[2] - w.min[2]),
            I = this._minimumAABBFrustumDistance(a, w),
            C = N.scale([], [0, 0, 1], S),
            z = N.add(C, T, C),
            k = I + (a.pitch === 0 ? 0 : N.distance(T, z)),
            O = a.globeCenterInViewSpace,
            V = N.sub([], T, [O[0], O[1], O[2]]);
          N.normalize(V, V), N.scale(V, V, k);
          const R = N.add([], T, V);
          N.transformMat4(R, R, E);
          const G = ya / mr,
            Z = N.length(R),
            X = Je(Math.max(Z * G - ya, Number.EPSILON), 0),
            j = Math.min(a.zoomFromMercatorZAdjusted(X), l.maxZoom);
          return j > 0.5 * (Sl + Oo) ? (a.setProjection({ name: 'mercator' }), (a.zoom = j), this._cameraForBounds(a, i, r, n, o, s)) : { center: a.center, zoom: j, bearing: n, pitch: o };
        }
        queryTerrainElevation(t, i) {
          const r = this.transform.elevation;
          return r ? ((i = Ft({}, { exaggerated: !0 }, i)), r.getAtPoint(Me.fromLngLat(t), null, i.exaggerated)) : null;
        }
        _cameraForBounds(t, i, r, n, o, s) {
          if (t.projection.name === 'globe') return this._cameraForBoundsOnGlobe(t, i, r, n, o, s);
          const a = t.clone(),
            l = this._extendCameraOptions(s),
            c = a.padding;
          (a.bearing = n), (a.pitch = o);
          const u = ie.convert(i),
            h = ie.convert(r),
            d = new ie(u.lng, h.lat),
            f = new ie(h.lng, u.lat),
            p = a.project(u),
            _ = a.project(h),
            g = this.queryTerrainElevation(u),
            y = this.queryTerrainElevation(h),
            v = this.queryTerrainElevation(d),
            w = this.queryTerrainElevation(f),
            T = [
              [p.x, p.y, Math.min(g || 0, y || 0, v || 0, w || 0)],
              [_.x, _.y, Math.max(g || 0, y || 0, v || 0, w || 0)],
            ];
          let b = ni.fromPoints(T);
          const E = a.getWorldToCameraMatrix(),
            S = J.invert(new Float64Array(16), E);
          b = ni.applyTransform(b, E);
          const I = N.sub([], b.max, b.min),
            C = c.left || 0,
            z = c.right || 0,
            k = c.bottom || 0,
            O = c.top || 0,
            { left: V, right: R, top: G, bottom: Z } = l.padding,
            X = 0.5 * (C + z),
            j = 0.5 * (O + k),
            q = Math.min(a.scaleZoom(a.scale * Math.min((a.width - (C + z + V + R)) / I[0], (a.height - (k + O + Z + G)) / I[1])), l.maxZoom),
            it = a.scale / a.zoomScale(q);
          b = new ni([b.min[0] - (V + X) * it, b.min[1] - (Z + j) * it, b.min[2]], [b.max[0] + (R + X) * it, b.max[1] + (G + j) * it, b.max[2]]);
          const st = 0.5 * I[2],
            nt = this._minimumAABBFrustumDistance(a, b),
            ut = [0, 0, 1, 0];
          We.transformMat4(ut, ut, E), We.normalize(ut, ut);
          const ht = N.scale([], ut, nt + st),
            pt = N.add([], b.center, ht),
            at = (typeof l.offset.x == 'number' && typeof l.offset.y == 'number' ? new H(l.offset.x, l.offset.y) : H.convert(l.offset)).rotate(-ne(n));
          (b.center[0] -= at.x * it), (b.center[1] += at.y * it), N.transformMat4(b.center, b.center, S), N.transformMat4(pt, pt, S);
          const _t = [b.center[0], b.center[1], pt[2] * a.pixelsPerMeter];
          N.scale(_t, _t, 1 / a.worldSize);
          const Ct = Or(_t[0]),
            Pt = Ni(_t[1]),
            Ot = Math.min(a._zoomFromMercatorZ(_t[2]), l.maxZoom),
            Ut = new ie(Ct, Pt);
          return a.mercatorFromTransition && Ot < 0.5 * (Sl + Oo) ? (a.setProjection({ name: 'globe' }), (a.zoom = Ot), this._cameraForBounds(a, i, r, n, o, s)) : { center: Ut, zoom: Ot, bearing: n, pitch: o };
        }
        fitBounds(t, i, r) {
          const n = this.cameraForBounds(t, i);
          return this._fitInternal(n, i, r);
        }
        fitScreenCoordinates(t, i, r, n, o) {
          const s = H.convert(t),
            a = H.convert(i),
            l = new H(Math.min(s.x, a.x), Math.min(s.y, a.y)),
            c = new H(Math.max(s.x, a.x), Math.max(s.y, a.y));
          if (this.transform.projection.name === 'mercator' && this.transform.anyCornerOffEdge(s, a)) return this;
          const u = this.transform.pointLocation3D(l),
            h = this.transform.pointLocation3D(c),
            d = this.transform.pointLocation3D(new H(l.x, c.y)),
            f = this.transform.pointLocation3D(new H(c.x, l.y)),
            p = [Math.min(u.lng, h.lng, d.lng, f.lng), Math.min(u.lat, h.lat, d.lat, f.lat)],
            _ = [Math.max(u.lng, h.lng, d.lng, f.lng), Math.max(u.lat, h.lat, d.lat, f.lat)],
            g = n && n.pitch ? n.pitch : this.getPitch(),
            y = this._cameraForBounds(this.transform, p, _, r, g, n);
          return this._fitInternal(y, n, o);
        }
        _fitInternal(t, i, r) {
          return t ? (delete (i = Ft(t, i)).padding, i.linear ? this.easeTo(i, r) : this.flyTo(i, r)) : this;
        }
        jumpTo(t, i) {
          this.stop();
          const r = t.preloadOnly ? this.transform.clone() : this.transform;
          let n = !1,
            o = !1,
            s = !1;
          return 'zoom' in t && r.zoom !== +t.zoom && ((n = !0), (r.zoom = +t.zoom)), t.center !== void 0 && (r.center = ie.convert(t.center)), 'bearing' in t && r.bearing !== +t.bearing && ((o = !0), (r.bearing = +t.bearing)), 'pitch' in t && r.pitch !== +t.pitch && ((s = !0), (r.pitch = +t.pitch)), t.padding == null || r.isPaddingEqual(t.padding) || (r.padding = t.padding), t.preloadOnly ? (this._preloadTiles(r), this) : (this.fire(new wt('movestart', i)).fire(new wt('move', i)), n && this.fire(new wt('zoomstart', i)).fire(new wt('zoom', i)).fire(new wt('zoomend', i)), o && this.fire(new wt('rotatestart', i)).fire(new wt('rotate', i)).fire(new wt('rotateend', i)), s && this.fire(new wt('pitchstart', i)).fire(new wt('pitch', i)).fire(new wt('pitchend', i)), this.fire(new wt('moveend', i)));
        }
        getFreeCameraOptions() {
          return this.transform.projection.supportsFreeCamera || B(xw), this.transform.getFreeCameraOptions();
        }
        setFreeCameraOptions(t, i) {
          const r = this.transform;
          if (!r.projection.supportsFreeCamera) return B(xw), this;
          this.stop();
          const n = r.zoom,
            o = r.pitch,
            s = r.bearing;
          r.setFreeCameraOptions(t);
          const a = n !== r.zoom,
            l = o !== r.pitch,
            c = s !== r.bearing;
          return this.fire(new wt('movestart', i)).fire(new wt('move', i)), a && this.fire(new wt('zoomstart', i)).fire(new wt('zoom', i)).fire(new wt('zoomend', i)), c && this.fire(new wt('rotatestart', i)).fire(new wt('rotate', i)).fire(new wt('rotateend', i)), l && this.fire(new wt('pitchstart', i)).fire(new wt('pitch', i)).fire(new wt('pitchend', i)), this.fire(new wt('moveend', i)), this;
        }
        easeTo(t, i) {
          this._stop(!1, t.easeId), ((t = Ft({ offset: [0, 0], duration: 500, easing: tr }, t)).animate === !1 || this._prefersReducedMotion(t)) && (t.duration = 0);
          const r = this.transform,
            n = this.getZoom(),
            o = this.getBearing(),
            s = this.getPitch(),
            a = this.getPadding(),
            l = 'zoom' in t ? +t.zoom : n,
            c = 'bearing' in t ? this._normalizeBearing(t.bearing, o) : o,
            u = 'pitch' in t ? +t.pitch : s,
            h = 'padding' in t ? t.padding : r.padding,
            d = H.convert(t.offset);
          let f, p, _;
          if (r.projection.name === 'globe') {
            const C = Me.fromLngLat(r.center),
              z = d.rotate(-r.angle);
            (C.x += z.x / r.worldSize), (C.y += z.y / r.worldSize);
            const k = C.toLngLat(),
              O = ie.convert(t.center || k);
            this._normalizeCenter(O), (f = r.centerPoint.add(z)), (p = new H(C.x, C.y).mult(r.worldSize)), (_ = new H(qi(O.lng), Hi(O.lat)).mult(r.worldSize).sub(p));
          } else {
            f = r.centerPoint.add(d);
            const C = r.pointLocation(f),
              z = ie.convert(t.center || C);
            this._normalizeCenter(z), (p = r.project(C)), (_ = r.project(z).sub(p));
          }
          const g = r.zoomScale(l - n);
          let y, v;
          t.around && ((y = ie.convert(t.around)), (v = r.locationPoint(y)));
          const w = this._zooming || l !== n,
            T = this._rotating || o !== c,
            b = this._pitching || u !== s,
            E = !r.isPaddingEqual(h),
            S = (C) => (z) => {
              if ((w && (C.zoom = ee(n, l, z)), T && (C.bearing = ee(o, c, z)), b && (C.pitch = ee(s, u, z)), E && (C.interpolatePadding(a, h, z), (f = C.centerPoint.add(d))), y)) C.setLocationAtPoint(y, v);
              else {
                const k = C.zoomScale(C.zoom - n),
                  O = l > n ? Math.min(2, g) : Math.max(0.5, g),
                  V = Math.pow(O, 1 - z),
                  R = C.unproject(p.add(_.mult(z * V)).mult(k));
                C.setLocationAtPoint(C.renderWorldCopies ? R.wrap() : R, f);
              }
              return t.preloadOnly || this._fireMoveEvents(i), C;
            };
          if (t.preloadOnly) {
            const C = this._emulate(S, t.duration, r);
            return this._preloadTiles(C), this;
          }
          const I = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
          return (
            (this._zooming = w),
            (this._rotating = T),
            (this._pitching = b),
            (this._padding = E),
            (this._easeId = t.easeId),
            this._prepareEase(i, t.noMoveStart, I),
            this._ease(
              S(r),
              (C) => {
                r.cameraElevationReference === 'sea' && r.recenterOnTerrain(), this._afterEase(i, C);
              },
              t
            ),
            this
          );
        }
        _prepareEase(t, i, r = {}) {
          (this._moving = !0), (this.transform.cameraElevationReference = 'sea'), this.transform._orthographicProjectionAtLowPitch && this.transform.pitch === 0 && this.transform.projection.name !== 'globe' && (this.transform.cameraElevationReference = 'ground'), i || r.moving || this.fire(new wt('movestart', t)), this._zooming && !r.zooming && this.fire(new wt('zoomstart', t)), this._rotating && !r.rotating && this.fire(new wt('rotatestart', t)), this._pitching && !r.pitching && this.fire(new wt('pitchstart', t));
        }
        _fireMoveEvents(t) {
          this.fire(new wt('move', t)), this._zooming && this.fire(new wt('zoom', t)), this._rotating && this.fire(new wt('rotate', t)), this._pitching && this.fire(new wt('pitch', t));
        }
        _afterEase(t, i) {
          if (this._easeId && i && this._easeId === i) return;
          (this._easeId = void 0), (this.transform.cameraElevationReference = 'ground');
          const r = this._zooming,
            n = this._rotating,
            o = this._pitching;
          (this._moving = !1), (this._zooming = !1), (this._rotating = !1), (this._pitching = !1), (this._padding = !1), r && this.fire(new wt('zoomend', t)), n && this.fire(new wt('rotateend', t)), o && this.fire(new wt('pitchend', t)), this.fire(new wt('moveend', t));
        }
        flyTo(t, i) {
          if (this._prefersReducedMotion(t)) {
            const q = ar(t, ['center', 'zoom', 'bearing', 'pitch', 'around']);
            return this.jumpTo(q, i);
          }
          this.stop(), (t = Ft({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: tr }, t));
          const r = this.transform,
            n = this.getZoom(),
            o = this.getBearing(),
            s = this.getPitch(),
            a = this.getPadding(),
            l = 'zoom' in t ? Bt(+t.zoom, r.minZoom, r.maxZoom) : n,
            c = 'bearing' in t ? this._normalizeBearing(t.bearing, o) : o,
            u = 'pitch' in t ? +t.pitch : s,
            h = 'padding' in t ? t.padding : r.padding,
            d = r.zoomScale(l - n),
            f = H.convert(t.offset);
          let p = r.centerPoint.add(f);
          const _ = r.pointLocation(p),
            g = ie.convert(t.center || _);
          this._normalizeCenter(g);
          const y = r.project(_),
            v = r.project(g).sub(y);
          let w = t.curve;
          const T = Math.max(r.width, r.height),
            b = T / d,
            E = v.mag();
          if ('minZoom' in t) {
            const q = Bt(Math.min(t.minZoom, n, l), r.minZoom, r.maxZoom),
              it = T / r.zoomScale(q - n);
            w = Math.sqrt((it / E) * 2);
          }
          const S = w * w;
          function I(q) {
            const it = (b * b - T * T + (q ? -1 : 1) * S * S * E * E) / (2 * (q ? b : T) * S * E);
            return Math.log(Math.sqrt(it * it + 1) - it);
          }
          function C(q) {
            return (Math.exp(q) - Math.exp(-q)) / 2;
          }
          function z(q) {
            return (Math.exp(q) + Math.exp(-q)) / 2;
          }
          const k = I(0);
          let O = function (q) {
              return z(k) / z(k + w * q);
            },
            V = function (q) {
              return (T * ((z(k) * (C((it = k + w * q)) / z(it)) - C(k)) / S)) / E;
              var it;
            },
            R = (I(1) - k) / w;
          if (Math.abs(E) < 1e-6 || !isFinite(R)) {
            if (Math.abs(T - b) < 1e-6) return this.easeTo(t, i);
            const q = b < T ? -1 : 1;
            (R = Math.abs(Math.log(b / T)) / w),
              (V = function () {
                return 0;
              }),
              (O = function (it) {
                return Math.exp(q * w * it);
              });
          }
          (t.duration = 'duration' in t ? +t.duration : (1e3 * R) / ('screenSpeed' in t ? +t.screenSpeed / w : +t.speed)), t.maxDuration && t.duration > t.maxDuration && (t.duration = 0);
          const G = o !== c,
            Z = u !== s,
            X = !r.isPaddingEqual(h),
            j = (q) => (it) => {
              const st = it * R,
                nt = 1 / O(st);
              (q.zoom = it === 1 ? l : n + q.scaleZoom(nt)), G && (q.bearing = ee(o, c, it)), Z && (q.pitch = ee(s, u, it)), X && (q.interpolatePadding(a, h, it), (p = q.centerPoint.add(f)));
              const ut = it === 1 ? g : q.unproject(y.add(v.mult(V(st))).mult(nt));
              return q.setLocationAtPoint(q.renderWorldCopies ? ut.wrap() : ut, p), q._updateCameraOnTerrain(), t.preloadOnly || this._fireMoveEvents(i), q;
            };
          if (t.preloadOnly) {
            const q = this._emulate(j, t.duration, r);
            return this._preloadTiles(q), this;
          }
          return (this._zooming = !0), (this._rotating = G), (this._pitching = Z), (this._padding = X), this._prepareEase(i, !1), this._ease(j(r), () => this._afterEase(i), t), this;
        }
        isEasing() {
          return !!this._easeFrameId;
        }
        stop() {
          return this._stop();
        }
        _stop(t, i) {
          if ((this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), (this._easeFrameId = void 0), (this._onEaseFrame = void 0)), this._onEaseEnd)) {
            const r = this._onEaseEnd;
            (this._onEaseEnd = void 0), r.call(this, i);
          }
          if (!t) {
            const r = this.handlers;
            r && r.stop(!1);
          }
          return this;
        }
        _ease(t, i, r) {
          r.animate === !1 || r.duration === 0 ? (t(1), i()) : ((this._easeStart = oe.now()), (this._easeOptions = r), (this._onEaseFrame = t), (this._onEaseEnd = i), (this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback)));
        }
        _renderFrameCallback() {
          const t = Math.min((oe.now() - this._easeStart) / this._easeOptions.duration, 1),
            i = this._onEaseFrame;
          i && i(this._easeOptions.easing(t)), t < 1 ? (this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback)) : this.stop();
        }
        _normalizeBearing(t, i) {
          t = en(t, -180, 180);
          const r = Math.abs(t - i);
          return Math.abs(t - 360 - i) < r && (t -= 360), Math.abs(t + 360 - i) < r && (t += 360), t;
        }
        _normalizeCenter(t) {
          const i = this.transform;
          if (i.maxBounds || (i.projection.name !== 'globe' && !i.renderWorldCopies)) return;
          const r = t.lng - i.center.lng;
          t.lng += r > 180 ? -360 : r < -180 ? 360 : 0;
        }
        _prefersReducedMotion(t) {
          return this._respectPrefersReducedMotion && oe.prefersReducedMotion && !(t && t.essential);
        }
        _emulate(t, i, r) {
          const n = Math.ceil((15 * i) / 1e3),
            o = [],
            s = t(r.clone());
          for (let a = 0; a <= n; a++) {
            const l = s(a / n);
            o.push(l.clone());
          }
          return o;
        }
      }
      class vw {
        constructor(t = {}) {
          (this.options = t), ot(['_toggleAttribution', '_updateEditLink', '_updateData', '_updateCompact'], this);
        }
        getDefaultPosition() {
          return 'bottom-right';
        }
        onAdd(t) {
          const i = this.options && this.options.compact;
          return (this._map = t), (this._container = ri('div', 'mapboxgl-ctrl mapboxgl-ctrl-attrib')), (this._compactButton = ri('button', 'mapboxgl-ctrl-attrib-button', this._container)), ri('span', 'mapboxgl-ctrl-icon', this._compactButton).setAttribute('aria-hidden', 'true'), (this._compactButton.type = 'button'), this._compactButton.addEventListener('click', this._toggleAttribution), this._setElementTitle(this._compactButton, 'ToggleAttribution'), (this._innerContainer = ri('div', 'mapboxgl-ctrl-attrib-inner', this._container)), i && this._container.classList.add('mapboxgl-compact'), this._updateAttributions(), this._updateEditLink(), this._map.on('styledata', this._updateData), this._map.on('sourcedata', this._updateData), this._map.on('moveend', this._updateEditLink), i === void 0 && (this._map.on('resize', this._updateCompact), this._updateCompact()), this._container;
        }
        onRemove() {
          this._container.remove(), this._map.off('styledata', this._updateData), this._map.off('sourcedata', this._updateData), this._map.off('moveend', this._updateEditLink), this._map.off('resize', this._updateCompact), (this._map = void 0), (this._attribHTML = void 0);
        }
        _setElementTitle(t, i) {
          const r = this._map._getUIString(`AttributionControl.${i}`);
          t.removeAttribute('title'), t.firstElementChild && t.firstElementChild.setAttribute('title', r);
        }
        _toggleAttribution() {
          this._container.classList.contains('mapboxgl-compact-show') ? (this._container.classList.remove('mapboxgl-compact-show'), this._compactButton.setAttribute('aria-expanded', 'false')) : (this._container.classList.add('mapboxgl-compact-show'), this._compactButton.setAttribute('aria-expanded', 'true'));
        }
        _updateEditLink() {
          let t = this._editLink;
          t || (t = this._editLink = this._container.querySelector('.mapbox-improve-map'));
          const i = [
            { key: 'owner', value: this.styleOwner },
            { key: 'id', value: this.styleId },
            { key: 'access_token', value: this._map._requestManager._customAccessToken || Mt.ACCESS_TOKEN },
          ];
          if (t) {
            const r = i.reduce((n, o, s) => (o.value && (n += `${o.key}=${o.value}${s < i.length - 1 ? '&' : ''}`), n), '?');
            (t.href = `${Mt.FEEDBACK_URL}/${r}#${fw(this._map, !0)}`), (t.rel = 'noopener nofollow'), this._setElementTitle(t, 'MapFeedback');
          }
        }
        _updateData(t) {
          !t || (t.sourceDataType !== 'metadata' && t.sourceDataType !== 'visibility' && t.dataType !== 'style') || (this._updateAttributions(), this._updateEditLink());
        }
        _updateAttributions() {
          if (!this._map.style) return;
          let t = [];
          if (this._map.style.stylesheet) {
            const n = this._map.style.stylesheet;
            (this.styleOwner = n.owner), (this.styleId = n.id);
          }
          const i = this._map.style._mergedSourceCaches;
          for (const n in i) {
            const o = i[n];
            if (o.used) {
              const s = o.getSource();
              s.attribution && t.indexOf(s.attribution) < 0 && t.push(s.attribution);
            }
          }
          t.sort((n, o) => n.length - o.length),
            (t = t.filter((n, o) => {
              for (let s = o + 1; s < t.length; s++) if (t[s].indexOf(n) >= 0) return !1;
              return !0;
            })),
            this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? (t = [...this.options.customAttribution, ...t]) : t.unshift(this.options.customAttribution));
          const r = t.join(' | ');
          r !== this._attribHTML && ((this._attribHTML = r), t.length ? ((this._innerContainer.innerHTML = r), this._container.classList.remove('mapboxgl-attrib-empty')) : this._container.classList.add('mapboxgl-attrib-empty'), (this._editLink = null));
        }
        _updateCompact() {
          this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add('mapboxgl-compact') : this._container.classList.remove('mapboxgl-compact', 'mapboxgl-compact-show');
        }
      }
      class bw {
        constructor() {
          ot(['_updateLogo', '_updateCompact'], this);
        }
        onAdd(t) {
          (this._map = t), (this._container = ri('div', 'mapboxgl-ctrl'));
          const i = ri('a', 'mapboxgl-ctrl-logo');
          return (i.target = '_blank'), (i.rel = 'noopener nofollow'), (i.href = 'https://www.mapbox.com/'), i.setAttribute('aria-label', this._map._getUIString('LogoControl.Title')), i.setAttribute('rel', 'noopener nofollow'), this._container.appendChild(i), (this._container.style.display = 'none'), this._map.on('sourcedata', this._updateLogo), this._updateLogo(), this._map.on('resize', this._updateCompact), this._updateCompact(), this._container;
        }
        onRemove() {
          this._container.remove(), this._map.off('sourcedata', this._updateLogo), this._map.off('resize', this._updateCompact);
        }
        getDefaultPosition() {
          return 'bottom-left';
        }
        _updateLogo(t) {
          (t && t.sourceDataType !== 'metadata') || (this._container.style.display = this._logoRequired() ? 'block' : 'none');
        }
        _logoRequired() {
          if (!this._map.style) return !0;
          const t = this._map.style._sourceCaches;
          if (Object.entries(t).length === 0) return !0;
          for (const i in t) {
            const r = t[i].getSource();
            if (r.hasOwnProperty('mapbox_logo') && !r.mapbox_logo) return !1;
          }
          return !0;
        }
        _updateCompact() {
          const t = this._container.children;
          if (t.length) {
            const i = t[0];
            this._map.getCanvasContainer().offsetWidth < 250 ? i.classList.add('mapboxgl-compact') : i.classList.remove('mapboxgl-compact');
          }
        }
      }
      class ww {
        constructor() {
          (this._queue = []), (this._id = 0), (this._cleared = !1), (this._currentlyRunning = !1);
        }
        add(t) {
          const i = ++this._id;
          return this._queue.push({ callback: t, id: i, cancelled: !1 }), i;
        }
        remove(t) {
          const i = this._currentlyRunning,
            r = i ? this._queue.concat(i) : this._queue;
          for (const n of r) if (n.id === t) return void (n.cancelled = !0);
        }
        run(t = 0) {
          const i = (this._currentlyRunning = this._queue);
          this._queue = [];
          for (const r of i) if (!r.cancelled && (r.callback(t), this._cleared)) break;
          (this._cleared = !1), (this._currentlyRunning = !1);
        }
        clear() {
          this._currentlyRunning && (this._cleared = !0), (this._queue = []);
        }
      }
      function Tw(e, t, i) {
        if (((e = new ie(e.lng, e.lat)), t)) {
          const r = new ie(e.lng - 360, e.lat),
            n = new ie(e.lng + 360, e.lat),
            o = 360 * Math.ceil(Math.abs(e.lng - i.center.lng) / 360),
            s = i.locationPoint(e).distSqr(t),
            a = t.x < 0 || t.y < 0 || t.x > i.width || t.y > i.height;
          i.locationPoint(r).distSqr(t) < s && (a || Math.abs(r.lng - i.center.lng) < o) ? (e = r) : i.locationPoint(n).distSqr(t) < s && (a || Math.abs(n.lng - i.center.lng) < o) && (e = n);
        }
        for (; Math.abs(e.lng - i.center.lng) > 180; ) {
          const r = i.locationPoint(e);
          if (r.x >= 0 && r.y >= 0 && r.x <= i.width && r.y <= i.height) break;
          e.lng > i.center.lng ? (e.lng -= 360) : (e.lng += 360);
        }
        return e;
      }
      const Um = { center: 'translate(-50%,-50%)', top: 'translate(-50%,0)', 'top-left': 'translate(0,0)', 'top-right': 'translate(-100%,0)', bottom: 'translate(-50%,-100%)', 'bottom-left': 'translate(0,-100%)', 'bottom-right': 'translate(-100%,-100%)', left: 'translate(0,-50%)', right: 'translate(-100%,-50%)' };
      class Vm extends Oi {
        constructor(t, i) {
          if ((super(), (t instanceof U.HTMLElement || i) && (t = Ft({ element: t }, i)), ot(['_update', '_onMove', '_onUp', '_addDragHandler', '_onMapClick', '_onKeyPress', '_clearFadeTimer'], this), (this._anchor = (t && t.anchor) || 'center'), (this._color = (t && t.color) || '#3FB1CE'), (this._scale = (t && t.scale) || 1), (this._draggable = (t && t.draggable) || !1), (this._clickTolerance = (t && t.clickTolerance) || 0), (this._isDragging = !1), (this._state = 'inactive'), (this._rotation = (t && t.rotation) || 0), (this._rotationAlignment = (t && t.rotationAlignment) || 'auto'), (this._pitchAlignment = (t && t.pitchAlignment && t.pitchAlignment) || 'auto'), (this._updateMoving = () => this._update(!0)), (this._occludedOpacity = (t && t.occludedOpacity) || 0.2), t && t.element)) (this._element = t.element), (this._offset = H.convert((t && t.offset) || [0, 0]));
          else {
            (this._defaultMarker = !0), (this._element = ri('div'));
            const o = 41,
              s = 27,
              a = Jn('svg', { display: 'block', height: o * this._scale + 'px', width: s * this._scale + 'px', viewBox: `0 0 ${s} ${o}` }, this._element),
              l = Jn('radialGradient', { id: 'shadowGradient' }, Jn('defs', {}, a));
            Jn('stop', { offset: '10%', 'stop-opacity': 0.4 }, l), Jn('stop', { offset: '100%', 'stop-opacity': 0.05 }, l), Jn('ellipse', { cx: 13.5, cy: 34.8, rx: 10.5, ry: 5.25, fill: 'url(#shadowGradient)' }, a), Jn('path', { fill: this._color, d: 'M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z' }, a), Jn('path', { opacity: 0.25, d: 'M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z' }, a), Jn('circle', { fill: 'white', cx: 13.5, cy: 13.5, r: 5.5 }, a), (this._offset = H.convert((t && t.offset) || [0, -14]));
          }
          this._element.hasAttribute('aria-label') || this._element.setAttribute('aria-label', 'Map marker'),
            this._element.hasAttribute('role') || this._element.setAttribute('role', 'img'),
            this._element.classList.add('mapboxgl-marker'),
            this._element.addEventListener('dragstart', (o) => {
              o.preventDefault();
            }),
            this._element.addEventListener('mousedown', (o) => {
              o.preventDefault();
            });
          const r = this._element.classList;
          for (const o in Um) r.remove(`mapboxgl-marker-anchor-${o}`);
          r.add(`mapboxgl-marker-anchor-${this._anchor}`);
          const n = t && t.className ? t.className.trim().split(/\s+/) : [];
          r.add(...n), (this._popup = null);
        }
        addTo(t) {
          return t === this._map || (this.remove(), (this._map = t), t.getCanvasContainer().appendChild(this._element), t.on('move', this._updateMoving), t.on('moveend', this._update), t.on('remove', this._clearFadeTimer), t._addMarker(this), this.setDraggable(this._draggable), this._update(), t.on('click', this._onMapClick)), this;
        }
        remove() {
          const t = this._map;
          return t && (t.off('click', this._onMapClick), t.off('move', this._updateMoving), t.off('moveend', this._update), t.off('mousedown', this._addDragHandler), t.off('touchstart', this._addDragHandler), t.off('mouseup', this._onUp), t.off('touchend', this._onUp), t.off('mousemove', this._onMove), t.off('touchmove', this._onMove), t.off('remove', this._clearFadeTimer), t._removeMarker(this), (this._map = void 0)), this._clearFadeTimer(), this._element.remove(), this._popup && this._popup.remove(), this;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(t) {
          return (this._lngLat = ie.convert(t)), (this._pos = null), this._popup && this._popup.setLngLat(this._lngLat), this._update(!0), this;
        }
        getElement() {
          return this._element;
        }
        setPopup(t) {
          if ((this._popup && (this._popup.remove(), (this._popup = null), this._element.removeAttribute('role'), this._element.removeEventListener('keypress', this._onKeyPress), this._originalTabIndex || this._element.removeAttribute('tabindex')), t)) {
            if (!('offset' in t.options)) {
              const n = Math.sqrt(Math.pow(13.5, 2) / 2);
              t.options.offset = this._defaultMarker ? { top: [0, 0], 'top-left': [0, 0], 'top-right': [0, 0], bottom: [0, -38.1], 'bottom-left': [n, -1 * (38.1 - 13.5 + n)], 'bottom-right': [-n, -1 * (38.1 - 13.5 + n)], left: [13.5, -1 * (38.1 - 13.5)], right: [-13.5, -1 * (38.1 - 13.5)] } : this._offset;
            }
            (this._popup = t), (t._marker = this), this._lngLat && this._popup.setLngLat(this._lngLat), this._element.setAttribute('role', 'button'), (this._originalTabIndex = this._element.getAttribute('tabindex')), this._originalTabIndex || this._element.setAttribute('tabindex', '0'), this._element.addEventListener('keypress', this._onKeyPress), this._element.setAttribute('aria-expanded', 'false');
          }
          return this;
        }
        _onKeyPress(t) {
          const i = t.code,
            r = t.charCode || t.keyCode;
          (i !== 'Space' && i !== 'Enter' && r !== 32 && r !== 13) || this.togglePopup();
        }
        _onMapClick(t) {
          const i = t.originalEvent.target,
            r = this._element;
          this._popup && (i === r || r.contains(i)) && this.togglePopup();
        }
        getPopup() {
          return this._popup;
        }
        togglePopup() {
          const t = this._popup;
          return t ? (t.isOpen() ? (t.remove(), this._element.setAttribute('aria-expanded', 'false')) : this._map && (t.addTo(this._map), this._element.setAttribute('aria-expanded', 'true')), this) : this;
        }
        _behindTerrain() {
          const t = this._map,
            i = this._pos;
          if (!t || !i) return !1;
          const r = t.unproject(i),
            n = t.getFreeCameraOptions();
          if (!n.position) return !1;
          const o = n.position.toLngLat();
          return o.distanceTo(r) < 0.9 * o.distanceTo(this._lngLat);
        }
        _evaluateOpacity() {
          const t = this._map;
          if (!t) return;
          const i = this._pos;
          if (!i || i.x < 0 || i.x > t.transform.width || i.y < 0 || i.y > t.transform.height) return void this._clearFadeTimer();
          const r = t.unproject(i);
          let n;
          t._showingGlobe() && fu(t.transform, this._lngLat) ? (n = 0) : ((n = 1 - t._queryFogOpacity(r)), t.transform._terrainEnabled() && t.getTerrain() && this._behindTerrain() && (n *= this._occludedOpacity)), (this._element.style.opacity = `${n}`), (this._element.style.pointerEvents = n > 0 ? 'auto' : 'none'), this._popup && this._popup._setOpacity(n), (this._fadeTimer = null);
        }
        _clearFadeTimer() {
          this._fadeTimer && (clearTimeout(this._fadeTimer), (this._fadeTimer = null));
        }
        _updateDOM() {
          const t = this._pos;
          if (!t || !this._map) return;
          const i = this._offset.mult(this._scale);
          this._element.style.transform = `
            translate(${t.x}px,${t.y}px)
            ${Um[this._anchor]}
            ${this._calculateXYTransform()} ${this._calculateZTransform()}
            translate(${i.x}px,${i.y}px)
        `;
        }
        _calculateXYTransform() {
          const t = this._pos,
            i = this._map,
            r = this.getPitchAlignment();
          if (!i || !t || r !== 'map') return '';
          if (!i._showingGlobe()) {
            const l = i.getPitch();
            return l ? `rotateX(${l}deg)` : '';
          }
          const n = Vi(ux(i.transform, this._lngLat)),
            o = t.sub(cx(i.transform)),
            s = Math.abs(o.x) + Math.abs(o.y);
          if (s === 0) return '';
          const a = n / s;
          return `rotateX(${-o.y * a}deg) rotateY(${o.x * a}deg)`;
        }
        _calculateZTransform() {
          const t = this._pos,
            i = this._map;
          if (!i || !t) return '';
          let r = 0;
          const n = this.getRotationAlignment();
          if (n === 'map')
            if (i._showingGlobe()) {
              const o = i.project(new ie(this._lngLat.lng, this._lngLat.lat + 0.001)),
                s = i.project(new ie(this._lngLat.lng, this._lngLat.lat - 0.001)).sub(o);
              r = Vi(Math.atan2(s.y, s.x)) - 90;
            } else r = -i.getBearing();
          else if (n === 'horizon') {
            const o = Zr(4, 6, i.getZoom()),
              s = cx(i.transform);
            s.y += o * i.transform.height;
            const a = t.sub(s),
              l = Vi(Math.atan2(a.y, a.x));
            r = (l > 90 ? l - 270 : l + 90) * (1 - o);
          }
          return (r += this._rotation), r ? `rotateZ(${r}deg)` : '';
        }
        _update(t) {
          U.cancelAnimationFrame(this._updateFrameId);
          const i = this._map;
          i &&
            (i.transform.renderWorldCopies && (this._lngLat = Tw(this._lngLat, this._pos, i.transform)),
            (this._pos = i.project(this._lngLat)),
            t === !0
              ? (this._updateFrameId = U.requestAnimationFrame(() => {
                  this._element && this._pos && this._anchor && ((this._pos = this._pos.round()), this._updateDOM());
                }))
              : (this._pos = this._pos.round()),
            i._requestDomTask(() => {
              this._map && (this._element && this._pos && this._anchor && this._updateDOM(), (i._showingGlobe() || i.getTerrain() || i.getFog()) && !this._fadeTimer && (this._fadeTimer = setTimeout(this._evaluateOpacity.bind(this), 60)));
            }));
        }
        getOffset() {
          return this._offset;
        }
        setOffset(t) {
          return (this._offset = H.convert(t)), this._update(), this;
        }
        addClassName(t) {
          return this._element.classList.add(t), this;
        }
        removeClassName(t) {
          return this._element.classList.remove(t), this;
        }
        toggleClassName(t) {
          return this._element.classList.toggle(t);
        }
        _onMove(t) {
          const i = this._map;
          if (!i) return;
          const r = this._pointerdownPos,
            n = this._positionDelta;
          if (r && n) {
            if (!this._isDragging) {
              const o = this._clickTolerance || i._clickTolerance;
              if (t.point.dist(r) < o) return;
              this._isDragging = !0;
            }
            (this._pos = t.point.sub(n)), (this._lngLat = i.unproject(this._pos)), this.setLngLat(this._lngLat), (this._element.style.pointerEvents = 'none'), this._state === 'pending' && ((this._state = 'active'), this.fire(new wt('dragstart'))), this.fire(new wt('drag'));
          }
        }
        _onUp() {
          (this._element.style.pointerEvents = 'auto'), (this._positionDelta = null), (this._pointerdownPos = null), (this._isDragging = !1);
          const t = this._map;
          t && (t.off('mousemove', this._onMove), t.off('touchmove', this._onMove)), this._state === 'active' && this.fire(new wt('dragend')), (this._state = 'inactive');
        }
        _addDragHandler(t) {
          const i = this._map,
            r = this._pos;
          i && r && this._element.contains(t.originalEvent.target) && (t.preventDefault(), (this._positionDelta = t.point.sub(r)), (this._pointerdownPos = t.point), (this._state = 'pending'), i.on('mousemove', this._onMove), i.on('touchmove', this._onMove), i.once('mouseup', this._onUp), i.once('touchend', this._onUp));
        }
        setDraggable(t) {
          this._draggable = !!t;
          const i = this._map;
          return i && (t ? (i.on('mousedown', this._addDragHandler), i.on('touchstart', this._addDragHandler)) : (i.off('mousedown', this._addDragHandler), i.off('touchstart', this._addDragHandler))), this;
        }
        isDraggable() {
          return this._draggable;
        }
        setRotation(t) {
          return (this._rotation = t || 0), this._update(), this;
        }
        getRotation() {
          return this._rotation;
        }
        setRotationAlignment(t) {
          return (this._rotationAlignment = t || 'auto'), this._update(), this;
        }
        getRotationAlignment() {
          return this._rotationAlignment === 'auto' || (this._rotationAlignment === 'horizon' && this._map && !this._map._showingGlobe()) ? 'viewport' : this._rotationAlignment;
        }
        setPitchAlignment(t) {
          return (this._pitchAlignment = t || 'auto'), this._update(), this;
        }
        getPitchAlignment() {
          return this._pitchAlignment === 'auto' ? this.getRotationAlignment() : this._pitchAlignment;
        }
        setOccludedOpacity(t) {
          return (this._occludedOpacity = t || 0.2), this._update(), this;
        }
        getOccludedOpacity() {
          return this._occludedOpacity;
        }
      }
      const wD = { closeButton: !0, closeOnClick: !0, focusAfterOpen: !0, className: '', maxWidth: '240px' },
        TD = ['a[href]', "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", 'button:not([disabled])', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])'].join(', ');
      function Ew(e = new H(0, 0), t = 'bottom') {
        if (typeof e == 'number') {
          const i = Math.round(Math.sqrt(0.5 * Math.pow(e, 2)));
          switch (t) {
            case 'top':
              return new H(0, e);
            case 'top-left':
              return new H(i, i);
            case 'top-right':
              return new H(-i, i);
            case 'bottom':
              return new H(0, -e);
            case 'bottom-left':
              return new H(i, -i);
            case 'bottom-right':
              return new H(-i, -i);
            case 'left':
              return new H(e, 0);
            case 'right':
              return new H(-e, 0);
          }
          return new H(0, 0);
        }
        return e instanceof H || Array.isArray(e) ? H.convert(e) : H.convert(e[t] || [0, 0]);
      }
      class ED {
        constructor(t) {
          this.jumpTo(t);
        }
        getValue(t) {
          if (t <= this._startTime) return this._start;
          if (t >= this._endTime) return this._end;
          const i = mi((t - this._startTime) / (this._endTime - this._startTime));
          return this._start * (1 - i) + this._end * i;
        }
        isEasing(t) {
          return t >= this._startTime && t <= this._endTime;
        }
        jumpTo(t) {
          (this._startTime = -1 / 0), (this._endTime = -1 / 0), (this._start = t), (this._end = t);
        }
        easeTo(t, i, r) {
          (this._start = this.getValue(i)), (this._end = t), (this._startTime = i), (this._endTime = i + r);
        }
      }
      const MD = { 'AttributionControl.ToggleAttribution': 'Toggle attribution', 'AttributionControl.MapFeedback': 'Map feedback', 'FullscreenControl.Enter': 'Enter fullscreen', 'FullscreenControl.Exit': 'Exit fullscreen', 'GeolocateControl.FindMyLocation': 'Find my location', 'GeolocateControl.LocationNotAvailable': 'Location not available', 'LogoControl.Title': 'Mapbox logo', 'Map.Title': 'Map', 'NavigationControl.ResetBearing': 'Reset bearing to north', 'NavigationControl.ZoomIn': 'Zoom in', 'NavigationControl.ZoomOut': 'Zoom out', 'ScrollZoomBlocker.CtrlMessage': 'Use ctrl + scroll to zoom the map', 'ScrollZoomBlocker.CmdMessage': 'Use  + scroll to zoom the map', 'TouchPanBlocker.Message': 'Use two fingers to move the map' },
        SD = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 85, interactive: !0, scrollZoom: !0, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, touchPitch: !0, cooperativeGestures: !1, performanceMetricsCollection: !0, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: !0, hash: !1, attributionControl: !0, antialias: !1, failIfMajorPerformanceCaveat: !1, preserveDrawingBuffer: !1, trackResize: !0, renderWorldCopies: !0, refreshExpiredTiles: !0, minTileCacheSize: null, maxTileCacheSize: null, localIdeographFontFamily: 'sans-serif', localFontFamily: null, transformRequest: null, accessToken: null, fadeDuration: 300, respectPrefersReducedMotion: !0, crossSourceCollisions: !0, collectResourceTiming: !1, testMode: !1 },
        AD = { showCompass: !0, showZoom: !0, visualizePitch: !1 };
      class ID {
        constructor(t, i, r = !1) {
          (this._clickTolerance = 10), (this.element = i), (this.mouseRotate = new pw({ clickTolerance: t.dragRotate._mouseRotate._clickTolerance })), (this.map = t), r && (this.mousePitch = new mw({ clickTolerance: t.dragRotate._mousePitch._clickTolerance })), ot(['mousedown', 'mousemove', 'mouseup', 'touchstart', 'touchmove', 'touchend', 'reset'], this), i.addEventListener('mousedown', this.mousedown), i.addEventListener('touchstart', this.touchstart, { passive: !1 }), i.addEventListener('touchmove', this.touchmove), i.addEventListener('touchend', this.touchend), i.addEventListener('touchcancel', this.reset);
        }
        down(t, i) {
          this.mouseRotate.mousedown(t, i), this.mousePitch && this.mousePitch.mousedown(t, i), G_();
        }
        move(t, i) {
          const r = this.map,
            n = this.mouseRotate.mousemoveWindow(t, i),
            o = n && n.bearingDelta;
          if ((o && r.setBearing(r.getBearing() + o), this.mousePitch)) {
            const s = this.mousePitch.mousemoveWindow(t, i),
              a = s && s.pitchDelta;
            a && r.setPitch(r.getPitch() + a);
          }
        }
        off() {
          const t = this.element;
          t.removeEventListener('mousedown', this.mousedown), t.removeEventListener('touchstart', this.touchstart, { passive: !1 }), t.removeEventListener('touchmove', this.touchmove), t.removeEventListener('touchend', this.touchend), t.removeEventListener('touchcancel', this.reset), this.offTemp();
        }
        offTemp() {
          q_(), U.removeEventListener('mousemove', this.mousemove), U.removeEventListener('mouseup', this.mouseup);
        }
        mousedown(t) {
          this.down(Ft({}, t, { ctrlKey: !0, preventDefault: () => t.preventDefault() }), Ja(this.element, t)), U.addEventListener('mousemove', this.mousemove), U.addEventListener('mouseup', this.mouseup);
        }
        mousemove(t) {
          this.move(t, Ja(this.element, t));
        }
        mouseup(t) {
          this.mouseRotate.mouseupWindow(t), this.mousePitch && this.mousePitch.mouseupWindow(t), this.offTemp();
        }
        touchstart(t) {
          t.targetTouches.length !== 1 ? this.reset() : ((this._startPos = this._lastPos = Tc(this.element, t.targetTouches)[0]), this.down({ type: 'mousedown', button: 0, ctrlKey: !0, preventDefault: () => t.preventDefault() }, this._startPos));
        }
        touchmove(t) {
          t.targetTouches.length !== 1 ? this.reset() : ((this._lastPos = Tc(this.element, t.targetTouches)[0]), this.move({ preventDefault: () => t.preventDefault() }, this._lastPos));
        }
        touchend(t) {
          t.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
        }
        reset() {
          this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
        }
      }
      const CD = { positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showAccuracyCircle: !0, showUserLocation: !0, showUserHeading: !1 },
        PD = { maxWidth: 100, unit: 'metric' },
        zD = { kilometer: 'km', meter: 'm', mile: 'mi', foot: 'ft', 'nautical-mile': 'nm' },
        Ph = {
          version: Et,
          supported: U_,
          setRTLTextPlugin: function (e, t, i = !1) {
            if (Dr === yf || Dr === xf || Dr === vf) throw new Error('setRTLTextPlugin cannot be called multiple times.');
            (Co = oe.resolveURL(e)), (Dr = yf), (bf = t), wf(), i || dy();
          },
          getRTLTextPluginStatus: Ef,
          Map: class extends bD {
            constructor(e) {
              F_.mark(vc.create);
              const t = e;
              if ((e = Ft({}, SD, e)).minZoom != null && e.maxZoom != null && e.minZoom > e.maxZoom) throw new Error('maxZoom must be greater than or equal to minZoom');
              if (e.minPitch != null && e.maxPitch != null && e.minPitch > e.maxPitch) throw new Error('maxPitch must be greater than or equal to minPitch');
              if (e.minPitch != null && e.minPitch < 0) throw new Error('minPitch must be greater than or equal to 0');
              if (e.maxPitch != null && e.maxPitch > 85) throw new Error('maxPitch must be less than or equal to 85');
              if (
                (e.antialias &&
                  (function (i) {
                    const r = i.navigator ? i.navigator.userAgent : null;
                    return (
                      !!(function (n) {
                        if (Lt == null) {
                          const o = n.navigator ? n.navigator.userAgent : null;
                          Lt = !!n.safari || !(!o || !(/\b(iPad|iPhone|iPod)\b/.test(o) || (o.match('Safari') && !o.match('Chrome'))));
                        }
                        return Lt;
                      })(i) &&
                      r &&
                      (r.match('Version/15.4') || r.match('Version/15.5') || r.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/))
                    );
                  })(U) &&
                  ((e.antialias = !1), B('Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609')),
                super(new em(e.minZoom, e.maxZoom, e.minPitch, e.maxPitch, e.renderWorldCopies), e),
                (this._interactive = e.interactive),
                (this._minTileCacheSize = e.minTileCacheSize),
                (this._maxTileCacheSize = e.maxTileCacheSize),
                (this._failIfMajorPerformanceCaveat = e.failIfMajorPerformanceCaveat),
                (this._preserveDrawingBuffer = e.preserveDrawingBuffer),
                (this._antialias = e.antialias),
                (this._trackResize = e.trackResize),
                (this._bearingSnap = e.bearingSnap),
                (this._refreshExpiredTiles = e.refreshExpiredTiles),
                (this._fadeDuration = e.fadeDuration),
                (this._isInitialLoad = !0),
                (this._crossSourceCollisions = e.crossSourceCollisions),
                (this._collectResourceTiming = e.collectResourceTiming),
                (this._language = this._parseLanguage(e.language)),
                (this._worldview = e.worldview),
                (this._renderTaskQueue = new ww()),
                (this._domRenderTaskQueue = new ww()),
                (this._controls = []),
                (this._markers = []),
                (this._popups = []),
                (this._mapId = $r()),
                (this._locale = Ft({}, MD, e.locale)),
                (this._clickTolerance = e.clickTolerance),
                (this._cooperativeGestures = e.cooperativeGestures),
                (this._performanceMetricsCollection = e.performanceMetricsCollection),
                (this._containerWidth = 0),
                (this._containerHeight = 0),
                (this._averageElevationLastSampledAt = -1 / 0),
                (this._averageElevationExaggeration = 0),
                (this._averageElevation = new ED(0)),
                (this._interactionRange = [1 / 0, -1 / 0]),
                (this._visibilityHidden = 0),
                (this._useExplicitProjection = !1),
                (this._requestManager = new Yt(e.transformRequest, e.accessToken, e.testMode)),
                (this._silenceAuthErrors = !!e.testMode),
                (this._contextCreateOptions = e.contextCreateOptions ? { ...e.contextCreateOptions } : {}),
                typeof e.container == 'string')
              ) {
                if (((this._container = U.document.getElementById(e.container)), !this._container)) throw new Error(`Container '${e.container.toString()}' not found.`);
              } else {
                if (!(e.container instanceof U.HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
                this._container = e.container;
              }
              if ((this._container.childNodes.length > 0 && B("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."), e.maxBounds && this.setMaxBounds(e.maxBounds), ot(['_onWindowOnline', '_onWindowResize', '_onVisibilityChange', '_onMapScroll', '_contextLost', '_contextRestored'], this), this._setupContainer(), this._setupPainter(), this.painter === void 0)) throw new Error('Failed to initialize WebGL.');
              if ((this.on('move', () => this._update(!1)), this.on('moveend', () => this._update(!1)), this.on('zoom', () => this._update(!0)), U !== void 0 && ((this._fullscreenchangeEvent = 'onfullscreenchange' in U.document ? 'fullscreenchange' : 'webkitfullscreenchange'), U.addEventListener('online', this._onWindowOnline, !1), U.addEventListener('resize', this._onWindowResize, !1), U.addEventListener('orientationchange', this._onWindowResize, !1), U.addEventListener(this._fullscreenchangeEvent, this._onWindowResize, !1), U.addEventListener('visibilitychange', this._onVisibilityChange, !1)), (this.handlers = new vD(this, e)), (this._localFontFamily = e.localFontFamily), (this._localIdeographFontFamily = e.localIdeographFontFamily), (e.style || !e.testMode) && this.setStyle(e.style || Mt.DEFAULT_STYLE, { localFontFamily: this._localFontFamily, localIdeographFontFamily: this._localIdeographFontFamily }), e.projection && this.setProjection(e.projection), e.hash && (this._hash = new qz((typeof e.hash == 'string' && e.hash) || void 0).addTo(this)), !this._hash || !this._hash._onHashChange())) {
                (t.center == null && t.zoom == null) || (this.transform._unmodified = !1), this.jumpTo({ center: e.center, zoom: e.zoom, bearing: e.bearing, pitch: e.pitch });
                const i = e.bounds;
                i && (this.resize(), this.fitBounds(i, Ft({}, e.fitBoundsOptions, { duration: 0 })));
              }
              this.resize(),
                e.attributionControl && this.addControl(new vw({ customAttribution: e.customAttribution })),
                (this._logoControl = new bw()),
                this.addControl(this._logoControl, e.logoPosition),
                this.on('style.load', () => {
                  this.transform.unmodified && this.jumpTo(this.style.stylesheet);
                }),
                this.on('data', (i) => {
                  this._update(i.dataType === 'style'), this.fire(new wt(`${i.dataType}data`, i));
                }),
                this.on('dataloading', (i) => {
                  this.fire(new wt(`${i.dataType}dataloading`, i));
                });
            }
            _getMapId() {
              return this._mapId;
            }
            addControl(e, t) {
              if ((t === void 0 && (t = e.getDefaultPosition ? e.getDefaultPosition() : 'top-right'), !e || !e.onAdd)) return this.fire(new re(new Error('Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.')));
              const i = e.onAdd(this);
              this._controls.push(e);
              const r = this._controlPositions[t];
              return t.indexOf('bottom') !== -1 ? r.insertBefore(i, r.firstChild) : r.appendChild(i), this;
            }
            removeControl(e) {
              if (!e || !e.onRemove) return this.fire(new re(new Error('Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.')));
              const t = this._controls.indexOf(e);
              return t > -1 && this._controls.splice(t, 1), e.onRemove(this), this;
            }
            hasControl(e) {
              return this._controls.indexOf(e) > -1;
            }
            getContainer() {
              return this._container;
            }
            getCanvasContainer() {
              return this._canvasContainer;
            }
            getCanvas() {
              return this._canvas;
            }
            resize(e) {
              if ((this._updateContainerDimensions(), this._containerWidth === this.transform.width && this._containerHeight === this.transform.height)) return this;
              this._resizeCanvas(this._containerWidth, this._containerHeight), this.transform.resize(this._containerWidth, this._containerHeight), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));
              const t = !this._moving;
              return t && this.fire(new wt('movestart', e)).fire(new wt('move', e)), this.fire(new wt('resize', e)), t && this.fire(new wt('moveend', e)), this;
            }
            getBounds() {
              return this.transform.getBounds();
            }
            getMaxBounds() {
              return this.transform.getMaxBounds() || null;
            }
            setMaxBounds(e) {
              return this.transform.setMaxBounds(kr.convert(e)), this._update();
            }
            setMinZoom(e) {
              if ((e = e ?? -2) >= -2 && e <= this.transform.maxZoom) return (this.transform.minZoom = e), this._update(), this.getZoom() < e ? this.setZoom(e) : this.fire(new wt('zoomstart')).fire(new wt('zoom')).fire(new wt('zoomend')), this;
              throw new Error('minZoom must be between -2 and the current maxZoom, inclusive');
            }
            getMinZoom() {
              return this.transform.minZoom;
            }
            setMaxZoom(e) {
              if ((e = e ?? 22) >= this.transform.minZoom) return (this.transform.maxZoom = e), this._update(), this.getZoom() > e ? this.setZoom(e) : this.fire(new wt('zoomstart')).fire(new wt('zoom')).fire(new wt('zoomend')), this;
              throw new Error('maxZoom must be greater than the current minZoom');
            }
            getMaxZoom() {
              return this.transform.maxZoom;
            }
            setMinPitch(e) {
              if ((e = e ?? 0) < 0) throw new Error('minPitch must be greater than or equal to 0');
              if (e >= 0 && e <= this.transform.maxPitch) return (this.transform.minPitch = e), this._update(), this.getPitch() < e ? this.setPitch(e) : this.fire(new wt('pitchstart')).fire(new wt('pitch')).fire(new wt('pitchend')), this;
              throw new Error('minPitch must be between 0 and the current maxPitch, inclusive');
            }
            getMinPitch() {
              return this.transform.minPitch;
            }
            setMaxPitch(e) {
              if ((e = e ?? 85) > 85) throw new Error('maxPitch must be less than or equal to 85');
              if (e >= this.transform.minPitch) return (this.transform.maxPitch = e), this._update(), this.getPitch() > e ? this.setPitch(e) : this.fire(new wt('pitchstart')).fire(new wt('pitch')).fire(new wt('pitchend')), this;
              throw new Error('maxPitch must be greater than or equal to minPitch');
            }
            getMaxPitch() {
              return this.transform.maxPitch;
            }
            getRenderWorldCopies() {
              return this.transform.renderWorldCopies;
            }
            setRenderWorldCopies(e) {
              return (this.transform.renderWorldCopies = e), this.transform.renderWorldCopies || this._forceMarkerAndPopupUpdate(!0), this._update();
            }
            getLanguage() {
              return this._language;
            }
            _parseLanguage(e) {
              return e === 'auto' ? U.navigator.language : Array.isArray(e) ? (e.length === 0 ? void 0 : e.map((t) => (t === 'auto' ? U.navigator.language : t))) : e;
            }
            setLanguage(e) {
              const t = this._parseLanguage(e);
              if (!this.style || t === this._language) return this;
              (this._language = t), this.style.reloadSources();
              for (const i of this._controls) i._setLanguage && i._setLanguage(this._language);
              return this;
            }
            getWorldview() {
              return this._worldview;
            }
            setWorldview(e) {
              return this.style && e !== this._worldview ? ((this._worldview = e), this.style.reloadSources(), this) : this;
            }
            getProjection() {
              return this.transform.mercatorFromTransition ? { name: 'globe', center: [0, 0] } : this.transform.getProjection();
            }
            _showingGlobe() {
              return this.transform.projection.name === 'globe';
            }
            setProjection(e) {
              return this._lazyInitEmptyStyle(), e ? typeof e == 'string' && (e = { name: e }) : (e = null), (this._useExplicitProjection = !!e), this._prioritizeAndUpdateProjection(e, this.style.projection);
            }
            _updateProjectionTransition() {
              if (this.getProjection().name !== 'globe') return;
              const e = this.transform,
                t = e.projection.name;
              let i;
              t === 'globe' && e.zoom >= Oo ? (e.setMercatorFromTransition(), (i = !0)) : t === 'mercator' && e.zoom < Oo && (e.setProjection({ name: 'globe' }), (i = !0)), i && (this.style.applyProjectionUpdate(), this.style._forceSymbolLayerUpdate());
            }
            _prioritizeAndUpdateProjection(e, t) {
              return this._updateProjection(e || t || { name: 'mercator' });
            }
            _updateProjection(e) {
              let t;
              return (t = e.name === 'globe' && this.transform.zoom >= Oo ? this.transform.setMercatorFromTransition() : this.transform.setProjection(e)), this.style.applyProjectionUpdate(), t && (this.painter.clearBackgroundTiles(), this.style.clearSources(), this._update(!0), this._forceMarkerAndPopupUpdate(!0)), this;
            }
            project(e) {
              return this.transform.locationPoint3D(ie.convert(e));
            }
            unproject(e) {
              return this.transform.pointLocation3D(H.convert(e));
            }
            isMoving() {
              return this._moving || (this.handlers && this.handlers.isMoving()) || !1;
            }
            isZooming() {
              return this._zooming || (this.handlers && this.handlers.isZooming()) || !1;
            }
            isRotating() {
              return this._rotating || (this.handlers && this.handlers.isRotating()) || !1;
            }
            _isDragging() {
              return (this.handlers && this.handlers._isDragging()) || !1;
            }
            _createDelegatedListener(e, t, i) {
              if (e === 'mouseenter' || e === 'mouseover') {
                let r = !1;
                const n = (s) => {
                    const a = t.filter((c) => this.getLayer(c)),
                      l = a.length ? this.queryRenderedFeatures(s.point, { layers: a }) : [];
                    l.length ? r || ((r = !0), i.call(this, new Kr(e, this, s.originalEvent, { features: l }))) : (r = !1);
                  },
                  o = () => {
                    r = !1;
                  };
                return { layers: new Set(t), listener: i, delegates: { mousemove: n, mouseout: o } };
              }
              if (e === 'mouseleave' || e === 'mouseout') {
                let r = !1;
                const n = (s) => {
                    const a = t.filter((l) => this.getLayer(l));
                    (a.length ? this.queryRenderedFeatures(s.point, { layers: a }) : []).length ? (r = !0) : r && ((r = !1), i.call(this, new Kr(e, this, s.originalEvent)));
                  },
                  o = (s) => {
                    r && ((r = !1), i.call(this, new Kr(e, this, s.originalEvent)));
                  };
                return { layers: new Set(t), listener: i, delegates: { mousemove: n, mouseout: o } };
              }
              {
                const r = (n) => {
                  const o = t.filter((a) => this.getLayer(a)),
                    s = o.length ? this.queryRenderedFeatures(n.point, { layers: o }) : [];
                  s.length && ((n.features = s), i.call(this, n), delete n.features);
                };
                return { layers: new Set(t), listener: i, delegates: { [e]: r } };
              }
            }
            on(e, t, i) {
              if (i === void 0) return super.on(e, t);
              if ((Array.isArray(t) || (t = [t]), t)) {
                for (const n of t) if (!this._isValidId(n)) return this;
              }
              const r = this._createDelegatedListener(e, t, i);
              (this._delegatedListeners = this._delegatedListeners || {}), (this._delegatedListeners[e] = this._delegatedListeners[e] || []), this._delegatedListeners[e].push(r);
              for (const n in r.delegates) this.on(n, r.delegates[n]);
              return this;
            }
            once(e, t, i) {
              if (i === void 0) return super.once(e, t);
              if ((Array.isArray(t) || (t = [t]), t)) {
                for (const n of t) if (!this._isValidId(n)) return this;
              }
              const r = this._createDelegatedListener(e, t, i);
              for (const n in r.delegates) this.once(n, r.delegates[n]);
              return this;
            }
            off(e, t, i) {
              if (i === void 0) return super.off(e, t);
              t = new Set(Array.isArray(t) ? t : [t]);
              for (const o of t) if (!this._isValidId(o)) return this;
              const r = (o, s) => {
                  if (o.size !== s.size) return !1;
                  for (const a of o) if (!s.has(a)) return !1;
                  return !0;
                },
                n = this._delegatedListeners ? this._delegatedListeners[e] : void 0;
              return (
                n &&
                  ((o) => {
                    for (let s = 0; s < o.length; s++) {
                      const a = o[s];
                      if (a.listener === i && r(a.layers, t)) {
                        for (const l in a.delegates) this.off(l, a.delegates[l]);
                        return o.splice(s, 1), this;
                      }
                    }
                  })(n),
                this
              );
            }
            queryRenderedFeatures(e, t) {
              if (!this.style) return [];
              if (
                (t !== void 0 || e === void 0 || e instanceof H || Array.isArray(e) || ((t = e), (e = void 0)),
                (e = e || [
                  [0, 0],
                  [this.transform.width, this.transform.height],
                ]),
                (t = t || {}).layers && Array.isArray(t.layers))
              ) {
                for (const i of t.layers) if (!this._isValidId(i)) return [];
              }
              return this.style.queryRenderedFeatures(e, t, this.transform);
            }
            querySourceFeatures(e, t) {
              return this._isValidId(e) ? this.style.querySourceFeatures(e, t) : [];
            }
            isPointOnSurface(e) {
              const { name: t } = this.transform.projection;
              return t !== 'globe' && t !== 'mercator' && B(`${t} projection does not support isPointOnSurface, this API may behave unexpectedly.`), this.transform.isPointOnSurface(H.convert(e));
            }
            setStyle(e, t) {
              return (t = Ft({}, { localIdeographFontFamily: this._localIdeographFontFamily, localFontFamily: this._localFontFamily }, t)).diff !== !1 && t.localIdeographFontFamily === this._localIdeographFontFamily && t.localFontFamily === this._localFontFamily && this.style && e ? (this._diffStyle(e, t), this) : ((this._localIdeographFontFamily = t.localIdeographFontFamily), (this._localFontFamily = t.localFontFamily), this._updateStyle(e, t));
            }
            _getUIString(e) {
              const t = this._locale[e];
              if (t == null) throw new Error(`Missing UI string '${e}'`);
              return t;
            }
            _updateStyle(e, t) {
              return this.style && (this.style.setEventedParent(null), this.style._remove(), (this.style = void 0)), e && ((this.style = new Mn(this, t || {})), this.style.setEventedParent(this, { style: this.style }), typeof e == 'string' ? this.style.loadURL(e) : this.style.loadJSON(e)), this._updateTerrain(), this;
            }
            _lazyInitEmptyStyle() {
              this.style || ((this.style = new Mn(this, {})), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
            }
            _diffStyle(e, t) {
              if (typeof e == 'string') {
                const i = this._requestManager.normalizeStyleURL(e),
                  r = this._requestManager.transformRequest(i, dt.Style);
                At(r, (n, o) => {
                  n ? this.fire(new re(n)) : o && this._updateDiff(o, t);
                });
              } else typeof e == 'object' && this._updateDiff(e, t);
            }
            _updateDiff(e, t) {
              try {
                this.style.setState(e) && this._update(!0);
              } catch (i) {
                B(`Unable to perform style diff: ${i.message || i.error || i}.  Rebuilding the style from scratch.`), this._updateStyle(e, t);
              }
            }
            getStyle() {
              if (this.style) return this.style.serialize();
            }
            isStyleLoaded() {
              return this.style ? this.style.loaded() : (B('There is no style added to the map.'), !1);
            }
            _isValidId(e) {
              return e == null ? (this.fire(new re(new Error("IDs can't be empty."))), !1) : !my(e) || (this.fire(new re(new Error(`IDs can't contain special symbols: "${e}".`))), !1);
            }
            addSource(e, t) {
              return this._isValidId(e) ? (this._lazyInitEmptyStyle(), this.style.addSource(e, t), this._update(!0)) : this;
            }
            isSourceLoaded(e) {
              return !!this._isValidId(e) && !!this.style && this.style._isSourceCacheLoaded(e);
            }
            areTilesLoaded() {
              const e = this.style && this.style._sourceCaches;
              for (const t in e) {
                const i = e[t]._tiles;
                for (const r in i) {
                  const n = i[r];
                  if (n.state !== 'loaded' && n.state !== 'errored') return !1;
                }
              }
              return !0;
            }
            addSourceType(e, t, i) {
              this._lazyInitEmptyStyle(), this.style.addSourceType(e, t, i);
            }
            removeSource(e) {
              return this._isValidId(e) ? (this.style.removeSource(e), this._updateTerrain(), this._update(!0)) : this;
            }
            getSource(e) {
              return this._isValidId(e) ? this.style.getOwnSource(e) : null;
            }
            addImage(e, t, { pixelRatio: i = 1, sdf: r = !1, stretchX: n, stretchY: o, content: s } = {}) {
              if ((this._lazyInitEmptyStyle(), t instanceof U.HTMLImageElement || (U.ImageBitmap && t instanceof U.ImageBitmap))) {
                const { width: a, height: l, data: c } = oe.getImageData(t);
                this.style.addImage(e, { data: new Li({ width: a, height: l }, c), pixelRatio: i, stretchX: n, stretchY: o, content: s, sdf: r, version: 0 });
              } else if (t.width === void 0 || t.height === void 0) this.fire(new re(new Error('Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`')));
              else {
                const { width: a, height: l } = t,
                  c = t;
                this.style.addImage(e, { data: new Li({ width: a, height: l }, new Uint8Array(c.data)), pixelRatio: i, stretchX: n, stretchY: o, content: s, sdf: r, version: 0, userImage: c }), c.onAdd && c.onAdd(this, e);
              }
            }
            updateImage(e, t) {
              this._lazyInitEmptyStyle();
              const i = this.style.getImage(e);
              if (!i) return void this.fire(new re(new Error('The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.')));
              const r = t instanceof U.HTMLImageElement || (U.ImageBitmap && t instanceof U.ImageBitmap) ? oe.getImageData(t) : t,
                { width: n, height: o } = r;
              n !== void 0 && o !== void 0
                ? n === i.data.width && o === i.data.height
                  ? (i.data.replace(r.data, !(t instanceof U.HTMLImageElement || (U.ImageBitmap && t instanceof U.ImageBitmap))), this.style.updateImage(e, i))
                  : this.fire(
                      new re(
                        new Error(`The width and height of the updated image (${n}, ${o})
                must be that same as the previous version of the image
                (${i.data.width}, ${i.data.height})`)
                      )
                    )
                : this.fire(new re(new Error('Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`')));
            }
            hasImage(e) {
              return e ? !!this.style && !!this.style.getImage(e) : (this.fire(new re(new Error('Missing required image id'))), !1);
            }
            removeImage(e) {
              this.style.removeImage(e);
            }
            loadImage(e, t) {
              de(this._requestManager.transformRequest(e, dt.Image), (i, r) => {
                t(i, r instanceof U.HTMLImageElement ? oe.getImageData(r) : r);
              });
            }
            listImages() {
              return this.style.listImages();
            }
            addModel(e, t) {
              this._lazyInitEmptyStyle(), this.style.addModel(e, t);
            }
            hasModel(e) {
              return e ? this.style.hasModel(e) : (this.fire(new re(new Error('Missing required model id'))), !1);
            }
            removeModel(e) {
              this.style.removeModel(e);
            }
            listModels() {
              return this.style.listModels();
            }
            addLayer(e, t) {
              return this._isValidId(e.id) ? (this._lazyInitEmptyStyle(), this.style.addLayer(e, t), this._update(!0)) : this;
            }
            moveLayer(e, t) {
              return this._isValidId(e) ? (this.style.moveLayer(e, t), this._update(!0)) : this;
            }
            removeLayer(e) {
              return this._isValidId(e) ? (this.style.removeLayer(e), this._update(!0)) : this;
            }
            getLayer(e) {
              return this._isValidId(e) ? this.style.getOwnLayer(e) : null;
            }
            setLayerZoomRange(e, t, i) {
              return this._isValidId(e) ? (this.style.setLayerZoomRange(e, t, i), this._update(!0)) : this;
            }
            setFilter(e, t, i = {}) {
              return this._isValidId(e) ? (this.style.setFilter(e, t, i), this._update(!0)) : this;
            }
            getFilter(e) {
              return this._isValidId(e) ? this.style.getFilter(e) : null;
            }
            setPaintProperty(e, t, i, r = {}) {
              return this._isValidId(e) ? (this.style.setPaintProperty(e, t, i, r), this._update(!0)) : this;
            }
            getPaintProperty(e, t) {
              return this._isValidId(e) ? this.style.getPaintProperty(e, t) : null;
            }
            setLayoutProperty(e, t, i, r = {}) {
              return this._isValidId(e) ? (this.style.setLayoutProperty(e, t, i, r), this._update(!0)) : this;
            }
            getLayoutProperty(e, t) {
              return this._isValidId(e) ? this.style.getLayoutProperty(e, t) : null;
            }
            getConfigProperty(e, t) {
              return this.style.getConfigProperty(e, t);
            }
            setConfigProperty(e, t, i) {
              return this.style.setConfigProperty(e, t, i), this._update(!0);
            }
            setLights(e) {
              if ((this._lazyInitEmptyStyle(), e && e.length === 1 && e[0].type === 'flat')) {
                const t = e[0];
                t.properties ? this.style.setFlatLight(t.properties, t.id, {}) : this.style.setFlatLight({}, 'flat');
              } else this.style.setLights(e), this.painter.terrain && (this.painter.terrain.invalidateRenderCache = !0);
              return this._update(!0);
            }
            getLights() {
              const e = this.style.getLights() || [];
              return e.length === 0 && e.push({ id: this.style.light.id, type: 'flat', properties: this.style.getFlatLight() }), e;
            }
            setLight(e, t = {}) {
              return console.log('The `map.setLight` function is deprecated, prefer using `map.setLights` with `flat` light type instead.'), this.setLights([{ id: 'flat', type: 'flat', properties: e }]);
            }
            getLight() {
              return console.log('The `map.getLight` function is deprecated, prefer using `map.getLights` instead.'), this.style.getFlatLight();
            }
            setTerrain(e) {
              return this._lazyInitEmptyStyle(), !e && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(e), (this._averageElevationLastSampledAt = -1 / 0), this._update(!0);
            }
            getTerrain() {
              return this.style ? this.style.getTerrain() : null;
            }
            setFog(e) {
              return this._lazyInitEmptyStyle(), this.style.setFog(e), this._update(!0);
            }
            getFog() {
              return this.style ? this.style.getFog() : null;
            }
            setCamera(e) {
              return this.style.setCamera(e), this._triggerCameraUpdate(e);
            }
            _triggerCameraUpdate(e) {
              return this._update(this.transform.setOrthographicProjectionAtLowPitch(e['camera-projection'] === 'orthographic'));
            }
            getCamera() {
              return this.style.camera;
            }
            _queryFogOpacity(e) {
              return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(ie.convert(e), this.transform) : 0;
            }
            setFeatureState(e, t) {
              return this._isValidId(e.source) ? (this.style.setFeatureState(e, t), this._update()) : this;
            }
            removeFeatureState(e, t) {
              return this._isValidId(e.source) ? (this.style.removeFeatureState(e, t), this._update()) : this;
            }
            getFeatureState(e) {
              return this._isValidId(e.source) ? this.style.getFeatureState(e) : null;
            }
            _updateContainerDimensions() {
              if (!this._container) return;
              const e = this._container.getBoundingClientRect().width || 400,
                t = this._container.getBoundingClientRect().height || 300;
              let i,
                r,
                n,
                o = this._container;
              for (; o && (!r || !n); ) {
                const s = U.getComputedStyle(o).transform;
                s && s !== 'none' && ((i = s.match(/matrix.*\((.+)\)/)[1].split(', ')), i[0] && i[0] !== '0' && i[0] !== '1' && (r = i[0]), i[3] && i[3] !== '0' && i[3] !== '1' && (n = i[3])), (o = o.parentElement);
              }
              (this._containerWidth = r ? Math.abs(e / r) : e), (this._containerHeight = n ? Math.abs(t / n) : t);
            }
            _detectMissingCSS() {
              U.getComputedStyle(this._missingCSSCanary).getPropertyValue('background-color') !== 'rgb(250, 128, 114)' && B('This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.');
            }
            _setupContainer() {
              const e = this._container;
              e.classList.add('mapboxgl-map'), ((this._missingCSSCanary = ri('div', 'mapboxgl-canary', e)).style.visibility = 'hidden'), this._detectMissingCSS();
              const t = (this._canvasContainer = ri('div', 'mapboxgl-canvas-container', e));
              (this._canvas = ri('canvas', 'mapboxgl-canvas', t)), this._interactive && (t.classList.add('mapboxgl-interactive'), this._canvas.setAttribute('tabindex', '0')), this._canvas.addEventListener('webglcontextlost', this._contextLost, !1), this._canvas.addEventListener('webglcontextrestored', this._contextRestored, !1), this._canvas.setAttribute('aria-label', this._getUIString('Map.Title')), this._canvas.setAttribute('role', 'region'), this._updateContainerDimensions(), this._resizeCanvas(this._containerWidth, this._containerHeight);
              const i = (this._controlContainer = ri('div', 'mapboxgl-control-container', e)),
                r = (this._controlPositions = {});
              ['top-left', 'top-right', 'bottom-left', 'bottom-right'].forEach((n) => {
                r[n] = ri('div', `mapboxgl-ctrl-${n}`, i);
              }),
                this._container.addEventListener('scroll', this._onMapScroll, !1);
            }
            _resizeCanvas(e, t) {
              const i = oe.devicePixelRatio || 1;
              (this._canvas.width = i * Math.ceil(e)), (this._canvas.height = i * Math.ceil(t)), (this._canvas.style.width = `${e}px`), (this._canvas.style.height = `${t}px`);
            }
            _addMarker(e) {
              this._markers.push(e);
            }
            _removeMarker(e) {
              const t = this._markers.indexOf(e);
              t !== -1 && this._markers.splice(t, 1);
            }
            _addPopup(e) {
              this._popups.push(e);
            }
            _removePopup(e) {
              const t = this._popups.indexOf(e);
              t !== -1 && this._popups.splice(t, 1);
            }
            _setupPainter() {
              const e = Ft({}, U_.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || !1 }),
                t = this._canvas.getContext('webgl2', e);
              t
                ? (B_(t, !0),
                  (this.painter = new kz(t, this._contextCreateOptions, this.transform)),
                  this.on('data', (i) => {
                    i.dataType === 'source' && this.painter.setTileLoadedFlag(!0);
                  }),
                  _e.testSupport(t))
                : this.fire(new re(new Error('Failed to initialize WebGL')));
            }
            _contextLost(e) {
              e.preventDefault(), this._frame && (this._frame.cancel(), (this._frame = null)), this.fire(new wt('webglcontextlost', { originalEvent: e }));
            }
            _contextRestored(e) {
              this._setupPainter(), this.resize(), this._update(), this.fire(new wt('webglcontextrestored', { originalEvent: e }));
            }
            _onMapScroll(e) {
              if (e.target === this._container) return (this._container.scrollTop = 0), (this._container.scrollLeft = 0), !1;
            }
            loaded() {
              return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
            }
            _update(e) {
              return this.style ? ((this._styleDirty = this._styleDirty || e), (this._sourcesDirty = !0), this.triggerRepaint(), this) : this;
            }
            _requestRenderFrame(e) {
              return this._update(), this._renderTaskQueue.add(e);
            }
            _cancelRenderFrame(e) {
              this._renderTaskQueue.remove(e);
            }
            _requestDomTask(e) {
              !this.loaded() || (this.loaded() && !this.isMoving()) ? e() : this._domRenderTaskQueue.add(e);
            }
            _render(e) {
              let t;
              this.fire(new wt('renderstart'));
              const i = this.painter.context.extTimerQuery,
                r = oe.now(),
                n = this.painter.context.gl;
              if ((this.listens('gpu-timing-frame') && ((t = n.createQuery()), n.beginQuery(i.TIME_ELAPSED_EXT, t)), this.painter.context.setDirty(), this.painter.setBaseState(), (this.isMoving() || this.isRotating() || this.isZooming()) && ((this._interactionRange[0] = Math.min(this._interactionRange[0], U.performance.now())), (this._interactionRange[1] = Math.max(this._interactionRange[1], U.performance.now()))), this._renderTaskQueue.run(e), this._domRenderTaskQueue.run(e), this._removed)) return;
              this._updateProjectionTransition();
              const o = this._isInitialLoad ? 0 : this._fadeDuration;
              if (this.style && this._styleDirty) {
                this._styleDirty = !1;
                const l = this.transform.zoom,
                  c = this.transform.pitch,
                  u = oe.now(),
                  h = new gi(l, { now: u, fadeDuration: o, pitch: c, transition: this.style.transition });
                this.style.update(h);
              }
              this.style && this.style.hasFogTransition() && ((this.style._markersNeedUpdate = !0), (this._sourcesDirty = !0));
              let s = !1;
              if ((this.style && this._sourcesDirty ? ((this._sourcesDirty = !1), this.painter._updateFog(this.style), this._updateTerrain(), (s = this._updateAverageElevation(r)), this.style.updateSources(this.transform), this._forceMarkerAndPopupUpdate()) : (s = this._updateAverageElevation(r)), (this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, o, this._crossSourceCollisions)), this.style && this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, wireframe: { terrain: this.showTerrainWireframe, layers2D: this.showLayers2DWireframe, layers3D: this.showLayers3DWireframe }, showOverdrawInspector: this._showOverdrawInspector, showQueryGeometry: !!this._showQueryGeometry, showTileAABBs: this.showTileAABBs, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: o, isInitialLoad: this._isInitialLoad, showPadding: this.showPadding, gpuTiming: !!this.listens('gpu-timing-layer'), gpuTimingDeferredRender: !!this.listens('gpu-timing-deferred-render'), speedIndexTiming: this.speedIndexTiming }), this.fire(new wt('render')), this.loaded() && !this._loaded && ((this._loaded = !0), this.fire(new wt('load'))), this.style && this.style.hasTransitions() && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), t)) {
                const l = oe.now() - r;
                n.endQuery(i.TIME_ELAPSED_EXT),
                  setTimeout(() => {
                    const c = n.getQueryParameter(t, n.QUERY_RESULT) / 1e6;
                    n.deleteQuery(t), this.fire(new wt('gpu-timing-frame', { cpuTime: l, gpuTime: c })), U.performance.mark('frame-gpu', { startTime: r, detail: { gpuTime: c } });
                  }, 50);
              }
              if (this.listens('gpu-timing-layer')) {
                const l = this.painter.collectGpuTimers();
                setTimeout(() => {
                  const c = this.painter.queryGpuTimers(l);
                  this.fire(new wt('gpu-timing-layer', { layerTimes: c }));
                }, 50);
              }
              if (this.listens('gpu-timing-deferred-render')) {
                const l = this.painter.collectDeferredRenderGpuQueries();
                setTimeout(() => {
                  const c = this.painter.queryGpuTimeDeferredRender(l);
                  this.fire(new wt('gpu-timing-deferred-render', { gpuTime: c }));
                }, 50);
              }
              const a = this._sourcesDirty || this._styleDirty || this._placementDirty || s;
              if (a || this._repaint) this.triggerRepaint();
              else {
                const l = !this.isMoving() && this.loaded();
                if ((l && (s = this._updateAverageElevation(r, !0)), s)) this.triggerRepaint();
                else if ((this._triggerFrame(!1), l && (this.fire(new wt('idle')), (this._isInitialLoad = !1), this.speedIndexTiming))) {
                  const c = this._calculateSpeedIndex();
                  this.fire(new wt('speedindexcompleted', { speedIndex: c })), (this.speedIndexTiming = !1);
                }
              }
              !this._loaded || this._fullyLoaded || a || ((this._fullyLoaded = !0), F_.mark(vc.fullLoad), this._performanceMetricsCollection && _E(this._requestManager._customAccessToken, { width: this.painter.width, height: this.painter.height, interactionRange: this._interactionRange, visibilityHidden: this._visibilityHidden, terrainEnabled: !!this.painter.style.getTerrain(), fogEnabled: !!this.painter.style.getFog(), projection: this.getProjection().name, zoom: this.transform.zoom, renderer: this.painter.context.renderer, vendor: this.painter.context.vendor }), this._authenticate());
            }
            _forceMarkerAndPopupUpdate(e) {
              for (const t of this._markers) e && !this.getRenderWorldCopies() && (t._lngLat = t._lngLat.wrap()), t._update();
              for (const t of this._popups) !e || this.getRenderWorldCopies() || t._trackPointer || (t._lngLat = t._lngLat.wrap()), t._update();
            }
            _updateAverageElevation(e, t = !1) {
              const i = (n) => ((this.transform.averageElevation = n), this._update(!1), !0);
              if (!this.painter.averageElevationNeedsEasing()) return this.transform.averageElevation !== 0 && i(0);
              const r = this.transform.elevation && this.transform.elevation.exaggeration() !== this._averageElevationExaggeration;
              if (r || ((t || e - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(e))) {
                const n = this.transform.averageElevation;
                let o = this.transform.sampleAverageElevation();
                this.transform.elevation && (this._averageElevationExaggeration = this.transform.elevation.exaggeration()), isNaN(o) ? (o = 0) : (this._averageElevationLastSampledAt = e);
                const s = Math.abs(n - o);
                if (s > 1) {
                  if (this._isInitialLoad || r) return this._averageElevation.jumpTo(o), i(o);
                  this._averageElevation.easeTo(o, e, 300);
                } else if (s > 1e-4) return this._averageElevation.jumpTo(o), i(o);
              }
              return !!this._averageElevation.isEasing(e) && i(this._averageElevation.getValue(e));
            }
            _authenticate() {
              gE(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, (e) => {
                if (e && (e.message === Ke || e.status === 401)) {
                  const t = this.painter.context.gl;
                  B_(t, !1), this._logoControl instanceof bw && this._logoControl._updateLogo(), t && t.clear(t.DEPTH_BUFFER_BIT | t.COLOR_BUFFER_BIT | t.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new re(new Error('A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/')));
                }
              }),
                mE(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, () => {});
            }
            _updateTerrain() {
              const e = this._isDragging();
              this.painter.updateTerrain(this.style, e);
            }
            _calculateSpeedIndex() {
              const e = this.painter.canvasCopy(),
                t = this.painter.getCanvasCopiesAndTimestamps();
              t.timeStamps.push(performance.now());
              const i = this.painter.context.gl,
                r = i.createFramebuffer();
              function n(o) {
                i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, o, 0);
                const s = new Uint8Array(i.drawingBufferWidth * i.drawingBufferHeight * 4);
                return i.readPixels(0, 0, i.drawingBufferWidth, i.drawingBufferHeight, i.RGBA, i.UNSIGNED_BYTE, s), s;
              }
              return i.bindFramebuffer(i.FRAMEBUFFER, r), this._canvasPixelComparison(n(e), t.canvasCopies.map(n), t.timeStamps);
            }
            _canvasPixelComparison(e, t, i) {
              let r = i[1] - i[0];
              const n = e.length / 4;
              for (let o = 0; o < t.length; o++) {
                const s = t[o];
                let a = 0;
                for (let l = 0; l < s.length; l += 4) s[l] === e[l] && s[l + 1] === e[l + 1] && s[l + 2] === e[l + 2] && s[l + 3] === e[l + 3] && (a += 1);
                r += (i[o + 2] - i[o + 1]) * (1 - a / n);
              }
              return r;
            }
            remove() {
              this._hash && this._hash.remove();
              for (const t of this._controls) t.onRemove(this);
              (this._controls = []), this._frame && (this._frame.cancel(), (this._frame = null)), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.style && this.style.destroy(), this.painter.destroy(), this.handlers && this.handlers.destroy(), (this.handlers = void 0), this.setStyle(null), U !== void 0 && (U.removeEventListener('resize', this._onWindowResize, !1), U.removeEventListener('orientationchange', this._onWindowResize, !1), U.removeEventListener(this._fullscreenchangeEvent, this._onWindowResize, !1), U.removeEventListener('online', this._onWindowOnline, !1), U.removeEventListener('visibilitychange', this._onVisibilityChange, !1));
              const e = this.painter.context.gl.getExtension('WEBGL_lose_context');
              e && e.loseContext(), this._canvas.removeEventListener('webglcontextlost', this._contextLost, !1), this._canvas.removeEventListener('webglcontextrestored', this._contextRestored, !1), this._canvasContainer.remove(), this._controlContainer.remove(), this._missingCSSCanary.remove(), (this._canvas = void 0), (this._canvasContainer = void 0), (this._controlContainer = void 0), (this._missingCSSCanary = void 0), this._container.classList.remove('mapboxgl-map'), this._container.removeEventListener('scroll', this._onMapScroll, !1), xc.delete(this.painter.context.gl), (this._removed = !0), this.fire(new wt('remove'));
            }
            triggerRepaint() {
              this._triggerFrame(!0);
            }
            _triggerFrame(e) {
              (this._renderNextFrame = this._renderNextFrame || e),
                this.style &&
                  !this._frame &&
                  (this._frame = oe.frame((t) => {
                    const i = !!this._renderNextFrame;
                    (this._frame = null), (this._renderNextFrame = null), i && this._render(t);
                  }));
            }
            _preloadTiles(e) {
              return (
                Yn(
                  this.style ? Object.values(this.style._sourceCaches) : [],
                  (t, i) => t._preloadTiles(e, i),
                  () => {
                    this.triggerRepaint();
                  }
                ),
                this
              );
            }
            _onWindowOnline() {
              this._update();
            }
            _onWindowResize(e) {
              this._trackResize && this.resize({ originalEvent: e })._update();
            }
            _onVisibilityChange() {
              U.document.visibilityState === 'hidden' && this._visibilityHidden++;
            }
            get showTileBoundaries() {
              return !!this._showTileBoundaries;
            }
            set showTileBoundaries(e) {
              this._showTileBoundaries !== e && ((this._showTileBoundaries = e), this._update());
            }
            get showTerrainWireframe() {
              return !!this._showTerrainWireframe;
            }
            set showTerrainWireframe(e) {
              this._showTerrainWireframe !== e && ((this._showTerrainWireframe = e), this._update());
            }
            get showLayers2DWireframe() {
              return !!this._showLayers2DWireframe;
            }
            set showLayers2DWireframe(e) {
              this._showLayers2DWireframe !== e && ((this._showLayers2DWireframe = e), this._update());
            }
            get showLayers3DWireframe() {
              return !!this._showLayers3DWireframe;
            }
            set showLayers3DWireframe(e) {
              this._showLayers3DWireframe !== e && ((this._showLayers3DWireframe = e), this._update());
            }
            get speedIndexTiming() {
              return !!this._speedIndexTiming;
            }
            set speedIndexTiming(e) {
              this._speedIndexTiming !== e && ((this._speedIndexTiming = e), this._update());
            }
            get showPadding() {
              return !!this._showPadding;
            }
            set showPadding(e) {
              this._showPadding !== e && ((this._showPadding = e), this._update());
            }
            get showCollisionBoxes() {
              return !!this._showCollisionBoxes;
            }
            set showCollisionBoxes(e) {
              this._showCollisionBoxes !== e && ((this._showCollisionBoxes = e), e ? this.style._generateCollisionBoxes() : this._update());
            }
            get showOverdrawInspector() {
              return !!this._showOverdrawInspector;
            }
            set showOverdrawInspector(e) {
              this._showOverdrawInspector !== e && ((this._showOverdrawInspector = e), this._update());
            }
            get repaint() {
              return !!this._repaint;
            }
            set repaint(e) {
              this._repaint !== e && ((this._repaint = e), this.triggerRepaint());
            }
            get vertices() {
              return !!this._vertices;
            }
            set vertices(e) {
              (this._vertices = e), this._update();
            }
            get showTileAABBs() {
              return !!this._showTileAABBs;
            }
            set showTileAABBs(e) {
              this._showTileAABBs !== e && ((this._showTileAABBs = e), e && this._update());
            }
            _setCacheLimits(e, t) {
              (function (i, r) {
                (er = i), (wi = r);
              })(e, t);
            }
            get version() {
              return Et;
            }
          },
          NavigationControl: class {
            constructor(e) {
              (this.options = Ft({}, AD, e)),
                (this._container = ri('div', 'mapboxgl-ctrl mapboxgl-ctrl-group')),
                this._container.addEventListener('contextmenu', (t) => t.preventDefault()),
                this.options.showZoom &&
                  (ot(['_setButtonTitle', '_updateZoomButtons'], this),
                  (this._zoomInButton = this._createButton('mapboxgl-ctrl-zoom-in', (t) => {
                    this._map && this._map.zoomIn({}, { originalEvent: t });
                  })),
                  ri('span', 'mapboxgl-ctrl-icon', this._zoomInButton).setAttribute('aria-hidden', 'true'),
                  (this._zoomOutButton = this._createButton('mapboxgl-ctrl-zoom-out', (t) => {
                    this._map && this._map.zoomOut({}, { originalEvent: t });
                  })),
                  ri('span', 'mapboxgl-ctrl-icon', this._zoomOutButton).setAttribute('aria-hidden', 'true')),
                this.options.showCompass &&
                  (ot(['_rotateCompassArrow'], this),
                  (this._compass = this._createButton('mapboxgl-ctrl-compass', (t) => {
                    const i = this._map;
                    i && (this.options.visualizePitch ? i.resetNorthPitch({}, { originalEvent: t }) : i.resetNorth({}, { originalEvent: t }));
                  })),
                  (this._compassIcon = ri('span', 'mapboxgl-ctrl-icon', this._compass)),
                  this._compassIcon.setAttribute('aria-hidden', 'true'));
            }
            _updateZoomButtons() {
              const e = this._map;
              if (!e) return;
              const t = e.getZoom(),
                i = t === e.getMaxZoom(),
                r = t === e.getMinZoom();
              (this._zoomInButton.disabled = i), (this._zoomOutButton.disabled = r), this._zoomInButton.setAttribute('aria-disabled', i.toString()), this._zoomOutButton.setAttribute('aria-disabled', r.toString());
            }
            _rotateCompassArrow() {
              const e = this._map;
              if (!e) return;
              const t = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(e.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${e.transform.pitch}deg) rotateZ(${e.transform.angle * (180 / Math.PI)}deg)` : `rotate(${e.transform.angle * (180 / Math.PI)}deg)`;
              e._requestDomTask(() => {
                this._compassIcon && (this._compassIcon.style.transform = t);
              });
            }
            onAdd(e) {
              return (this._map = e), this.options.showZoom && (this._setButtonTitle(this._zoomInButton, 'ZoomIn'), this._setButtonTitle(this._zoomOutButton, 'ZoomOut'), e.on('zoom', this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, 'ResetBearing'), this.options.visualizePitch && e.on('pitch', this._rotateCompassArrow), e.on('rotate', this._rotateCompassArrow), this._rotateCompassArrow(), (this._handler = new ID(e, this._compass, this.options.visualizePitch))), this._container;
            }
            onRemove() {
              const e = this._map;
              e && (this._container.remove(), this.options.showZoom && e.off('zoom', this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && e.off('pitch', this._rotateCompassArrow), e.off('rotate', this._rotateCompassArrow), this._handler && this._handler.off(), (this._handler = void 0)), (this._map = void 0));
            }
            _createButton(e, t) {
              const i = ri('button', e, this._container);
              return (i.type = 'button'), i.addEventListener('click', t), i;
            }
            _setButtonTitle(e, t) {
              if (!this._map) return;
              const i = this._map._getUIString(`NavigationControl.${t}`);
              e.setAttribute('aria-label', i), e.firstElementChild && e.firstElementChild.setAttribute('title', i);
            }
          },
          GeolocateControl: class extends Oi {
            constructor(e) {
              super(), (this.options = Ft({ geolocation: U.navigator.geolocation }, CD, e)), ot(['_onSuccess', '_onError', '_onZoom', '_finish', '_setupUI', '_updateCamera', '_updateMarker', '_updateMarkerRotation', '_onDeviceOrientation'], this), (this._updateMarkerRotationThrottled = dw(this._updateMarkerRotation, 20)), (this._numberOfWatches = 0);
            }
            onAdd(e) {
              return (this._map = e), (this._container = ri('div', 'mapboxgl-ctrl mapboxgl-ctrl-group')), this._checkGeolocationSupport(this._setupUI), this._container;
            }
            onRemove() {
              this._geolocationWatchID !== void 0 && (this.options.geolocation.clearWatch(this._geolocationWatchID), (this._geolocationWatchID = void 0)), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), this._container.remove(), this._map.off('zoom', this._onZoom), (this._map = void 0), (this._numberOfWatches = 0), (this._noTimeout = !1);
            }
            _checkGeolocationSupport(e) {
              const t = (i = !!this.options.geolocation) => {
                (this._supportsGeolocation = i), e(i);
              };
              this._supportsGeolocation !== void 0
                ? e(this._supportsGeolocation)
                : U.navigator.permissions !== void 0
                ? U.navigator.permissions
                    .query({ name: 'geolocation' })
                    .then((i) => t(i.state !== 'denied'))
                    .catch(() => t())
                : t();
            }
            _isOutOfMapMaxBounds(e) {
              const t = this._map.getMaxBounds(),
                i = e.coords;
              return !!t && (i.longitude < t.getWest() || i.longitude > t.getEast() || i.latitude < t.getSouth() || i.latitude > t.getNorth());
            }
            _setErrorState() {
              switch (this._watchState) {
                case 'WAITING_ACTIVE':
                  (this._watchState = 'ACTIVE_ERROR'), this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-active'), this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-active-error');
                  break;
                case 'ACTIVE_LOCK':
                  (this._watchState = 'ACTIVE_ERROR'), this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-active'), this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-active-error'), this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-waiting');
                  break;
                case 'BACKGROUND':
                  (this._watchState = 'BACKGROUND_ERROR'), this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-background'), this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-background-error'), this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-waiting');
              }
            }
            _onSuccess(e) {
              if (this._map) {
                if (this._isOutOfMapMaxBounds(e)) return this._setErrorState(), this.fire(new wt('outofmaxbounds', e)), this._updateMarker(), void this._finish();
                if (this.options.trackUserLocation)
                  switch (((this._lastKnownPosition = e), this._watchState)) {
                    case 'WAITING_ACTIVE':
                    case 'ACTIVE_LOCK':
                    case 'ACTIVE_ERROR':
                      (this._watchState = 'ACTIVE_LOCK'), this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-waiting'), this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-active-error'), this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-active');
                      break;
                    case 'BACKGROUND':
                    case 'BACKGROUND_ERROR':
                      (this._watchState = 'BACKGROUND'), this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-waiting'), this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-background-error'), this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-background');
                  }
                this.options.showUserLocation && this._watchState !== 'OFF' && this._updateMarker(e), (this.options.trackUserLocation && this._watchState !== 'ACTIVE_LOCK') || this._updateCamera(e), this.options.showUserLocation && this._userLocationDotMarker.removeClassName('mapboxgl-user-location-dot-stale'), this.fire(new wt('geolocate', e)), this._finish();
              }
            }
            _updateCamera(e) {
              const t = new ie(e.coords.longitude, e.coords.latitude),
                i = e.coords.accuracy,
                r = Ft({ bearing: this._map.getBearing() }, this.options.fitBoundsOptions);
              this._map.fitBounds(t.toBounds(i), r, { geolocateSource: !0 });
            }
            _updateMarker(e) {
              if (e) {
                const t = new ie(e.coords.longitude, e.coords.latitude);
                this._accuracyCircleMarker.setLngLat(t).addTo(this._map), this._userLocationDotMarker.setLngLat(t).addTo(this._map), (this._accuracy = e.coords.accuracy), this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
              } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
            }
            _updateCircleRadius() {
              const e = this._map.transform,
                t = Je(1, e._center.lat) * e.worldSize,
                i = Math.ceil(2 * this._accuracy * t);
              (this._circleElement.style.width = `${i}px`), (this._circleElement.style.height = `${i}px`);
            }
            _onZoom() {
              this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            }
            _updateMarkerRotation() {
              this._userLocationDotMarker && typeof this._heading == 'number' ? (this._userLocationDotMarker.setRotation(this._heading), this._userLocationDotMarker.addClassName('mapboxgl-user-location-show-heading')) : (this._userLocationDotMarker.removeClassName('mapboxgl-user-location-show-heading'), this._userLocationDotMarker.setRotation(0));
            }
            _onError(e) {
              if (this._map) {
                if (this.options.trackUserLocation)
                  if (e.code === 1) {
                    (this._watchState = 'OFF'), this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-waiting'), this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-active'), this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-active-error'), this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-background'), this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-background-error'), (this._geolocateButton.disabled = !0);
                    const t = this._map._getUIString('GeolocateControl.LocationNotAvailable');
                    this._geolocateButton.setAttribute('aria-label', t), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute('title', t), this._geolocationWatchID !== void 0 && this._clearWatch();
                  } else {
                    if (e.code === 3 && this._noTimeout) return;
                    this._setErrorState();
                  }
                this._watchState !== 'OFF' && this.options.showUserLocation && this._userLocationDotMarker.addClassName('mapboxgl-user-location-dot-stale'), this.fire(new wt('error', e)), this._finish();
              }
            }
            _finish() {
              this._timeoutId && clearTimeout(this._timeoutId), (this._timeoutId = void 0);
            }
            _setupUI(e) {
              if (this._map !== void 0) {
                if ((this._container.addEventListener('contextmenu', (t) => t.preventDefault()), (this._geolocateButton = ri('button', 'mapboxgl-ctrl-geolocate', this._container)), ri('span', 'mapboxgl-ctrl-icon', this._geolocateButton).setAttribute('aria-hidden', 'true'), (this._geolocateButton.type = 'button'), e === !1)) {
                  B('Geolocation support is not available so the GeolocateControl will be disabled.');
                  const t = this._map._getUIString('GeolocateControl.LocationNotAvailable');
                  (this._geolocateButton.disabled = !0), this._geolocateButton.setAttribute('aria-label', t), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute('title', t);
                } else {
                  const t = this._map._getUIString('GeolocateControl.FindMyLocation');
                  this._geolocateButton.setAttribute('aria-label', t), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute('title', t);
                }
                this.options.trackUserLocation && (this._geolocateButton.setAttribute('aria-pressed', 'false'), (this._watchState = 'OFF')),
                  this.options.showUserLocation && ((this._dotElement = ri('div', 'mapboxgl-user-location')), this._dotElement.appendChild(ri('div', 'mapboxgl-user-location-dot')), this._dotElement.appendChild(ri('div', 'mapboxgl-user-location-heading')), (this._userLocationDotMarker = new Vm({ element: this._dotElement, rotationAlignment: 'map', pitchAlignment: 'map' })), (this._circleElement = ri('div', 'mapboxgl-user-location-accuracy-circle')), (this._accuracyCircleMarker = new Vm({ element: this._circleElement, pitchAlignment: 'map' })), this.options.trackUserLocation && (this._watchState = 'OFF'), this._map.on('zoom', this._onZoom)),
                  this._geolocateButton.addEventListener('click', this.trigger.bind(this)),
                  (this._setup = !0),
                  this.options.trackUserLocation &&
                    this._map.on('movestart', (t) => {
                      t.geolocateSource || this._watchState !== 'ACTIVE_LOCK' || (t.originalEvent && t.originalEvent.type === 'resize') || ((this._watchState = 'BACKGROUND'), this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-background'), this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-active'), this.fire(new wt('trackuserlocationend')));
                    });
              }
            }
            _onDeviceOrientation(e) {
              this._userLocationDotMarker && (e.webkitCompassHeading ? (this._heading = e.webkitCompassHeading) : e.absolute === !0 && (this._heading = -1 * e.alpha), this._updateMarkerRotationThrottled());
            }
            trigger() {
              if (!this._setup) return B('Geolocate control triggered before added to a map'), !1;
              if (this.options.trackUserLocation) {
                switch (this._watchState) {
                  case 'OFF':
                    (this._watchState = 'WAITING_ACTIVE'), this.fire(new wt('trackuserlocationstart'));
                    break;
                  case 'WAITING_ACTIVE':
                  case 'ACTIVE_LOCK':
                  case 'ACTIVE_ERROR':
                  case 'BACKGROUND_ERROR':
                    this._numberOfWatches--, (this._noTimeout = !1), (this._watchState = 'OFF'), this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-waiting'), this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-active'), this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-active-error'), this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-background'), this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-background-error'), this.fire(new wt('trackuserlocationend'));
                    break;
                  case 'BACKGROUND':
                    (this._watchState = 'ACTIVE_LOCK'), this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-background'), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new wt('trackuserlocationstart'));
                }
                switch (this._watchState) {
                  case 'WAITING_ACTIVE':
                    this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-waiting'), this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-active');
                    break;
                  case 'ACTIVE_LOCK':
                    this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-active');
                    break;
                  case 'ACTIVE_ERROR':
                    this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-waiting'), this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-active-error');
                    break;
                  case 'BACKGROUND':
                    this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-background');
                    break;
                  case 'BACKGROUND_ERROR':
                    this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-waiting'), this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-background-error');
                }
                if (this._watchState === 'OFF' && this._geolocationWatchID !== void 0) this._clearWatch();
                else if (this._geolocationWatchID === void 0) {
                  let e;
                  this._geolocateButton.classList.add('mapboxgl-ctrl-geolocate-waiting'), this._geolocateButton.setAttribute('aria-pressed', 'true'), this._numberOfWatches++, this._numberOfWatches > 1 ? ((e = { maximumAge: 6e5, timeout: 0 }), (this._noTimeout = !0)) : ((e = this.options.positionOptions), (this._noTimeout = !1)), (this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, e)), this.options.showUserHeading && this._addDeviceOrientationListener();
                }
              } else this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), (this._timeoutId = setTimeout(this._finish, 1e4));
              return !0;
            }
            _addDeviceOrientationListener() {
              const e = () => {
                U.addEventListener('ondeviceorientationabsolute' in U ? 'deviceorientationabsolute' : 'deviceorientation', this._onDeviceOrientation);
              };
              U.DeviceMotionEvent !== void 0 && typeof U.DeviceMotionEvent.requestPermission == 'function'
                ? DeviceOrientationEvent.requestPermission()
                    .then((t) => {
                      t === 'granted' && e();
                    })
                    .catch(console.error)
                : e();
            }
            _clearWatch() {
              this.options.geolocation.clearWatch(this._geolocationWatchID), U.removeEventListener('deviceorientation', this._onDeviceOrientation), U.removeEventListener('deviceorientationabsolute', this._onDeviceOrientation), (this._geolocationWatchID = void 0), this._geolocateButton.classList.remove('mapboxgl-ctrl-geolocate-waiting'), this._geolocateButton.setAttribute('aria-pressed', 'false'), this.options.showUserLocation && this._updateMarker(null);
            }
          },
          AttributionControl: vw,
          ScaleControl: class {
            constructor(e) {
              (this.options = Ft({}, PD, e)),
                (this._isNumberFormatSupported = (function () {
                  try {
                    return new Intl.NumberFormat('en', { style: 'unit', unitDisplay: 'short', unit: 'meter' }), !0;
                  } catch {
                    return !1;
                  }
                })()),
                ot(['_update', '_setScale', 'setUnit'], this);
            }
            getDefaultPosition() {
              return 'bottom-left';
            }
            _update() {
              const e = this.options.maxWidth || 100,
                t = this._map,
                i = t._containerHeight / 2,
                r = t._containerWidth / 2 - e / 2,
                n = t.unproject([r, i]),
                o = t.unproject([r + e, i]),
                s = n.distanceTo(o);
              if (this.options.unit === 'imperial') {
                const a = 3.2808 * s;
                a > 5280 ? this._setScale(e, a / 5280, 'mile') : this._setScale(e, a, 'foot');
              } else this.options.unit === 'nautical' ? this._setScale(e, s / 1852, 'nautical-mile') : s >= 1e3 ? this._setScale(e, s / 1e3, 'kilometer') : this._setScale(e, s, 'meter');
            }
            _setScale(e, t, i) {
              this._map._requestDomTask(() => {
                const r = (function (o) {
                    const s = Math.pow(10, `${Math.floor(o)}`.length - 1);
                    let a = o / s;
                    return (
                      (a =
                        a >= 10
                          ? 10
                          : a >= 5
                          ? 5
                          : a >= 3
                          ? 3
                          : a >= 2
                          ? 2
                          : a >= 1
                          ? 1
                          : (function (l) {
                              const c = Math.pow(10, Math.ceil(-Math.log(l) / Math.LN10));
                              return Math.round(l * c) / c;
                            })(a)),
                      s * a
                    );
                  })(t),
                  n = r / t;
                (this._container.innerHTML = this._isNumberFormatSupported && i !== 'nautical-mile' ? new Intl.NumberFormat(this._language, { style: 'unit', unitDisplay: 'short', unit: i }).format(r) : `${r}&nbsp;${zD[i]}`), (this._container.style.width = e * n + 'px');
              });
            }
            onAdd(e) {
              return (this._map = e), (this._language = e.getLanguage()), (this._container = ri('div', 'mapboxgl-ctrl mapboxgl-ctrl-scale', e.getContainer())), (this._container.dir = 'auto'), this._map.on('move', this._update), this._update(), this._container;
            }
            onRemove() {
              this._container.remove(), this._map.off('move', this._update), (this._map = void 0);
            }
            _setLanguage(e) {
              (this._language = e), this._update();
            }
            setUnit(e) {
              (this.options.unit = e), this._update();
            }
          },
          FullscreenControl: class {
            constructor(e) {
              (this._fullscreen = !1), e && e.container && (e.container instanceof U.HTMLElement ? (this._container = e.container) : B("Full screen control 'container' must be a DOM element.")), ot(['_onClickFullscreen', '_changeIcon'], this), 'onfullscreenchange' in U.document ? (this._fullscreenchange = 'fullscreenchange') : 'onwebkitfullscreenchange' in U.document && (this._fullscreenchange = 'webkitfullscreenchange');
            }
            onAdd(e) {
              return (this._map = e), this._container || (this._container = this._map.getContainer()), (this._controlContainer = ri('div', 'mapboxgl-ctrl mapboxgl-ctrl-group')), this._checkFullscreenSupport() ? this._setupUI() : ((this._controlContainer.style.display = 'none'), B('This device does not support fullscreen mode.')), this._controlContainer;
            }
            onRemove() {
              this._controlContainer.remove(), (this._map = null), U.document.removeEventListener(this._fullscreenchange, this._changeIcon);
            }
            _checkFullscreenSupport() {
              return !(!U.document.fullscreenEnabled && !U.document.webkitFullscreenEnabled);
            }
            _setupUI() {
              const e = (this._fullscreenButton = ri('button', 'mapboxgl-ctrl-fullscreen', this._controlContainer));
              ri('span', 'mapboxgl-ctrl-icon', e).setAttribute('aria-hidden', 'true'), (e.type = 'button'), this._updateTitle(), this._fullscreenButton.addEventListener('click', this._onClickFullscreen), U.document.addEventListener(this._fullscreenchange, this._changeIcon);
            }
            _updateTitle() {
              const e = this._getTitle();
              this._fullscreenButton.setAttribute('aria-label', e), this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute('title', e);
            }
            _getTitle() {
              return this._map._getUIString(this._isFullscreen() ? 'FullscreenControl.Exit' : 'FullscreenControl.Enter');
            }
            _isFullscreen() {
              return this._fullscreen;
            }
            _changeIcon() {
              ((U.document.fullscreenElement || U.document.webkitFullscreenElement) === this._container) !== this._fullscreen && ((this._fullscreen = !this._fullscreen), this._fullscreenButton.classList.toggle('mapboxgl-ctrl-shrink'), this._fullscreenButton.classList.toggle('mapboxgl-ctrl-fullscreen'), this._updateTitle());
            }
            _onClickFullscreen() {
              this._isFullscreen() ? (U.document.exitFullscreen ? U.document.exitFullscreen() : U.document.webkitCancelFullScreen && U.document.webkitCancelFullScreen()) : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
            }
          },
          Popup: class extends Oi {
            constructor(e) {
              super(), (this.options = Ft(Object.create(wD), e)), ot(['_update', '_onClose', 'remove', '_onMouseEvent'], this), (this._classList = new Set(e && e.className ? e.className.trim().split(/\s+/) : []));
            }
            addTo(e) {
              return this._map && this.remove(), (this._map = e), this.options.closeOnClick && e.on('preclick', this._onClose), this.options.closeOnMove && e.on('move', this._onClose), e.on('remove', this.remove), this._update(), e._addPopup(this), this._focusFirstElement(), this._trackPointer ? (e.on('mousemove', this._onMouseEvent), e.on('mouseup', this._onMouseEvent), e._canvasContainer.classList.add('mapboxgl-track-pointer')) : e.on('move', this._update), this.fire(new wt('open')), this;
            }
            isOpen() {
              return !!this._map;
            }
            remove() {
              this._content && this._content.remove(), this._container && (this._container.remove(), (this._container = void 0));
              const e = this._map;
              return e && (e.off('move', this._update), e.off('move', this._onClose), e.off('preclick', this._onClose), e.off('click', this._onClose), e.off('remove', this.remove), e.off('mousemove', this._onMouseEvent), e.off('mouseup', this._onMouseEvent), e.off('drag', this._onMouseEvent), e._canvasContainer && e._canvasContainer.classList.remove('mapboxgl-track-pointer'), e._removePopup(this), (this._map = void 0)), this.fire(new wt('close')), this;
            }
            getLngLat() {
              return this._lngLat;
            }
            setLngLat(e) {
              (this._lngLat = ie.convert(e)), (this._pos = null), (this._trackPointer = !1), this._update();
              const t = this._map;
              return t && (t.on('move', this._update), t.off('mousemove', this._onMouseEvent), t._canvasContainer.classList.remove('mapboxgl-track-pointer')), this;
            }
            trackPointer() {
              (this._trackPointer = !0), (this._pos = null), this._update();
              const e = this._map;
              return e && (e.off('move', this._update), e.on('mousemove', this._onMouseEvent), e.on('drag', this._onMouseEvent), e._canvasContainer.classList.add('mapboxgl-track-pointer')), this;
            }
            getElement() {
              return this._container;
            }
            setText(e) {
              return this.setDOMContent(U.document.createTextNode(e));
            }
            setHTML(e) {
              const t = U.document.createDocumentFragment(),
                i = U.document.createElement('body');
              let r;
              for (i.innerHTML = e; (r = i.firstChild), r; ) t.appendChild(r);
              return this.setDOMContent(t);
            }
            getMaxWidth() {
              return this._container && this._container.style.maxWidth;
            }
            setMaxWidth(e) {
              return (this.options.maxWidth = e), this._update(), this;
            }
            setDOMContent(e) {
              let t = this._content;
              if (t) for (; t.hasChildNodes(); ) t.firstChild && t.removeChild(t.firstChild);
              else t = this._content = ri('div', 'mapboxgl-popup-content', this._container || void 0);
              if ((t.appendChild(e), this.options.closeButton)) {
                const i = (this._closeButton = ri('button', 'mapboxgl-popup-close-button', t));
                (i.type = 'button'), i.setAttribute('aria-label', 'Close popup'), i.setAttribute('aria-hidden', 'true'), (i.innerHTML = '&#215;'), i.addEventListener('click', this._onClose);
              }
              return this._update(), this._focusFirstElement(), this;
            }
            addClassName(e) {
              return this._classList.add(e), this._updateClassList(), this;
            }
            removeClassName(e) {
              return this._classList.delete(e), this._updateClassList(), this;
            }
            setOffset(e) {
              return (this.options.offset = e), this._update(), this;
            }
            toggleClassName(e) {
              let t;
              return this._classList.delete(e) ? (t = !1) : (this._classList.add(e), (t = !0)), this._updateClassList(), t;
            }
            _onMouseEvent(e) {
              this._update(e.point);
            }
            _getAnchor(e) {
              if (this.options.anchor) return this.options.anchor;
              const t = this._map,
                i = this._container,
                r = this._pos;
              if (!t || !i || !r) return 'bottom';
              const n = i.offsetWidth,
                o = i.offsetHeight,
                s = r.x < n / 2,
                a = r.x > t.transform.width - n / 2;
              if (r.y + e < o) return s ? 'top-left' : a ? 'top-right' : 'top';
              if (r.y > t.transform.height - o) {
                if (s) return 'bottom-left';
                if (a) return 'bottom-right';
              }
              return s ? 'left' : a ? 'right' : 'bottom';
            }
            _updateClassList() {
              const e = this._container;
              if (!e) return;
              const t = [...this._classList];
              t.push('mapboxgl-popup'), this._anchor && t.push(`mapboxgl-popup-anchor-${this._anchor}`), this._trackPointer && t.push('mapboxgl-popup-track-pointer'), (e.className = t.join(' '));
            }
            _update(e) {
              const t = this._map,
                i = this._content;
              if (!t || (!this._lngLat && !this._trackPointer) || !i) return;
              let r = this._container;
              if ((r || ((r = this._container = ri('div', 'mapboxgl-popup', t.getContainer())), (this._tip = ri('div', 'mapboxgl-popup-tip', r)), r.appendChild(i)), this.options.maxWidth && r.style.maxWidth !== this.options.maxWidth && (r.style.maxWidth = this.options.maxWidth), t.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = Tw(this._lngLat, this._pos, t.transform)), !this._trackPointer || e)) {
                const n = (this._pos = this._trackPointer && e ? e : t.project(this._lngLat)),
                  o = Ew(this.options.offset),
                  s = (this._anchor = this._getAnchor(o.y)),
                  a = Ew(this.options.offset, s),
                  l = n.add(a).round();
                t._requestDomTask(() => {
                  this._container && s && (this._container.style.transform = `${Um[s]} translate(${l.x}px,${l.y}px)`);
                });
              }
              if (!this._marker && t._showingGlobe()) {
                const n = fu(t.transform, this._lngLat) ? 0 : 1;
                this._setOpacity(n);
              }
              this._updateClassList();
            }
            _focusFirstElement() {
              if (!this.options.focusAfterOpen || !this._container) return;
              const e = this._container.querySelector(TD);
              e && e.focus();
            }
            _onClose() {
              this.remove();
            }
            _setOpacity(e) {
              this._container && (this._container.style.opacity = `${e}`), this._content && (this._content.style.pointerEvents = e ? 'auto' : 'none');
            }
          },
          Marker: Vm,
          Style: Mn,
          LngLat: ie,
          LngLatBounds: kr,
          Point: H,
          MercatorCoordinate: Me,
          FreeCameraOptions: kv,
          Evented: Oi,
          config: Mt,
          prewarm: function () {
            Ql().acquire(hm);
          },
          clearPrewarmedResources: function () {
            const e = Jl;
            e && (e.isPreloaded() && e.numActive() === 1 ? (e.release(hm), (Jl = null)) : console.warn('Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()'));
          },
          get accessToken() {
            return Mt.ACCESS_TOKEN;
          },
          set accessToken(e) {
            Mt.ACCESS_TOKEN = e;
          },
          get baseApiUrl() {
            return Mt.API_URL;
          },
          set baseApiUrl(e) {
            Mt.API_URL = e;
          },
          get workerCount() {
            return ka.workerCount;
          },
          set workerCount(e) {
            ka.workerCount = e;
          },
          get maxParallelImageRequests() {
            return Mt.MAX_PARALLEL_IMAGE_REQUESTS;
          },
          set maxParallelImageRequests(e) {
            Mt.MAX_PARALLEL_IMAGE_REQUESTS = e;
          },
          clearStorage(e) {
            (function (t) {
              if (!Hs()) return;
              const i = U.caches.delete(Ye);
              t && i.catch(t).then(() => t());
            })(e);
          },
          workerUrl: '',
          workerClass: null,
          get dracoUrl() {
            return Y1();
          },
          set dracoUrl(e) {
            (function (t) {
              (dm = oe.resolveURL(t)), fm || (fm = new Cs(Ql(), new Oi())), fm.broadcast('setDracoUrl', dm);
            })(e);
          },
          setNow: oe.setNow,
          restoreNow: oe.restoreNow,
        };
      ($.A = V1),
        ($.D = zu),
        ($.E = lt),
        ($.F = Lp),
        ($.K = ph),
        ($.O = Le),
        ($.P = H),
        ($.T = s1),
        ($.V = Su),
        ($.a = Mu),
        ($.b = Fx),
        ($.c = oh),
        ($.d = class extends Oi {
          constructor(e, t, i, r, n, o) {
            super(), (this.actor = e), (this.layerIndex = t), (this.availableImages = i), (this.loadVectorData = n || W1), (this.loading = {}), (this.loaded = {}), (this.deduped = new H1(e.scheduler)), (this.isSpriteLoaded = r), (this.scheduler = e.scheduler), (this.brightness = o);
          }
          loadTile(e, t) {
            const i = e.uid,
              r = e && e.request,
              n = r && r.collectResourceTiming,
              o = (this.loading[i] = new KC(e));
            o.abort = this.loadVectorData(e, (s, a) => {
              const l = !this.loading[i];
              if ((delete this.loading[i], l || s || !a)) return (o.status = 'done'), l || (this.loaded[i] = o), t(s);
              const c = a.rawData,
                u = {};
              a.expires && (u.expires = a.expires), a.cacheControl && (u.cacheControl = a.cacheControl), (o.vectorTile = a.vectorTile || new Dp(new Pu(c)));
              const h = () => {
                o.parse(o.vectorTile, this.layerIndex, this.availableImages, this.actor, (d, f) => {
                  if (d || !f) return t(d);
                  const p = {};
                  if (n) {
                    const _ = N_(r);
                    _.length > 0 && (p.resourceTiming = JSON.parse(JSON.stringify(_)));
                  }
                  t(null, Ft({ rawTileData: c.slice(0) }, f, u, p));
                });
              };
              this.isSpriteLoaded
                ? h()
                : this.once('isSpriteLoaded', () => {
                    this.scheduler ? this.scheduler.add(h, { type: 'parseTile', isSymbolTile: e.isSymbolTile, zoom: e.tileZoom }) : h();
                  }),
                (this.loaded = this.loaded || {}),
                (this.loaded[i] = o);
            });
          }
          reloadTile(e, t) {
            const i = this.loaded,
              r = e.uid,
              n = this;
            if (i && i[r]) {
              const o = i[r];
              (o.showCollisionBoxes = e.showCollisionBoxes), (o.projection = e.projection), (o.brightness = e.brightness), (o.tileTransform = Es(e.tileID.canonical, e.projection)), (o.extraShadowCaster = e.extraShadowCaster);
              const s = (a, l) => {
                const c = o.reloadCallback;
                c && (delete o.reloadCallback, o.parse(o.vectorTile, n.layerIndex, this.availableImages, n.actor, c)), t(a, l);
              };
              o.status === 'parsing' ? (o.reloadCallback = s) : o.status === 'done' && (o.vectorTile ? o.parse(o.vectorTile, this.layerIndex, this.availableImages, this.actor, s) : s());
            } else t(null, void 0);
          }
          abortTile(e, t) {
            const i = e.uid,
              r = this.loading[i];
            r && (r.abort && r.abort(), delete this.loading[i]), t();
          }
          removeTile(e, t) {
            const i = this.loaded,
              r = e.uid;
            i && i[r] && delete i[r], t();
          }
        }),
        ($.e = So),
        ($.f = N_),
        ($.g = ze),
        ($.h = At),
        ($.i = Dt),
        ($.j = function (e, t) {
          const i = xm(e);
          for (const r of i) {
            for (const n of r.meshes) aP(n);
            r.lights && ((r.lightMeshIndex = r.meshes.length), r.meshes.push(lP(r.lights, t)));
          }
          return i;
        }),
        ($.k = gi),
        ($.l = function (e) {
          let t = 0;
          if (new Uint32Array(e, 0, 1)[0] !== J1) {
            const i = new Uint32Array(e, 0, 7),
              [, , r, n, o, s] = i;
            (t = i.byteLength + n + o + s + o), (r !== e.byteLength || t >= e.byteLength) && B('Invalid b3dm header information.');
          }
          return ib(e, t);
        }),
        ($.m = Uu),
        ($.n = an),
        ($.o = wt),
        ($.p = ur),
        ($.q = function (e) {
          Ir(),
            zi &&
              zi.then((t) => {
                t.keys().then((i) => {
                  for (let r = 0; r < i.length - e; r++) t.delete(i[r]);
                });
              });
        }),
        ($.r = ab),
        ($.s = Ph),
        ($.t = Il),
        ($.v = hr),
        ($.w = U);
    }),
      W(['./shared'], function ($) {
        function U(tt) {
          if (typeof tt == 'number' || typeof tt == 'boolean' || typeof tt == 'string' || tt == null) return JSON.stringify(tt);
          if (Array.isArray(tt)) {
            let L = '[';
            for (const B of tt) L += `${U(B)},`;
            return `${L}]`;
          }
          let P = '{';
          for (const L of Object.keys(tt).sort()) P += `${L}:${U(tt[L])},`;
          return `${P}}`;
        }
        function Et(tt) {
          let P = '';
          for (const L of $.r) P += `/${U(tt[L])}`;
          return P;
        }
        class Zt {
          constructor(P) {
            (this.keyCache = {}), (this._layers = {}), (this._layerConfigs = {}), P && this.replace(P);
          }
          replace(P, L) {
            (this._layerConfigs = {}), (this._layers = {}), this.update(P, [], L);
          }
          update(P, L, B) {
            this._options = B;
            for (const K of P) {
              this._layerConfigs[K.id] = K;
              const ft = (this._layers[K.id] = $.c(K, this._options));
              ft.setScope(this.scope), ft.compileFilter(), this.keyCache[K.id] && delete this.keyCache[K.id];
            }
            for (const K of L) delete this.keyCache[K], delete this._layerConfigs[K], delete this._layers[K];
            this.familiesBySource = {};
            const et = (function (K, ft) {
              const gt = {};
              for (let Tt = 0; Tt < K.length; Tt++) {
                const Lt = (ft && ft[K[Tt].id]) || Et(K[Tt]);
                ft && (ft[K[Tt].id] = Lt);
                let jt = gt[Lt];
                jt || (jt = gt[Lt] = []), jt.push(K[Tt]);
              }
              const ct = [];
              for (const Tt in gt) ct.push(gt[Tt]);
              return ct;
            })($.v(this._layerConfigs), this.keyCache);
            for (const K of et) {
              const ft = K.map((le) => this._layers[le.id]),
                gt = ft[0];
              if (gt.visibility === 'none') continue;
              const ct = gt.source || '';
              let Tt = this.familiesBySource[ct];
              Tt || (Tt = this.familiesBySource[ct] = {});
              const Lt = gt.sourceLayer || '_geojsonTileLayer';
              let jt = Tt[Lt];
              jt || (jt = Tt[Lt] = []), jt.push(ft);
            }
          }
        }
        class Mt {
          loadTile(P, L) {
            const { uid: B, encoding: et, rawImageData: K, padding: ft } = P,
              gt = $.w.ImageBitmap && K instanceof $.w.ImageBitmap ? this.getImageData(K, ft) : K;
            L(null, new $.D(B, gt, et, ft < 1));
          }
          getImageData(P, L) {
            (this.offscreenCanvas && this.offscreenCanvasContext) || ((this.offscreenCanvas = new OffscreenCanvas(P.width, P.height)), (this.offscreenCanvasContext = this.offscreenCanvas.getContext('2d', { willReadFrequently: !0 }))), (this.offscreenCanvas.width = P.width), (this.offscreenCanvas.height = P.height), this.offscreenCanvasContext.drawImage(P, 0, 0, P.width, P.height);
            const B = this.offscreenCanvasContext.getImageData(-L, -L, P.width + 2 * L, P.height + 2 * L);
            return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), B;
          }
        }
        function _e(tt, P) {
          if (tt.length !== 0) {
            ei(tt[0], P);
            for (var L = 1; L < tt.length; L++) ei(tt[L], !P);
          }
        }
        function ei(tt, P) {
          for (var L = 0, B = 0, et = 0, K = tt.length, ft = K - 1; et < K; ft = et++) {
            var gt = (tt[et][0] - tt[ft][0]) * (tt[ft][1] + tt[et][1]),
              ct = L + gt;
            (B += Math.abs(L) >= Math.abs(gt) ? L - ct + gt : gt - ct + L), (L = ct);
          }
          L + B >= 0 != !!P && tt.reverse();
        }
        var Oe = $.g(function tt(P, L) {
          var B,
            et = P && P.type;
          if (et === 'FeatureCollection') for (B = 0; B < P.features.length; B++) tt(P.features[B], L);
          else if (et === 'GeometryCollection') for (B = 0; B < P.geometries.length; B++) tt(P.geometries[B], L);
          else if (et === 'Feature') tt(P.geometry, L);
          else if (et === 'Polygon') _e(P.coordinates, L);
          else if (et === 'MultiPolygon') for (B = 0; B < P.coordinates.length; B++) _e(P.coordinates[B], L);
          return P;
        });
        const Si = $.V.prototype.toGeoJSON;
        var pi = { exports: {} },
          cr = $.p,
          Ue = $.a.VectorTileFeature,
          ze = ui;
        function ui(tt, P) {
          (this.options = P || {}), (this.features = tt), (this.length = tt.length);
        }
        function qe(tt, P) {
          (this.id = typeof tt.id == 'number' ? tt.id : void 0), (this.type = tt.type), (this.rawGeometry = tt.type === 1 ? [tt.geometry] : tt.geometry), (this.properties = tt.tags), (this.extent = P || 4096);
        }
        (ui.prototype.feature = function (tt) {
          return new qe(this.features[tt], this.options.extent);
        }),
          (qe.prototype.loadGeometry = function () {
            var tt = this.rawGeometry;
            this.geometry = [];
            for (var P = 0; P < tt.length; P++) {
              for (var L = tt[P], B = [], et = 0; et < L.length; et++) B.push(new cr(L[et][0], L[et][1]));
              this.geometry.push(B);
            }
            return this.geometry;
          }),
          (qe.prototype.bbox = function () {
            this.geometry || this.loadGeometry();
            for (var tt = this.geometry, P = 1 / 0, L = -1 / 0, B = 1 / 0, et = -1 / 0, K = 0; K < tt.length; K++)
              for (var ft = tt[K], gt = 0; gt < ft.length; gt++) {
                var ct = ft[gt];
                (P = Math.min(P, ct.x)), (L = Math.max(L, ct.x)), (B = Math.min(B, ct.y)), (et = Math.max(et, ct.y));
              }
            return [P, B, L, et];
          }),
          (qe.prototype.toGeoJSON = Ue.prototype.toGeoJSON);
        var Mr = $.b,
          ur = ze;
        function Sr(tt) {
          var P = new Mr();
          return (
            (function (L, B) {
              for (var et in L.layers) B.writeMessage(3, H, L.layers[et]);
            })(tt, P),
            P.finish()
          );
        }
        function H(tt, P) {
          var L;
          P.writeVarintField(15, tt.version || 1), P.writeStringField(1, tt.name || ''), P.writeVarintField(5, tt.extent || 4096);
          var B = { keys: [], values: [], keycache: {}, valuecache: {} };
          for (L = 0; L < tt.length; L++) (B.feature = tt.feature(L)), P.writeMessage(2, we, B);
          var et = B.keys;
          for (L = 0; L < et.length; L++) P.writeStringField(3, et[L]);
          var K = B.values;
          for (L = 0; L < K.length; L++) P.writeMessage(4, nr, K[L]);
        }
        function we(tt, P) {
          var L = tt.feature;
          L.id !== void 0 && P.writeVarintField(1, L.id), P.writeMessage(2, vo, tt), P.writeVarintField(3, L.type), P.writeMessage(4, Vi, L);
        }
        function vo(tt, P) {
          var L = tt.feature,
            B = tt.keys,
            et = tt.values,
            K = tt.keycache,
            ft = tt.valuecache;
          for (var gt in L.properties) {
            var ct = L.properties[gt],
              Tt = K[gt];
            if (ct !== null) {
              Tt === void 0 && (B.push(gt), (K[gt] = Tt = B.length - 1)), P.writeVarint(Tt);
              var Lt = typeof ct;
              Lt !== 'string' && Lt !== 'boolean' && Lt !== 'number' && (ct = JSON.stringify(ct));
              var jt = Lt + ':' + ct,
                le = ft[jt];
              le === void 0 && (et.push(ct), (ft[jt] = le = et.length - 1)), P.writeVarint(le);
            }
          }
        }
        function Qr(tt, P) {
          return (P << 3) + (7 & tt);
        }
        function ne(tt) {
          return (tt << 1) ^ (tt >> 31);
        }
        function Vi(tt, P) {
          for (var L = tt.loadGeometry(), B = tt.type, et = 0, K = 0, ft = L.length, gt = 0; gt < ft; gt++) {
            var ct = L[gt],
              Tt = 1;
            B === 1 && (Tt = ct.length), P.writeVarint(Qr(1, Tt));
            for (var Lt = B === 3 ? ct.length - 1 : ct.length, jt = 0; jt < Lt; jt++) {
              jt === 1 && B !== 1 && P.writeVarint(Qr(2, Lt - 1));
              var le = ct[jt].x - et,
                Ie = ct[jt].y - K;
              P.writeVarint(ne(le)), P.writeVarint(ne(Ie)), (et += le), (K += Ie);
            }
            B === 3 && P.writeVarint(Qr(7, 1));
          }
        }
        function nr(tt, P) {
          var L = typeof tt;
          L === 'string' ? P.writeStringField(1, tt) : L === 'boolean' ? P.writeBooleanField(7, tt) : L === 'number' && (tt % 1 != 0 ? P.writeDoubleField(3, tt) : tt < 0 ? P.writeSVarintField(6, tt) : P.writeVarintField(5, tt));
        }
        (pi.exports = Sr),
          (pi.exports.fromVectorTileJs = Sr),
          (pi.exports.fromGeojsonVt = function (tt, P) {
            P = P || {};
            var L = {};
            for (var B in tt) (L[B] = new ur(tt[B].features, P)), (L[B].name = B), (L[B].version = P.version), (L[B].extent = P.extent);
            return Sr({ layers: L });
          }),
          (pi.exports.GeoJSONWrapper = ur);
        var mi = $.g(pi.exports);
        const _i = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: (tt) => tt },
          yr = Math.fround || ((tn = new Float32Array(1)), (tt) => ((tn[0] = +tt), tn[0]));
        var tn;
        const tr = 3,
          Bt = 5,
          Zr = 6;
        class en {
          constructor(P) {
            (this.options = Object.assign(Object.create(_i), P)), (this.trees = new Array(this.options.maxZoom + 1)), (this.stride = this.options.reduce ? 7 : 6), (this.clusterProps = []);
          }
          load(P) {
            const { log: L, minZoom: B, maxZoom: et } = this.options;
            L && console.time('total time');
            const K = `prepare ${P.length} points`;
            L && console.time(K), (this.points = P);
            const ft = [];
            for (let ct = 0; ct < P.length; ct++) {
              const Tt = P[ct];
              if (!Tt.geometry) continue;
              const [Lt, jt] = Tt.geometry.coordinates,
                le = yr(Ft(Lt)),
                Ie = yr(ar(jt));
              ft.push(le, Ie, 1 / 0, ct, -1, 1), this.options.reduce && ft.push(0);
            }
            let gt = (this.trees[et + 1] = this._createTree(ft));
            L && console.timeEnd(K);
            for (let ct = et; ct >= B; ct--) {
              const Tt = +Date.now();
              (gt = this.trees[ct] = this._createTree(this._cluster(gt, ct))), L && console.log('z%d: %d clusters in %dms', ct, gt.numItems, +Date.now() - Tt);
            }
            return L && console.timeEnd('total time'), this;
          }
          getClusters(P, L) {
            let B = ((((P[0] + 180) % 360) + 360) % 360) - 180;
            const et = Math.max(-90, Math.min(90, P[1]));
            let K = P[2] === 180 ? 180 : ((((P[2] + 180) % 360) + 360) % 360) - 180;
            const ft = Math.max(-90, Math.min(90, P[3]));
            if (P[2] - P[0] >= 360) (B = -180), (K = 180);
            else if (B > K) {
              const jt = this.getClusters([B, et, 180, ft], L),
                le = this.getClusters([-180, et, K, ft], L);
              return jt.concat(le);
            }
            const gt = this.trees[this._limitZoom(L)],
              ct = gt.range(Ft(B), ar(ft), Ft(K), ar(et)),
              Tt = gt.data,
              Lt = [];
            for (const jt of ct) {
              const le = this.stride * jt;
              Lt.push(Tt[le + Bt] > 1 ? Yn(Tt, le, this.clusterProps) : this.points[Tt[le + tr]]);
            }
            return Lt;
          }
          getChildren(P) {
            const L = this._getOriginId(P),
              B = this._getOriginZoom(P),
              et = 'No cluster with the specified id.',
              K = this.trees[B];
            if (!K) throw new Error(et);
            const ft = K.data;
            if (L * this.stride >= ft.length) throw new Error(et);
            const gt = this.options.radius / (this.options.extent * Math.pow(2, B - 1)),
              ct = K.within(ft[L * this.stride], ft[L * this.stride + 1], gt),
              Tt = [];
            for (const Lt of ct) {
              const jt = Lt * this.stride;
              ft[jt + 4] === P && Tt.push(ft[jt + Bt] > 1 ? Yn(ft, jt, this.clusterProps) : this.points[ft[jt + tr]]);
            }
            if (Tt.length === 0) throw new Error(et);
            return Tt;
          }
          getLeaves(P, L, B) {
            const et = [];
            return this._appendLeaves(et, P, (L = L || 10), (B = B || 0), 0), et;
          }
          getTile(P, L, B) {
            const et = this.trees[this._limitZoom(P)],
              K = Math.pow(2, P),
              { extent: ft, radius: gt } = this.options,
              ct = gt / ft,
              Tt = (B - ct) / K,
              Lt = (B + 1 + ct) / K,
              jt = { features: [] };
            return this._addTileFeatures(et.range((L - ct) / K, Tt, (L + 1 + ct) / K, Lt), et.data, L, B, K, jt), L === 0 && this._addTileFeatures(et.range(1 - ct / K, Tt, 1, Lt), et.data, K, B, K, jt), L === K - 1 && this._addTileFeatures(et.range(0, Tt, ct / K, Lt), et.data, -1, B, K, jt), jt.features.length ? jt : null;
          }
          getClusterExpansionZoom(P) {
            let L = this._getOriginZoom(P) - 1;
            for (; L <= this.options.maxZoom; ) {
              const B = this.getChildren(P);
              if ((L++, B.length !== 1)) break;
              P = B[0].properties.cluster_id;
            }
            return L;
          }
          _appendLeaves(P, L, B, et, K) {
            const ft = this.getChildren(L);
            for (const gt of ft) {
              const ct = gt.properties;
              if ((ct && ct.cluster ? (K + ct.point_count <= et ? (K += ct.point_count) : (K = this._appendLeaves(P, ct.cluster_id, B, et, K))) : K < et ? K++ : P.push(gt), P.length === B)) break;
            }
            return K;
          }
          _createTree(P) {
            const L = new $.K((P.length / this.stride) | 0, this.options.nodeSize, Float32Array);
            for (let B = 0; B < P.length; B += this.stride) L.add(P[B], P[B + 1]);
            return L.finish(), (L.data = P), L;
          }
          _addTileFeatures(P, L, B, et, K, ft) {
            for (const gt of P) {
              const ct = gt * this.stride,
                Tt = L[ct + Bt] > 1;
              let Lt, jt, le;
              if (Tt) (Lt = hr(L, ct, this.clusterProps)), (jt = L[ct]), (le = L[ct + 1]);
              else {
                const ii = this.points[L[ct + tr]];
                Lt = ii.properties;
                const [bi, Ye] = ii.geometry.coordinates;
                (jt = Ft(bi)), (le = ar(Ye));
              }
              const Ie = { type: 1, geometry: [[Math.round(this.options.extent * (jt * K - B)), Math.round(this.options.extent * (le * K - et))]], tags: Lt };
              let ai;
              (ai = Tt || this.options.generateId ? L[ct + tr] : this.points[L[ct + tr]].id), ai !== void 0 && (Ie.id = ai), ft.features.push(Ie);
            }
          }
          _limitZoom(P) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+P), this.options.maxZoom + 1));
          }
          _cluster(P, L) {
            const { radius: B, extent: et, reduce: K, minPoints: ft } = this.options,
              gt = B / (et * Math.pow(2, L)),
              ct = P.data,
              Tt = [],
              Lt = this.stride;
            for (let jt = 0; jt < ct.length; jt += Lt) {
              if (ct[jt + 2] <= L) continue;
              ct[jt + 2] = L;
              const le = ct[jt],
                Ie = ct[jt + 1],
                ai = P.within(ct[jt], ct[jt + 1], gt),
                ii = ct[jt + Bt];
              let bi = ii;
              for (const Ye of ai) {
                const er = Ye * Lt;
                ct[er + 2] > L && (bi += ct[er + Bt]);
              }
              if (bi > ii && bi >= ft) {
                let Ye,
                  er = le * ii,
                  wi = Ie * ii,
                  zi = -1;
                const Ar = (((jt / Lt) | 0) << 5) + (L + 1) + this.points.length;
                for (const Hs of ai) {
                  const Ir = Hs * Lt;
                  if (ct[Ir + 2] <= L) continue;
                  ct[Ir + 2] = L;
                  const Kn = ct[Ir + Bt];
                  (er += ct[Ir] * Kn), (wi += ct[Ir + 1] * Kn), (ct[Ir + 4] = Ar), K && (Ye || ((Ye = this._map(ct, jt, !0)), (zi = this.clusterProps.length), this.clusterProps.push(Ye)), K(Ye, this._map(ct, Ir)));
                }
                (ct[jt + 4] = Ar), Tt.push(er / bi, wi / bi, 1 / 0, Ar, -1, bi), K && Tt.push(zi);
              } else {
                for (let Ye = 0; Ye < Lt; Ye++) Tt.push(ct[jt + Ye]);
                if (bi > 1)
                  for (const Ye of ai) {
                    const er = Ye * Lt;
                    if (!(ct[er + 2] <= L)) {
                      ct[er + 2] = L;
                      for (let wi = 0; wi < Lt; wi++) Tt.push(ct[er + wi]);
                    }
                  }
              }
            }
            return Tt;
          }
          _getOriginId(P) {
            return (P - this.points.length) >> 5;
          }
          _getOriginZoom(P) {
            return (P - this.points.length) % 32;
          }
          _map(P, L, B) {
            if (P[L + Bt] > 1) {
              const ft = this.clusterProps[P[L + Zr]];
              return B ? Object.assign({}, ft) : ft;
            }
            const et = this.points[P[L + tr]].properties,
              K = this.options.map(et);
            return B && K === et ? Object.assign({}, K) : K;
          }
        }
        function Yn(tt, P, L) {
          return { type: 'Feature', id: tt[P + tr], properties: hr(tt, P, L), geometry: { type: 'Point', coordinates: [((B = tt[P]), 360 * (B - 0.5)), $s(tt[P + 1])] } };
          var B;
        }
        function hr(tt, P, L) {
          const B = tt[P + Bt],
            et = B >= 1e4 ? `${Math.round(B / 1e3)}k` : B >= 1e3 ? Math.round(B / 100) / 10 + 'k' : B,
            K = tt[P + Zr],
            ft = K === -1 ? {} : Object.assign({}, L[K]);
          return Object.assign(ft, { cluster: !0, cluster_id: tt[P + tr], point_count: B, point_count_abbreviated: et });
        }
        function Ft(tt) {
          return tt / 360 + 0.5;
        }
        function ar(tt) {
          const P = Math.sin((tt * Math.PI) / 180),
            L = 0.5 - (0.25 * Math.log((1 + P) / (1 - P))) / Math.PI;
          return L < 0 ? 0 : L > 1 ? 1 : L;
        }
        function $s(tt) {
          const P = ((180 - 360 * tt) * Math.PI) / 180;
          return (360 * Math.atan(Math.exp(P))) / Math.PI - 90;
        }
        var $r = { exports: {} };
        $r.exports = (function () {
          function tt(dt, mt, bt, St) {
            for (var At, Dt = St, kt = (bt - mt) >> 1, It = bt - mt, qt = dt[mt], Rt = dt[mt + 1], de = dt[bt], Ke = dt[bt + 1], Yt = mt + 3; Yt < bt; Yt += 3) {
              var Ze = P(dt[Yt], dt[Yt + 1], qt, Rt, de, Ke);
              if (Ze > Dt) (At = Yt), (Dt = Ze);
              else if (Ze === Dt) {
                var Ei = Math.abs(Yt - kt);
                Ei < It && ((At = Yt), (It = Ei));
              }
            }
            Dt > St && (At - mt > 3 && tt(dt, mt, At, St), (dt[At + 2] = Dt), bt - At > 3 && tt(dt, At, bt, St));
          }
          function P(dt, mt, bt, St, At, Dt) {
            var kt = At - bt,
              It = Dt - St;
            if (kt !== 0 || It !== 0) {
              var qt = ((dt - bt) * kt + (mt - St) * It) / (kt * kt + It * It);
              qt > 1 ? ((bt = At), (St = Dt)) : qt > 0 && ((bt += kt * qt), (St += It * qt));
            }
            return (kt = dt - bt) * kt + (It = mt - St) * It;
          }
          function L(dt, mt, bt, St) {
            var At = { id: dt === void 0 ? null : dt, type: mt, geometry: bt, tags: St, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
            return (
              (function (Dt) {
                var kt = Dt.geometry,
                  It = Dt.type;
                if (It === 'Point' || It === 'MultiPoint' || It === 'LineString') B(Dt, kt);
                else if (It === 'Polygon' || It === 'MultiLineString') for (var qt = 0; qt < kt.length; qt++) B(Dt, kt[qt]);
                else if (It === 'MultiPolygon') for (qt = 0; qt < kt.length; qt++) for (var Rt = 0; Rt < kt[qt].length; Rt++) B(Dt, kt[qt][Rt]);
              })(At),
              At
            );
          }
          function B(dt, mt) {
            for (var bt = 0; bt < mt.length; bt += 3) (dt.minX = Math.min(dt.minX, mt[bt])), (dt.minY = Math.min(dt.minY, mt[bt + 1])), (dt.maxX = Math.max(dt.maxX, mt[bt])), (dt.maxY = Math.max(dt.maxY, mt[bt + 1]));
          }
          function et(dt, mt, bt, St) {
            if (mt.geometry) {
              var At = mt.geometry.coordinates,
                Dt = mt.geometry.type,
                kt = Math.pow(bt.tolerance / ((1 << bt.maxZoom) * bt.extent), 2),
                It = [],
                qt = mt.id;
              if ((bt.promoteId ? (qt = mt.properties[bt.promoteId]) : bt.generateId && (qt = St || 0), Dt === 'Point')) K(At, It);
              else if (Dt === 'MultiPoint') for (var Rt = 0; Rt < At.length; Rt++) K(At[Rt], It);
              else if (Dt === 'LineString') ft(At, It, kt, !1);
              else if (Dt === 'MultiLineString') {
                if (bt.lineMetrics) {
                  for (Rt = 0; Rt < At.length; Rt++) ft(At[Rt], (It = []), kt, !1), dt.push(L(qt, 'LineString', It, mt.properties));
                  return;
                }
                gt(At, It, kt, !1);
              } else if (Dt === 'Polygon') gt(At, It, kt, !0);
              else {
                if (Dt !== 'MultiPolygon') {
                  if (Dt === 'GeometryCollection') {
                    for (Rt = 0; Rt < mt.geometry.geometries.length; Rt++) et(dt, { id: qt, geometry: mt.geometry.geometries[Rt], properties: mt.properties }, bt, St);
                    return;
                  }
                  throw new Error('Input data is not a valid GeoJSON object.');
                }
                for (Rt = 0; Rt < At.length; Rt++) {
                  var de = [];
                  gt(At[Rt], de, kt, !0), It.push(de);
                }
              }
              dt.push(L(qt, Dt, It, mt.properties));
            }
          }
          function K(dt, mt) {
            mt.push(ct(dt[0])), mt.push(Tt(dt[1])), mt.push(0);
          }
          function ft(dt, mt, bt, St) {
            for (var At, Dt, kt = 0, It = 0; It < dt.length; It++) {
              var qt = ct(dt[It][0]),
                Rt = Tt(dt[It][1]);
              mt.push(qt), mt.push(Rt), mt.push(0), It > 0 && (kt += St ? (At * Rt - qt * Dt) / 2 : Math.sqrt(Math.pow(qt - At, 2) + Math.pow(Rt - Dt, 2))), (At = qt), (Dt = Rt);
            }
            var de = mt.length - 3;
            (mt[2] = 1), tt(mt, 0, de, bt), (mt[de + 2] = 1), (mt.size = Math.abs(kt)), (mt.start = 0), (mt.end = mt.size);
          }
          function gt(dt, mt, bt, St) {
            for (var At = 0; At < dt.length; At++) {
              var Dt = [];
              ft(dt[At], Dt, bt, St), mt.push(Dt);
            }
          }
          function ct(dt) {
            return dt / 360 + 0.5;
          }
          function Tt(dt) {
            var mt = Math.sin((dt * Math.PI) / 180),
              bt = 0.5 - (0.25 * Math.log((1 + mt) / (1 - mt))) / Math.PI;
            return bt < 0 ? 0 : bt > 1 ? 1 : bt;
          }
          function Lt(dt, mt, bt, St, At, Dt, kt, It) {
            if (((St /= mt), Dt >= (bt /= mt) && kt < St)) return dt;
            if (kt < bt || Dt >= St) return null;
            for (var qt = [], Rt = 0; Rt < dt.length; Rt++) {
              var de = dt[Rt],
                Ke = de.geometry,
                Yt = de.type,
                Ze = At === 0 ? de.minX : de.minY,
                Ei = At === 0 ? de.maxX : de.maxY;
              if (Ze >= bt && Ei < St) qt.push(de);
              else if (!(Ei < bt || Ze >= St)) {
                var Di = [];
                if (Yt === 'Point' || Yt === 'MultiPoint') jt(Ke, Di, bt, St, At);
                else if (Yt === 'LineString') le(Ke, Di, bt, St, At, !1, It.lineMetrics);
                else if (Yt === 'MultiLineString') ai(Ke, Di, bt, St, At, !1);
                else if (Yt === 'Polygon') ai(Ke, Di, bt, St, At, !0);
                else if (Yt === 'MultiPolygon')
                  for (var ji = 0; ji < Ke.length; ji++) {
                    var dr = [];
                    ai(Ke[ji], dr, bt, St, At, !0), dr.length && Di.push(dr);
                  }
                if (Di.length) {
                  if (It.lineMetrics && Yt === 'LineString') {
                    for (ji = 0; ji < Di.length; ji++) qt.push(L(de.id, Yt, Di[ji], de.tags));
                    continue;
                  }
                  (Yt !== 'LineString' && Yt !== 'MultiLineString') || (Di.length === 1 ? ((Yt = 'LineString'), (Di = Di[0])) : (Yt = 'MultiLineString')), (Yt !== 'Point' && Yt !== 'MultiPoint') || (Yt = Di.length === 3 ? 'Point' : 'MultiPoint'), qt.push(L(de.id, Yt, Di, de.tags));
                }
              }
            }
            return qt.length ? qt : null;
          }
          function jt(dt, mt, bt, St, At) {
            for (var Dt = 0; Dt < dt.length; Dt += 3) {
              var kt = dt[Dt + At];
              kt >= bt && kt <= St && (mt.push(dt[Dt]), mt.push(dt[Dt + 1]), mt.push(dt[Dt + 2]));
            }
          }
          function le(dt, mt, bt, St, At, Dt, kt) {
            for (var It, qt, Rt = Ie(dt), de = At === 0 ? bi : Ye, Ke = dt.start, Yt = 0; Yt < dt.length - 3; Yt += 3) {
              var Ze = dt[Yt],
                Ei = dt[Yt + 1],
                Di = dt[Yt + 2],
                ji = dt[Yt + 3],
                dr = dt[Yt + 4],
                rn = At === 0 ? Ze : Ei,
                Wi = At === 0 ? ji : dr,
                xr = !1;
              kt && (It = Math.sqrt(Math.pow(Ze - ji, 2) + Math.pow(Ei - dr, 2))), rn < bt ? Wi > bt && ((qt = de(Rt, Ze, Ei, ji, dr, bt)), kt && (Rt.start = Ke + It * qt)) : rn > St ? Wi < St && ((qt = de(Rt, Ze, Ei, ji, dr, St)), kt && (Rt.start = Ke + It * qt)) : ii(Rt, Ze, Ei, Di), Wi < bt && rn >= bt && ((qt = de(Rt, Ze, Ei, ji, dr, bt)), (xr = !0)), Wi > St && rn <= St && ((qt = de(Rt, Ze, Ei, ji, dr, St)), (xr = !0)), !Dt && xr && (kt && (Rt.end = Ke + It * qt), mt.push(Rt), (Rt = Ie(dt))), kt && (Ke += It);
            }
            var fr = dt.length - 3;
            (Ze = dt[fr]), (Ei = dt[fr + 1]), (Di = dt[fr + 2]), (rn = At === 0 ? Ze : Ei) >= bt && rn <= St && ii(Rt, Ze, Ei, Di), (fr = Rt.length - 3), Dt && fr >= 3 && (Rt[fr] !== Rt[0] || Rt[fr + 1] !== Rt[1]) && ii(Rt, Rt[0], Rt[1], Rt[2]), Rt.length && mt.push(Rt);
          }
          function Ie(dt) {
            var mt = [];
            return (mt.size = dt.size), (mt.start = dt.start), (mt.end = dt.end), mt;
          }
          function ai(dt, mt, bt, St, At, Dt) {
            for (var kt = 0; kt < dt.length; kt++) le(dt[kt], mt, bt, St, At, Dt, !1);
          }
          function ii(dt, mt, bt, St) {
            dt.push(mt), dt.push(bt), dt.push(St);
          }
          function bi(dt, mt, bt, St, At, Dt) {
            var kt = (Dt - mt) / (St - mt);
            return dt.push(Dt), dt.push(bt + (At - bt) * kt), dt.push(1), kt;
          }
          function Ye(dt, mt, bt, St, At, Dt) {
            var kt = (Dt - bt) / (At - bt);
            return dt.push(mt + (St - mt) * kt), dt.push(Dt), dt.push(1), kt;
          }
          function er(dt, mt) {
            for (var bt = [], St = 0; St < dt.length; St++) {
              var At,
                Dt = dt[St],
                kt = Dt.type;
              if (kt === 'Point' || kt === 'MultiPoint' || kt === 'LineString') At = wi(Dt.geometry, mt);
              else if (kt === 'MultiLineString' || kt === 'Polygon') {
                At = [];
                for (var It = 0; It < Dt.geometry.length; It++) At.push(wi(Dt.geometry[It], mt));
              } else if (kt === 'MultiPolygon')
                for (At = [], It = 0; It < Dt.geometry.length; It++) {
                  for (var qt = [], Rt = 0; Rt < Dt.geometry[It].length; Rt++) qt.push(wi(Dt.geometry[It][Rt], mt));
                  At.push(qt);
                }
              bt.push(L(Dt.id, kt, At, Dt.tags));
            }
            return bt;
          }
          function wi(dt, mt) {
            var bt = [];
            (bt.size = dt.size), dt.start !== void 0 && ((bt.start = dt.start), (bt.end = dt.end));
            for (var St = 0; St < dt.length; St += 3) bt.push(dt[St] + mt, dt[St + 1], dt[St + 2]);
            return bt;
          }
          function zi(dt, mt) {
            if (dt.transformed) return dt;
            var bt,
              St,
              At,
              Dt = 1 << dt.z,
              kt = dt.x,
              It = dt.y;
            for (bt = 0; bt < dt.features.length; bt++) {
              var qt = dt.features[bt],
                Rt = qt.geometry,
                de = qt.type;
              if (((qt.geometry = []), de === 1)) for (St = 0; St < Rt.length; St += 2) qt.geometry.push(Ar(Rt[St], Rt[St + 1], mt, Dt, kt, It));
              else
                for (St = 0; St < Rt.length; St++) {
                  var Ke = [];
                  for (At = 0; At < Rt[St].length; At += 2) Ke.push(Ar(Rt[St][At], Rt[St][At + 1], mt, Dt, kt, It));
                  qt.geometry.push(Ke);
                }
            }
            return (dt.transformed = !0), dt;
          }
          function Ar(dt, mt, bt, St, At, Dt) {
            return [Math.round(bt * (dt * St - At)), Math.round(bt * (mt * St - Dt))];
          }
          function Hs(dt, mt, bt, St, At) {
            for (var Dt = mt === At.maxZoom ? 0 : At.tolerance / ((1 << mt) * At.extent), kt = { features: [], numPoints: 0, numSimplified: 0, numFeatures: 0, source: null, x: bt, y: St, z: mt, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0 }, It = 0; It < dt.length; It++) {
              kt.numFeatures++, Ir(kt, dt[It], Dt, At);
              var qt = dt[It].minX,
                Rt = dt[It].minY,
                de = dt[It].maxX,
                Ke = dt[It].maxY;
              qt < kt.minX && (kt.minX = qt), Rt < kt.minY && (kt.minY = Rt), de > kt.maxX && (kt.maxX = de), Ke > kt.maxY && (kt.maxY = Ke);
            }
            return kt;
          }
          function Ir(dt, mt, bt, St) {
            var At = mt.geometry,
              Dt = mt.type,
              kt = [];
            if (Dt === 'Point' || Dt === 'MultiPoint') for (var It = 0; It < At.length; It += 3) kt.push(At[It]), kt.push(At[It + 1]), dt.numPoints++, dt.numSimplified++;
            else if (Dt === 'LineString') Kn(kt, At, dt, bt, !1, !1);
            else if (Dt === 'MultiLineString' || Dt === 'Polygon') for (It = 0; It < At.length; It++) Kn(kt, At[It], dt, bt, Dt === 'Polygon', It === 0);
            else if (Dt === 'MultiPolygon')
              for (var qt = 0; qt < At.length; qt++) {
                var Rt = At[qt];
                for (It = 0; It < Rt.length; It++) Kn(kt, Rt[It], dt, bt, !0, It === 0);
              }
            if (kt.length) {
              var de = mt.tags || null;
              if (Dt === 'LineString' && St.lineMetrics) {
                for (var Ke in ((de = {}), mt.tags)) de[Ke] = mt.tags[Ke];
                (de.mapbox_clip_start = At.start / At.size), (de.mapbox_clip_end = At.end / At.size);
              }
              var Yt = { geometry: kt, type: Dt === 'Polygon' || Dt === 'MultiPolygon' ? 3 : Dt === 'LineString' || Dt === 'MultiLineString' ? 2 : 1, tags: de };
              mt.id !== null && (Yt.id = mt.id), dt.features.push(Yt);
            }
          }
          function Kn(dt, mt, bt, St, At, Dt) {
            var kt = St * St;
            if (St > 0 && mt.size < (At ? kt : St)) bt.numPoints += mt.length / 3;
            else {
              for (var It = [], qt = 0; qt < mt.length; qt += 3) (St === 0 || mt[qt + 2] > kt) && (bt.numSimplified++, It.push(mt[qt]), It.push(mt[qt + 1])), bt.numPoints++;
              At &&
                (function (Rt, de) {
                  for (var Ke = 0, Yt = 0, Ze = Rt.length, Ei = Ze - 2; Yt < Ze; Ei = Yt, Yt += 2) Ke += (Rt[Yt] - Rt[Ei]) * (Rt[Yt + 1] + Rt[Ei + 1]);
                  if (Ke > 0 === de)
                    for (Yt = 0, Ze = Rt.length; Yt < Ze / 2; Yt += 2) {
                      var Di = Rt[Yt],
                        ji = Rt[Yt + 1];
                      (Rt[Yt] = Rt[Ze - 2 - Yt]), (Rt[Yt + 1] = Rt[Ze - 1 - Yt]), (Rt[Ze - 2 - Yt] = Di), (Rt[Ze - 1 - Yt] = ji);
                    }
                })(It, Dt),
                dt.push(It);
            }
          }
          function To(dt, mt) {
            var bt = (mt = this.options =
              (function (At, Dt) {
                for (var kt in Dt) At[kt] = Dt[kt];
                return At;
              })(Object.create(this.options), mt)).debug;
            if ((bt && console.time('preprocess data'), mt.maxZoom < 0 || mt.maxZoom > 24)) throw new Error('maxZoom should be in the 0-24 range');
            if (mt.promoteId && mt.generateId) throw new Error('promoteId and generateId cannot be used together.');
            var St = (function (At, Dt) {
              var kt = [];
              if (At.type === 'FeatureCollection') for (var It = 0; It < At.features.length; It++) et(kt, At.features[It], Dt, It);
              else et(kt, At.type === 'Feature' ? At : { geometry: At }, Dt);
              return kt;
            })(dt, mt);
            (this.tiles = {}),
              (this.tileCoords = []),
              bt && (console.timeEnd('preprocess data'), console.log('index: maxZoom: %d, maxPoints: %d', mt.indexMaxZoom, mt.indexMaxPoints), console.time('generate tiles'), (this.stats = {}), (this.total = 0)),
              (St = (function (At, Dt) {
                var kt = Dt.buffer / Dt.extent,
                  It = At,
                  qt = Lt(At, 1, -1 - kt, kt, 0, -1, 2, Dt),
                  Rt = Lt(At, 1, 1 - kt, 2 + kt, 0, -1, 2, Dt);
                return (qt || Rt) && ((It = Lt(At, 1, -kt, 1 + kt, 0, -1, 2, Dt) || []), qt && (It = er(qt, 1).concat(It)), Rt && (It = It.concat(er(Rt, -1)))), It;
              })(St, mt)).length && this.splitTile(St, 0, 0, 0),
              bt && (St.length && console.log('features: %d, points: %d', this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd('generate tiles'), console.log('tiles generated:', this.total, JSON.stringify(this.stats)));
          }
          function Ws(dt, mt, bt) {
            return 32 * ((1 << dt) * bt + mt) + dt;
          }
          return (
            (To.prototype.options = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !1, promoteId: null, generateId: !1, debug: 0 }),
            (To.prototype.splitTile = function (dt, mt, bt, St, At, Dt, kt) {
              for (var It = [dt, mt, bt, St], qt = this.options, Rt = qt.debug; It.length; ) {
                (St = It.pop()), (bt = It.pop()), (mt = It.pop()), (dt = It.pop());
                var de = 1 << mt,
                  Ke = Ws(mt, bt, St),
                  Yt = this.tiles[Ke];
                if (!Yt && (Rt > 1 && console.time('creation'), (Yt = this.tiles[Ke] = Hs(dt, mt, bt, St, qt)), this.tileCoords.push({ z: mt, x: bt, y: St }), Rt)) {
                  Rt > 1 && (console.log('tile z%d-%d-%d (features: %d, points: %d, simplified: %d)', mt, bt, St, Yt.numFeatures, Yt.numPoints, Yt.numSimplified), console.timeEnd('creation'));
                  var Ze = 'z' + mt;
                  (this.stats[Ze] = (this.stats[Ze] || 0) + 1), this.total++;
                }
                if (((Yt.source = dt), At)) {
                  if (mt === qt.maxZoom || mt === At) continue;
                  var Ei = 1 << (At - mt);
                  if (bt !== Math.floor(Dt / Ei) || St !== Math.floor(kt / Ei)) continue;
                } else if (mt === qt.indexMaxZoom || Yt.numPoints <= qt.indexMaxPoints) continue;
                if (((Yt.source = null), dt.length !== 0)) {
                  Rt > 1 && console.time('clipping');
                  var Di,
                    ji,
                    dr,
                    rn,
                    Wi,
                    xr,
                    fr = (0.5 * qt.buffer) / qt.extent,
                    Xs = 0.5 - fr,
                    Eo = 0.5 + fr,
                    Ys = 1 + fr;
                  (Di = ji = dr = rn = null), (Wi = Lt(dt, de, bt - fr, bt + Eo, 0, Yt.minX, Yt.maxX, qt)), (xr = Lt(dt, de, bt + Xs, bt + Ys, 0, Yt.minX, Yt.maxX, qt)), (dt = null), Wi && ((Di = Lt(Wi, de, St - fr, St + Eo, 1, Yt.minY, Yt.maxY, qt)), (ji = Lt(Wi, de, St + Xs, St + Ys, 1, Yt.minY, Yt.maxY, qt)), (Wi = null)), xr && ((dr = Lt(xr, de, St - fr, St + Eo, 1, Yt.minY, Yt.maxY, qt)), (rn = Lt(xr, de, St + Xs, St + Ys, 1, Yt.minY, Yt.maxY, qt)), (xr = null)), Rt > 1 && console.timeEnd('clipping'), It.push(Di || [], mt + 1, 2 * bt, 2 * St), It.push(ji || [], mt + 1, 2 * bt, 2 * St + 1), It.push(dr || [], mt + 1, 2 * bt + 1, 2 * St), It.push(rn || [], mt + 1, 2 * bt + 1, 2 * St + 1);
                }
              }
            }),
            (To.prototype.getTile = function (dt, mt, bt) {
              var St = this.options,
                At = St.extent,
                Dt = St.debug;
              if (dt < 0 || dt > 24) return null;
              var kt = 1 << dt,
                It = Ws(dt, (mt = ((mt % kt) + kt) % kt), bt);
              if (this.tiles[It]) return zi(this.tiles[It], At);
              Dt > 1 && console.log('drilling down to z%d-%d-%d', dt, mt, bt);
              for (var qt, Rt = dt, de = mt, Ke = bt; !qt && Rt > 0; ) Rt--, (de = Math.floor(de / 2)), (Ke = Math.floor(Ke / 2)), (qt = this.tiles[Ws(Rt, de, Ke)]);
              return qt && qt.source ? (Dt > 1 && console.log('found parent tile z%d-%d-%d', Rt, de, Ke), Dt > 1 && console.time('drilling down'), this.splitTile(qt.source, Rt, de, Ke, dt, mt, bt), Dt > 1 && console.timeEnd('drilling down'), this.tiles[It] ? zi(this.tiles[It], At) : null) : null;
            }),
            function (dt, mt) {
              return new To(dt, mt);
            }
          );
        })();
        var bo = $.g($r.exports);
        function wo(tt, P) {
          const L = tt.tileID.canonical;
          if (!this._geoJSONIndex) return P(null, null);
          const B = this._geoJSONIndex.getTile(L.z, L.x, L.y);
          if (!B) return P(null, null);
          const et = new (class {
            constructor(ft) {
              (this.layers = { _geojsonTileLayer: this }), (this.name = '_geojsonTileLayer'), (this.extent = $.E), (this.length = ft.length), (this._features = ft);
            }
            feature(ft) {
              return new (class {
                constructor(gt) {
                  (this._feature = gt), (this.extent = $.E), (this.type = gt.type), (this.properties = gt.tags), 'id' in gt && !isNaN(gt.id) && (this.id = parseInt(gt.id, 10));
                }
                loadGeometry() {
                  if (this._feature.type === 1) {
                    const gt = [];
                    for (const ct of this._feature.geometry) gt.push([new $.P(ct[0], ct[1])]);
                    return gt;
                  }
                  {
                    const gt = [];
                    for (const ct of this._feature.geometry) {
                      const Tt = [];
                      for (const Lt of ct) Tt.push(new $.P(Lt[0], Lt[1]));
                      gt.push(Tt);
                    }
                    return gt;
                  }
                }
                toGeoJSON(gt, ct, Tt) {
                  return Si.call(this, gt, ct, Tt);
                }
              })(this._features[ft]);
            }
          })(B.features);
          let K = mi(et);
          (K.byteOffset === 0 && K.byteLength === K.buffer.byteLength) || (K = new Uint8Array(K)), P(null, { vectorTile: et, rawData: K.buffer });
        }
        class Y extends $.d {
          constructor(P, L, B, et, K, ft) {
            super(P, L, B, et, wo, ft), K && (this.loadGeoJSON = K);
          }
          loadData(P, L) {
            const B = P && P.request,
              et = B && B.collectResourceTiming;
            this.loadGeoJSON(P, (K, ft) => {
              if (K || !ft) return L(K);
              if (typeof ft != 'object') return L(new Error(`Input data given to '${P.source}' is not a valid GeoJSON object.`));
              {
                Oe(ft, !0);
                try {
                  if (P.filter) {
                    const ct = $.e(P.filter, { type: 'boolean', 'property-type': 'data-driven', overridable: !1, transition: !1 });
                    if (ct.result === 'error') throw new Error(ct.value.map((Lt) => `${Lt.key}: ${Lt.message}`).join(', '));
                    ft = { type: 'FeatureCollection', features: ft.features.filter((Lt) => ct.value.evaluate({ zoom: 0 }, Lt)) };
                  }
                  this._geoJSONIndex = P.cluster
                    ? new en(
                        (function ({ superclusterOptions: ct, clusterProperties: Tt }) {
                          if (!Tt || !ct) return ct;
                          const Lt = {},
                            jt = {},
                            le = { accumulated: null, zoom: 0 },
                            Ie = { properties: null },
                            ai = Object.keys(Tt);
                          for (const ii of ai) {
                            const [bi, Ye] = Tt[ii],
                              er = $.e(Ye),
                              wi = $.e(typeof bi == 'string' ? [bi, ['accumulated'], ['get', ii]] : bi);
                            (Lt[ii] = er.value), (jt[ii] = wi.value);
                          }
                          return (
                            (ct.map = (ii) => {
                              Ie.properties = ii;
                              const bi = {};
                              for (const Ye of ai) bi[Ye] = Lt[Ye].evaluate(le, Ie);
                              return bi;
                            }),
                            (ct.reduce = (ii, bi) => {
                              Ie.properties = bi;
                              for (const Ye of ai) (le.accumulated = ii[Ye]), (ii[Ye] = jt[Ye].evaluate(le, Ie));
                            }),
                            ct
                          );
                        })(P)
                      ).load(ft.features)
                    : bo(ft, P.geojsonVtOptions);
                } catch (ct) {
                  return L(ct);
                }
                this.loaded = {};
                const gt = {};
                if (et) {
                  const ct = $.f(B);
                  ct && ((gt.resourceTiming = {}), (gt.resourceTiming[P.source] = JSON.parse(JSON.stringify(ct))));
                }
                L(null, gt);
              }
            });
          }
          reloadTile(P, L) {
            const B = this.loaded;
            return B && B[P.uid] ? super.reloadTile(P, L) : this.loadTile(P, L);
          }
          loadGeoJSON(P, L) {
            if (P.request) $.h(P.request, L);
            else {
              if (typeof P.data != 'string') return L(new Error(`Input data given to '${P.source}' is not a valid GeoJSON object.`));
              try {
                return L(null, JSON.parse(P.data));
              } catch {
                return L(new Error(`Input data given to '${P.source}' is not a valid GeoJSON object.`));
              }
            }
          }
          getClusterExpansionZoom(P, L) {
            try {
              L(null, this._geoJSONIndex.getClusterExpansionZoom(P.clusterId));
            } catch (B) {
              L(B);
            }
          }
          getClusterChildren(P, L) {
            try {
              L(null, this._geoJSONIndex.getChildren(P.clusterId));
            } catch (B) {
              L(B);
            }
          }
          getClusterLeaves(P, L) {
            try {
              L(null, this._geoJSONIndex.getLeaves(P.clusterId, P.limit, P.offset));
            } catch (B) {
              L(B);
            }
          }
        }
        class ot {
          constructor(P, L) {
            (this.tileID = new $.O(P.tileID.overscaledZ, P.tileID.wrap, P.tileID.canonical.z, P.tileID.canonical.x, P.tileID.canonical.y)), (this.tileZoom = P.tileZoom), (this.uid = P.uid), (this.zoom = P.zoom), (this.canonical = P.tileID.canonical), (this.pixelRatio = P.pixelRatio), (this.tileSize = P.tileSize), (this.source = P.source), (this.overscaling = this.tileID.overscaleFactor()), (this.projection = P.projection), (this.brightness = L);
          }
          parse(P, L, B, et) {
            this.status = 'parsing';
            const K = new $.O(B.tileID.overscaledZ, B.tileID.wrap, B.tileID.canonical.z, B.tileID.canonical.x, B.tileID.canonical.y),
              ft = {},
              gt = L.familiesBySource[B.source],
              ct = new $.F(K, B.promoteId);
            return (
              (ct.bucketLayerIDs = []),
              $.l(P)
                .then((Tt) => {
                  if (!Tt) return et(new Error('Could not parse tile'));
                  const Lt = $.j(Tt, 1 / $.t(B.tileID.canonical)),
                    jt = Tt.json.extensionsUsed && Tt.json.extensionsUsed.includes('MAPBOX_mesh_features'),
                    le = new $.k(this.zoom, { brightness: this.brightness });
                  for (const Ie in gt)
                    for (const ai of gt[Ie]) {
                      const ii = ai[0],
                        bi = Tt.json.extensionsUsed;
                      ii.recalculate(le, []);
                      const Ye = new $.T(Lt, K, bi && bi.includes('MAPBOX_mesh_features'), this.brightness);
                      jt || (Ye.needsUpload = !0), (ft[ii.fqid] = Ye), Ye.evaluate(ii);
                    }
                  (this.status = 'done'), et(null, { buckets: ft, featureIndex: ct });
                })
                .catch((Tt) => et(new Error(Tt.message)))
            );
          }
        }
        class xt {
          constructor(P, L, B, et, K, ft) {
            (this.actor = P), (this.layerIndex = L), (this.brightness = ft), (this.loading = {}), (this.loaded = {});
          }
          loadTile(P, L) {
            const B = P.uid,
              et = (this.loading[B] = new ot(P, this.brightness));
            $.i(P.request, (K, ft) => {
              const gt = !this.loading[B];
              return (
                delete this.loading[B],
                gt || K
                  ? ((et.status = 'done'), gt || (this.loaded[B] = et), L(K))
                  : ft && ft.byteLength !== 0
                  ? void et.parse(ft, this.layerIndex, P, (ct, Tt) => {
                      (et.status = 'done'), (this.loaded = this.loaded || {}), (this.loaded[B] = et), ct || !Tt ? L(ct) : L(null, Tt);
                    })
                  : ((et.status = 'done'), (this.loaded[B] = et), L())
              );
            });
          }
          reloadTile(P, L) {
            const B = this.loaded,
              et = P.uid;
            if (B && B[et]) {
              const K = B[et];
              (K.projection = P.projection), (K.brightness = P.brightness);
              const ft = (gt, ct) => {
                K.reloadCallback && (delete K.reloadCallback, this.loadTile(P, L)), L(gt, ct);
              };
              K.status === 'parsing' ? (K.reloadCallback = ft) : K.status === 'done' && this.loadTile(P, L);
            }
          }
          abortTile(P, L) {
            const B = P.uid;
            this.loading[B] && delete this.loading[B], L();
          }
          removeTile(P, L) {
            const B = this.loaded,
              et = P.uid;
            B && B[et] && delete B[et], L();
          }
        }
        class zt {
          constructor(P) {
            (this.self = P),
              (this.actor = new $.A(P, this)),
              (this.layerIndexes = {}),
              (this.availableImages = {}),
              (this.isSpriteLoaded = {}),
              (this.projections = {}),
              (this.defaultProjection = $.m({ name: 'mercator' })),
              (this.workerSourceTypes = { vector: $.d, geojson: Y, 'batched-model': xt }),
              (this.workerSources = {}),
              (this.demWorkerSources = {}),
              (this.self.registerWorkerSource = (L, B) => {
                if (this.workerSourceTypes[L]) throw new Error(`Worker source with name "${L}" already registered.`);
                this.workerSourceTypes[L] = B;
              }),
              (this.self.registerRTLTextPlugin = (L) => {
                if ($.n.isParsed()) throw new Error('RTL text plugin already registered.');
                ($.n.applyArabicShaping = L.applyArabicShaping), ($.n.processBidirectionalText = L.processBidirectionalText), ($.n.processStyledBidirectionalText = L.processStyledBidirectionalText);
              });
          }
          clearCaches(P, L, B) {
            delete this.layerIndexes[P], delete this.availableImages[P], delete this.workerSources[P], delete this.demWorkerSources[P], B();
          }
          checkIfReady(P, L, B) {
            B();
          }
          setReferrer(P, L) {
            this.referrer = L;
          }
          spriteLoaded(P, { scope: L, isLoaded: B }) {
            if ((this.isSpriteLoaded[P] || (this.isSpriteLoaded[P] = {}), (this.isSpriteLoaded[P][L] = B), this.workerSources[P] && this.workerSources[P][L]))
              for (const et in this.workerSources[P][L]) {
                const K = this.workerSources[P][L][et];
                for (const ft in K) K[ft] instanceof $.d && ((K[ft].isSpriteLoaded = B), K[ft].fire(new $.o('isSpriteLoaded')));
              }
          }
          setImages(P, { scope: L, images: B }, et) {
            if ((this.availableImages[P] || (this.availableImages[P] = {}), (this.availableImages[P][L] = B), this.workerSources[P] && this.workerSources[P][L])) {
              for (const K in this.workerSources[P][L]) {
                const ft = this.workerSources[P][L][K];
                for (const gt in ft) ft[gt].availableImages = B;
              }
              et();
            } else et();
          }
          setProjection(P, L) {
            this.projections[P] = $.m(L);
          }
          setBrightness(P, L, B) {
            (this.brightness = L), B();
          }
          setLayers(P, L, B) {
            this.getLayerIndex(P, L.scope).replace(L.layers, L.options), B();
          }
          updateLayers(P, L, B) {
            this.getLayerIndex(P, L.scope).update(L.layers, L.removedIds, L.options), B();
          }
          loadTile(P, L, B) {
            (L.projection = this.projections[P] || this.defaultProjection), this.getWorkerSource(P, L.type, L.source, L.scope).loadTile(L, B);
          }
          loadDEMTile(P, L, B) {
            this.getDEMWorkerSource(P, L.source, L.scope).loadTile(L, B);
          }
          reloadTile(P, L, B) {
            (L.projection = this.projections[P] || this.defaultProjection), this.getWorkerSource(P, L.type, L.source, L.scope).reloadTile(L, B);
          }
          abortTile(P, L, B) {
            this.getWorkerSource(P, L.type, L.source, L.scope).abortTile(L, B);
          }
          removeTile(P, L, B) {
            this.getWorkerSource(P, L.type, L.source, L.scope).removeTile(L, B);
          }
          removeSource(P, L, B) {
            if (!(this.workerSources[P] && this.workerSources[P][L.scope] && this.workerSources[P][L.scope][L.type] && this.workerSources[P][L.scope][L.type][L.source])) return;
            const et = this.workerSources[P][L.scope][L.type][L.source];
            delete this.workerSources[P][L.scope][L.type][L.source], et.removeSource !== void 0 ? et.removeSource(L, B) : B();
          }
          loadWorkerSource(P, L, B) {
            try {
              this.self.importScripts(L.url), B();
            } catch (et) {
              B(et.toString());
            }
          }
          syncRTLPluginState(P, L, B) {
            try {
              $.n.setState(L);
              const et = $.n.getPluginURL();
              if ($.n.isLoaded() && !$.n.isParsed() && et != null) {
                this.self.importScripts(et);
                const K = $.n.isParsed();
                B(K ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${et}`), K);
              }
            } catch (et) {
              B(et.toString());
            }
          }
          setDracoUrl(P, L) {
            this.dracoUrl = L;
          }
          getAvailableImages(P, L) {
            this.availableImages[P] || (this.availableImages[P] = {});
            let B = this.availableImages[P][L];
            return B || (B = []), B;
          }
          getLayerIndex(P, L) {
            this.layerIndexes[P] || (this.layerIndexes[P] = {});
            let B = this.layerIndexes[P][L];
            return B || ((B = this.layerIndexes[P][L] = new Zt()), (B.scope = L)), B;
          }
          getWorkerSource(P, L, B, et) {
            if ((this.workerSources[P] || (this.workerSources[P] = {}), this.workerSources[P][et] || (this.workerSources[P][et] = {}), this.workerSources[P][et][L] || (this.workerSources[P][et][L] = {}), this.isSpriteLoaded[P] || (this.isSpriteLoaded[P] = {}), !this.workerSources[P][et][L][B])) {
              const K = {
                send: (ft, gt, ct, Tt, Lt, jt) => {
                  this.actor.send(ft, gt, ct, P, Lt, jt);
                },
                scheduler: this.actor.scheduler,
              };
              this.workerSources[P][et][L][B] = new this.workerSourceTypes[L](K, this.getLayerIndex(P, et), this.getAvailableImages(P, et), this.isSpriteLoaded[P][et], void 0, this.brightness);
            }
            return this.workerSources[P][et][L][B];
          }
          getDEMWorkerSource(P, L, B) {
            return this.demWorkerSources[P] || (this.demWorkerSources[P] = {}), this.demWorkerSources[P][B] || (this.demWorkerSources[P][B] = {}), this.demWorkerSources[P][B][L] || (this.demWorkerSources[P][B][L] = new Mt()), this.demWorkerSources[P][B][L];
          }
          enforceCacheSizeLimit(P, L) {
            $.q(L);
          }
          getWorkerPerformanceMetrics(P, L, B) {
            B(void 0, void 0);
          }
        }
        return typeof WorkerGlobalScope < 'u' && typeof self < 'u' && self instanceof WorkerGlobalScope && (self.worker = new zt(self)), zt;
      }),
      W(['./shared'], function ($) {
        return $.s;
      });
    var rt = F;
    return rt;
  });
})(fE);
var S3 = fE.exports;
const ac = M3(S3),
  A3 = { class: 'relative mb-20 lg:mb-40' },
  I3 = cE('<div class="flex flex-col-reverse lg:flex-row lg:mt-0"><div id="map" class="w-full h-40 mt-0 z-0"></div><div class="max-w-screen-xl mx-auto lg:absolute lg:top-min2rem lg:left-1/2 lg:transform lg:-translate-x-1/2 bg-fixed-nav-green p-4 rounded-1px shadow-lg w-full flex justify-center"><div class="flex py-8 w-full lg:w-85p justify-center items-center"><div class="flex justify-center items-center gap-2"><div><img src="' + s3 + '" alt="iconmarker" class="w-5 mr-2"></div><p class="text-2xl md:text-xl xl:text-2xl text-primary-white">Kom zeker eens langs in onze winkel</p></div></div></div></div>', 1),
  C3 = [I3],
  P3 = {
    __name: 'AppContactMap',
    setup(m) {
      return (
        YT(() => {
          ac.accessToken = 'pk.eyJ1IjoiZnJlZWtoZXJyZWdvZHMiLCJhIjoiY2xoNXl6dnNqMDB5cTNxcm84NGpnMXk5ciJ9.fBS-uIrKQ6yTaPdz55PYgQ';
          const x = new ac.Map({ container: 'map', style: 'mapbox://styles/mapbox/streets-v11', center: [3.264449, 50.819478], zoom: 10, attributionControl: !1 });
          x.scrollZoom.disable(),
            x.on('load', () => {
              const M = new ac.Popup({ offset: 25 }).setHTML(`
      <strong>Bikestore</strong>
      <p>Mandellaan 377, 8800 Roeselare</p>
      <img src="src/assets/blogitem1.svg" alt="Bikestore" style="width: 100%; height: auto;">
    `);
              new ac.Marker({ color: '#557260' }).setLngLat([3.251073, 50.824672]).setPopup(M).addTo(x), x.addControl(new ac.NavigationControl(), 'bottom-left');
            });
        }),
        (x, M) => (An(), $n('div', A3, C3))
      );
    },
  },
  z3 = { class: 'bg-primary-white' },
  D3 = $i('div', { class: 'mb-10 lg:mb-20' }, null, -1),
  R3 = {
    __name: 'AppContact',
    setup(m) {
      return (x, M) => (An(), $n('div', z3, [mn(T3), D3, mn(P3)]));
    },
  },
  L3 = r3(R3);
L3.mount('#app');
